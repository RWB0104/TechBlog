<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>𝝅번째 알파카의 개발 낙서장</title>
		<description>𝝅번째 알파카의 우당탕탕 개발 기록</description>
		<link>https://blog.itcode.dev</link>
		<copyright>Copyright ⓒ RWB 2021.05</copyright>
		<language>ko-KR</language>
		<managingEditor>psj2716@gmail.com</managingEditor>
		<webMaster>psj2716@gmail.com</webMaster>
		<generator>Kapoo's next-seo.js</generator>
		<pubDate>Wed, 26 May 2021 14:36:57 GMT</pubDate>
		<lastBuildDate>Wed, 13 Oct 2021 17:09:34 GMT</lastBuildDate>
		<item>
			<title>./pages/404.tsx</title>
			<description>./pages/404.tsx</description>
			<pubDate>Wed, 13 Oct 2021 17:09:34 GMT</pubDate>
			<link>https://blog.itcode.dev/404.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/404.html</guid>
		</item>
		<item>
			<title>./pages/500.tsx</title>
			<description>./pages/500.tsx</description>
			<pubDate>Wed, 13 Oct 2021 17:09:34 GMT</pubDate>
			<link>https://blog.itcode.dev/500.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/500.html</guid>
		</item>
		<item>
			<title>./pages/about/index.tsx</title>
			<description>./pages/about/index.tsx</description>
			<pubDate>Wed, 13 Oct 2021 17:09:34 GMT</pubDate>
			<link>https://blog.itcode.dev/about.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/about.html</guid>
		</item>
		<item>
			<title>./pages/posts/index.tsx</title>
			<description>./pages/posts/index.tsx</description>
			<pubDate>Wed, 13 Oct 2021 17:09:34 GMT</pubDate>
			<link>https://blog.itcode.dev/posts.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts.html</guid>
		</item>
		<item>
			<title>./pages/projects/index.tsx</title>
			<description>./pages/projects/index.tsx</description>
			<pubDate>Wed, 13 Oct 2021 17:09:34 GMT</pubDate>
			<link>https://blog.itcode.dev/projects.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/projects.html</guid>
		</item>
		<item>
			<title>Jekyll에서 Next.js로</title>
			<description>Jekyll에서 Next.js로의 블로그 이동기</description>
			<pubDate>Fri, 21 May 2021 06:09:33 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/21/jekyll-to-nextjs.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/21/jekyll-to-nextjs.html</guid>
			<category>잡담</category>
			<category>React(리액트)</category>
			<category>Next.js</category>
			<category>개발 블로그</category>
			<category>Jekyll</category>
		</item>
		<item>
			<title>백준 알고리즘 시작하기</title>
			<description>코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다. 그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다. 풀이의 규칙은 아래와 같다.</description>
			<pubDate>Fri, 21 May 2021 12:22:31 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/21/start-beakjoon.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/21/start-beakjoon.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1000번 A + B</title>
			<description>두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.</description>
			<pubDate>Fri, 21 May 2021 12:38:17 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/21/a1000.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/21/a1000.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>사칙연산</category>
			<category>BRONZE</category>
			<category>BRONZE V</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1001번 A - B</title>
			<description>두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.</description>
			<pubDate>Fri, 21 May 2021 12:51:19 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/21/a1001.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/21/a1001.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>사칙연산</category>
			<category>BRONZE</category>
			<category>BRONZE V</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1002번 터렛</title>
			<description>조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.</description>
			<pubDate>Fri, 21 May 2021 12:56:10 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/21/a1002.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/21/a1002.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>기하학</category>
			<category>SILVER</category>
			<category>SILVER IV</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1003번 피보나치 함수</title>
			<description>다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.</description>
			<pubDate>Fri, 21 May 2021 14:29:03 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/21/a1003.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/21/a1003.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>피보나치 수열</category>
			<category>Dynamic Programming(동적 프로그래밍)</category>
			<category>SILVER</category>
			<category>SILVER III</category>
		</item>
		<item>
			<title>도메인이란?</title>
			<description>도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다. 인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 고유한 12자리 숫자로 구성된 IP주소를 가진다. IP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다. 유동 IP: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨. 고정 IP: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함. 우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, 특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요하다.</description>
			<pubDate>Sat, 22 May 2021 03:52:51 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/22/about-domain.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/22/about-domain.html</guid>
			<category>WEB</category>
			<category>WEB(웹)</category>
			<category>Domain(도메인)</category>
		</item>
		<item>
			<title>Tomcat(톰캣) 콘솔창 한글 인코딩 깨짐 현상 해결하기</title>
			<description>톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상. Windows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.</description>
			<pubDate>Sat, 22 May 2021 03:52:51 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/22/tomcat-encoding-euckr.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/22/tomcat-encoding-euckr.html</guid>
			<category>WAS</category>
			<category>Tomcat(톰캣)</category>
			<category>Console(콘솔)</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1004번 어린 왕자</title>
			<description>어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.</description>
			<pubDate>Sat, 22 May 2021 12:42:23 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/22/a1004.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/22/a1004.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>기하학</category>
			<category>SILVER</category>
			<category>SILVER III</category>
		</item>
		<item>
			<title>Tomcat(톰캣) 현재 콘솔창에서 구동하기</title>
			<description>오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?</description>
			<pubDate>Wed, 26 May 2021 07:32:16 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/26/tomcat-current-window.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/26/tomcat-current-window.html</guid>
			<category>WAS</category>
			<category>Tomcat(톰캣)</category>
			<category>Console(콘솔)</category>
		</item>
		<item>
			<title>URI? URL? URN? 리소스 식별자 구분하기</title>
			<description>우리가 인터넷 상에서 특정한 데이터에 접근할 때 URL이라는 것을 활용하여 접근한다. 원하는 자료의 URL을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 URL을 호출하여 응답을 얻는 것이다.</description>
			<pubDate>Fri, 28 May 2021 18:30:17 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/29/uri-url-urn.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/29/uri-url-urn.html</guid>
			<category>WEB</category>
			<category>WEB(웹)</category>
			<category>URI</category>
			<category>URL</category>
			<category>URN</category>
		</item>
		<item>
			<title>Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)</title>
			<description>간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 "지원하지 않는 주/부 버전"이다. JAVA 버전관련 오류라고 보면 된다.</description>
			<pubDate>Sat, 29 May 2021 17:16:35 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/05/30/unsupported-version-error.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/05/30/unsupported-version-error.html</guid>
			<category>JAVA</category>
			<category>WAS</category>
			<category>Tomcat(톰캣)</category>
			<category>오류 해결책</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1005번 ACM Craft</title>
			<description>서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.</description>
			<pubDate>Mon, 31 May 2021 16:27:56 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/01/a1005.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/01/a1005.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>Dynamic Programming(동적 프로그래밍)</category>
			<category>위상 정렬</category>
			<category>GOLD</category>
			<category>GOLD III</category>
		</item>
		<item>
			<title>Compiler(컴파일러) &amp; Interpreter(인터프리터)</title>
			<description>천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다. 하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 컴퓨터가 알아먹을 수 있어야 실행된다는 얘기다. 글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 컴퓨터는 개발 이래로 초지일관 기계어만을 고집한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.</description>
			<pubDate>Thu, 03 Jun 2021 08:25:23 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/03/compiler-interpreter.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/03/compiler-interpreter.html</guid>
			<category>CS</category>
			<category>Compiler(컴파일러)</category>
			<category>Interpreter(인터프리터)</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1006번 습격자 초라기</title>
			<description>초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.</description>
			<pubDate>Sun, 06 Jun 2021 13:42:02 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/06/a1006.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/06/a1006.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>Dynamic Programming(동적 프로그래밍)</category>
			<category>PLATINUM</category>
			<category>PLATINUM III</category>
		</item>
		<item>
			<title>[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 1. Jekyll이란?</title>
			<description>대형 포탈이나 크고 작은 플랫폼을 통해 자신만의 블로그를 만들 수 있다. 이러한 플랫폼을 통한 블로그는 연동된 계정과 버튼 클릭 몇 번으로 만들 수 있을 정도로 쉽고 간편하다. 하지만 이와 같은 블로그는 페이지의 기본 프레임이 정해져있고, 자유로운 커스터마이징이 제한된 편이다. 자신만의 색이나 가치관을 담은 블로그를 만들기 위해선 소위 "기성품"이 아닌 방법을 찾아야하는데, 이는 곧 자신이 직접 웹 페이지를 제작하고 퍼블리싱, 호스팅까지 전반적인 웹 서비스 자체를 구축해야하는 큰 작업으로 이어진다. 어찌어찌 페이지를 제작한다 하더라도, CSS를 통한 디자인이나 JavaScript같은 부가기능은 프레임 제작 이상으로 어렵다. 여기까지는 어떻게 자력으로 했다고 하더라도, 호스팅은 돈이 든다. DB까지 연동한다면 금액은 더욱 커지게 된다. 내가 원한건 단순한 블로그였는데.</description>
			<pubDate>Sun, 06 Jun 2021 14:18:25 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/06/jekyll-blog-start.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/06/jekyll-blog-start.html</guid>
			<category>Jekyll</category>
			<category>GitHub Pages(깃허브 페이지)</category>
			<category>Jekyll(지킬)</category>
			<category>Blog(블로그)</category>
		</item>
		<item>
			<title>[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 2. GitHub와 친해지기</title>
			<description>Jekyll은 GitHub를 통해 호스팅한다. 즉, Jekyll로 블로그를 만들기 위해선 GitHub를 조금이나마 알고 있어야 한다. 본문에서는 GitHub의 여러 기능은 제쳐두고, Jekyll 호스팅을 목적을 기준으로 설명한다.</description>
			<pubDate>Sun, 06 Jun 2021 14:29:32 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/06/jekyll-blog-github.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/06/jekyll-blog-github.html</guid>
			<category>Jekyll</category>
			<category>GitHub Pages(깃허브 페이지)</category>
			<category>Jekyll(지킬)</category>
			<category>Blog(블로그)</category>
			<category>GitHub(깃허브)</category>
		</item>
		<item>
			<title>[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 3. Git 설치하기</title>
			<description>GitHub는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 Git을 이용하여 관리할 수 있다. GitHub 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 Git을 활용하는 것이 권장된다.</description>
			<pubDate>Sun, 06 Jun 2021 14:42:11 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/06/jekyll-blog-prepare-git.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/06/jekyll-blog-prepare-git.html</guid>
			<category>Jekyll</category>
			<category>GitHub Pages(깃허브 페이지)</category>
			<category>Jekyll(지킬)</category>
			<category>Blog(블로그)</category>
			<category>Git</category>
		</item>
		<item>
			<title>[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 4. Jekyll 쇼핑하기</title>
			<description>GitHub는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 Git을 이용하여 관리할 수 있다. GitHub 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 Git을 활용하는 것이 권장된다.</description>
			<pubDate>Mon, 07 Jun 2021 14:42:11 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/07/jekyll-blog-jekyll-shopping.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/07/jekyll-blog-jekyll-shopping.html</guid>
			<category>Jekyll</category>
			<category>GitHub Pages(깃허브 페이지)</category>
			<category>Jekyll(지킬)</category>
			<category>Blog(블로그)</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1007번 벡터</title>
			<description>평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다. V에 있는 벡터의 갯수는 P에 있는 점의 절반이다. 평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.</description>
			<pubDate>Tue, 08 Jun 2021 15:50:26 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/09/a1007.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/09/a1007.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>Brute Force(무차별 대입 공격)</category>
			<category>Combination(조합)</category>
			<category>GOLD</category>
			<category>GOLD II</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1008번 A / B</title>
			<description>두 정수 A와 B를 입력받은 다음, A / B를 출력하는 프로그램을 작성하시오.</description>
			<pubDate>Wed, 09 Jun 2021 01:25:31 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/09/a1008.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/09/a1008.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>사칙연산</category>
			<category>BRONZE</category>
			<category>BRONZE IV</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1009번 분산처리</title>
			<description>재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.</description>
			<pubDate>Wed, 09 Jun 2021 02:06:38 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/09/a1009.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/09/a1009.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>수학</category>
			<category>BRONZE</category>
			<category>BRONZE IV</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1010번 다리 놓기</title>
			<description>재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)</description>
			<pubDate>Wed, 09 Jun 2021 05:14:09 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/09/a1010.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/09/a1010.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>Combination(조합)</category>
			<category>SILVER</category>
			<category>SILVER V</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1011번 Fly me to the Alpha Centauri</title>
			<description>우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다. 그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k - 1 , k 혹은 k + 1 광년만을 다시 이동할 수 있다.</description>
			<pubDate>Fri, 11 Jun 2021 05:14:09 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/11/a1011.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/11/a1011.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>SILVER</category>
			<category>SILVER I</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1012번 유기농 배추</title>
			<description>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)</description>
			<pubDate>Sat, 12 Jun 2021 16:42:10 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/13/a1012.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/13/a1012.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>DFS(깊이 우선 탐색)</category>
			<category>BFS(너비 우선 탐색)</category>
			<category>SILVER</category>
			<category>SILVER II</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1013번 Contact</title>
			<description>푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다. 이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.</description>
			<pubDate>Sat, 12 Jun 2021 19:53:32 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/13/a1013.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/13/a1013.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>정규 표현식</category>
			<category>GOLD</category>
			<category>GOLD V</category>
		</item>
		<item>
			<title>[JAVA] split vs StringTokenizer</title>
			<description>알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.</description>
			<pubDate>Sun, 13 Jun 2021 16:56:01 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/14/split-and-stringtokenizer.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/14/split-and-stringtokenizer.html</guid>
			<category>JAVA</category>
			<category>JAVA(자바)</category>
			<category>String(문자열)</category>
			<category>split</category>
			<category>StringTokenizer</category>
		</item>
		<item>
			<title>IntelliJ(인텔리제이) 시작 시 오류(java.net.BindException: Address already in use: bind)</title>
			<description></description>
			<pubDate>Mon, 14 Jun 2021 12:59:16 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/14/intellij-error-onstart.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/14/intellij-error-onstart.html</guid>
			<category>JAVA</category>
			<category>IntelliJ(인텔리제이)</category>
			<category>Hyper-V</category>
			<category>오류 해결책</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1014번 컨닝</title>
			<description>최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다. 시험은 N행 X M열 크기의 직사각형 교실에서 이루어진다. 교실은 1 X 1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다. 최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.</description>
			<pubDate>Fri, 18 Jun 2021 07:42:44 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/18/a1014.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/18/a1014.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>PLATINUM</category>
			<category>PLATINUM IV</category>
			<category>네트워크 플로우</category>
			<category>최소 버텍스 커버</category>
			<category>이분 매칭</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1015번 수열 정렬</title>
			<description>P[0], P[1], ..., P[N - 1]은 0부터 N - 1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다. 적용하는 방법은 B[P[i]] = A[i]이다. 배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.</description>
			<pubDate>Mon, 21 Jun 2021 16:23:31 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/22/a1015.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/22/a1015.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>SILVER</category>
			<category>SILVER IV</category>
			<category>정렬</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1016번 제곱 ㄴㄴ수</title>
			<description>어떤 수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.</description>
			<pubDate>Tue, 22 Jun 2021 15:22:31 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/23/a1016.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/23/a1016.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>GOLD</category>
			<category>GOLD I</category>
			<category>에라토스 테네스의 체</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1017번 소수 쌍</title>
			<description>지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, {1, 4, 7, 10, 11, 12}가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다. 1 + 4 = $, 7 + 10 = 17$, $11 + 12 = 23 또는 1 + 10 = 11, 4 + 7 = 11, 11 + 12 = 23 수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 1 + 12 = 13으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.</description>
			<pubDate>Fri, 25 Jun 2021 18:19:32 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/26/a1017.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/26/a1017.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>PLATINUM</category>
			<category>PLATINUM III</category>
			<category>에라토스 테네스의 체</category>
			<category>이분 매칭</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1018번 체스판 다시 칠하기</title>
			<description>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8*8 크기의 체스판으로 만들려고 한다. 체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다. 보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8 X 8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.</description>
			<pubDate>Sat, 26 Jun 2021 07:46:20 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/26/a1018.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/26/a1018.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>SILVER</category>
			<category>SILVER V</category>
			<category>Brute Force(무차별 대입 공격)</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1019번 책 페이지</title>
			<description>지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1페이지이고, 마지막 페이지는 N페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.</description>
			<pubDate>Mon, 28 Jun 2021 03:28:50 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/06/28/a1019.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/06/28/a1019.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>GOLD</category>
			<category>GOLD I</category>
		</item>
		<item>
			<title>자료구조가 중요한 까닭</title>
			<description>혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.</description>
			<pubDate>Fri, 09 Jul 2021 16:30:56 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>배열</category>
		</item>
		<item>
			<title>알고리즘이 중요한 까닭</title>
			<description>IT영역에서의 알고리즘이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. 개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구된다.</description>
			<pubDate>Fri, 09 Jul 2021 19:21:37 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>배열</category>
			<category>정렬</category>
			<category>이진 검색</category>
		</item>
		<item>
			<title>빅 오 표기법</title>
			<description>하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 문제를 해결하는 효율성의 차이 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.</description>
			<pubDate>Tue, 13 Jul 2021 19:21:37 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/14/about-algorithm-chapter03.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/14/about-algorithm-chapter03.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>빅 오 표기법</category>
		</item>
		<item>
			<title>빅 오로 코드 속도 올리기</title>
			<description>이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.</description>
			<pubDate>Fri, 16 Jul 2021 12:39:54 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/16/about-algorithm-chapter04.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/16/about-algorithm-chapter04.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>버블 정렬</category>
		</item>
		<item>
			<title>빅 오를 사용하거나 사용하지 않는 코드 최적화</title>
			<description>지금까지 알고리즘의 퍼포먼스를 비교하면서 빅 오 표기법을 통해 수치화했다. 하지만 빅 오 표기법도 알고리즘의 퍼포먼스를 측정함에 있어서 완벽함을 보여주진 않는다. 이전 장에서 N(O^2)이나 N(N^2 - N) 모두 빅 오 표기법에선 N(O^2)로 간주한다고 설명했다. 이러한 특성으로 인해, 실제로는 명백한 차이를 보이는 알고리즘임에도 불구하고 빅 오 표기법으론 성능이 거의 동일하게 측정되기도 한다.</description>
			<pubDate>Fri, 23 Jul 2021 14:42:33 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/23/about-algorithm-chapter05.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/23/about-algorithm-chapter05.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>선택 정렬</category>
		</item>
		<item>
			<title>긍정적인 시나리오 최적화</title>
			<description>지금까지는 항상 알고리즘을 비관적인 관점으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다. 이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.</description>
			<pubDate>Fri, 23 Jul 2021 19:54:40 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/24/about-algorithm-chapter06.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/24/about-algorithm-chapter06.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>삽입 정렬</category>
		</item>
		<item>
			<title>블로그 개편기</title>
			<description>이 블로그를 처음 개발한지가 한 5월 쯤으로 기억한다. 4월부터 접한 리액트에 흥미가 생겨 두서없이 만든게 시작이였으니, 결과물은 내 생각보다 훨씬 조잡하지 않았나 생각했다. 다행스럽게(?)도 블로그 또한 그런 내 믿음을 져버리기 싫었는지, 동작 과정에서 크고 작은 문제들을 보여주곤 했다. 동작 자체에 영향을 미칠 정도로 크리티컬한 문제는 아니였다만, 내 신경엔 영향을 미칠 정도로 거슬리는 부분이 몇 가지 있었다. 아무도 관심 없지만 이왕 만든거 이번 포스팅을 통해 블로그의 개선점을 정리해놓고자 한다.</description>
			<pubDate>Sun, 25 Jul 2021 19:54:40 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/26/brand-new.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/26/brand-new.html</guid>
			<category>React</category>
			<category>React(리액트)</category>
			<category>Next.js</category>
			<category>개발 블로그</category>
			<category>TypeScript</category>
			<category>SCSS</category>
		</item>
		<item>
			<title>해시 테이블로 매우 빠른 룩업</title>
			<description>현재까지 다룬 데이터 형식 중 다수의 데이터를 다루는 데 가장 효과적인 형식은 배열일 것이다. 하지만 배열의 경우, 요소별로 단 하나의 값이 들어가는 데 특화되어 있다. 만약 하나의 요소에 두 값을 넣고자 한다면 어떻게 될까? [[A, 1], [B, 2], [C, 3]]과 같은 형태로 나타낼 것이다. 배열의 단점 중 하나는, 값을 빠르게 찾기 위해선 반드시 정렬을 수행해야 한다는 것이다. 하지만 저렇게 배열 안에 또다른 배열이 포함되는 것처럼 배열의 depth가 심해질 경우 구조가 복잡해서 배열을 다루기 점점 난해해진다. 더군다나 배열의 경우 원하는 요소를 탐색하기 위해선 적어도 O(logN) 이상의 시간복잡도를 필요로 한다. 만약, 배열과 같이 특정 데이터의 모음에서 내가 원하는 데이터를 O(1)과 같이 상수 시간으로 탐색할 수 있는 데이터가 있다면 어떨까? 왠지 이 장에서 그 해답을 찾을 수 있을 것 같다.</description>
			<pubDate>Thu, 29 Jul 2021 14:02:27 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/29/about-algorithm-chapter07.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/29/about-algorithm-chapter07.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>해시 테이블</category>
		</item>
		<item>
			<title>스택과 큐로 간결한 코드 생성</title>
			<description>이 장에서는 스택과 큐에 대해 알아본다. 사실 이 두 자료구조는 배열에 특정한 제약을 건 자료구조다. 제약이라는 개념 때문에 특수한 상황에서만 쓰이지 않을까 싶지만, 오히려 이러한 제약이 주는 규칙으로 인해 굉장히 많은 곳에서 쓰인다. 스택과 큐의 가장 큰 특징은 데이터 처리에 순서가 있다는 점이다. 스택과 큐는 그 제약에 따라 반드시 정해진 순서로 데이터를 처리한다. 이러한 특징 덕에 순서가 필요한 작업들에 유용하게 사용된다. 대표적으로 스케쥴러, 대기 등이 있으며 OS의 인터럽트(Interrupt) 작업에서 스택이 쓰인다.</description>
			<pubDate>Sat, 31 Jul 2021 02:58:37 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/07/31/about-algorithm-chapter08.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/07/31/about-algorithm-chapter08.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>큐</category>
			<category>스택</category>
		</item>
		<item>
			<title>재귀를 사용한 재귀적 반복</title>
			<description>컴퓨터 언어에서의 재귀란 자기 자신을 호출함을 의미한다. 알고리즘에서의 재귀는 매우 중요한 개념 중 하나로써, 그 특성 상 복잡한 연산 및 연산에 걸리는 소요 시간을 효과적으로 개선할 수 있다.</description>
			<pubDate>Tue, 03 Aug 2021 15:26:26 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/04/about-algorithm-chapter09.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/04/about-algorithm-chapter09.html</guid>
			<category>알고리즘</category>
			<category>자료구조</category>
			<category>누구나 자료 구조와 알고리즘</category>
			<category>재귀</category>
		</item>
		<item>
			<title>[OOP] 객체지향 프로그래밍(Object Oriented Programming)이란?</title>
			<description>IT 업계에 종사하게 된다면 십중팔구 JAVA, C++, C# 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 객체지향언어라는 점이다. 물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, C의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.</description>
			<pubDate>Sat, 07 Aug 2021 03:06:45 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/07/what-is-oop.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/07/what-is-oop.html</guid>
			<category>CS</category>
			<category>객체지향</category>
		</item>
		<item>
			<title>[OOP] 객체지향의 특징 - 캡슐화(Encapsulation)와 정보 은닉</title>
			<description>객체. 즉, 클래스의 내부 변수와 메소드를 하나로 패키징하는 특징이다. 객체에 선언된 변수나 메소드가 구분없이 중구난방으로 접근할 수 있다면 정상적인 객체로 보기 어렵다. 캡슐화와 비슷한 개념으로 정보 은닉이라는 개념이 있다. 정보 은닉은 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도한다. 이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다.</description>
			<pubDate>Sun, 08 Aug 2021 02:05:05 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/08/encapulation.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/08/encapulation.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>캡슐화</category>
			<category>정보 은닉</category>
			<category>접근제어자</category>
		</item>
		<item>
			<title>[OOP] 객체지향의 특징 - 상속(Inheritance)</title>
			<description>나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다. 나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 상속이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.</description>
			<pubDate>Wed, 11 Aug 2021 11:32:33 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/11/inheritance.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/11/inheritance.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>상속</category>
			<category>추상</category>
		</item>
		<item>
			<title>[OOP] 객체지향의 특징 - 다형성(Polymorphism)</title>
			<description>객체지향 언어는 동일한 이름을 가진 메소드를 허용하지 않는다. 예를 들어, "먹는다"는 동작이 구현된 메소드가 있다고 가정하자. 먹는다는 동일한 동작이 구태여 두 개나 구현될 필요는 없다. 이러한 관점에서 본다면 메소드의 고유 아이덴티티라고도 불릴 수 있는 메소드명의 유니크화는 어쩌면 당연하다. 하지만 조금 생각해보면 좀 이상하다. JAVA는 타입에 죽고 타입에 산다. JavaScript와 달리 파라미터에 아무 타입이나 넣을 수 없기 때문에, 정해진 타입 이외의 무언가를 넣으면 컴파일 단계에서 가차없이 컷한다.</description>
			<pubDate>Wed, 11 Aug 2021 15:32:42 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/12/polymorphism.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/12/polymorphism.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>다형성</category>
		</item>
		<item>
			<title>[OOP] 객체지향 5원칙(SOLID) - 단일 책임 원칙 (Single Responsibility Principle)</title>
			<description>올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 객체지향 5원칙(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다. 이 다섯가지 원칙은 아래와 같다.</description>
			<pubDate>Thu, 12 Aug 2021 16:37:48 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/13/single-responsibility-principle.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/13/single-responsibility-principle.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>객체지향 5원칙</category>
		</item>
		<item>
			<title>[OOP] 객체지향 5원칙(SOLID) - 개방-폐쇄 원칙 (Open-Closed Principle)</title>
			<description>개방 폐쇄 원칙이란 객체를 다룸에 있어서 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미. 좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다. 만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다. 이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.</description>
			<pubDate>Fri, 13 Aug 2021 19:04:40 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/14/open-closed-principle.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/14/open-closed-principle.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>객체지향 5원칙</category>
		</item>
		<item>
			<title>[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)</title>
			<description>리스코프 치환 원칙은 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다. 객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다. 리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.</description>
			<pubDate>Sun, 15 Aug 2021 04:42:11 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>객체지향 5원칙</category>
		</item>
		<item>
			<title>[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)</title>
			<description>인터페이스 분리 원칙이란 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙이다. 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다. 위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다. 왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, Method1을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다. 하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.</description>
			<pubDate>Mon, 16 Aug 2021 10:24:57 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/16/interface-segregation-principle.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/16/interface-segregation-principle.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>객체지향 5원칙</category>
		</item>
		<item>
			<title>[OOP] 객체지향 5원칙(SOLID) - 의존성 역전 원칙 (Dependency Inversion Principle)</title>
			<description>의존성 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다. 말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가? 고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, 객체는 객체보다 인터페이스에 의존해야한다로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.</description>
			<pubDate>Mon, 16 Aug 2021 18:06:35 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/17/dependency-inversion-principle.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/17/dependency-inversion-principle.html</guid>
			<category>CS</category>
			<category>객체지향</category>
			<category>객체지향 5원칙</category>
		</item>
		<item>
			<title>[SSL] SSL이란?</title>
			<description>웹을 배포해본 적이 있다면 SSL에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 https://로 시작하며, http://와 달리 보안(Secure)을 의미하는 s가 붙는다. 지금 이 사이트의 주소도 https://blog.itcode.dev로 SSL이 적용된 걸 확인할 수 있다. NAVER나 Google도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.</description>
			<pubDate>Tue, 17 Aug 2021 15:26:08 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/18/about-ssl.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/18/about-ssl.html</guid>
			<category>WEB</category>
			<category>CS</category>
			<category>객체지향</category>
			<category>SSL</category>
			<category>TLS</category>
		</item>
		<item>
			<title>[SSL] SSL 인증서</title>
			<description>이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다. SSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다. 그렇다면, 해당 도메인에 SSL이 적용되어 https를 사용할 수 있는 이유는 무엇일까?</description>
			<pubDate>Wed, 18 Aug 2021 01:55:24 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/18/about-ssl-license.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/18/about-ssl-license.html</guid>
			<category>WEB</category>
			<category>CS</category>
			<category>객체지향</category>
			<category>SSL</category>
		</item>
		<item>
			<title>[SSL] Freenom을 활용한 무료 도메인 발급하기</title>
			<description>이전 글들에서 SSL이 뭔지, 어떤식으로 동작하는지를 다뤘다. 사이트에 SSL을 적용하기 위해선 SSL 인증서를 발급받아야한다. SSL 인증서를 발급받기 위해선 인증받기 위한 도메인이 필요하다. 국내에서 서비스 중인 도메인 업체에서 쉽게 발급받을 수 있다. 위 업체는 도메인 외에도 호스팅 등 다양한 서비스를 제공한다. 이 외에도 여러 업체들이 있으며, 국내 뿐만 아니라 해외에서 서비스 중인 업체들도 있다. 업체마다 가격 및 정책이 다르니 발품팔다보면 좋은 금액으로 구매할 수도 있다. TLD(Top Level Domain)에 따라 가격이 달라지며, 저렴한 건 연간 몇 천원에서부터 비싸면 수십만원대에 이르기도 한다.</description>
			<pubDate>Wed, 18 Aug 2021 14:44:43 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/18/freenom-domain.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/18/freenom-domain.html</guid>
			<category>WEB</category>
			<category>CS</category>
			<category>객체지향</category>
			<category>SSL</category>
			<category>도메인</category>
		</item>
		<item>
			<title>[SSL] Windows 10에서 Let's Encrypt로 SSL 인증서 무료 발급받기</title>
			<description>도메인도 있겠다. 이제 이 도메인을 가지고 SSL 인증서를 발급받아보자. 물론 SSL 인증서 또한 발급받는데 비용이 든다. 대부분의 운영 중인 도메인 업체는 SSL 발급도 병행한다. 테스트 목적이라면 도메인과 마찬가지로 SSL 발급도 부담스러울 것이다. SSL 역시 무료로 발급받을 수 있는 방법이 있으며, 도메인보다 그 방법이 훨씬 많다.</description>
			<pubDate>Thu, 19 Aug 2021 14:37:21 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/19/lets-encrypt.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/19/lets-encrypt.html</guid>
			<category>WEB</category>
			<category>CS</category>
			<category>객체지향</category>
			<category>SSL</category>
		</item>
		<item>
			<title>[SSL] Tomcat에 SSL 적용하기</title>
			<description>SSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다. 이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.</description>
			<pubDate>Thu, 19 Aug 2021 15:35:21 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/20/apply-ssl.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/20/apply-ssl.html</guid>
			<category>WEB</category>
			<category>CS</category>
			<category>객체지향</category>
			<category>SSL</category>
			<category>Tomcat(톰캣)</category>
		</item>
		<item>
			<title>블로그 텍스트 색상 예시</title>
			<description>색상 테스트</description>
			<pubDate>Fri, 20 Aug 2021 06:43:00 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/20/color-test.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/20/color-test.html</guid>
			<category>잡담</category>
			<category>개발 블로그</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1020번 디지털 카운터</title>
			<description>지민이는 매 초마다 수가 증가하는 N자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. 10^N-1에 이르면 다시 0부터 시작한다. 각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다. 모든 인접한 두 개의 선분은 +로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다. 현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오. 1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 N자리를 채워야 하므로, N자리보다 작을 때는 앞에 0이 있을 수도 있다.</description>
			<pubDate>Mon, 23 Aug 2021 16:17:46 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/24/a1020.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/24/a1020.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>Dynamic Programming(동적 프로그래밍)</category>
			<category>PLATINUM</category>
			<category>PLATINUM II</category>
		</item>
		<item>
			<title>[백준 / JAVA] 백준 알고리즘 1021번 회전하는 큐</title>
			<description>지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다. 지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.</description>
			<pubDate>Wed, 25 Aug 2021 16:39:29 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/26/a1021.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/26/a1021.html</guid>
			<category>알고리즘</category>
			<category>백준</category>
			<category>JAVA(자바)</category>
			<category>덱</category>
			<category>SILVER</category>
			<category>SILVER IV</category>
		</item>
		<item>
			<title>[라즈베리파이 4] Hello Raspberry!</title>
			<description>개발자의 적지않은 수가 클라우드든, 디바이스든 자신만의 서버를 구축하여 다양하게 활용하고 있다. 개발을 하다보면 필연적으로 24시간 언제나 가동되는 서버 비스무리한 것이 필요할 때가 있다. 일례로 GitHub Pages의 경우 정적 페이지만 호스팅해줄 뿐, 백엔드나 DB는 사용할 수가 없어 동적 페이지 호스팅은 불가능하다. 그러나 개인 API 혹은 DB 서버가 존재한다면, 해당 서버와의 통신을 통해 더욱 동적 페이지 호스팅이 가능하다. 웹에서 백엔드가 갖는 역할을 생각해본다면, 개인이 활용 가능한 서버가 있고 없고의 차이는 천지차이가 난다. 나 역시도 개발하는 입장에서 제약없이 사용할 수 있는 서버의 소요가 이전부터 있어왔고, 개인 서버를 구축하기 위한 방안을 모색했다.</description>
			<pubDate>Sun, 29 Aug 2021 04:41:41 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/29/hello-raspberry.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/29/hello-raspberry.html</guid>
			<category>RaspberryPi</category>
			<category>라즈베리파이</category>
		</item>
		<item>
			<title>[라즈베리파이 4] 라즈베리파이에 Unbuntu 설치하기</title>
			<description>목요일을 기점으로 모든 준비물의 배송이 완료됐다. 클린 상태의 라즈베리파이는 OS가 별도로 깔려있지 않은 FreeDOS 상태이므로, 직접 OS를 설치해야한다. 컴퓨터도 주기적으로 포맷하고, 가상머신도 몇 개 돌려본 나로썬 크게 문제될 건 없지만, 이건 내가 지금까지 다루던 컴퓨터와는 좀 다르다는점이 흠. 한 번도 다뤄보지 않은 장비인데다, 일반적인 데스크탑에 비해 여러 차이점과 제약사항이 있어 그리 순탄하진 않았다.</description>
			<pubDate>Mon, 30 Aug 2021 16:51:39 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/08/31/ubuntu-in-raspberry.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/08/31/ubuntu-in-raspberry.html</guid>
			<category>RaspberryPi</category>
			<category>라즈베리파이</category>
			<category>Ubuntu</category>
		</item>
		<item>
			<title>[라즈베리파이 4] Ubuntu에 톰캣 설치하기</title>
			<description>OS가 준비되었으므로 본격적으로 웹 서버 환경을 구축해보자. 대표적인 WAS인 Tomcat을 활용하여 페이지를 호스팅한다.</description>
			<pubDate>Thu, 02 Sep 2021 14:07:19 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/02/ubuntu-in-tomcat.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/02/ubuntu-in-tomcat.html</guid>
			<category>RaspberryPi</category>
			<category>라즈베리파이</category>
			<category>Ubuntu</category>
			<category>도메인</category>
		</item>
		<item>
			<title>[Ubuntu] ufw로 방화벽 포트 설정하기</title>
			<description>모든 건물에는 입구가 존재한다. 일반적인 상황에서, 누구든지 해당 건물에 드나들기 위해선 좋든 싫든 입구를 통과해야한다. 이 입구라는 것이 또 마냥 열려있는 건 아니라서, 필요 시엔 개방되어있다가도 특정 시간에는 폐쇄되기도 한다. 심지어 어떤 곳은 까다롭기 그지없어서, 사람을 가려받기도 한다. 이를테면 보안구역이라던가, 금요일 밤의 클럽이라던가. PC통신도 이와 원리가 별반 다를 바 없다. 보기엔 그냥 막 통신하는 것 같아도, 저마다 할당받은 입구를 통해 PC에 드나든다. PC가 건물이라고 한다면, PC의 입구는 포트(PORT)라 할 수 있다.</description>
			<pubDate>Fri, 03 Sep 2021 16:26:20 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/04/firewall-with-ufw.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/04/firewall-with-ufw.html</guid>
			<category>Ubuntu</category>
			<category>방화벽</category>
		</item>
		<item>
			<title>[라즈베리파이 4] 라즈베리파이에 도메인 입히기</title>
			<description>지금까지 과정을 거치면서 라즈베리파이에 OS를 설치하고, Tomcat을 구동하여 웹 서버로 동작할 수 있도록 환경을 구축했다. 이제 우리는 라즈베리파이의 IP로 접속하여 웹 사이트를 호스팅할 수 있다. 하지만 정상적인 페이지라면 IP를 입력하여 접속하지 않는다. Domain을 발급받아 IP에 연동하고, 이를 URL 주소로 사용할 것이다. 이 장에서는 Domain을 직접 구입하고 라즈베리파이 서버에 이를 연동한다.</description>
			<pubDate>Sat, 04 Sep 2021 03:09:04 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/04/raspberry-domain.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/04/raspberry-domain.html</guid>
			<category>RaspberryPi</category>
			<category>라즈베리파이</category>
			<category>Ubuntu</category>
			<category>도메인</category>
		</item>
		<item>
			<title>[라즈베리파이 4] Let's Ecrypt로 Ubuntu 서버에 HTTPS 통신 제공하기</title>
			<description>이전 장에서 Google Domains를 통해 dev 도메인을 발급받았다. 이 블로그의 주소는 실제로 구입한 https://blog.itcode.dev 도메인이 적용되어있다. dev 도메인은 강화된 보안정책이 적용되어있다. 해당 도메인으로의 모든 HTTP 통신은 반드시 HTTPS 보안 통신으로만 제공된다. 네트워크 계층에서 https 프로토콜로 라우팅하므로 좋든 싫든 HTTPS 서비스를 제공해야만 한다.</description>
			<pubDate>Mon, 06 Sep 2021 07:50:40 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/06/raspberry-ssl-domain.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/06/raspberry-ssl-domain.html</guid>
			<category>RaspberryPi</category>
			<category>라즈베리파이</category>
			<category>Ubuntu</category>
			<category>Tomcat(톰캣)</category>
			<category>SSL</category>
		</item>
		<item>
			<title>[라즈베리파이 4] 원격 환경 구축하기 (SSH, RDP)</title>
			<description>이제 얼추 라즈베리파이에 그럴듯한 웹서버 환경이 구축됐다. 하지만 라즈베리파이를 다루기 위해서 기기에 직접 모니터랑 키보드, 마우스를 연결해서 쓰긴 좀 번거롭다. 이 주제에서의 라즈베리파이는 어디까지나 서브로 운영되는 웹서버이므로, 메인 컴퓨터가 될 수 없다. 즉, 개발같은 대부분의 작업은 메인 컴퓨터에서 진행하고, 배포만 서버가 담당하는 방식이다. 이렇게 디바이스가 서로 나뉠 경우, 두 디바이스의 접근이 서로 원활해야한다. 한 마디로, 원격 환경이 필요하다. 이 장에서는 라즈베리파이에 원격 환경을 구축한다. SSH, RDP 통신을 구축함으로써 SSH 혹은 윈도우 PC 어디에서나 라즈베리파이에 접근할 수 있도록 구성한다.</description>
			<pubDate>Wed, 08 Sep 2021 13:40:38 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/08/raspberry-remote.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/08/raspberry-remote.html</guid>
			<category>RaspberryPi</category>
			<category>라즈베리파이</category>
			<category>Ubuntu</category>
			<category>SSH</category>
			<category>RDP</category>
		</item>
		<item>
			<title>[라즈베리파이 4] MariaDB 구축하기</title>
			<description>드디어 라즈베리파이 개발환경 구축의 마지막 장이다. DBMS는 다양한 데이터를 저장하는 저장소인 DB(Database)를 관리하는 시스템이다. 필요한 데이터를 DB에 저장하고, 이를 적재적소에 꺼내어 데이터를 다룰 수 있도록 해준다. 웹 서버와 DBMS를 연동하면 사용자의 계정 정보, 설정 등을 저장하고 활용할 수 있다.</description>
			<pubDate>Mon, 13 Sep 2021 17:04:02 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/14/ubuntu-in-mariadb.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/14/ubuntu-in-mariadb.html</guid>
			<category>RaspberryPi</category>
			<category>라즈베리파이</category>
			<category>Ubuntu</category>
			<category>MariaDB</category>
			<category>RDBMS</category>
		</item>
		<item>
			<title>[Ubuntu] Ubuntu 원격 프로토콜 보안 강화하기</title>
			<description>SSH, SFTP와 같은 원격 프로토콜은 서버의 접근성을 향상시켜주지만, 서버의 보안성을 극도로 훼손한다. 공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다. 따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다. 외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.</description>
			<pubDate>Tue, 14 Sep 2021 16:53:21 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/15/increase-ubuntu-remote-security.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/15/increase-ubuntu-remote-security.html</guid>
			<category>Ubuntu</category>
			<category>SSH</category>
			<category>SFTP</category>
		</item>
		<item>
			<title>[NextJS] 블로그 개편기 - 1. Record One</title>
			<description>인터넷으로 알음알음 React를 배워, 뭣도 모르고 호기롭게 블로그를 개발한지가 5월이였다. 그 때만 해도 이 재밌는 걸 가지고 뭐라도 만들어보고 싶다는 강한 열망에 사로잡혔었는데, 그 때 눈에 보였던 게 개발 블로그였다. 그 때 내가 사용하던 블로그는 Jekyll 기반의 GitHub 블로그였는데, 재밌어보여서 시작했다가 며칠 안 가 관둔지가 1년이 넘었었다. 블로그에 흥미가 떨어진 이유 중 하나가 뭐 좀 할라치면 남이 작성한 코드를 일일히 분석한다는 스트레스였다. 개발 블로그를 보자마자 떠오른 내 머릿속의 흐름은 대충 저랬다.</description>
			<pubDate>Mon, 20 Sep 2021 18:22:35 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/21/nextjs-reorganization-1.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/21/nextjs-reorganization-1.html</guid>
			<category>NextJS</category>
			<category>React</category>
		</item>
		<item>
			<title>[NextJS] 블로그 개편기 - 2. Typescript 입히기</title>
			<description>내가 JavaScript를 접하고 기본 개념 정도에 익숙해졌을 때, 개발 커뮤니티에서 전설처럼 들려오던 이야기를 듣게 되었다.</description>
			<pubDate>Mon, 20 Sep 2021 20:30:21 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/21/nextjs-reorganization-2.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/21/nextjs-reorganization-2.html</guid>
			<category>NextJS</category>
			<category>React</category>
			<category>TypeScript</category>
		</item>
		<item>
			<title>[NextJS] 블로그 개편기 - 3. SCSS 입히기</title>
			<description>원래 내 블로그는 JS-in-CSS 스타일 방식을 사용하고 있었다. 그 이유는 Material-UI 때문. Material-UI의 공식 예제에서 대놓고 JS-in-CSS 방식으로 설명하기 때문에, React 기초 수준이였던 난 당연히 이렇게 해야하는 줄 알고 있었다. 하지만 개발을 거듭하며, 그 중 몇몇은 복잡한 스타일을 강요받기도 하며 점점 스타일 구문이 비대해지는 컴포넌트가 생겨나기 시작했다. 이에 따라 JS-in-CSS의 단점이 점점 대두되기 시작했다. 대표적인 문제점으로 FOCU(Flash Of Unstyled Content). 스타일 렌더링에 시간이 소요되어, 사용자가 렌더링 이전의 페이지를 보게 되는 현상이다. 내 페이지의 경우 약 1초가 조금 안 되게 FOUC가 발생했는데, 사용자 경험을 극도로 해치는 일이였다. 블로그 개편을 마음먹게 된 가장 큰 이유 역시 이 FOCU 현상 때문이였으며, 관련 정보 조사 결과 CSS-in-CSS의 성능이 월등히 뛰어나다는 점을 확인했다.</description>
			<pubDate>Fri, 24 Sep 2021 04:17:24 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/09/24/nextjs-reorganization-3.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/09/24/nextjs-reorganization-3.html</guid>
			<category>NextJS</category>
			<category>React</category>
			<category>SCSS</category>
			<category>CSS</category>
		</item>
		<item>
			<title>[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 1. OAuth2.0이란?</title>
			<description>사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 "네이버로 로그인하기"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다. 이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 "플랫폼으로 로그인하기"와 같은 기능을 제공한다. 이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.</description>
			<pubDate>Wed, 13 Oct 2021 15:56:31 GMT</pubDate>
			<link>https://blog.itcode.dev/posts/2021/10/14/oauth2-java-server-1.html</link>
			<guid isPermaLink="true">https://blog.itcode.dev/posts/2021/10/14/oauth2-java-server-1.html</guid>
			<category>JAVA</category>
			<category>OAuth2.0</category>
		</item>
	</channel>
</rss>