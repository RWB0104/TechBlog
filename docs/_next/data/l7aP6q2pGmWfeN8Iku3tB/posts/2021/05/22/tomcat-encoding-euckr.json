{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"도메인이란?","excerpt":"도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다. 인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 고유한 12자리 숫자로 구성된 IP주소를 가진다. IP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다. 유동 IP: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨. 고정 IP: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함. 우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, 특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요하다.","coverImage":"https://user-images.githubusercontent.com/50317129/120056028-b2985880-c074-11eb-8cc3-39f5f10a2c7f.png","date":"2021-05-22T12:52:51","type":"posts","category":"WEB","tag":["WEB(웹)","Domain(도메인)"],"comment":true,"publish":true},"name":"2021-05-22-about-domain.md","content":"\r\n# Domain(도메인)이란?\r\n\r\n도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다.  \r\n인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 <span class=\"blue-500\">고유한 12자리 숫자로 구성된 IP주소</span>를 가진다.  \r\nIP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다.\r\n\r\n* <span class=\"primary\">유동 IP</span>: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨.\r\n* <span class=\"primary\">고정 IP</span>: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함.\r\n\r\n우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, <span class=\"green-500\">특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요</span>하다.  \r\n불행히도, IP는 불규칙적인 숫자로 이루어져있어, 사람이 쉽게 기억하기 다소 어렵다. 이러한 불편함을 해소하기 위한 것이 Domain(도메인)이다.\r\n\r\n도메인은 <span class=\"pink-400\">SLD(서브도메인)</span>, <span class=\"pink-400\">도메인</span>, <span class=\"pink-400\">TLD(최상위 도메인)</span>으로 구분되며, 해당 도메인의 정보는 1차적으로 각 로컬 DNS 서버가 관리하며, 최종적으로는 TLD를 관리하는 Root DNS에서 관리한다.\r\n\r\n> 도메인에 대한 자세한 내용은 이전에 작성된 [URI? URL? URN? 리소스 식별자 구분하기](/posts/uri-url-urn)를 참조한다.\r\n\r\n# 그래서 도메인을 왜 쓰는데?\r\n\r\n우리가 흔히 <span class=\"green-A700\">네이버</span>라고 부르는 사이트의 실제 IP는 [125.209.222.141](http://125.209.222.141)이다. 하지만 우리들 중 그 누구도 저런 IP로 <span class=\"green-A700\">네이버</span>에 접속하지 않는다. 대신 우리는 [https://www.naver.com](https://www.naver.com)이라는 도메인으로 접속한다. 이유는 간단하다. 주소 자체에 <span class=\"green-A700\">naver</span>라는 키워드가 포함되어 있으므로 기억하기 쉽기 때문이다.\r\n\r\n<span class=\"pink-400\">도메인</span>은 숫자가 아닌, 문자 형태로 이루어진 주소다. 문자이므로, 주소에 의미를 부여하기 용이하다. 사용자가 주소를 기억하기 쉬워 주소에 대한 접근성을 높여준다.  \r\n생성한 <span class=\"pink-400\">도메인</span>에 원하는 IP를 연결하면 <span class=\"pink-400\">도메인</span> 주소를 통해서도 해당 IP에 접근할 수 있다.\r\n<span class=\"pink-400\">도메인</span> 제공 업체에 따라, 영숫자 뿐만 아니라 한글과 같은 유니코드 문자도 지원하므로, 딱딱한 IP 대신 개성있는 주소를 사용할 수 있는 것이다.\r\n\r\n# 도메인의 원리\r\n\r\n여기서 의문점이 한 가지 생긴다. IP [125.209.222.141](http://125.209.222.141)와 <span class=\"pink-400\">도메인</span> [https://www.naver.com](https://www.naver.com)가 <span class=\"green-A700\">네이버</span>를 가리키는 주소인건 알겠는데, 인터넷은 과연 두 주소의 연결고리를 어떻게 아는 걸까?\r\n\r\n이는 <span class=\"pink-400\">도메인</span>의 동작 원리를 보면 알 수 있다. `blog.itcode.dev` <span class=\"pink-400\">도메인</span>에 접근하는 과정을 예시로 보자.\r\n\r\n1. HTTP 통신을 통해 `blog.itcode.dev`에 접근을 시도한다.\r\n2. 네트워크에 지정된 로컬 DNS에게 `blog.itcode.dev`의 정보를 요청한다.\r\n   * 만약 로컬 DNS가 해당 도메인의 정보를 보유하고 있을 경우, 즉시 정보를 제공한다.\r\n3. `blog.itcode.dev`에 대한 정보가 없을 경우, 근접한 Root DNS에 해당 도메인의 정보를 요청한다.\r\n4. Root DNS가 `.io` TLD를 관리하는 DNS 서버의 정보를 로컬 DNS에 제공한다.\r\n5. 로컬 DNS가 `blog.itcode.dev`를 관리하는 TLD의 DNS 서버에 해당 정보를 요청한다.\r\n6. TLD DNS 서버가 `blog.itcode.dev`에 대한 정보(IP 등)을 제공한다.\r\n7. 로컬 DNS가 `blog.itcode.dev`의 IP를 알고 있으므로, 이를 통해 해당 사이트에 접근할 수 있다.\r\n\r\n기본적으로 <span class=\"pink-400\">도메인</span>은 반드시 하나의 IP와 연결된다. 이런 특징 덕분에 <span class=\"pink-400\">도메인</span>은 항상 특정한 하나의 IP만을 반환한다.","url":["2021-05-22-about-domain","2021","05","22","about-domain"]},"next":{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1004번 어린 왕자","excerpt":"어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-22T21:42:23","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","기하학","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-22-a1004.md","content":"\r\n# 어린 왕자\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/8.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1004번 문제](https://www.acmicpc.net/problem/1004)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.\r\n\r\n![image](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfcmhrjj_113gw6bcng2_b.gif)\r\n\r\n빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.\r\n\r\n위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. (행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다고 가정한다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.)\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 $(x_1, y_1)$과 도착점 $(x_2, y_2)$이 주어진다. 두 번째 줄에는 행성계의 개수 $n$이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 $(c_x, c_y, r)$이 주어진다. 입력제한은 다음과 같다. $(-1000 ≤ x_1, y_1, x_2, y_2, c_x, c_y ≤ 1000, 1 ≤ r ≤ 1000, 1 ≤ n ≤ 50)$\r\n\r\n좌표와 반지름은 모두 정수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n-5 1 12 1\r\n7\r\n1 1 8\r\n-3 -1 1\r\n2 2 2\r\n5 5 1\r\n-4 5 1\r\n12 1 1\r\n12 1 2\r\n-5 1 5 1\r\n1\r\n0 0 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n1002번째 알고리즘의 내용을 응용하면 쉽게 풀 수 있는 문제인 것 같다. 실제로 별다른 레퍼런스를 찾지도 않고 풀 수 있었으니.\r\n\r\n문제를 풀기 전에 몇 가지 집고 넘아갈 게 있다.  \r\n숫자들 때문에 입력의 한 세트를 착각하기 쉽다.\r\n\r\n위 예제를 기준으로 설명하면, 첫 번째 숫자는 세트의 갯수. 본문에서는 `2`이므로, 두 세트를 테스트하므로 결과는 두 줄이 출력된다.  \r\n이후 테스트에 필요한 데이터가 출력된다.\r\n\r\n-5 1 12 1 <= $x_1, y_1, x_2, y_2$  \r\n7 <= 행성 갯수  \r\n1 1 8 <= $c_{x1}, c_{y1}, r_1$  \r\n-3 -1 1  \r\n2 2 2  \r\n5 5 1  \r\n-4 5 1  \r\n12 1 1  \r\n12 1 2 <= 행성 갯수만큼 출력됨\r\n\r\n또한, 결과는 행성계의 진입/이탈 횟수를 통틀어서 출력하므로 굳이 진입/이탈을 구분하여 저장할 필요는 없다.\r\n\r\n문제에서 **출발점에서 도착점까지 가는데 통과해야하는 행성계(이하 원, circle)의 최소**를 목적으로 두기 때문에, 반드시 통과해야하는 원만 계산하면 된다.  \r\n출발/도착점이 임의의 원 안에 포함될 경우 반드시 진입/이탈이 일어난다. 따라서, 출발/도착점을 온전히 포함하는 원의 갯수를 계산하면 진입/이탈의 횟수를 구할 수 있다.  \r\n주의할 점이 있는데, **한 원이 출발/도착점을 모두 포함할 경우 계산에서 제외**시켜야 한다.  \r\n하나의 원이 출발/도착점을 전부 포함할 경우, 원 안에서 이동하기 때문에 진입/이탈이 일어나지 않기 때문.  \r\n\r\n![example](https://user-images.githubusercontent.com/50317129/120758690-188d5000-c54d-11eb-917c-f910eb7b3199.png)\r\n\r\n원리는 간단하다. 원점과 점의 거리를 계산한다. 계산한 거리가 원의 반지름보다 짧을 경우, 해당 원은 점을 포함하는 셈이다.  \r\n이를 식으로 정리하면 아래와 같다.\r\n\r\n|     변수     |      의미      |\r\n| :----------: | :------------: |\r\n|   $x$, $y$   |   원점 좌표    |\r\n| $x_o$, $y_o$ | 원의 원점 좌표 |\r\n|     $r$      |  원의 반지름   |\r\n\r\n변수는 위 표와 같이 정의하고 <span class=\"green-A700\">한 원이 원점을 포함하는 식</span>을 전개한다.\r\n\r\n$$\r\n\\sqrt{(x_0 - x)^2 + (y_0 - y)^2} < r\r\n$$\r\n\r\n위 식을 코드로 표현하면 되는 비교적 간단한 알고리즘이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1004 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/05/22/a1004\">1004 풀이</a>\r\n * @since 2021.04.24 Sat 02:15:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint length = scanner.nextInt();\r\n\t\tscanner.nextLine();\r\n\t\t\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tString base = scanner.nextLine();\r\n\t\t\t\r\n\t\t\tint x_start = Integer.parseInt(base.split(\" \")[0]);\r\n\t\t\tint y_start = Integer.parseInt(base.split(\" \")[1]);\r\n\t\t\t\r\n\t\t\tint x_end = Integer.parseInt(base.split(\" \")[2]);\r\n\t\t\tint y_end = Integer.parseInt(base.split(\" \")[3]);\r\n\t\t\t\r\n\t\t\tint through = 0;\r\n\t\t\t\r\n\t\t\tint count = scanner.nextInt();\r\n\t\t\tscanner.nextLine();\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < count; j++)\r\n\t\t\t{\r\n\t\t\t\tString circle = scanner.nextLine();\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(circle.split(\" \")[0]);\r\n\t\t\t\tint y = Integer.parseInt(circle.split(\" \")[1]);\r\n\t\t\t\tint r = Integer.parseInt(circle.split(\" \")[2]);\r\n\t\t\t\t\r\n\t\t\t\tboolean hasStartContain = hasContain(x_start, y_start, x, y, r);\r\n\t\t\t\tboolean hasEndContain = hasContain(x_end, y_end, x, y, r);\r\n\t\t\t\t\r\n\t\t\t\t// 해당 행성이 출발 혹은 도착점 중 하나만을 포함할 경우\r\n\t\t\t\tif (!(hasStartContain && hasEndContain) && (hasStartContain || hasEndContain))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrough++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(through);\r\n\t\t}\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 출발/도착점 포함 여부 반환 함수\r\n\t *\r\n\t * @param xo: [int] 출발/도착점의 x좌표\r\n\t * @param yo: [int] 출발/도착점의 y좌표\r\n\t * @param x: [int] 행성의 x좌표\r\n\t * @param y: [int] 행성의 y좌표\r\n\t * @param r: [int] 행성의 반지름\r\n\t *\r\n\t * @return [boolean] 출발/도착점 포함 여부\r\n\t */\r\n\tprivate static boolean hasContain(int xo, int yo, int x, int y, int r)\r\n\t{\r\n\t\treturn Math.sqrt(Math.pow(xo - x, 2) + Math.pow(yo - y, 2)) < r;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 기하학","url":["2021-05-22-a1004","2021","05","22","a1004"]}},"group":[],"data":{"header":{"title":"Tomcat(톰캣) 콘솔창 한글 인코딩 깨짐 현상 해결하기","excerpt":"톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상. Windows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-22T12:52:51","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-22-tomcat-encoding-euckr.md","content":"<h1 id=\"와장창!\">와장창! <a href=\"#와장창!\">🔗</a></h1><p><img src=\"https://user-images.githubusercontent.com/50317129/119212087-342a3c80-baf1-11eb-89bc-06829a5f7c16.png\" alt=\"Encoding Broken\"></p>\n<p>톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상.<br>Windows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.</p>\n<h1 id=\"도대체-왜?\">도대체 왜? <a href=\"#도대체-왜?\">🔗</a></h1><p>실력 좋은 개발자가 아니더라도, 컴퓨터와 친분이 있다면 언어가 깨짐은 곧 인코딩의 불일치라는 걸 개괄적으로 이해하고 있다. 이러한 현상이 일어나는 이유는 아래와 같은데,</p>\n<ul>\n<li><span class=\"primary\">Windows Console</span>: Windows OS 설정 언어의 기본 인코딩 (한국어는 <strong>EUC-KR</strong>)</li>\n<li><span class=\"primary\">Tomcat Console</span>: 설정파일의 인코딩 (<strong>기본 UTF-8</strong>)</li>\n</ul>\n<p>이 처럼, 기본 인코딩이 서로 다르다.</p>\n<h1 id=\"해결책\">해결책 <a href=\"#해결책\">🔗</a></h1><p>이를 해결하는 방법은 크게 두 가지가 존재한다. 개인적으로 <span class=\"red-300\">두 번째 방법을 추천</span>한다.</p>\n<h3 id=\"Windows-Console 인코딩 변경하기\">Windows Console 인코딩 변경하기 <a href=\"#Windows-Console 인코딩 변경하기\">🔗</a></h3><p>첫 번째로, Windows Console의 인코딩을 변경한다. Windows 10 기준으로 OS의 기본 콘솔은 <span class=\"green-500\">cmd</span>와 <span class=\"green-500\">PowerShell</span> 두 가지다. <strong>사용할 콘솔의 기본 인코딩을 EUC-KR에서 UTF-8로 변경</strong>해주면 된다.</p>\n<p>애석하게도, 두 콘솔 모두 인코딩을 변경하는 옵션을 제공하지 않는다. 그렇다고 방법이 없는 건 아니고, 레지스트리 수정을 통해 문제를 해결할 수 있다.</p>\n<br />\n\n<ol>\n<li>작업표시줄에서 <code class=\"inline-code\">regedit</code>을 입력하여 <span class=\"blue-500\">레지스트리 편집기</span>를 띄운다.</li>\n<li><code class=\"inline-code\">HKEY_CURRENT_USER\\Console</code> 경로에 접근한다. 사용자 계정에 설치된 콘솔들이 출력된다. (cmd, PowerShell, Git 등)</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/119212160-83706d00-baf1-11eb-92c8-b41458950f20.png\" alt=\"Registry\"></p>\n<ol start=\"3\">\n<li>인코딩을 변경하려는 콘솔의 폴더를 클릭한다.<ul>\n<li><strong>%SystemRoot%_system32_cmd.exe</strong>: cmd</li>\n<li><strong>%SystemRoot%_System32_WindowsPowerShell_v1.0_powershell.exe</strong>: 32비트 PowerShell</li>\n<li><strong>%SystemRoot%_SysWOW64_WindowsPowerShell_v1.0_powershell.exe</strong>: 64비트 PowerShell</li>\n</ul>\n</li>\n<li><code class=\"inline-code\">CodePage</code> 키를 더블클릭하여 편집을 수행한다.\n<code class=\"inline-code\">CodePage</code>가 없을 경우, 오른쪽 마우스 버튼을 클릭하여 새 DWORD(32비트) 키를 동일한 이름으로 생성한다.</li>\n<li>값 데이터를 10진수 <code class=\"inline-code\">65001</code>로 변경한다.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/119212198-ab5fd080-baf1-11eb-981b-82599148c8f8.png\" alt=\"Registry\"></p>\n<ol start=\"6\">\n<li>앞으로 실행되는 Windows Console은 해당 인코딩이 적용된다.</li>\n</ol>\n<p>이렇게 하면 Windows Console과 Tomcat의 기본 인코딩이 UTF-8로 서로 일치하므로, 한글이 정상적으로 출력된다.<br>하지만 이 방법은 Windows Console의 인코딩을 바꾸므로, 차후 해당 <span class=\"red-500\">콘솔을 통해 다른 작업이나 프로그램이 실행될 경우 엉뚱한 프로그램의 한글이 깨질 우려</span>가 있다.<br>(대부분은 OS 언어의 기본 인코딩을 따라가도록 설계함)</p>\n<p>Windows Console은 범용적으로 사용되는 프로그램이므로, 다른 작업에 영향을 줄 수 있다. 내가 이 방법을 굳이 추천하지 않는 이유이기도 하다.  </p>\n<h3 id=\"Tomcat-Console 인코딩 변경하기\">Tomcat Console 인코딩 변경하기 <a href=\"#Tomcat-Console 인코딩 변경하기\">🔗</a></h3><p>두 번째로, Tomcat Console의 인코딩을 변경한다. 첫 번째 방법보다 이 방법이 나은 이유는, Tomcat이라는 제한적인 용도의 콘솔에만 영향을 미치기 때문. 어차피 Tomcat Console의 인코딩이 불일치해서 생기는 문제이므로, 이쪽을 바꾸는게 상식적으로도 맞다.</p>\n<p>대부분 마찬가지로 위 방법처럼 레지스트리를 수정하라고 안내할텐데, Tomcat은 굳이 그렇게 바꿔줄 필요 없다.</p>\n<ol>\n<li><code class=\"inline-code\">%TOMCAT_HOME%\\conf\\logging.properties</code>을 연다.</li>\n<li><strong>java.util.logging.ConsoleHandler.encoding</strong>의 값을 <strong>EUC-KR</strong>로 변경한다.\n별다른 설정이 없었다면, UTF-8이 기본으로 설정되어 있다.</li>\n<li>앞으로 실행되는 Tomcat은 해당 인코딩이 적용된다.</li>\n</ol>\n<p>Tomcat을 실행하면 한글이 정상적으로 출력된다.</p>\n","url":["2021-05-22-tomcat-encoding-euckr","2021","05","22","tomcat-encoding-euckr"],"toc":[{"text":"와장창!","tag":"와장창!","depth":1},{"text":"도대체 왜?","tag":"도대체-왜?","depth":1},{"text":"해결책","tag":"해결책","depth":1},{"text":"Windows Console 인코딩 변경하기","tag":"Windows-Console 인코딩 변경하기","depth":3},{"text":"Tomcat Console 인코딩 변경하기","tag":"Tomcat-Console 인코딩 변경하기","depth":3}]},"hash":"8de03571fc1"},"__N_SSG":true}