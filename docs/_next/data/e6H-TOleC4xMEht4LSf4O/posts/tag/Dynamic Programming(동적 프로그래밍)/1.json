{"pageProps":{"posts":[{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1006번 습격자 초라기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-06T22:42:02","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","PLATINUM","PLATINUM III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-06-A1006.md","content":"\r\n# 습격자 초라기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1006번 문제](https://www.acmicpc.net/problem/1006)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg\" width=\"400px\" />\r\n</p>\r\n\r\n초라기는 각각 $W$명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.\r\n\r\n1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.\r\n2. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.\r\n3. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 $W$ 보다 작거나 같아야 한다.\r\n\r\n이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n첫째 줄에는 (구역의 개수)/2 값 $N$과 특수 소대원의 수 $W$가 주어진다. ($1 ≤ N ≤ 10000$, $1 ≤ W ≤ 10000$).\r\n\r\n둘째 줄에는 $1 ~ N$번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 $N + 1 ~ 2N$번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ $W$)\r\n\r\n## 출력\r\n\r\n각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n8 100\r\n70 60 55 43 57 60 44 50\r\n58 40 47 90 45 52 80 40\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n## 힌트\r\n\r\n하나의 특수 소대로 인접한 두 영역을 커버할 수 있는 배치는 (2,10), (9,16), (4,5), (7,8), (13,14) 이다. 그리고 나머지 6개 구역은 각각 하나의 특수 소대로 커버할 수 있다. 그러므로 최소 11개 특수 소대를 침투시켜야 한다.\r\n\r\n# 풀이\r\n\r\n백준 알고리즘을 순서대로 푸는 나 같은 초심자들에게 <span class=\"red-A400\">힘의 차이</span>를 느끼게 해주는 문제라고 한다. [solved.ac](https://solved.ac/)에 의하면 문제 등급이 무려 <span class=\"teal-A400\">PLATINUM III</span> 수준. 지금까지 푼 문제 중 가장 높은 등급이 [ACM Craft](/posts/2021/06/01/A1005/) (<span class=\"amber-A400\">GOLD III</span>) 수준임을 감안하면 월등히 높은 수준의 문제. 실제로 풀면서도 혼자서는 도저히 방법이 안 떠오르는데다, 풀이를 봐도 이해가 잘 안 됐다.\r\n\r\n해당 문제에 주어지는 <span class=\"primary\">구역</span>은 원형이다. 문제를 쉽게 접근하기 위해선 이 원형을 임의로 잘라 직사각형 형태로 전개해야 한다. 즉, <span class=\"error\">풀 때는 직사각형 형태지만, 실제로는 원형이므로 직사각형의 잘린 양 끝부분까지 염두하여 계산</span>을 해야한다. 난이도를 상승시키는 요인 중 하나.\r\n\r\n케이스에 제시된 예제를 기준으로 구역을 사각형으로 도식화하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n위 사진과 같이 8x8 배열로 표현할 수 있다. 여기서 여기서 6번째 행까지 특수소대로 채울 수 있는 최소값은 어떻게 구할 수 있을까?\r\n\r\n역으로 한번 생각해보자. 우리 특수소대는 너무나 유능해서 항상 최소의 팀만으로 목표 구역을 점령한다고 해보자. 작전 보고서엔 아래와 같이 점령한 구역을 표시하며, 이를 <span class=\"yellow-a500\">노란색</span> 영역으로 마킹해서 보여준다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926996-378d0d00-c71a-11eb-9b0f-baacb8da1647.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, <span class=\"yellow-a500\">노란색</span> 영역은 최소의 특수소대팀이 투입된 것이며, 우리가 실제로 구현할 알고리즘의 결과물이기도 하다.\r\n\r\n문제의 설정 상, 특수소대는 반드시 한 팀이 온전히 투입되어야 하며, 최소로 투입 가능한 인원 역시 한 팀이다. 그렇다면 위 사진에서 특수소대 한 팀이 커버할 수 있는 영역을 제외해보면 아래와 같이 세 케이스 $a$, $b$, $c$로 나눌 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927024-568b9f00-c71a-11eb-9309-7e4ef2f06ac2.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, 우리가 저 세 케이스에 대한 특수소대팀의 최소값을 계산할 수 있다면, 결과적으로 6번째 행 전체를 커버하는 특수소대팀의 수를 구할 수 있다. 이미 최소 인원이 나머지 구역을 점령한 상황에서, 투입할 수 있는 최소 인원인 한 팀만 투입할 수 있기 때문.\r\n\r\n여러 블로그에서 위 세 그림을 많이 봤을 텐데, 뜬금없이 저런 그림이 등장함에는 이와같은 배경이 있는 것이다.\r\n\r\n## 변수\r\n\r\n알고리즘 설계에 사용할 변수는 아래와 같다.\r\n\r\n* $T$: 케이스 수\r\n* $N$: 구역의 행 수\r\n* $e$: 구역별 적의 수\r\n* $a_i$: 첫 번째 케이스의 특수소대 최소 투입 수\r\n* $b_i$: 두 번째 케이스의 특수소대 최소 투입 수\r\n* $c_i$: 세 번째 케이스의 특수소대 최소 투입 수\r\n\r\n## a 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927050-77ec8b00-c71a-11eb-8034-5b02a6c04246.png\" width=\"512px\" />\r\n</p>\r\n\r\n첫번째 케이스로 $a_5$의 최소값 공식을 설계하자.\r\n\r\n위에서 했던 방식과 마찬가지로 추론하면 $a_5$에서 한팀을 뺀 $a_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927077-90f53c00-c71a-11eb-96cd-38edba684b10.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = c_5$ 이므로 $a_5 = c_5 + 1$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{05} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927092-9c486780-c71a-11eb-91c7-1922f98a1b01.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = b_4$ 이므로 $a_5 = b_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $a_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $a_5 = c_5 + 1$ -> $a_{i+1} = c_{i+1} + 1$\r\n* $a_5 = b_4 + 1$ -> $a_{i+1} = b_i + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## b 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927110-ac604700-c71a-11eb-989a-3d97d8e6a3ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5$의 최소값 공식을 설계하자.\r\n\r\n$b_5$에서 한팀을 뺀 $b_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927135-c0a44400-c71a-11eb-9c22-4e1303799b3b.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = c_5$ 이므로 $b_5 = c_5 + 1$\r\n\r\n$a_5$의 식과 동일하다.\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{14} + e_{15} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927154-d285e700-c71a-11eb-8b25-14fd85e1b1b0.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = a_4$ 이므로 $b_5 = a_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $b_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $b_5 = c_5 + 1$ -> $b_{n+1} = c_{n+1} + 1$\r\n* $b_5 = a_4 + 1$ -> $b_{n+1} = a_n + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## c 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927173-e3365d00-c71a-11eb-9c1b-dfb34ab3b444.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5$의 최소값 공식을 설계하자. ($c_5$는 4행까지 채워짐에 유의하자)\r\n\r\n$c_5$에서 한팀을 뺀 $c_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 여러 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927189-f47f6980-c71a-11eb-8c17-2120a82b4b6e.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 - 1 = a_4$ 이므로 $c_5 = a_4 + 1$\r\n\r\n$c_5 - 1 = b_4$ 이므로 $c_5 = b_4 + 1$\r\n\r\n두 케이스 중 더 작은 케이스가 $c_5$이므로 아래의 식으로 귀결된다.\r\n\r\n$c_5 = min(a_4 + 1, b_4 + 1)$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927199-ff39fe80-c71a-11eb-8b45-bb4f13aadf08.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 한팀이 네개의 구역을 커버할 수 있을 경우\r\n\r\n$c_i$의 경우 한 가지 특이 케이스가 발생한다. $a_i$, $b_i$의 경우 최소 투입인원인 1을 뺀 값만을 계산했다. $c_i$의 경우 직사각형이라는 특징 때문에 최대 4개 구역을 2팀이 점령할 수 있다.\r\n\r\n$e_{03} + e_{04} ≤ W$ 이고 $e_{13} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927226-11b43800-c71b-11eb-8845-7597a3a502b8.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_3 + 2$\r\n\r\n모든 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $c_{i+1} = min(a_{i} + 1, b_{i} + 1)$\r\n* $c_{i+1} = c_{i} + 1$\r\n* $c_{i+1} = c_{i-1} + 2$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 최종 일반식\r\n\r\n구한 일반식을 정리하면 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 원형 구조 적용을 위한 초기값 지정하기\r\n\r\n위 수식을 코드로 녹여내면 되지만, 완벽한 건 아니다. 왜냐하면 이 구역이 <span class=\"red-A400\">선형이 아닌 원형 구조</span>이기 때문.\r\n\r\n지금까지 우리는 원리 이해 및 수식 도출의 편의를 위해 원타곤을 임의로 잘라 표타곤으로 전개하여 수식을 계산했다. 이러한 <span class=\"green-A700\">선형 구조는 시작점과 도착점이 있지만 원형은 순환 구조</span>이므로 이에 맞춰 조건식을 작성해야 한다. 즉, <span class=\"red-A400\">원형 구조에 호환되도록 일부 케이스에 초기값을 지정</span>해야 최종적으로 원하는 알고리즘을 작성할 수 있다.\r\n\r\n아래의 사진은 원타곤과 표타곤을 비교한 것이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927246-2b557f80-c71b-11eb-92bf-fe5f92cf5504.png\" width=\"512px\" />\r\n</p>\r\n\r\n이 처럼, 원형 구조는 $e_{00}, e_{07}$끼리도 연결이 가능하지만, 선형 구조는 구조상 불가능하다. 때문에 이러한 케이스들의 초기값을 지정해줘야한다.\r\n\r\n대충 감이 오겠지만, 걸친 모양에 따라 총 4가지 케이스가 존재한다.\r\n\r\n### 걸치지 않을 경우 (기본)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$ 혹은 $e_{10}, e_{17}$과 같이 영역이 겹치지 않을 경우. 선형 구조에서도 적용 가능한 기본적인 케이스다. $a_i, b_i, c_i$의 모양과 연관지어 생각하면 아래와 같이 도식이 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927267-4a541180-c71b-11eb-8596-497ba12219e4.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_i$는 $i$열의 윗 칸만 채우므로 $e_{00}$만 점령한 상태이므로 1\r\n\r\n$b_i$는 $i$열의 아래 칸만 채우므로 $e_{01}$만 점령한 상태이므로 1\r\n\r\n$c_i$는 $i - 1$열을 채우는데, $c_{-1}$은 논리상 불가능하므로 0\r\n\r\n즉 초기값은 아래와 같다.\r\n\r\n$$\r\na_0 = 1\r\n$$\r\n\r\n$$\r\nb_0 = 1\r\n$$\r\n\r\n$$\r\nc_0 = 0\r\n$$\r\n\r\n$i = 0$일 때의 초기값을 지정한다.\r\n\r\n이 케이스일 경우 $c_N$이 알고리즘의 답이 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_8$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927320-88e9cc00-c71b-11eb-8ae4-3dfb03d4e0f0.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 윗 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927336-9bfc9c00-c71b-11eb-837d-77c000661702.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$을 점령할 경우. 원형 구조에서만 가능한 케이스다. **걸치지 않는 경우**를 제외한 나머지 케이스는 전부 원형 구조에서만 가능한 케이스이니 참고할 것. $i = 0$일 때는 영향을 받지 않아 **걸치지 않는 경우**와 동일하다. 걸치기 위해선 반드시 두 행 이상이 필요하기 때문에, $N > 1$을 충족해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927372-a880f480-c71b-11eb-84cc-689658a3a89c.png\" width=\"512px\" />\r\n</p>\r\n\r\n연결된 부분을 체크패턴으로 하이라이팅 했다. 이 둘이 서로 연결되기 때문에, 다른 구역의 특수소대가 점령할 수 없다. 따라서 <b class=\"red-A400\">해당 부분은 초기값 계산 시 없는 영역으로 생각하면 된다.</b> 이러한 특징을 감안하면 아래와 같이 초기값을 지정할 수 있다.\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 2\r\n$$\r\n\r\n$$\r\nb_1 = \r\n\\begin{cases}\r\n\t1, & (e_{10} + e_{11} ≤ W)\\\\\r\n\t2, & (e_{10} + e_{11} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $b_{N-1} + 1$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927427-b767a700-c71b-11eb-9306-0931ede25cba.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 아래 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927442-c6e6f000-c71b-11eb-8f51-2fab907fbcc2.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927459-d1a18500-c71b-11eb-9c6c-07919e9f4f8d.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = \r\n\\begin{cases}\r\n\t1, & (e_{00} + e_{01} ≤ W)\\\\\r\n\t2, & (e_{00} + e_{01} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_1 = 2\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $a_{N-1} + 1$이 알고리즘의 답이 된다. $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927475-e120ce00-c71b-11eb-8bd6-c44d4137fae8.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 두 행 모두 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927491-ee3dbd00-c71b-11eb-98b9-f0d4209ec965.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$, $e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927507-fd246f80-c71b-11eb-8e78-f08c15922ad8.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$, $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 1\r\n$$\r\n\r\n$$\r\nb_1 = 1\r\n$$\r\n\r\n$$\r\nc_1 = 0\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $c_{N-1} + 2$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$, $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_{N-1} + 2$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927519-07df0480-c71c-11eb-9fdf-c8f05858b72d.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 최종 케이스\r\n\r\n* 기본\r\n  * $a_0 = 1$\r\n  * $b_0 = 1$\r\n  * $c_0 = 0$\r\n\r\n<br />\r\n\r\n* 윗 행만 걸칠 경우 $(e_{00} + e_{0(N-1))} ≤ W)$\r\n  * $a_1 = 2$\r\n  * $b_1 = \\begin{cases} 1, & (e_{10} + e_{11} ≤ W)\\\\ 2, & (e_{10} + e_{11} > W) \\end{cases}$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 아래 행만 걸칠 경우 $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = \\begin{cases} 1, & (e_{00} + e_{01} ≤ W)\\\\ 2, & (e_{00} + e_{01} > W) \\end{cases}$\r\n  * $b_1 = 2$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 두 행 모두 걸칠 경우 $(e_{00} + e_{0(N-1)} ≤ W)$, $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = 1$\r\n  * $b_1 = 1$\r\n  * $c_1 = 0$\r\n\r\n비로소 알고리즘을 구현하기 위한 모든 준비물이 갖춰졌다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1006 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/06/A1006/\">1006 풀이</a>\r\n * @since 2021.06.06 Sun 22:44:45\r\n */\r\npublic class Main\r\n{\r\n\tprivate static int N;\r\n\tprivate static int W;\r\n\t\r\n\tprivate static int[][] e;\r\n\t\r\n\tprivate static int[] a;\r\n\tprivate static int[] b;\r\n\tprivate static int[] c;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tint result = 2147483647;\r\n\t\t\t\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 행 수\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\t// 특수소대원 수\r\n\t\t\tW = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 구역별 적 배열\r\n\t\t\te = new int[2][N];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < 2; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tfor (int k = 0; k < N; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\te[j][k] = Integer.parseInt(temp[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ta = new int[N];\r\n\t\t\tb = new int[N];\r\n\t\t\tc = new int[N + 1];\r\n\t\t\t\r\n\t\t\ta[0] = 1;\r\n\t\t\tb[0] = 1;\r\n\t\t\tc[0] = 0;\r\n\t\t\t\r\n\t\t\t// 인덱스 0부터 시작\r\n\t\t\tsolve(0);\r\n\t\t\t\r\n\t\t\tresult = Math.min(result, c[N]);\r\n\t\t\t\r\n\t\t\t// 두 행 이상일 경우\r\n\t\t\tif (N > 1)\r\n\t\t\t{\r\n\t\t\t\t// 두 행 모두 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W && e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 1;\r\n\t\t\t\t\tb[1] = 1;\r\n\t\t\t\t\tc[1] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, c[N - 1] + 2);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 윗 행만 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 2;\r\n\t\t\t\t\tb[1] = e[1][0] + e[1][1] > W ? 2 : 1;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, b[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아래 행만 걸칠 경우\r\n\t\t\t\tif (e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = e[0][0] + e[0][1] > W ? 2 : 1;\r\n\t\t\t\t\tb[1] = 2;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, a[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 함수\r\n\t *\r\n\t * @param num: [int] 시작 인덱스\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\tfor (int i = num; i < N; i++)\r\n\t\t{\r\n\t\t\tc[i + 1] = Math.min(a[i] + 1, b[i] + 1);\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\tif (e[0][i] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i] + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두개의 구역 2개를 점령할 수 있을 경우\r\n\t\t\tif (i > 0 && e[0][i - 1] + e[0][i] <= W && e[1][i - 1] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i - 1] + 2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// a, b팀의 인덱스 보정 (c팀은 인덱스가 하나 더 많음)\r\n\t\t\tif (i < N - 1)\r\n\t\t\t{\r\n\t\t\t\ta[i + 1] = c[i + 1] + 1;\r\n\t\t\t\tb[i + 1] = c[i + 1] + 1;\r\n\t\t\t\t\r\n\t\t\t\t// a팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[0][i] + e[0][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[i + 1] = Math.min(a[i + 1], b[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// b팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[1][i] + e[1][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\tb[i + 1] = Math.min(b[i + 1], a[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n6월 1일부터 풀기 시작해서 이 문제를 완전히 이해하는데 근 일주일 가까이 걸렸다. 나름의 풀이를 작성해야하는데, 남의 풀이가 아닌 내 풀이를 작성하기 위해선 해당 문제를 온전히 이해할 필요가 있었다. 내가 다른 사람들의 풀이를 보면서 이해하지 못해서 내 스스로 생각하고 이해한 걸 나름대로 녹여냈다. 다른 사람이 내 글을 보고 이 어려운 문제를 쉽게 이해할 수 있었으면 좋겠다.\r\n\r\n이해하고 봐도 다소 난해한데, 이걸 원리부터 코드까지 이끌어내어 풀어내는 사람은 정말 대단한 거 같다. 아님 내가 실력이 없는건가.\r\n\r\n## 참고\r\n\r\n* [The Casterian](https://casterian.net/archives/1356)\r\n* [굳건하게](https://travelbeeee.tistory.com/354)\r\n* [테스트 케이스](https://www.acmicpc.net/board/view/11381)","url":["2021-06-06-A1006","2021","06","06","A1006"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1005번 ACM Craft","excerpt":"서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-01T01:27:56","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","위상 정렬","GOLD","GOLD III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-01-A1005.md","content":"\r\n# ACM Craft\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1005번 문제](https://www.acmicpc.net/problem/1005)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다.\r\n\r\n이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219763-b1cf1480-c276-11eb-8131-a3471db1cfc4.png\" width=\"1024px\" />\r\n</p>\r\n\r\n위의 예시를 보자.\r\n\r\n이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할 수 있다. (동시에 진행이 가능하다.) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번 건물의 건설을 시작할 수 있다.\r\n\r\n따라서 4번 건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물와 3번 건물을 동시에 건설하기 시작하면 2번은 1초 뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을 수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.\r\n\r\n프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM Craft 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정 건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정 건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.\r\n\r\n## 입력\r\n\r\n첫째 줄에는 테스트케이스의 갯수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다, 첫째 줄에 건물의 갯수 $N$과 건물 간의 건설순서 규칙의 총 갯수 $K$가 주어진다.(전물의 번호는 1번 부터 $N$번 까지 존재한다.)\r\n\r\n둘째 줄에는 각 건물 당 건설에 걸리는 시간 $D$가 공백을 사이로 주어진다. 셋째 줄부터 $K + 2$줄 까지 건설순서 $X$ $Y$가 주어진다.(이는 건물 X를 지은 다음에 건물 $Y$를 짓는 것이 가능하다는 의미이다.)\r\n\r\n마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 $W$가 주어진다.\r\n\r\n## 출력\r\n\r\n건물 $W$를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.  \r\n건설순서는 모든 건물이 건설 가능하도록 주어진다.\r\n\r\n## 제한\r\n\r\n* $2 ≤ N ≤ 1,000$\r\n* $1 ≤ K ≤ 100,000$\r\n* $1 ≤ X, Y, W ≤ N$\r\n* $0 ≤ D ≤ 100,000)$ $D$는 정수\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4 4\r\n10 1 100 10\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4\r\n8 8\r\n10 20 1 5 8 7 1 43\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n5 7\r\n6 7\r\n7 8\r\n7\r\n```\r\n+ 출력\r\n\r\n``` tc\r\n120\r\n39\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n3 2\r\n1 2 3\r\n3 2\r\n2 1\r\n1\r\n4 3\r\n5 5 5 5\r\n1 2\r\n1 3\r\n2 3\r\n4\r\n5 10\r\n100000 99999 99997 99994 99990\r\n4 5\r\n3 5\r\n3 4\r\n2 5\r\n2 4\r\n2 3\r\n1 5\r\n1 4\r\n1 3\r\n1 2\r\n4\r\n4 3\r\n1 1 1 1\r\n1 2\r\n3 2\r\n1 4\r\n4\r\n7 8\r\n0 0 0 0 0 0 0\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4 5\r\n4 6\r\n5 7\r\n6 7\r\n7\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n6\r\n5\r\n399990\r\n2\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 이해가 되는데, 이를 코딩으로 풀어내기가 어려웠던 알고리즘. <span class=\"primary\">위상정렬</span> 알고리즘에 대한 이해가 있어야한다.  \r\n문제의 경우, 스타크래프트의 건물 테크트리랑 비슷한 개념으로 접근하면 된다. 군수공장을 짓기 위해선 병영을 지어야하는 것처럼, 요구 트리가 있는 건물의 경우 해당 건물을 반드시 완료해야 하며, 하나의 건물이 여러 요구 트리를 가질 경우도 존재한다. 물론 이 경우 요구하는 건물들을 **모두** 건설한 뒤에 건설 가능하다. 요구하는 건물들 중 하나만 건설하면 충족되는게 아니다.\r\n\r\n<span class=\"primary\">위상정렬</span>은 <span class=\"green-A400\">순서가 정해진 작업을 수행할 때, 이 순서를 결정하는 알고리즘</span>이다. <span class=\"primary\">위상정렬</span>은 반드시 DAG(Directed Acyclic Graph, 유향 비순환 그래프) 형태여야 한다. 즉, 순서를 도식화했을 때 반드시 <span class=\"red-A400\">시작/도착점이 존재</span>해야 한다. 시작/도착점이 구분되지 않는 순환 형태일 경우 위상정렬을 적용할 수 없다.\r\n\r\n위상정렬은 순서를 정하는 알고리즘이고, 순서도의 형태에 따라 여러가지의 답이 나올 수 있다. 이 문제는 최적의 답을 도출하기 위해 각 **건물을 건설하는데 필요한 요구 건물**과 **건설 시간**을 적용했다.\r\n\r\n다음 건물을 건설하기 위해선 요구 건물을 모두 건설해야하므로 요구 건물의 건설시간이 가장 많은 건물이 다음 순서가 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219453-3b321700-c276-11eb-9029-ec105c694854.png\" width=\"1024px\" />\r\n</p>\r\n\r\n예시 1번의 두 번째 케이스를 예시로 하여 위상정렬을 도식화하면 위 사진과 같다.\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   0   |   1   |   1   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n위 표는 도식를 수치화하여 정리한 것이다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">1. 순서의 시작점(진입선이 없는 점)을 찾는다. 시작점이 여러개일 경우 시작점 중 무작위로 하나를 선택해도 무방하다. (위 예시는 시작점이 하나)</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219469-4127f800-c276-11eb-91c8-db36e543c217.png\" width=\"1024px\" />\r\n</p>\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">2. 시작점 1을 큐에 넣고, 시작점에 연결된 진출선을 전부 제거한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219471-438a5200-c276-11eb-9cd3-ca5f31dfb19b.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   0   |   0   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |\r\n| :---: | :---: |\r\n\r\n이 과정에서 2와 3이 새로운 시작점이 된 것을 확인할 수 있다.\r\n\r\n1을 건설하는데 걸리는 시간은 1초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">3. 2에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219484-45ecac00-c276-11eb-8114-a6c4c8b17036.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   0   |   0   |   0   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |\r\n| :---: | :---: | :---: |\r\n\r\n4와 5의 진입선이 0이 된다. 즉, 4와 5를 건설할 수 있게 된다.\r\n\r\n2를 건설하는데는 $10(1) + 20(2)$로 총 30초가 소요된다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">4. 3에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219493-48e79c80-c276-11eb-8f48-cf132cab8f5c.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   0   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n\r\n6의 진입선이 0이 된다. 6을 건설할 수 있게 된다.\r\n\r\n3의 건설시간은 $10(1) + 1(3)$으로 총 11초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">5. 4에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219504-4be28d00-c276-11eb-9b40-07c5ea51cbd9.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |\r\n| :---: | :---: | :---: | :---: | :---: |\r\n\r\n4는 진출선이 없으므로 큐에만 추가된다.\r\n\r\n4의 건설시간은 $10(1) + 20(2) + 5(4)$로 총 35초\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">6. 5에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219509-4edd7d80-c276-11eb-9c5f-fc17d373bf50.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   0   |   1   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7이 5와 6에 연결되어 있으므로, 7의 진입선은 1이 된다. 아직 7을 건설할 수 없다.\r\n\r\n5의 건설시간은 $10(1) + 20(2) + 8(5)$로 총 38초\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">7. 6에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219520-53099b00-c276-11eb-9c99-060dcd2039d8.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   0   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7의 진입선이 0이 된다. 7을 건설할 수 있게 된다.\r\n\r\n6의 건설시간은 $10(1) + 1(3) + 7(6)$으로 총 18초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">8. 7에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219527-56048b80-c276-11eb-866b-9b411445b22b.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   0   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n8의 진입선이 0이 된다.\r\n\r\n1 ~ 6까지는 요구 건물이 하나였지만, 7은 두개이다. 앞서 언급했듯이, 5와 6 중 건설시간이 더 긴 것을 기준으로 계산해야한다.\r\n\r\n즉, 7의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7)$로 총 39초\r\n\r\n5번을 기준으로 계산하므로, <span class=\"red-A400\">6번과 중간인 3번은 계산에서 제외</span>된다. 만약, 3의 건설시간을 1초에서 4초로 증가시켜도 결과에 영향을 미치지 않는다. 3의 건설시간을 무시하기 때문이다. 단, 3의 건설시간이 너무 커지게되면 5보다 6의 건설시간이 같이 커지게 되어 결과에 영향을 미치게 된다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">9. 8에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219535-58ff7c00-c276-11eb-907c-2a90cc84c596.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n문제는 7에 대한 건설시간을 요구하고 있으므로 8은 무시해도 무방하다. \r\n8의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7) + 43(8)$로 총 82초\r\n\r\n## 전체 소스\r\n\r\n`time`, `matrix`, `link`의 배열 크기가 $N + 1$이다. 별다른 이유는 아니고, 건물은 1번부터 시작하는데 배열은 0번부터 시작한다. 이러한 차이에서 오는 혼란을 방지하기 위해 건물이 총 4개면 배열의 크기를 5로(0, 1, 2, 3, 4, 5)로 지정하여 0을 제외하고 1부터 사용한다.\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1005 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.05.31 Mon 19:11:58\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\t// 케이스 갯수\r\n\t\tint T = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 건물 갯수\r\n\t\t\tint N = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 규칙(건설시간) 갯수\r\n\t\t\tint K = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 건물별 건설시간 배열\r\n\t\t\tint[] time = new int[N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결여부 배열\r\n\t\t\tboolean[][] maxtrix = new boolean[N + 1][N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결 갯수 배열\r\n\t\t\tint[] link = new int[N + 1];\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j < N + 1; j++)\r\n\t\t\t{\r\n\t\t\t\ttime[j] = scanner.nextInt();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물\r\n\t\t\t\tint X = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\t// 상위 건물\r\n\t\t\t\tint Y = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\tmaxtrix[X][Y] = true;\r\n\t\t\t\tlink[Y]++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표 건물\r\n\t\t\tint W = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tbuilder.append(calcTopologicalSort(time, maxtrix, link)[W]).append(\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString());\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위상정렬 결과 반환 함수\r\n\t *\r\n\t * @param time: [int[]] 건물별 건설시간\r\n\t * @param matrix: [boolean[][]] 건물별 연결여부\r\n\t * @param link: [int[]] 건물별 연결 갯수\r\n\t *\r\n\t * @return [int[]] 건물별 종 건설시간 배열\r\n\t */\r\n\tprivate static int[] calcTopologicalSort(int[] time, boolean[][] matrix, int[] link)\r\n\t{\r\n\t\tQueue<Integer> queue = new LinkedList<>();\r\n\t\t\r\n\t\tint[] result = new int[link.length];\r\n\t\t\r\n\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t{\r\n\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\tif (link[i] == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = time[i];\r\n\t\t\t\tqueue.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\t// 하위 건물\r\n\t\t\tint prev = queue.poll();\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물 건설을 요구 하는 건물일 경우\r\n\t\t\t\tif (matrix[prev][i])\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = Math.max(result[i], result[prev] + time[i]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 해당 건물의 요구 건물 갯수 1 감소\r\n\t\t\t\t\t--link[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\t\t\tif (link[i] == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tqueue.add(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 그래프 이론\r\n* 위상 정렬","url":["2021-06-01-A1005","2021","06","01","A1005"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1003번 피보나치 함수","excerpt":"다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T23:29:03","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","피보나치 수열","Dynamic Programming(동적 프로그래밍)","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-A1003.md","content":"\r\n# 피보나치 함수\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1003번 문제](https://www.acmicpc.net/problem/1003)\r\n\r\n## 조건\r\n\r\n|        시간제한         | 메모리 제한 |\r\n| :---------------------: | :---------: |\r\n| 0.25초 (추가 시간 없음) |    128MB    |\r\n\r\n## 문제\r\n\r\n다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.\r\n\r\n``` cpp\r\nint fibonacci(int n) {\r\n    if (n == 0) {\r\n        printf(\"0\");\r\n        return 0;\r\n    } else if (n == 1) {\r\n        printf(\"1\");\r\n        return 1;\r\n    } else {\r\n        return fibonacci(n‐1) + fibonacci(n‐2);\r\n    }\r\n}\r\n```\r\n\r\n$fibonacci(3)$을 호출하면 다음과 같은 일이 일어난다.\r\n\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$ (첫 번째 호출)을 호출한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$ (두 번째 호출)과 $fibonacci(0)$을 호출한다.\r\n* 두 번째 호출한 $fibonacci(1)$은 1을 출력하고 1을 리턴한다.\r\n* $fibonacci(0)$은 0을 출력하고 0을 리턴한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$과 $fibonacci(0)$의 결과를 얻고, 1을 리턴한다.\r\n* 첫 번째 호출한 $fibonacci(1)$은 1을 출력하고, 1을 리턴한다.\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$의 결과를 얻고, 2를 리턴한다.\r\n\r\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, $fibonacci(N)$을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 적성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.  \r\n각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0\r\n1\r\n3\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 0\r\n0 1\r\n1 2\r\n```\r\n\r\n# 풀이\r\n\r\n알고리즘 풀면서 느끼는 거지만, 문제가 뭘 말하는 지 이해가 안 되는 경우가 많은 것 같다. 내가 멍청해서 그런건가.\r\n\r\n이 문제를 풀기 위해선, 피보나치 수열에 대한 식을 이해하고 있어야 한다.  \r\n피보나치 수열이 $f()$일 때, $n$번째 피보나치 수열의 식은 $f(n) = f(n - 1) + f(n - 2)$로 정의할 수 있다.\r\n\r\n$n = 0, 1$일 때의 초기값이 정해져있다. (식의 특성 상 초기값이 없으면 계산할 수가 없다.)  \r\n$f(0) = 0$  \r\n$f(1) = 1$  \r\n초기값은 위와 같으며, 실질적으로 $n >= 2$ 부터 의미있는 연산이 수행된다.\r\n\r\n다시 문제로 돌아가서, 임의의 수 N이 주어질 경우 $f(N)$을 수행하면서 $f(0)$, $f(1)$이 몇 번 호출되는지를 구하면 된다.  \r\n예를 들어, $N = 4$라고 가정하고 식을 전개하면 아래와 같다.  \r\n$f(4) = f(3) + f(2)$  \r\n위 식에서 $f(3)$은 $f(2) + f(1)$로 치환할 수 있으며, 같은 이유로 $f(2)$ 역시 $f(1) + f(0)$으로 치환 가능하다.  \r\n$f(4) = f(2) + f(1) + f(1) + f(0)$  \r\n$= f(1) + f(0) + f(1) + f(1) + f(0)$\r\n\r\n결과적으로 $f(4) = 2(f0) + 3f(1)$로 정리할 수 있다.  \r\n따라서 이 문제의 알고리즘은 $N = 4$일 경우 `2 3`이 출력되어야 한다.\r\n\r\n우선 식을 정리하여 한 눈에 보면 문제 해결에 도움이 될 것 같다.  \r\n피보나치 수열을 쭉 정리하면 아래와 같다.\r\n\r\n|  $n$  | $f(0)$의 갯수 | $f(1)$의 갯수 | $f(n)$ |\r\n| :---: | :-----------: | :-----------: | :----: |\r\n|   0   |       1       |       0       |   0    |\r\n|   1   |       0       |       1       |   1    |\r\n|   2   |       1       |       1       |   1    |\r\n|   3   |       1       |       2       |   2    |\r\n|   4   |       2       |       3       |   3    |\r\n|   5   |       3       |       5       |   5    |\r\n|   6   |       5       |       8       |   8    |\r\n|   7   |       8       |      13       |   13   |\r\n|   8   |      13       |      21       |   21   |\r\n|   9   |      21       |      34       |   34   |\r\n\r\n표로 정리하니 어느정도 규칙성이 눈에 보이기 시작한다.\r\n\r\n* N의 $f(1)$ 출력 갯수는 $f(N)$과 동일하다.  \r\n* N의 $f(0)$ 출력 갯수는 $f(N - 1)$과 동일하다.\r\n\r\n즉, $N = 4$일 경우 알고리즘은 $f(3)$ $f(4)$가 출력되면 된다.\r\n\r\n여기서 단순하게 생각하면 아래와 같이 코드를 짤 수 있다.\r\n\r\n## 완성....?\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[][] arr = new Integer[41][2];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// N = 0일 때, 0이 호출되는 횟수\r\n\t\tarr[0][0] = 1;\r\n\r\n\t\t// N = 0일 때, 1이 호출되는 횟수\r\n\t\tarr[0][1] = 0;\r\n\r\n\t\t// N = 1일 때, 0이 호출되는 횟수\r\n\t\tarr[1][0] = 0;\r\n\r\n\t\t// N = 1일 때, 1이 호출되는 횟수\r\n\t\tarr[1][1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tint f0 = fibonacci(n - 1);\r\n\t\t\tint f1 = fibonacci(n);\r\n\r\n\t\t\tSystem.out.println(f0 + \" \" + f1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 인덱스가 0일 경우\r\n\t\tif (n == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 1일 경우\r\n\t\telse if (n == 1)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 2 이상일 경우 (연산 가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 코드는 크게 두 가지 문제가 있는데, 우선 $n = 0, 1$일 때의 처리가 정상적으로 이루어지지 않고 있다.  \r\n$f(1) = f(0) + f(-1)$  \r\nN이 문제되기 이전에 이 코드는 런타임 시간 초과로 실패한다. 왜일까?\r\n\r\n위 코드는 **불필요한 연산을 너무 많이 수행한다.** 피보나치 수열의 특성 상 $f(N)$을 계산할 경우, $f(N - 1)$, $f(N - 2)$ ... 등과 같이 N 이하의 피보나치 값까지 전부 계산하게 된다.  \r\n다시 말하면, $f(6)$을 연산할 경우 계산 과정에서 자연스레 $f(4)$, $f(2)$ 등의 피보나치 값을 구할 수 있다.\r\n\r\n위 이론을 알고리즘에 적용하면 아래와 같이 응용할 수 있다.  \r\nN을 총 3번 입력한다고 가정하면 $N_1$, $N_2$, $N_3$으로 구분할 수 있다.\r\n\r\n$N_2 = 8$ -> $f(8)$ 부터 $f(0)$까지의 값을 구할 수 있음.  \r\n$N_3 = 4$ -> $f(4)$ 부터 $f(0)$까지의 값을 구할 수 있음.\r\n\r\n피보나치 연산값을 저장하면 $N_n > N_n+1$일 경우 굳이 **추가적인 연산을 진행하지 않고 이미 저장된 값을 출력**만 함으로써, 런타임 리소스를 줄일 수 있다.\r\n\r\n클래스의 멤버변수로 **Integer 배열을 선언**하여 피보나치 수열값을 저장하고, 알고리즘 연산에 이를 활용하면 될 것 같다.\r\n\r\n> int는 Primitive(자료형) 데이터고, Integer는 Wrapper 클래스다. Wrapper 클래스는 null 입력이 가능하다는 특징이 있으므로, Integer 역시 숫자 이외에 null값을 입력할 수 있다.  \r\nInteger 배열의 초기값은 null로 지정되므로, 배열의 값이 null인 인덱스는 아직 피보나치 수열 계산이 이루어지지 않은 인덱스라고 판단할 수 있다.\r\n\r\n다행히 문제에서 주어진 $N$의 조건은 $0 <= N <= 40$이므로, 배열의 인덱스는 최대 41을 넘지 않음을 알 수 있다.  \r\n(배열은 0부터 시작하므로 40개가 아닌 0을 포함한 41개임에 유의하자)\r\n\r\n이후 피보나치 연산에서 각 과정의 값을 배열에 저장하는 로직을 추가한다.  \r\n배열의 값이 null일 경우, 아직 연산이 진행되지 않았으므로 피보나치 연산을 수행하고 배열에 저장한다.  \r\n반대로, 배열이 특정 숫자값을 가질 경우, 이미 연산이 진행된 인덱스이므로 별도의 연산을 거치지 않고 해당 값을 바로 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\npackage all.a1003;\r\n\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[] arr = new Integer[41];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 0)\r\n\t\tarr[0] = 0;\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 1)\r\n\t\tarr[1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tfibonacci(n);\r\n\r\n\t\t\t// n이 0일 경우\r\n\t\t\tif (n == 0)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"1 0\");\r\n\t\t\t}\r\n\r\n\t\t\t// n이 1일 경우\r\n\t\t\telse if (n == 1)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"0 1\");\r\n\t\t\t}\r\n\r\n\t\t\t// 초기값이 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(new StringBuffer().append(arr[n - 1]).append(\" \").append(arr[n]).toString());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscanner.close();\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 해당 인덱스의 피보나치가 아직 연산되지 않았을 경우\r\n\t\tif (arr[n] == null)\r\n\t\t{\r\n\t\t\tarr[n] = fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\r\n\t\treturn arr[n];\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍","url":["2021-05-21-A1003","2021","05","21","A1003"]}],"categories":["CS","JAVA","Jekyll","WAS","WEB","알고리즘","잡담"],"images":["celeb1.gif","celeb10.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"Dynamic Programming(동적 프로그래밍)","page":1},"__N_SSG":true}