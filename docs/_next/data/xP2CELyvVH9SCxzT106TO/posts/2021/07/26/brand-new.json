{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"긍정적인 시나리오 최적화","excerpt":"지금까지는 항상 알고리즘을 비관적인 관점으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다. 이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-24T04:54:40","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","삽입 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-24-about-algorithm-chapter06.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 6장 긍정적인 시나리오 최적화\r\n\r\n지금까지는 항상 알고리즘을 <span class=\"orange-400\">비관적인 관점</span>으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다.\r\n\r\n이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.\r\n\r\n## 6-1. 삽입 정렬\r\n\r\n이 장에서는 <span class=\"primary\">삽입 정렬</span> 알고리즘을 토대로 전개한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834021-dcb0625e-80fb-4567-bd8d-982ae60a04c0.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬할 배열은 위와 같으며, 원리는 아래와 같다.\r\n\r\n1. 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" />\r\n</p>\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" />\r\n</p>\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n3. 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n## 6-2. 삽입 정렬해보기\r\n\r\n이전 문단의 원리를 토대로 삽입 정렬을 수행한다.\r\n\r\n1. 패스스루 1: 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 패스스루 1: 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" />\r\n</p>\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" />\r\n</p>\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n1. 패스스루 1: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n4. 패스스루 2: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834064-d8e10cd3-d825-47d4-9a29-ee3a95b9cb60.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 9\r\n* 비교값: -\r\n\r\n세 번째 요소의 값인 9를 임시 변수로 할당한다.\r\n\r\n5. 패스스루 2: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834073-83c7f417-d7ac-43ce-8421-0119ef5d4712.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 9\r\n* 비교값: 7\r\n\r\n임시 변수보다 비교값이 작을 경우, 비교를 종료하고 현재 공백에 임시 변수를 삽입한다. 이 케이스의 경우 바로 왼쪽에 위치한 요소가 7로 9보다 작으므로, 그 즉시 비교가 종료되며 삽입을 진행한다.\r\n\r\n5. 패스스루 2: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834078-3e4fda60-79af-4f58-9915-aca42d5babfd.png\" width=\"600px\" />\r\n</p>\r\n\r\n공교롭게도, 원래의 위치에 임시 변수 9가 삽입된다.\r\n\r\n6. 패스스루 3: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834085-ce09440c-11a9-418c-ac7e-07c307bb16b5.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: -\r\n\r\n네 번째 요소의 값인 2를 임시 변수로 할당한다.\r\n\r\n7. 패스스루 3: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834098-f4dbef5a-0a59-4668-aa73-0e98b431895a.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 9\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834107-74cc6e75-3a59-4fa3-8c66-56160cdb6913.png\" width=\"600px\" />\r\n</p>\r\n\r\n비교값 9가 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834113-25e6eac5-d5eb-4380-918f-249eaf9de4d1.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834120-2df440ae-cad4-4f7b-a3fd-708b2ec0b6d3.png\" width=\"600px\" />\r\n</p>\r\n\r\n비교값 7이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834129-5ee81114-faf3-43cd-ba96-4e3f46a705a8.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 3\r\n\r\n비교값 3이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834134-09db5b58-6c7a-49af-a1e9-b3125e85dd6b.png\" width=\"600px\" />\r\n</p>\r\n\r\n8. 패스스루 3: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834141-cc23a70b-f809-4783-affb-cefae7faa2cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n가장 맨 첫 요소에 임시 변수 2가 삽입된다.\r\n\r\n9. 패스스루 4: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834150-6cd89c4c-6f2a-4360-b4cc-677d073ccd85.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 5\r\n* 비교값: -\r\n\r\n다섯 번째 요소의 값인 5를 임시 변수로 할당한다.\r\n\r\n10. 패스스루 4: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834157-416ea349-6684-496b-bb98-cbd456232e54.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 5\r\n* 비교값: 9\r\n\r\n비교값 9가 임시 변수 5보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834166-f03e3731-66b8-4b66-95e8-51d176a92bee.png\" width=\"600px\" />\r\n</p>\r\n\r\n11. 패스스루 4: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834174-6b6b0444-fc8a-4983-814f-e54e93914765.png\" width=\"600px\" />\r\n</p>\r\n\r\n네 번째 요소에 임시 변수 5가 삽입된다.\r\n\r\n가장 마지막 요소까지 기준 인덱스가 이동했으므로, 해당 패스스루를 마지막으로 종료한다.\r\n\r\n## 6-3. 삽입 정렬 구현\r\n\r\n삽입 정렬의 과정을 토대로 이를 <span class=\"orange-400\">JAVA</span>로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 삽입 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 02:40:19\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int shiftCount = 0;\r\n\tprivate static int deleteCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tselectionSort(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 시프트 작업량: \");\r\n\t\twriter.write(String.valueOf(shiftCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삭제 작업량: \");\r\n\t\twriter.write(String.valueOf(deleteCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + shiftCount + deleteCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 삽입 정렬 알고리즘\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t */\r\n\tprivate static void selectionSort(int[] array)\r\n\t{\r\n\t\tfor (int i = 1; i < array.length; i++)\r\n\t\t{\r\n\t\t\t// 임시 변수\r\n\t\t\tint temp = array[i];\r\n\t\t\t\r\n\t\t\t// 빈 공간\r\n\t\t\tint blank = i;\r\n\t\t\t\r\n\t\t\t// 삭제 작업 추가\r\n\t\t\tdeleteCount++;\r\n\t\t\t\r\n\t\t\t// 공백 표시\r\n\t\t\tarray[i] = Integer.MIN_VALUE;\r\n\t\t\t\r\n\t\t\tfor (int j = i - 1; j > -1; j--)\r\n\t\t\t{\r\n\t\t\t\t// 비교 작업 추가\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소가 임시 변수보다 클 경우\r\n\t\t\t\tif (array[j] > temp)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 시프트 작업 추가\r\n\t\t\t\t\tshiftCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = array[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tblank--;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아닐 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 삽입 작업 추가\r\n\t\t\tinsertCount++;\r\n\t\t\t\r\n\t\t\tarray[blank] = temp;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n10 9 8 7 6 5 4 3 2 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n - 비교 작업량: 45\r\n - 시프트 작업량: 45\r\n - 삭제 작업량: 9\r\n - 삽입 작업량: 9\r\n - 총 작업량: 108\r\n```\r\n\r\n소스와 입력, 출력값은 위와 같다. 사용자로부터 임의의 배열을 입력받아 삽입 정렬을 수행하고, 졍렬 결과와 각 작업량을 구분하여 표시한다.\r\n\r\n실제 핵심 동작은 `selectionSort` 메소드에서 이루어진다. 공백은 `Integer.MIN_VALUE`를 삽입하여 표시하며, 삭제됨을 표현하기 위한 것으로 작업량에 포함되지 않는다.\r\n\r\n``` java\r\nfor (int i = 1; i < array.length; i++)\r\n{\r\n\t// 임시 변수\r\n\tint temp = array[i];\r\n\t\r\n\t// 빈 공간\r\n\tint blank = i;\r\n\t\r\n\t// 삭제 작업 추가\r\n\tdeleteCount++;\r\n\t\r\n\t// 공백 표시\r\n\tarray[i] = Integer.MIN_VALUE;\r\n\t\r\n\t// ...\r\n}\r\n```\r\n\r\n첫 번째 `for`문은 각 패스스루를 의미한다. 각 패스스루마다 기준 인덱스 `i`, 임시 변수 `temp`, 삭제된 요소의 인덱스 `blank`가 새로 정의된다. 이 과정에서 삭제 연산이 고정으로 한 번 수행된다.\r\n\r\n``` java\r\nfor (int j = i - 1; j > -1; j--)\r\n{\r\n\t// 비교 작업 추가\r\n\tcompareCount++;\r\n\t\r\n\t// 현재 요소가 임시 변수보다 클 경우\r\n\tif (array[j] > temp)\r\n\t{\r\n\t\t// 시프트 작업 추가\r\n\t\tshiftCount++;\r\n\t\t\r\n\t\tarray[blank] = array[j];\r\n\t\t\r\n\t\tblank--;\r\n\t\t\r\n\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n두 번째 `for`문은 각 기준 인덱스 `i`의 왼쪽 요소부터 0까지 비교 및 시프트 작업을 의미한다. 각 사이클마다 비교 작업 한 번이 반드시 발생하며, 임시 변수와 현재 요소 간의 크기에 따라 시프트 작업이 발생할 수 있다.\r\n\r\n``` java\r\nfor (int i = 1; i < array.length; i++)\r\n{\r\n\t// ...\r\n\t\r\n\t// 삽입 작업 추가\r\n\tinsertCount++;\r\n\t\r\n\tarray[blank] = temp;\r\n}\r\n```\r\n\r\n모든 비교가 끝나면 현재 공백인 요소에 임시 변수를 삽입한다. 이 과정에서 삽입 작업 한 번이 반드시 발생한다.\r\n\r\n## 6-4. 삽입 정렬의 효율성\r\n\r\n삽입 정렬 시 발생하는 작업을 분석하여 그 효율성에 대해 알아보자. 삽입 정렬은 <span class=\"orange-400\">삭제</span>, <span class=\"orange-400\">비교</span>, <span class=\"orange-400\">시프트</span>, <span class=\"orange-400\">삽입</span>의 4개 작업으로 이루어져있다.\r\n\r\n삽입 정렬에서 가장 최악의 케이스는 요소가 역순으로 정렬된 배열이다. 모든 요소가 역순으로 정렬될 경우, 발생할 수 있는 모든 작업이 발생한다. 최악의 경우에 발생하는 각 작업량을 일반식으로 정의하면 아래와 같다.\r\n\r\n* 삭제: $N - 1$\r\n* 비교: $N^2 \\div 2$ (대략적인 값)\r\n* 시프트: $N^2 \\div 2$ (대략적인 값)\r\n* 삽입: $N - 1$\r\n\r\n이를 토대로 삽입 정렬의 시간 복잡도는 $O(N^2 + 2N - 2)$임을 알 수 있다. 빅 오 표기법은 <span class=\"blue-400\">상수를 무시</span>하므로 $O(N^2 + N)$으로 간략하게 표기할 수 있다. 하지만 빅 오 표기법은 상수만 무시하는 게 아니다. <span class=\"blue-400\">가장 높은 차수를 제외한 나머지 차수 또한 무시</span>한다. 그말인 즉슨, $N^2 + N$에서 가장 높은 차수는 $N^2$이므로, $N$은 무시한다. 따라서 최종적으로 삽입 정렬의 시간 복잡도는 $O(N^2)$이 된다.\r\n\r\n|  $N$  |   $N^2$   |     $N^3$     |       $N^4$       |\r\n| :---: | :-------: | :-----------: | :---------------: |\r\n|   2   |     4     |       8       |        16         |\r\n|   5   |    25     |      125      |        625        |\r\n|  10   |    100    |     1,000     |      10,000       |\r\n|  100  |  10,000   |   1,000,000   |    100,000,000    |\r\n| 1,000 | 1,000,000 | 1,000,000,000 | 1,000,000,000,000 |\r\n\r\n요소 $N$의 갯수가 100일 때, $N^4$와 $N^3$은 $N$의 값인 100배 차이가 난다. $N^4$ 입장에서는 $N^3$ 작업 한 사이클이 발생해도, 자신의 작업량의 1%밖에 되지 않는다. 차수가 높아질 수록 작업량의 차이가 기하급수적으로 벌어지기 때문에 무시하는 것이다.\r\n\r\n지금까지 버블, 선택, 삽입 정렬 세 가지를 다뤄봤다. 각 알고리즘의 시간 복잡도를 정리하면 아래와 같다.\r\n\r\n|       구분        | 버블 정렬 |    선택 정렬    |     삽입 정렬     |\r\n| :---------------: | :-------: | :-------------: | :---------------: |\r\n|   빅 오 표기법    | $O(N^2)$  |    $O(N^2)$     |     $O(N^2)$      |\r\n| 실제 빅 오 표기법 | $O(N^2)$  | $O(N^2 \\div 2)$ | $O(N^2 + 2N - 2)$ |\r\n\r\n4장 부터 6장까지 오면서, 우리는 각 정렬의 빅 오 표기법과 실제 나타나는 빅 오 표기법에 대해 알고있다. 위 표를 토대로 본다면, 세 정렬 기법 중 선택 정렬이 가장 빠르다고 할 수 있을 것이다. 단, 누누히 말했듯이 최악의 경우에 가깝다는 전제가 수반된다.\r\n\r\n그렇다면 평균적인 경우는 어떨까?\r\n\r\n## 6-5. 평균적인 경우\r\n\r\n데이터가 1억, 1조가 넘어간다면 모를까, 대부분의 일반적인 환경에선 그리 많은 데이터를 처리하지 않는다. 즉, 대부분의 경우 최악의 케이스에 도달하지 않는다는 뜻이기도 하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834185-4dfa70f6-0a15-4069-a7a4-7f3ed43809f4.png\" width=\"600px\" />\r\n</p>\r\n\r\n대부분의 케이스는 위와 같은 정규 분포도를 따른다. 좌측으로 수렴할 수록 최악의 케이스, 우측으로 수렴할 수록 최선의 케이스, 정 가운데로 수렴할 수록 평균적인 케이스다. <span class=\"green-400\">대다수는 평균적인 영역에 포함</span>되며, 양 옆의 극단적인 케이스는 상대적으로 양이 적다.\r\n\r\n지금까지 다룬 정렬 알고리즘의 대부분은 역순으로 정렬될 경우가 최악의 케이스였다. 완전 무작위의 배열이 입력된다고 가정할 때, 정확히 역순으로 나열된 배열이 나올 확률이 얼마나 될지 생각해보자. 대부분의 배열은 어떠한 규칙도 없이 무작위로 나열됐을 것이다. 굳이 위 같은 정규 분포도가 아니더라도 일상 생활에서 비슷한 사례는 많이 있다. 여러 케이스 중 발생하는 특이 케이스는 다른 대다수의 케이스와는 어떠한 방향으로든 다르다는 뜻이다. 최선, 최악의 케이스는 어찌 보면 이러한 특이 케이스의 범주에 속한다.\r\n\r\n우리가 이번 장에서 다룬 삽입 정렬을 토대로 확인해보자.\r\n\r\n* 최악의 경우, $O(N^2 + 2N - 2)$. 즉, $O(N^2)$를 가진다.\r\n* 최선의 경우, $O(3(N - 1))$. 즉, $O(N)$를 가진다.\r\n* 일반적인 경우, $O(N^2 \\div 2)$. 즉, $O(N^2)$를 가진다.\r\n\r\n이를 표로 나타내면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834196-63471f0e-41df-4715-ac15-8c79fd606fae.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 케이스에 따라 유의미한 성능의 차이가 존재한다. 반대로 선택 정렬의 경우 꽤 난감한데, 선택 정렬은 어떠한 케이스에서든 $O(N^2)$의 시간 복잡도를 가진다.\r\n\r\n``` java\r\n/**\r\n * 선택 정렬 함수\r\n *\r\n * @param array : [int[]] 대상 배열\r\n *\r\n * @return [int[]] 작업 갯수 배열\r\n */\r\nprivate static int[] selectionSort(int[] array)\r\n{\r\n\tint compareCount = 0;\r\n\tint swapCount = 0;\r\n\t\r\n\tfor (int i = 0; i < array.length; i++)\r\n\t{\r\n\t\t// 패스스루의 최소값 인덱스\r\n\t\tint min = i;\r\n\t\t\r\n\t\tfor (int j = i + 1; j < array.length; j++)\r\n\t\t{\r\n\t\t\tcompareCount++;\r\n\t\t\t\r\n\t\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\t\tif (array[j] < array[min])\r\n\t\t\t{\r\n\t\t\t\tmin = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 최소 인덱스에 변화가 있었을 경우\r\n\t\tif (min != i)\r\n\t\t{\r\n\t\t\tint temp = array[min];\r\n\t\t\t\r\n\t\t\tarray[min] = array[i];\r\n\t\t\tarray[i] = temp;\r\n\t\t\t\r\n\t\t\tswapCount++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn new int[] { compareCount, swapCount };\r\n}\r\n```\r\n\r\n위 소스는 5장에서 다룬 선택 정렬 소스다. 보시다시피 `for`문이 2개나 존재함으로 $O(N^2)$의 시간 복잡도를 가진다는 것을 어렵지 않게 유추할 수 있다. 더군다나 소스를 자세히 보자. 중간에 반복문을 종료할 수 있는 `break` 또한 존재하지 않는다. 좋든 싫든 항상 $N^2$의 작업을 수행한다는 뜻이다. 실제로 5장의 소스를 구동하면 케이스별로 작업량의 차이가 그리 크지 않다.\r\n\r\n만약 사용할 데이터의 대부분이 어느정도 정렬되어있을 경우, 삽입 정렬이 훨씬 유리하다고 판단할 수 있다. 만약 데이터가 완전히 무작위라면 선택 정렬이나 삽입 정렬이나 크게 차이가 없다고 볼 수 있다.\r\n\r\n## 6-6. 실제 예제\r\n\r\n두 배열이 존재하며, 각 배열에 공통으로 존재하는 요소를 추출하여 반환하는 교집합 알고리즘을 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 25\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n이중 `for` 구조이므로 시간 복잡도는 당연히 $O(N^2)$일 것이다. 두 배열의 요소의 크기가 완전히 동일할 때, 나타날 수 있는 최악의 케이스는 $O(N^2 + N)$이다. 간략히 $O(N^2)$라고 할 수 있다.\r\n\r\n위 알고리즘의 경우 불필요한 연산을 수행하기도 한다. 이를 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class ImproveIntersection\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 24\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n차이점은 `for`문 안의 `if` 구문에 있다.\r\n\r\n``` java\r\n// 두 배열의 요소가 같을 경우\r\nif (item1 == item2)\r\n{\r\n\tinsertCount++;\r\n\t\r\n\tlist.add(item1);\r\n\t\r\n\tbreak;\r\n}\r\n```\r\n\r\n이처럼 동일한 요소가 탐색되었을 경우, `break`를 통해 패스스루 강제 종료 기능을 추가했다. 최악의 시나리오에선 $O(N^2)$로 동일하지만, 최선의 시나리오에선 $O(N)$으로 동작할 것이다. 이전의 알고리즘이 항상 $O(N^2)$임을 감안한다면 적절한 최적화라 할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서 주로 얘기한 내용은 아래와 같다.\r\n\r\n* 알고리즘을 꼭 비관적으로만 바라보는 것은 아니다.\r\n* 오히려 대부분의 케이스는 평균의 범주에 속한다.\r\n* 알고리즘의 로직에 따라 케이스의 양에 따라시간 복잡도가 유의미하게 달라지기도 한다.\r\n\r\n이 장에서는 알고리즘의 또 다른 관점에 대해 알아봤다. 대부분의 케이스가 평균의 범주에 속하므로, 평균 시간 복잡도 역시 성능을 측정함에 있어서 중요한 요소 중 하나일 것이다.\r\n\r\n다음 장에서는 새로운 개념인 해시 테이블에 대해 알아본다.","url":["2021-07-24-about-algorithm-chapter06","2021","07","24","about-algorithm-chapter06"]},"next":null},"group":[],"data":{"header":{"title":"블로그 개편기","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-26T04:54:40","type":"posts","category":"React","tag":["React(리액트)","Next.js","개발 블로그","TypeScript","SCSS"],"comment":true,"publish":true},"name":"2021-07-26-brand-new.md","content":"<h1 id=\"리모델링\">리모델링 <a href=\"#리모델링\">🔗</a></h1><p>이 블로그를 처음 개발한지가 한 5월 쯤으로 기억한다. 4월부터 접한 리액트에 흥미가 생겨 두서없이 만든게 시작이였으니, 결과물은 내 생각보다 훨씬 조잡하지 않았나 생각했다.</p>\n<p>다행스럽게(?)도 블로그 또한 그런 내 믿음을 져버리기 싫었는지, 동작 과정에서 크고 작은 문제들을 보여주곤 했다.</p>\n<p>동작 자체에 영향을 미칠 정도로 크리티컬한 문제는 아니였다만, 내 신경엔 영향을 미칠 정도로 거슬리는 부분이 몇 가지 있었다. 아무도 관심 없지만 이왕 만든거 이번 포스팅을 통해 블로그의 개선점을 정리해놓고자 한다.</p>\n<h1 id=\"문제점\">문제점 <a href=\"#문제점\">🔗</a></h1><p>크고작은 여러 문제점들이 있었는데, 목록은 아래와 같다.</p>\n<h2 id=\"1.-렌더링 지연 현상\">1. 렌더링 지연 현상 <a href=\"#1.-렌더링 지연 현상\">🔗</a></h2><p>여러 문제들 중 가장 가시적이고 불편한 문제였다. 어떠한 이유에서인지 이상하리만치 렌더링이 늦었다. 처음으로 페이지에 접근할 경우 렌더링하느라 버벅이는게 보일 정도. 사양에 따라서 CSS가 입혀지기 전인 날 것의 HTML 프레임이 그대로 보이기도 했다.</p>\n<p>이 괴상한 렌더링 지연은 React의 고질적인 블랙박스 문제로 디버깅조차 잘 되지 않았다.</p>\n<blockquote>\n<p><strong>블랙... 뭔 박스요?</strong><br>소스코드가 동작할 때, 어떤 특정한 모듈을 통해 동작하는 경우가 빈번하다. 잘 구성된 모듈은 은닉화, 모듈화가 잘 되어 있는 경우가 대부분이다. 하지만 이러한 모듈의 폐쇄성은 해당 모듈의 사용자로 하여금 모듈 내부의 오류로 인해 발생하는 이슈를 디버깅하기 매우 어렵게 만든다.<br>이러한 모듈의 은닉된 영역을 가리켜 <strong>블랙박스</strong>라 칭한다.</p>\n</blockquote>\n<p>간혹 어떤 페이지는 렌더링이 두 번씩 되기도 했다. 설상가상으로 React의 다중 렌더링 문제는 꽤 고질적이라고 한다.</p>\n<h2 id=\"2.-Unified.js과 관련 플러그인 커스터마이징 문제\">2. Unified.js과 관련 플러그인 커스터마이징 문제 <a href=\"#2.-Unified.js과 관련 플러그인 커스터마이징 문제\">🔗</a></h2><p>해당 블로그는 JAMStack 기반 블로그다. 통상 JAMStack 기반 블로그의 경우 게시글을 Markdown으로 관리한다. 하지만 아쉽게도 웹 페이지는 HTML 기반으로 동작한다. 즉, Markdown에서 HTML로 적절히 변환해줄 로직이 필요하다.</p>\n<blockquote>\n<p><strong>JAMStack</strong><br><strong>J</strong>avaScript<br><strong>A</strong>PI<br><strong>M</strong>arkup</p>\n</blockquote>\n<p>단순히 변환만 해준다고 다가 아니다. 코드 하이라이팅을 위한 Prism.js, 수식 작성을 위한 LaTex 등 여러 플러그인을 적용해야한다.</p>\n<p>하지만 Unified.js는 내 바램과 달리 공식 문서가 그리 친절하지도 않았으며, 커스터마이징을 위한 API 또한 찾아보기 힘들었다. 그 말인즉슨 <code class=\"inline-code\">remark-prism</code>, <code class=\"inline-code\">remark-toc</code>와 같은 플러그인에 의존해야 하는데, 정해진 형태로 변환만 해줄 뿐, 내가 끼어들어 커스터마이징할 여지는 없어보였다.</p>\n<h2 id=\"3.-CSS-in-JS 방식\">3. CSS-in-JS 방식 <a href=\"#3.-CSS-in-JS 방식\">🔗</a></h2><p>이 블로그의 CSS는 <a href=\"https://material-ui.com/\">Material-UI</a>를 적극적으로 사용했다. Material-UI는 CSS를 적용할 때, <code class=\"inline-code\">makeStyles</code>와 같은 메소드를 통해 JavaScript 내부에서 스타일링을 하도록 안내하고 있다.</p>\n<p>React를 독학으로 배운데다가, 그 체계에 익숙하지 않아 그 당시만 해도 이렇게 해야만하는 줄 알았다.</p>\n<h2 id=\"4.-부실한 RESTful URL\">4. 부실한 RESTful URL <a href=\"#4.-부실한 RESTful URL\">🔗</a></h2><p>NextJS는 Dynamic Routing을 지원한다. 파일 이름을 <code class=\"inline-code\">[page].js</code>와 같이 생성하고 <code class=\"inline-code\">getStaticPaths</code> 메소드에서 page 변수에 적절한 값을 할당하면 해당 값을 가진 URL을 생성해준다.</p>\n<p>GitHub에 호스팅하기 위해선 좋든 싫든 CSR 정적 방식을 차용할 수 밖에 없다. 때문에 내가 잘 하던 기존의 query 방식을 차용했었다.</p>\n<p>게시글 2 페이지를 나타내는 URL이 <code class=\"inline-code\">/posts?page=2</code>와 같은 방식이였다. 현재 트렌드로 미루어보아, 그리 좋은 방식은 아니지 싶다.</p>\n<h1 id=\"개선점\">개선점 <a href=\"#개선점\">🔗</a></h1><p>자잘한 문제들은 제외하고, 굵직한 것들만 생각나는대로 적으면 저 정도 나오는 것 같다.</p>\n<p>블로그가 개발된 5월 이래로 개편을 시작한 7월 중순까지 그래도 나름 내적인 성장을 했던 건지, 이전보단 훨씬 나은 방향으로 개선할 수 있었다.</p>\n<p>개선 내용은 아래와 같다.</p>\n<h2 id=\"1.-TypeScript 적용\">1. TypeScript 적용 <a href=\"#1.-TypeScript 적용\">🔗</a></h2><p>JavaScript의 가장 큰 장점이자 단점은 변수 타입의 모호성이다. 첫 언어를 C#, JAVA와 같이 경직된 객체지향 언어로 접한 내겐 거슬리는 부분 중 하나였다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/127337733-e43081ab-71f8-4906-89b2-b33cd7b4320e.png\" alt=\"TypsScript\"></p>\n<p><span class=\"blue-400\">TypeScript</span>는 JavaScript에 변수 타입이라는 개념을 도입함으로써, 변수의 모호함에서 유발되는 오류를 최소화한다.</p>\n<p>Next.js는 TypeScript 기반의 템플릿을 제공해준다. TypeScript를 전혀 해보진 않았지만, \"어차피 JavaScript에 타입 선언만 추가된 거 아닌가?\"라는 생각이 들어 적용했다.</p>\n<p>TypeScript에 적응하는 데 그리 오랜 시간이 걸리진 않은 걸로 기억한다. 내 생각대로 타입 선언 말곤 크게 달라진 게 없으니. 오히려 타입이 명시되니 해당 변수에 사용할 수 있는 올바른 내부함수라던가, 자동완성이 적용되서 훨씬 쾌적한 개발을 할 수 있었다.</p>\n<p>단, 짜증나는 점이 하나 있었는데, 바로 라이브 서버와 컴파일 간의 차이였다. Next.js에서는 작성한 소스코드를 즉시 반영해주는 일종의 라이브 서버를 구동할 수 있다. 여기서 좀 짜증나는 차이가 발생하는데, <span class=\"red-400\">TypeScript에서 오류가 나는 문장이나 문법이 라이브 서버에선 영향을 미치지 않는다.</span> 즉, 보기에 멀쩡한 코드도 라이브 서버에선 실행까지 잘 되지만 빌드를 수행하면 갖가지 오류를 뱉어낸다.</p>\n<p align=\"center\">\n    <i>타입이 정확하지 않아아아아아앙아ㅏㅇㄲㄲㄱㅇㅇ악!! 이딴 \"불분명한\"거 내 앞에서 치워!!!</i>\n</p>\n\n<p align=\"center\">\n    <i>이거 타입 선언 안 한 새x끼가 너냐?? ㅋㅋㅋㅋㅋㅋ 컴파일 오류 보고싶지 않으면 처---신 잘 하라고-</i>\n</p>\n\n<p align=\"center\">\n    <i>아니 이거 \"null\"일 가능성이 있는뎁쇼?? 아 렌더링 후에 반드시 생성되는 DOM이라 확실히 있는 놈이라구요? 아 DOM 그딴건 모르겠고 암튼 null일 수도 있다고 아ㅋㅋㅋㅋㅋㅋ</i>\n</p>\n\n<p>더 환장하는건, 실제론 동작 자체에 문제가 없는 소스다. JavaScript라면 무사통과할 수 있는 매우 정상적인 소스라는 뜻이다.</p>\n<p>하지만 작고 소중한 TypeScript는 아무도 막을 수 없어서 조금만 의심스러운 부분이 있다면 바로 찡찡대기 시작한다.</p>\n<p>특히 라이브러리의 내부 함수를 쓸 때가 좀 고역이였다. 정확한 타입을 선언해주기 위해서 소스 내부를 까서 어떤 타입의 파라미터를 받는지, 어떤 타입을 반환하는지를 확인해야했다. 물론 이게 TypeScript의 존재 의의다만...</p>\n<p>이러한 문제에도 불구하고 TypeScript는 내가 JavaScript에서 불편하다고 느낀 것들을 해소해줬다. 문제는 전혀 다른 불편함을 준다는 점이지만..</p>\n<p>그래도 나름 재밌는 개발 경험을 줬지 싶다.</p>\n<h2 id=\"2.-CSS-in-CSS 적용\">2. CSS-in-CSS 적용 <a href=\"#2.-CSS-in-CSS 적용\">🔗</a></h2><p>어렸을 때, 이런 문구 들어본 적 있을 거다.</p>\n<p align=\"center\">\n    <i>진료는 의사에게, 약은 약사에게</i>\n</p>\n\n<p>의약분업을 위한 캐치프레이즈다. 내 블로그에는 통용되지 않는 말이기도 하다.</p>\n<p>이전까지의 내 블로그는 CSS-in-JS가 적용되어 있었다. 위에서도 언급했듯이, 내 블로그의 CSS는 전적으로 Material-UI에 의존하고 있었다. 이로 인해 의존할 수 있는 래퍼런스 또한 많지 않았고, 불행히도 Material-UI는 CSS-in-JS 방식의 래퍼런스를 제공한 탓에 지금까지 이런 방식을 적용했었다.</p>\n<blockquote>\n<p><strong>CSS-in-JS?</strong> <strong>CSS-in-CSS??</strong><br><code class=\"inline-code\">CSS-in-JS</code>: JavaScript에서 CSS 담당<br><code class=\"inline-code\">CSS-in-CSS</code>: CSS에서 CSS 담당</p>\n</blockquote>\n<p>몰론 장점도 있었다. CSS-in-JS의 가장 큰 장점은 CSS를 JavaScript에서 관리하므로 CSS의 동적 생성이 쉽다. 더군다나 내 블로그는 다크, 라이트 모드를 토글할 수 있기 때문에 이러한 장점은 더더욱 강력하게 다가왔다.</p>\n<p>하지만 위에서도 언급했듯이, 렌더링 및 성능 문제가 가장 큰 이슈로 대두됐고, 이 중 스타일링 구문이 가장 의심이 됐다.</p>\n<p>모든 컴포넌트 마다 JavaScript에서 스타일링 구문을 생성해야했고, 게시글 같은 경우 스타일링 요소가 많아 JSX 코드보다도 스타일링 코드가 훨씬 더 길어지는 주객전도가 일어나기도 했다.</p>\n<p>더군다나 CSS-in-JS에서 일어나는 치명적인 문제가 있는데, CSS가 적용되기 전인 날 것의 HTML이 잠깐 보이는 현상이다. 이러한 현상을 <span class=\"priamry\">FOUC</span>(Flash of Unstyled Content)라고 부른다.</p>\n<p>NextJS에선 emotion.js를 적극적으로 차용하도록 유도하여 이러한 문제를 줄인다고 하는데.. 특별한 이유가 없다면 CSS는 CSS가 담당하는 게 맞다고 생각하여, CSS-in-CSS를 차용하기로 했다.</p>\n<h2 id=\"3.-SCSS 적용\">3. SCSS 적용 <a href=\"#3.-SCSS 적용\">🔗</a></h2><p>위에서 언급한 CSS-in-CSS를 위해, 처음엔 CSS를 사용하고자 했다. 하지만 사소한 문제가 하나 있었는데, 기존 소스와의 호환성을 위해선 CSS만으로는 안 된다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVASCRIPT</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"window.getSelection().selectAllChildren(this.parentElement.querySelector('code'));document.execCommand('copy');\">COPY</button>\n\n\t\t\t\t\t\t<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * 스타일 객체 반환 함수\n *\n * @returns {JSON} 스타일 객체\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getStyles</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">makeStyles</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">theme</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        fab_bright<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            position<span class=\"token operator\">:</span> <span class=\"token string\">\"fixed\"</span><span class=\"token punctuation\">,</span>\n            bottom<span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span>\n            right<span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span>\n            backgroundColor<span class=\"token operator\">:</span> grey<span class=\"token punctuation\">[</span><span class=\"token number\">800</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            color<span class=\"token operator\">:</span> grey<span class=\"token punctuation\">[</span><span class=\"token number\">200</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"&amp;:hover\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                backgroundColor<span class=\"token operator\">:</span> grey<span class=\"token punctuation\">[</span><span class=\"token number\">700</span><span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"&amp; svg\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                color<span class=\"token operator\">:</span> orange<span class=\"token punctuation\">[</span><span class=\"token number\">600</span><span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">[</span>theme<span class=\"token punctuation\">.</span>breakpoints<span class=\"token punctuation\">.</span><span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"md\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token string\">\"&amp; span\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                    marginLeft<span class=\"token operator\">:</span> theme<span class=\"token punctuation\">.</span><span class=\"token function\">spacing</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">[</span>theme<span class=\"token punctuation\">.</span>breakpoints<span class=\"token punctuation\">.</span><span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sm\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                bottom<span class=\"token operator\">:</span> <span class=\"token number\">70</span><span class=\"token punctuation\">,</span>\n                right<span class=\"token operator\">:</span> <span class=\"token number\">20</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        fab_dark<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            position<span class=\"token operator\">:</span> <span class=\"token string\">\"fixed\"</span><span class=\"token punctuation\">,</span>\n            bottom<span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span>\n            right<span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span>\n            backgroundColor<span class=\"token operator\">:</span> grey<span class=\"token punctuation\">[</span><span class=\"token number\">200</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            color<span class=\"token operator\">:</span> grey<span class=\"token punctuation\">[</span><span class=\"token number\">900</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"&amp;:hover\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                backgroundColor<span class=\"token operator\">:</span> grey<span class=\"token punctuation\">[</span><span class=\"token number\">300</span><span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"&amp; svg\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                color<span class=\"token operator\">:</span> blue<span class=\"token punctuation\">[</span><span class=\"token number\">600</span><span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">[</span>theme<span class=\"token punctuation\">.</span>breakpoints<span class=\"token punctuation\">.</span><span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"md\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token string\">\"&amp; span\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                    marginLeft<span class=\"token operator\">:</span> theme<span class=\"token punctuation\">.</span><span class=\"token function\">spacing</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">[</span>theme<span class=\"token punctuation\">.</span>breakpoints<span class=\"token punctuation\">.</span><span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sm\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n                bottom<span class=\"token operator\">:</span> <span class=\"token number\">70</span><span class=\"token punctuation\">,</span>\n                right<span class=\"token operator\">:</span> <span class=\"token number\">20</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        div<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            height<span class=\"token operator\">:</span> <span class=\"token number\">24</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>기존에 사용 중인 CSS-in-JS 소스는 이와 같다. Material-UI의 <code class=\"inline-code\">makeStyles</code>를 활용한 것으로, 구조를 보면 알겠지만 일반적인 CSS와는 좀 다르다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>CSS</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"window.getSelection().selectAllChildren(this.parentElement.querySelector('code'));document.execCommand('copy');\">COPY</button>\n\n\t\t\t\t\t\t<pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">.alpha</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token selector\">.alpha:hover</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> blue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token selector\">.alpha .beta</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> black<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n\t\t\t\t\t</div>\n\t\t\t\t\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>SCSS</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"window.getSelection().selectAllChildren(this.parentElement.querySelector('code'));document.execCommand('copy');\">COPY</button>\n\n\t\t\t\t\t\t<pre class=\"language-scss\"><code class=\"language-scss\"><span class=\"token selector\">.alpha </span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span>\n\n    <span class=\"token selector\"><span class=\"token parent important\">&amp;</span>:hover </span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> blue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token selector\">.beta </span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> black<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>각각 동일한 동작을 CSS와 SCSS로 표현했다. 보다시피, <code class=\"inline-code\">makeStyles</code>와 SCSS의 표기가 매우 흡사함을 알 수 있다. 즉, 구버전의 스타일링 시스템와 호환성을 최대한 높이기 위해선 SCSS 내지는 SASS와 같은 스타일 전처리기가 반드시 필요했다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/127337877-974ffb27-90a1-4013-a2d3-08494e5d0ebb.png\" alt=\"SCSS\"></p>\n<p>그 중 내가 차용한 건 SCSS. SASS는 기존의 CSS와는 살짝 다른 문법을 가지고 있다는 점이 거슬렸다. SCSS는 단순한 스타일링 이외에도 <code class=\"inline-code\">@mixin</code>, <code class=\"inline-code\">@for</code>나 변수 선언과 같이 좀 더 프로그래밍적인 요소가 강해 더욱 간편한 스타일링 개발 경험을 제공했다.</p>\n<p>일장일단이 있던 TypeScript와 달리, 앞으로도 계속 쓰고 싶을 정도로 마음에 들었다.</p>\n<h2 id=\"4.-marked.js 차용\">4. marked.js 차용 <a href=\"#4.-marked.js 차용\">🔗</a></h2><p>내가 제대로 알아보질 않아서 그런지 모르겠으나, 기존에 썼던 <code class=\"inline-code\">unified.js</code>, <code class=\"inline-code\">remark</code>, <code class=\"inline-code\">rehype</code> 계열 플러그인의 경우 사용자가 커스터마이징할 여력이 없었던 걸로 기억한다. 때문에 이와 연관된 수 많은 플러그인을 설치해야했다.</p>\n<p>더 골때리는건, 적용된 결과물을 커스텀할 명확한 방법을 제공해주지 않았다. 즉, 주는 대로 쓰라는 말인데.. 여러모로 달갑지 않았다.</p>\n<p>특히 코드 블록의 경우, 복사 버튼이나 언어 표시 등 다채로운 기능을 추가하고 싶었으나, 그럴 수 없어 난감했다. 굳이 거창한 플러그인이 아니더라도, 변환된 HTML 구문만 던져주면 wrapper라도 하나 만들어서 감싸줄텐데, 그런 것도 없으니 여의치 않았다. 물론 전체 HTML은 갖고 있었다만, 이걸 일일히 파싱해서 추출한다는 것도 다소 무식하기도 하고.</p>\n<p>그렇게 찾은 차선책이 <code class=\"inline-code\">marked.js</code>다. 이유는 단 한 가지로, 사용자가 결과물을 기본적인 구문 혹은 직접 커스텀한 구문별로 자유로운 커스터마이징이 가능했기 때문.</p>\n<p>그래도 <code class=\"inline-code\">Prism.js</code>와 <code class=\"inline-code\">LaTeX</code>를 적용하는 건 녹록치 않았었다. 특히 LaTeX는 완벽히 적용하는데 3일 정도는 걸리지 않았나 싶다. LaTeX의 경우 <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"></span></span>로 감싼 구문에 적용되는데, 마크다운이 기본적으로 <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"></span></span>에 뭔가 특수한 구문이 적용되는게 아니기 때문에 해당 문자열 토큰을 구문별로 감지할 수 있는 로직을 작성해야했다.</p>\n<p>그나마 Prism.js는 마크다운에 코드블럭 문법 자체가 있어서 그리 어렵지는 않았지만, LaTeX는 구문 분리부터 끝까지 다 만드느라 정말 힘들었다. </p>\n<p>그래도 어쨌든 unified.js와 달리 커스터마이징 API가 잘 설명되어 있어서, 이런 것들도 만들 수 있었다.</p>\n<img src=\"https://user-images.githubusercontent.com/50317129/127338162-d8ab86fe-69e8-4ef7-a1d0-78cfccb0c0a5.png\" alt=\"Codeblock\" width=\"600px\" />\n\n<ul>\n<li>코드블럭 디자인</li>\n<li>언어 표시</li>\n<li>복사 버튼</li>\n</ul>\n<p>코드블럭의 Mac 스타일 디자인은 외국 블로그들을 많이 참고했다. 간간히 구글링하다보면 좋든 싫든 외국 사이트에 접근하게 되는데, 저런 형식의 디자인이 많았다. 막상 직접 보면서 만드려고 하니 안 나오길래, 기억을 살려서 비슷하게 만들었다.</p>\n<p>복사 버튼도 간단한 JS를 통해 그리 어렵지 않게 구현했다. 원래 Prism.js에 여러 플러그인이 있긴 한데, 리액트 상에서 적용하려니 잘 되지 않았다. 특히 라인 표시는 꼭 넣고 싶었는데, 다른건 어찌어찌 직접 만들었다만, 이런 류의 디자인은 좀 난이도가 있기도 하고, 라인을 세서 동적으로 넣어줘야 해서 따로 만들진 않았다. 나중에 여유가 되면 한 번 시도해볼 수도..?</p>\n<p>또 하나, 테이블의 경우 중앙 정렬에 스크롤을 만들어주려면 반드시 div로 한 번 감싸줘야 했는데, 이 부분도 커스터마이징을 통해 어렵지않게 만들었다.</p>\n<img src=\"https://user-images.githubusercontent.com/50317129/127339017-74118f65-f475-4514-b3af-75460aec8a67.png\" alt=\"테이블\" width=\"500px\" />\n\n<p>여러모로 블로그 개편 중 가장 빡세고 난감했던 부분이였다.</p>\n<h2 id=\"5.-카테고리별, 태그별 리스트 페이지 추가\">5. 카테고리별, 태그별 리스트 페이지 추가 <a href=\"#5.-카테고리별, 태그별 리스트 페이지 추가\">🔗</a></h2><p>기존의 블로그에도 카테고리가 select 형태로 존재하긴 했었다. 태그의 경우 아예 관련 페이지가 존재하지도 않았었고. 처음 만들 당시에만 해도 NextJS에 대한 기능을 환전히 이해하지 못 해서, 동적 라우팅이 있는지조차 몰랐었다.</p>\n<img src=\"https://user-images.githubusercontent.com/50317129/127339546-9ba96b92-b580-4081-a1a1-12e98bbdcf24.png\" alt=\"카테고리\" width=\"500px\" />\n\n<p>카테고리와 태그별로 해당하는 리스트를 보여주는 페이지를 동적 라우팅으로 만들었다. 카테고리의 경우 기존의 select 방식이 그닥 이쁘지 않은 것 같아서 카드뷰 형식으로 간단하게 만들었는데, 그렇게 이쁘단 느낌은 안 드는 것 같다. 우선은 마땅한 디자인이 구상되지 않아서 냅둘 생각이다.</p>\n<ul>\n<li>/posts/category/{카테고리}/1</li>\n<li>/posts/tags/{태그}/1</li>\n</ul>\n<p>URL은 위와 같이 정의했다.</p>\n<h2 id=\"6.-RESTful URL 적용\">6. RESTful URL 적용 <a href=\"#6.-RESTful URL 적용\">🔗</a></h2><p>기존의 URL은 아래와 같이 적용되어 있었다.</p>\n<ul>\n<li><code class=\"inline-code\">/posts/?page=1&amp;category=all</code>: 전체 카테고리의 게시글 리스트 1 페이지</li>\n<li><code class=\"inline-code\">/posts/brand-new/</code>: 현재 게시글 URL</li>\n</ul>\n<p>게시글 URL은 그렇다 치고, 게시글 리스트는 정말 꼴보기 싫은 형태다.</p>\n<p>NextJS는 동적 라우팅을 지원한다. TypeScript 기준으로 <code class=\"inline-code\">[page].tsx</code>, <code class=\"inline-code\">[...page].tsx</code>와 같이 생성하면 된다. 이름의 page는 단순히 할당되는 라우팅 변수명을 의미하므로, 어떤 것이 와도 상관없다. <code class=\"inline-code\">[...page].tsx</code>와 같은 형태는 동적 변수가 여러개가 올 경우 사용한다.</p>\n<p>블로그 개편하기 이전에 적용하긴 했지만, 게시글 URL에도 약간의 변화를 줬다. 이는 기존의 Jekyll 블로그를 사용하면서 겪었던 경험을 토대로 개선한건데, Jekyll의 경우 블로그 제목을 <code class=\"inline-code\">yyyy-MM-dd-title.md</code>와 같은 형태로 관리한다. 즉, 날짜정보를 제목에서 관리하는데, 이게 또 게시글을 시간순으로 정렬하기 편해서 보기가 쉬웠다. 또한 요즘 블로그 보니 <code class=\"inline-code\">/yyyy/MM/title</code>과 같이 URL을 구성하던데, URL에 덩그러니 제목만 있는 것보다 이쪽이 뭔가 더 이뻐보여서 이렇게 구성하기로 했다.</p>\n<p>굳이 <code class=\"inline-code\">/yyyy/MM/dd/title</code> 형식으로 일자까지 포함시킨 이유는, NextJS 특성 상 URL 정보만으로 완전한 마크다운 파일 이름을 역으로 만들 수 있어야 라우팅하기 편하기 때문.</p>\n<p>최종적으로 변경된 URL은 아래와 같다.</p>\n<ul>\n<li><code class=\"inline-code\">/posts/1</code>: 전체 카테고리의 게시글 리스트 1 페이지</li>\n<li><code class=\"inline-code\">/posts/JAVA/2</code>: JAVA 카테고리의 게시글 리스트 2 페이지</li>\n<li><code class=\"inline-code\">/posts/2021/07/26/brand-new</code>: 현재 게시글</li>\n</ul>\n<p>URL 끝에 <code class=\"inline-code\">/</code>가 붙는데, NextJS에서 trailing slash 옵션을 켰기 때문이다. 해당 옵션을 키면 해당 페이지를 항상 <code class=\"inline-code\">index.html</code>로 만들어준다. 예를 들어, <code class=\"inline-code\">/pages/posts.tsx</code>가 있다면 옵션 여부에 따라 아래와 같이 변환된다.</p>\n<ul>\n<li><code class=\"inline-code\">/posts.html</code>: 옵션을 끌 경우</li>\n<li><code class=\"inline-code\">/posts/index.html</code>: 옵션을 킬 경우</li>\n</ul>\n<p>톰캣에서 개발 서버를 테스트할 때, 반드시 <code class=\"inline-code\">.html</code>을 붙여줘야 하길래, 해당 옵션을 켰었는데, GitHub는 <code class=\"inline-code\">.html</code> 확장자를 생략 가능해서 굳이 안 해줘도 상관없었다.</p>\n<p>끝에 <code class=\"inline-code\">index.html</code>이 있을 경우 <code class=\"inline-code\">/posts/</code>로 접속하기 때문에 구글 서치엔진의 URL이 꼬여버렸다... 새로 갱신은 해놨는데, 구글 서치엔진 반영이 워낙 느려서 당분간은 유입이 잘 안 될 것 같다.</p>\n<h2 id=\"7.-기타 UI 개선\">7. 기타 UI 개선 <a href=\"#7.-기타 UI 개선\">🔗</a></h2><p>그 밖에 크고 작은 UI를 개선했다. 가장 큰 변경점은 Bottom Nav 삭제.</p>\n<p>모바일의 브라우저는 상단의 주소창과 하단의 메뉴가 나타났다 안 나타났다 하는데, 이 과정에서 페이지의 높이가 바뀌어버린다. 이에 따라서 Bottom Nav의 위치가 수시로 왔다갔다해서 UX를 너무 해친다.</p>\n<p>Bottom Nav를 없엔 대신 슬라이드 메뉴를 추가했는데, 이게 그리 이쁘지 않아서 적절하게 디자인을 다시 해 줄 생각이다.</p>\n<img src=\"https://user-images.githubusercontent.com/50317129/127339739-950f4948-51da-4f9f-976d-225cef201aa3.png\" alt=\"게시물 아이템\" width=\"600px\" />\n\n<p>또한 기존의 게시글 아이템도 좀 더 카드뷰스럽게 만들었고, 사진을 좀 더 강조했다. 또한 태그같은 난잡한 부분은 슬라이드 메뉴 형태로 깔끔하게 정리했다.</p>\n<h1 id=\"여담\">여담 <a href=\"#여담\">🔗</a></h1><p>근 며칠 간 블로그 개편 작업에 몰두해서 진행 중이던 백준 알고리즘 풀이가 홀딩됐다. 1020번을 풀었는데, 중간 정도 풀이만 써놓고 아직 마무리하질 못 했다. 이거 풀이도 까먹을 지경인데...</p>\n<p>아직 완전히 완성된 건 아니지만, 어느정도 정리가 된 것 같으니, 그동안 멈춘 작업을 다시 진행해야겠다.</p>\n","url":["2021-07-26-brand-new","2021","07","26","brand-new"],"toc":[{"text":"리모델링","tag":"리모델링","depth":1},{"text":"문제점","tag":"문제점","depth":1},{"text":"1. 렌더링 지연 현상","tag":"1.-렌더링 지연 현상","depth":2},{"text":"2. Unified.js과 관련 플러그인 커스터마이징 문제","tag":"2.-Unified.js과 관련 플러그인 커스터마이징 문제","depth":2},{"text":"3. CSS-in-JS 방식","tag":"3.-CSS-in-JS 방식","depth":2},{"text":"4. 부실한 RESTful URL","tag":"4.-부실한 RESTful URL","depth":2},{"text":"개선점","tag":"개선점","depth":1},{"text":"1. TypeScript 적용","tag":"1.-TypeScript 적용","depth":2},{"text":"2. CSS-in-CSS 적용","tag":"2.-CSS-in-CSS 적용","depth":2},{"text":"3. SCSS 적용","tag":"3.-SCSS 적용","depth":2},{"text":"4. marked.js 차용","tag":"4.-marked.js 차용","depth":2},{"text":"5. 카테고리별, 태그별 리스트 페이지 추가","tag":"5.-카테고리별, 태그별 리스트 페이지 추가","depth":2},{"text":"6. RESTful URL 적용","tag":"6.-RESTful URL 적용","depth":2},{"text":"7. 기타 UI 개선","tag":"7.-기타 UI 개선","depth":2},{"text":"여담","tag":"여담","depth":1}]}},"__N_SSG":true}