{"pageProps":{"posts":[{"header":{"title":"알고리즘이 중요한 까닭","excerpt":"IT영역에서의 알고리즘이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. 개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구된다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열","정렬","이진 검색"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-10-about-algorithm-chapter02.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 2장 알고리즘이 중요한 까닭\r\n\r\nIT영역에서의 <span class=\"primary\">알고리즘</span>이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. <span class=\"teal-400\">개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구</span>된다.\r\n\r\n이러한 특징으로 알고리즘은 뛰어난 문제 해결력과 수학적 사고 능력을 요한다. 때문에 많은 사람들이 어려워하는 분야 중 하나지만, 그 강력함과 효율로 인해 개발 역량의 척도를 확인하는데 사용하기도 한다. 흔히 기업에서 보는 <span class=\"teal-400\">코딩 테스트</span>가 좋은 예시다.\r\n\r\n이 장에서는 <span class=\"primary\">알고리즘</span>을 통해 검색 연산을 더욱 효과적으로 개선하는 방법에 대해 설명한다. 이전 장에서 언급했듯이, 검색 연산은 무수히 많은 읽기 연산의 모음이나 다름없다. 알고리즘이 어떻게 읽기 연산을 최적화시키는지 알아보자.\r\n\r\n## 2-1. 정렬된 배열\r\n\r\n<span class=\"primary\">정렬된 배열</span>이란, 기존의 배열에서 요소들이 특정 조건으로 정렬된 배열을 의미한다. 정렬된 배열은 그 요소들이 항상 정해진 조건에 따라 순서대로 배치된다. 이는 삽입을 할 때도 동일하다. 정렬된 배열이 항상 정렬된 상태를 유지하기 위해선 <span class=\"red-A400\">삽입 시에도 요소의 정렬에 따라 정렬을 훼손하지 않는 올바른 자리에 삽입</span>되어야 한다.\r\n\r\n기존의 배열이라면 배열의 크기가 허락하는 한, 원하는 위치 어디에서나 삽입이 가능하다. 배열에 55를 삽입할 때, 일반적인 배열은 아래처럼 삽입에 제한이 없다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144062-a3b6c280-e157-11eb-88d6-20689d8f05b1.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 정렬된 배열이라면 어떨까? 이번엔 배열이 오름차순으로 정렬된 배열이라고 가정해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144070-aa453a00-e157-11eb-9390-1550623a57bd.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬된 위 배열에서 55를 삽입한다면 어떨까?\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144072-aca79400-e157-11eb-8939-cc0beb583b9b.png\" width=\"600px\" />\r\n</p>\r\n\r\n반드시 44와 94의 사이에 삽입되어야 오름차순 정렬을 유지할 수 있다. 그렇다면 우리는 여기서 정렬된 배열의 삽입은 기존의 삽입 연산에 비해 로직이 추가됨을 유추할 수 있다. 원리는 간단하다. 요소를 순차적으로 읽어서 55보다 큰 수가 나올 때까지 반복한다. 배열이 정렬되어 있으므로, 55보다 큰 수를 만나게 되면 이전의 요소는 모두 55보다 작을 것이다. 이 위치를 기준으로 삽입을 진행하면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144075-ae715780-e157-11eb-92ed-71ee06140c5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 그림과 같이 순차적으로 요소를 검색하여 55보다 큰 요소를 찾는다. 94는 배열에서 55보다 큰 가장 작은 수다.\r\n\r\n94의 인덱스인 4번째 요소에 55를 삽입하고, 94를 한 칸 뒤로 미룬다. 이 과정을 통해 정렬된 배열의 연산을 수행할 수 있다.\r\n\r\n그렇다면 이 고생을 뭐하러 사서하는 것일까? 그 이유는 검색의 최적화에 있다. <span class=\"orange-A400\">정렬된 배열은 그 자체로 순서라는 규칙성을 지니기 때문에 이를 활용한 알고리즘 적용이 가능</span>하기 때문이다. 이를 통해 검색의 작업량을 효과적으로 줄여 더욱 빠른 검색이 가능하다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 정렬된 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 02:41:14\r\n */\r\npublic class SortedArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 9, 14, 43, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tint result = run(item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(result);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 및 삽입된 인덱스 반환 함수\r\n\t *\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [int] 삽입된 인덱스\r\n\t */\r\n\tprivate static int run(int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\tinsert(result, item);\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자보다 배열의 값이 클 경우\r\n\t\t\tif (target < ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 인덱스에 55 삽입: [6, 9, 14, 43, 55, 94, -1, -1, -1, -1]\r\n```\r\n\r\n`insert` 함수는 이전 장에 나왔던 함수와 동일하지만, `find`의 경우 조금 달라졌다. `target == ARRAY[i]`로 동일한 값을 찾는 것이 아니라, `target < ARRAY[i]`로 삽입할 요소보다 큰 값을 찾도록 변경됐다. `run` 함수는 이를 적절히 구동하여 삽입된 인덱스를 반환한다.\r\n\r\n> **JAVA의 정렬 함수**  \r\n> 자바는 `Arrays.sort()`라는 함수가 제공되며, 인수로 정렬할 배열을 전달한다. 기본적으로 오름차순으로 정렬되며, 본인이 직접 정렬 함수를 오버라이딩함으로써 자신만의 조건으로 정렬되도록 설계할 수도 있다.\r\n\r\n## 2-3. 이진 검색\r\n\r\n우리가 앞에서 배열을 정렬한 이유가 바로 이 것이다. <span class=\"primary\">이진 검색</span>이라는 알고리즘을 적용하면 검색의 속도를 상당부분 개선할 수 있다. 심지어 이진 검색은 알고리즘 축에서는 매우 쉬운 편에 속한다. 심지어 우리는 이미 다른 형태로 이진 검색이라는 알고리즘을 접한 적이 있다.\r\n\r\n어렸을 때나, 혹은 술자리에서 Up & Down이라는 게임을 해본적이 있을 것이다. 진행자가 임의의 구간에 해당하는 임의의 수 하나를 머릿속으로 생각하면, 참가자들이 이 수를 맞추는 것이다. 참가자가 수를 말하면 진행자는 그 수가 자신의 수보다 큰 지, 작은 지 알려준다. 이걸 누군가 맞출 때까지 반복한다. 이진 검색의 원리는 이와 정확히 일치한다.\r\n\r\n<span class=\"red-A400\">이진 검색은 그 특성 상 정렬된 배열에서만 가능</span>하다. 1 ~ 100의 구간으로 순차적으로 정렬된 배열이 있다고 가정해보자. 찾아야 할 수가 68일 때, 이진 검색은 아래와 같이 이루어진다.\r\n\r\n1. 1과 100의 중간인 50과 비교한다. (작업 +1)\r\n2. 50은 68보다 작으로 51 ~ 100의 구간을 검색한다.\r\n3. 51과 100의 중간인 75와 비교한다. (작업 +1)\r\n4. 75는 68보다 크므로 51 ~ 74의 구간을 검색한다.\r\n5. 51과 74의 중간인 62와 비교한다. (작업 +1)\r\n6. 62는 68보다 작으므로 63 ~ 74의 구간을 검색한다.\r\n7. 63과 74의 중간인 68과 비교한다. (작업 +1)\r\n8. 검색이 종료된다.\r\n\r\n만약 순차적으로 검색했다면 1 부터 68까지 총 68번의 작업이 발생할 것을 단 4번의 작업으로 검색을 완료했다. 간단한 알고리즘을 적용하는 것으로도 작업량이 17배 줄어든 것이다. 지금은 구간이 작지만, 구간의 끝이 만 단위가 넘어간다면 검색하려는 숫자의 위치에 따라 작업량이 기하급수적으로 감소한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색을 구현한 소스는 위와 같다. 눈여겨 볼 부분은 `binarySearch` 함수다. 시작값 `start`는 1로 초기화되고, 끝값 `max`는 배열의 크기와 동일하다.\r\n\r\n`mid`를 계산하여 `target`과 크기비교를 한다. `target`이 더 클 경우, 중간값을 기준으로 윗 구간이므로 `start`를 `mid + 1`로 보정한다. 반대로 `target`이 더 작을 경우, 중간값을 기준으로 아랫 구간이므로 `end`를 `mid - 1`로 보정한다. 검색 대상값인 `target`과 중간값 `mid`가 동일할 때까지 알고리즘을 반복한다.\r\n\r\n1 ~ 100까지 차례대로 배치되어 있으므로, 1은 `ARRAY[0]`, 43은 `ARRAY[42]`로 값 자체로 인덱스나 다름없기 때문에 인덱스는 따로 구하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색의 단점이 있는데, 1 ~ 100의 구간이 있다고 가정하면, 1이나 100과 같은 <span class=\"orange-A400\">구간의 시작과 끝을 검색하는데 시간이 매우 오래 걸린다.</span> 이는 이진 검색이 중간값을 기준으로 검색한다는 특징으로 인한 단점이다. 위의 소스는 구간의 시작과 끝도 비교함으로써 이진 검색을 강화한 소스다.\r\n\r\n``` java\r\n// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\nif (target == start || target == end)\r\n{\r\n\tbreak;\r\n}\r\n```\r\n\r\n눈여겨 볼 부분은 `binarySearch` 함수의 해당 부분이다. 기존에 없던 `start`와 `end`의 비교 로직이 추가되어, <span class=\"orange-A400\">구간의 시작과 끝이 목표일 경우 더욱 빠르게 검색</span>할 수 있도록 보정한 것이다.\r\n\r\n| 구분  | 보정 전 | 보정 후 |\r\n| :---: | :-----: | :-----: |\r\n|   1   |    6    |    1    |\r\n|  51   |    6    |    2    |\r\n|  100  |    7    |    1    |\r\n\r\n## 2-4. 이진 검색 대 선형 검색\r\n\r\n1부터 순차적으로 하나하나 검색하는 알고리즘을 <span class=\"primary\">선형 검색</span>, 구간의 중간값을 기준으로 검색하는 알고리즘을 <span class=\"primary\">이진 검색</span>이라 한다. 우리가 2장까지 진행하면서, 배열의 일반적인 검색과 이진 검색에 대해 설계하고 차이점을 비교했다.\r\n\r\n선형 검색의 경우 요소의 갯수 $N$이 늘어나면 늘어날수록 예상되는 최대 작업량도 $N$개로 비례하여 늘어난다. 이에 비해 이진 검색의 경우 $N = 10,000$일 때, 책에 의하면 최대 작업량이 13이라고 한다. $N = 1,000,000$이면 작업량은 20으로, 선형 검색의 작업량이 1,000,000임을 감안하면 <span class=\"green-A400\">데이터가 많아질 수록 이진 검색으로 절약할 수 있는 기대 비용이 더욱 큼</span>을 알 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 검색 퍼포먼스 비교 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 04:21:37\r\n */\r\npublic class SearchCompare\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100000000;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 86421478;\r\n\t\t\r\n\t\tlong tic = System.nanoTime();\r\n\t\t\r\n\t\tint linearResult = find(target);\r\n\t\t\r\n\t\tlong toc1 = System.nanoTime() - tic;\r\n\t\t\r\n\t\ttic = System.nanoTime();\r\n\t\t\r\n\t\tint binaryResult = binarySearch(target);\r\n\t\t\r\n\t\tlong toc2 = System.nanoTime() - tic;\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 선형 검색 프로세스: \");\r\n\t\tbuilder.append(linearResult);\r\n\t\tbuilder.append(\"(\").append(toc1).append(\"ns)\\n\");\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 이진 검색 프로세스: \");\r\n\t\tbuilder.append(binaryResult);\r\n\t\tbuilder.append(\"(\").append(toc2).append(\"ns)\\n\\n\");\r\n\t\tbuilder.append(\"이진 검색이 약 \").append(toc1 / toc2).append(\"배 더 빠릅니다.\");\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n86421478을 탐색하는데 소요된 선형 검색 프로세스: 86421477(26936600ns)\r\n86421478을 탐색하는데 소요된 이진 검색 프로세스: 26(5100ns)\r\n\r\n이진 검색이 약 5281배 더 빠릅니다.\r\n```\r\n\r\n위 소스는 선형 검색과 이진 검색을 통합해 퍼포먼스를 비교할 수 있는 소스다. 100,000,000(1억)의 구간에서 임의의 수 `target`을 검색한다. 해당 소스에서는 86,421,478으로 지정했다.\r\n\r\n|    구분     | 선형 검색  | 이진 검색 |    차이    |\r\n| :---------: | :--------: | :-------: | :--------: |\r\n| 프로세스 수 | 86,421,477 |    26     |     -      |\r\n|  테스트 1   | $2.442ms$  |  $5.2us$  | 약 4,699배 |\r\n|  테스트 2   | $2.463ms$  |  $5.3us$  | 약 4,648배 |\r\n|  테스트 3   | $2.434ms$  |  $5.5us$  | 약 4,424배 |\r\n|  테스트 4   | $2.536ms$  |  $5.3us$  | 약 4,785배 |\r\n|  테스트 5   | $2.383ms$  |   $5us$   | 약 4,766배 |\r\n|  테스트 6   | $2.509ms$  |  $5.1us$  | 약 4,919배 |\r\n|  테스트 7   | $2.487ms$  |  $5.4us$  | 약 4,605배 |\r\n|  테스트 8   | $2.394ms$  |  $4.5us$  | 약 5,320배 |\r\n|  테스트 9   | $2.666ms$  |  $5.3us$  | 약 5,030배 |\r\n|  테스트 10  | $2.352ms$  |  $5.3us$  | 약 4,438배 |\r\n\r\n<small class=\"red-400\">※ 위 테스트는 CPU i7-10700K, RAM 32GB에서 테스트한 결과물로, 구동 환경에 따라 연산 결과가 달라질 수 있음</small>\r\n\r\n이진검색이 선형검색에 비해 약 5000배 까지도 차이가 남을 확인할 수 있다. 단위가 $ms$, $us$니까 사람 입장에선 그게 그거지만, 기계 입장에선 이진 검색으로 5000번 수행할 동안 선형 검색은 한 번 수행하는 셈이니 실로 어마어마한 차이다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 알고리즘을 적용한 이진 검색을 구현하고 이를 기존의 선형 검색과 비교함으로써 알고리즘의 강력함을 체감할 수 있었다.\r\n\r\n현업에서 일하면서 알고리즘이 강력하다는 건 알고있었지만, 이렇게 간단하게 구현해서 직접 비교해보니 역시나 알고리즘이 중요한 이유를 알 것 같다.\r\n\r\n원래 오늘같이 내일 쉬는 날이면 새벽 네 다섯시까지 공부하긴 하는데, 포스팅 때문에 풀타임으로 집중하다 보니 유난히 더 피곤하다....","url":["2021-07-10-about-algorithm-chapter02","2021","07","10","about-algorithm-chapter02"]},{"header":{"title":"자료구조가 중요한 까닭","excerpt":"혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T01:30:56","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-10-about-algorithm-chapter01.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 개요\r\n\r\n혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다.\r\n\r\n마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.\r\n\r\n비전공자가 자료구조같은 기초지식이 항상 아킬레스건이였다. 특히 백준 풀 때 뼈저리게 느끼지만. 이 스터디가 끝나면 자료구조에 대해 기초정도는 알 수 있었음 한다.\r\n\r\n언어는 가급적 <span class=\"orange-400\">JAVA</span>로 진행한다.\r\n\r\n# 1장 자료 구조가 중요한 까닭\r\n\r\n이 장에서는 배열의 기초와 그에 해당하는 연산들에 대한 내용을 소개하면서 사용자에게 배열에 관한 러프한 개념을 설명해준다.\r\n\r\n배열과 <span class=\"primary\">집합</span>이라는 개념에 대한 내용을 기술한다. 저자에 의하면 챕터가 진행될 수록 연산 성능에 대한 점진적인 비교를 한다고 하니, 알고리즘 적용에 따른 성능 향상의 차이를 확인해 볼 수 있을 것이다.\r\n\r\n## 1-1. 배열: 기초 자료 구조\r\n\r\n<span class=\"primary\">배열</span>은 거의 모든 언어에 존재하는 매우 기초적인 자료구조다.\r\n\r\nJAVA에는 `int`, `boolean`과 같은 <span class=\"green-A400\">기본형 타입(Primitive Type)</span>과 `String`, `HashMap`과 같은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>으로 구분된다.\r\n\r\n이와 같은 데이터들은 각각 단일로 사용할 수도 있지만, 다수의 데이터를 동시에 다뤄야하는 경우가 심심치않게 발생한다. 이러한 데이터들이 모여 하나의 배열이 될 수 있다.\r\n\r\n`String` 데이터가 모여 `String[]`이라는 <span class=\"primary\">문자열 배열</span>이 되며, `int` 데이터가 모여 `int[]`라는 <span class=\"primary\">정수 배열</span>이 된다.\r\n\r\nJAVA에서의 배열은 이처럼 특정한 데이터가 여러개 모인 자료 구조이며, 반드시 <span class=\"red-A400\">지정된 데이터만을 요소로 받아들일 수 있다.</span>\r\n\r\n예를 들어, `boolean`은 `true`, `false`로 이루어진 데이터 형식이다. `boolean[]`은 `boolean` 데이터가 여러개 모인 배열이며, 이렇게 선언된 배열은 `boolean`에 해당하는 `true`, `false`만 받아들일 수 있다. 즉, 1이나 \"A\"와 같은 문자열은 배열에 삽입할 수 없다.\r\n\r\n또한 <span class=\"red-A400\">배열은 고정 길이를 가진다.</span> 한 번 할당된 배열의 길이는 재할당되지 않는 이상 절대로 길이가 변경되지 않는다.\r\n\r\n> **⚠잠깐! 이건 어디까지나 JAVA 얘기에요!**  \r\n> 지금 설명하는 배열의 특징은 JAVA에 국한되는 예시다. 당장 JavaScript만 봐도, 배열에 별다른 제약이 존재하지 않는다. 길이는 필요에 따라 증축할 수 있으며, 요소에 아무 데이터 타입이나 할당 가능하다.\r\n\r\nJAVA에서 배열은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>에 해당한다.\r\n\r\n배열에서 수행 가능한 연산에는 4가지가 존재한다.\r\n\r\n* 읽기\r\n* 검색\r\n* 삽입\r\n* 삭제\r\n\r\n위 4가지 연산은 배열의 가장 기초적인 연산이다. 이 4가지 연산을 JAVA로 직접 구현하며 어떤 단계를 거치는지 확인해보자.\r\n\r\n## 1-2 읽기\r\n\r\n<span class=\"primary\">읽기</span>연산은 배열의 특정 인덱스에 어떠한 값이 있는지 읽는 연산이다.\r\n\r\n대부분 모든 언어의 런타임에서 할당되는 데이터들은 메모리에 기록된다. 많은 양의 데이터가 할당될수록 프로그램이 요구하는 메모리, 즉 RAM의 요구사항이 높아진다. 배틀그라운드나, 스타크래프트2와 같은 게임들은 많은 양의 메모리를 요구한다. 그 만큼 기록되고 처리되는 데이터의 양이 매우 방대하기 때문이다.\r\n\r\n데이터가 메모리에 할당될 때, 가용한 임의의 메모리 주소에 저장된다. 해당 메모리 주소에 원하는 값이 존재할 것이므로, 값을 호출하기 위해선 해당 값이 저장된 메모리 주소에 접근하여 값을 조회한다. JAVA를 포함한 대부분의 언어들은 이러한 과정이 개발자에게까지 노출되지 않는 내부의 영역에 존재한다. 이걸 직접 다루는 것이 C언어의 그 악명높은 포인터다.\r\n\r\nJAVA의 메모리는 JVM(Java Virtual Machine, 자바 가상머신)이 관리한다. JVM의 메모리 구조부터 시작하면 한도끝도 없이 브랜치가 뻗어나가니, 핵심만 찝어보자.\r\n\r\n위에서 언급했듯이, 배열은 참조형 타입이며, 이 참조형 타입은 JVM의 Heap 영역에서 관리한다. 메모리를 간략하게 도식화하면 아래와 같이 표현할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111131-7dc1fb80-e120-11eb-8a75-0cf615c9c020.png\" width=\"600px\" />\r\n</p>\r\n\r\n네모 한 칸에 하나의 데이터를 할당할 수 있다고 해보자. 만약 6, 43, 14, 9, 94 5개의 정수로 이루어진 정수형 배열을 메모리에 할당한다고 가정하자. JVM이 해당 배열의 크기를 메모리에 기록할 수 있는지 확인하고, 가능하다면 기록한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111294-b2ce4e00-e120-11eb-8a6e-d5fc241db0ee.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 처럼 메모리 상의 적절한 위치에 배열이 기록될 것이다. 여기서 배열의 4번째 데이터를 읽어보자.\r\n\r\n프로그램은 해당 배열의 주소를 알고있다. 자기가 직접 할당했으니 당연하다. 배열의 주소를 0x0404라고 가정하면 아래와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n0x0404에서 4번째 데이터를 호출하므로 0x0407의 데이터를 조회하면 된다.\r\n\r\n> **😒아니 4번째 데이터라면서요...**  \r\n> 거의 대부분의 컴퓨터 언어는 시작 인덱스를 0으로 지정한다. 그 이유는 메모리에 있는데, 메모리를 기준으로 배열의 첫 번째 데이터는 주소의 이동이 없다.  \r\n> 만약 주소가 0x0101이라면, 첫 번째 데이터는 0x0101이 되기 때문에 주소의 이동이 없으므로 0번째 데이터라고 정의하는 것이다. 이는 관점의 차이로, 초대 프로그램의 언어가 이와 같은 방식을 차용했다. 이후 이를 기반으로 생겨난 수 많은 언어들이 이 영향을 받았다.\r\n\r\n이처럼 배열의 주소에서 해당 인덱스만큼 주소에 더해 데이터를 읽는 것이므로, 동작은 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111156-887c9080-e120-11eb-94db-46545b8a5e9c.png\" width=\"600px\" />\r\n</p>\r\n\r\n주소 0x0404를 시작으로 4번째 데이터인 0x0407인 주소에 접근한다. 배열의 주소와 배열의 인덱스를 알고 있으므로 별도의 연산 없이 바로 접근 가능하다. 이로써 0x0407의 값 9에 접근할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 읽기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 22:53:39\r\n */\r\npublic class ArrayRead\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 읽을 인덱스\r\n\t\tint index = 4;\r\n\t\t\r\n\t\tint result = read(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(\"4번 째 아이템: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 읽기 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t *\r\n\t * @return [int] 인덱스에 해당하는 값\r\n\t */\r\n\tprivate static int read(int index)\r\n\t{\r\n\t\treturn ARRAY[index];\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 아이템: 9\r\n```\r\n\r\nJAVA 소스는 위와 같다. 배열 `array`을 선언하고, `array[3]`을 호출하면 배열의 4번째 값인 94가 변수 `four`에 할당된다. 목표에 바로 접근하므로 작업에 필요한 단계는 단 하나다.\r\n\r\n## 1-3. 검색\r\n\r\n이처럼 주소의 값이나 인덱스를 정확히 알고 있다면, 별도의 연산 없이 바로 해당하는 값을 갖고올 수 있다. 하지만 실제로 배열을 다루다보면 꼭 이렇게 간단한 케이스만 있지는 않다.\r\n\r\n우리가 구조를 알지 못하는 배열이 있다고 가정할 때, 해당 배열에서 우리가 원하는 값을 찾아야할 경우가 적지않게 발생한다. 이 경우 원하는 값의 인덱스를 가지고 있지도 않으며, 심지어 배열 내부에 원하는 값이 존재하는지조차 알 수 없다. 이 경우 <span class=\"primary\">검색</span>연산을 통해 배열의 값을 찾아야 한다.\r\n\r\n위에서 선언했던 배열을 다시 가져와보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n이번엔 우리가 이 배열에 대한 정확한 정보를 가지고있지 않다고 가정해보자. 현재 우리는 이 배열의 어떤 인덱스에 어떤 값이 있는지 전혀 모르는 상태다.\r\n\r\n이 상황에서 14라는 값을 검색해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111164-8a465400-e120-11eb-9432-8c127bfed9b2.png\" width=\"600px\" />\r\n</p>\r\n\r\n검색은 읽기 작업의 반복이라고 봐도 무방하다. 위 그림은 이러한 검색의 특성을 여실히 보여준다. 목표값인 14를 찾기 위해 `array[0]` 부터 순차적으로 읽음으로써 14를 찾는다.\r\n\r\n만약 어떠한 방법으로든 읽기과정을 줄이면서도 정상적인 검색이 가능하다면 소요시간이 효과적으로 감소할 것이다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 23:47:03\r\n */\r\npublic class ArrayFind\r\n{\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 목표 숫자\r\n\t\tint target = 14;\r\n\t\t\r\n\t\tint result = find(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"이 포함된 인덱스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n14이 포함된 인덱스: 2\r\n```\r\n\r\n하지만 위는 가장 기초적인 검색 알고리즘을 적용한 것이다. 3번째 요소를 찾기 위해선 3개 과정이 필요하고, 5484번째 요소를 찾기 위해선 5484개 과정이 필요하다.\r\n\r\n그러나, 요소가 맨 끝에 있거나, 불행히도 배열 내에 존재하지 않을 경우 배열 전체를 검색해야할 수도 있다. 즉 배열에 $N$개의 요소가 있다면, 검색의 최대 작업 갯수는 $N$개가 된다.\r\n\r\n## 1-4. 삽입\r\n\r\n배열에 새로운 요소를 넣는 작업을 <span class=\"primary\">삽입</span> 연산이라 한다. 배열에서 55를 삽입하는 과정을 통해 삽입 연산에 대해 알아보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111179-8d414480-e120-11eb-9c36-965d4506fd8c.png\" width=\"600px\" />\r\n</p>\r\n\r\n런타임 시 배열을 할당했다면 우리는 배열의 주소를 알고 있을 것이다. 배열의 맨 끝에 요소를 추가한다면 그냥 이어붙이면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111188-8fa39e80-e120-11eb-8576-aee6d30ae3a7.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간에 삽입한다면 이야기가 조금 달라진다. 삽입하려는 위치 이후의 요소를 한 칸씩 뒤로 미루고, 해당 위치에 값을 삽입하게 된다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치에 요소를 삽입한다면 모든 배열의 요소를 한 칸씩 뒤로 미룬뒤 55를 삽입해야한다. 즉, 배열에 $N$개의 요소가 있을 경우 삽입에 필요한 작업량은 $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $N + 1$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:27:47\r\n */\r\npublic class ArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tinsert(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 요소에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 요소에 55 삽입: [6, 43, 55, 14, 9, 94, -1, -1, -1, -1]\r\n```\r\n\r\n삽입 소스는 위와 같다.\r\n\r\n> **@SuppressWarnings는 뭔가요?**  \r\n> Eclipse, IntelliJ와 같은 IDE는 코드를 분석하는 과정에서 오류 또는 경고를 개발자에게 알려줌으로써 잠재적 위험을 제거할 수 있도록 유도한다. 간혹 의도된 동작임에도, IDE의 최적화 설정과 맞지 않아 경고를 띄우기도 한다. 이 경우 @SuppressWarnings 애노테이션을 쓰면 해당 경고를 무시할 수 있다. @@SuppressWarnings를 지워도 소스 동작엔 아무런 문제가 없다.\r\n\r\n위에서도 언급했지만, JAVA의 배열은 고정길이를 가진다. 삽입 연산을 하기 위해선 필연적으로 현재 배열의 크기보다 하나 이상 커야하므로, 이전과 달이 총 길이가 10인 배열을 선언했다. 배열의 요소가 -1일 경우, 해당 요소는 아직 할당되지 않은 빈 요소로 간주한다.\r\n\r\n> **가변 길이를 가지는 List**  \r\n> JAVA에서도 얼마든지 가변길이 배열이 필요한 경우가 생긴다. 이 경우 `ArrayList`와 같은 `List` 데이터를 활용하면 된다. `List`는 가변길이를 가짐으로써 비정형화된 배열 데이터를 다루는데 유리하다.\r\n\r\n배열의 가장 끝 요소부터 삽입하려는 인덱스 이전까지 순차적으로 내려오며 현재 요소의 값을 이전 요소의 값으로 할당하여 요소를 이동시킨다. 이후 삽입하려는 인덱스에 요소를 할당함으로써 삽입이 완료된다.\r\n\r\n## 1-5. 삭제\r\n\r\n삽입을 했으니, 반대로 <span class=\"primary\">삭제</span>도 필요할 수 있다. 삭제 연산은 원하는 인덱스의 요소를 삭제하는 것이다. 간단히 말하자면, 삽입과 정 반대의 프로세스를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111198-93372580-e120-11eb-9949-aa21aef11dfa.png\" width=\"600px\" />\r\n</p>\r\n\r\n마찬가지로, 배열의 맨 끝에 요소를 삭제한다면 그냥 끝의 요소를 삭제하면 그만이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111204-9500e900-e120-11eb-8c44-c45faeb459fd.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간을 삭제한다면 동일한 작업이 필요하다. 삭제하려는 위치의 요소를 삭제하고, 요소를 한 칸씩 당겨야 한다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치의 요소를 삭제한다면 해당 요소를 삭제한 뒤 모든 배열의 요소를 한 칸씩 앞으로 당길 것이다. 즉, 배열에 $N$개의 요소가 있을 경우 삭제에 필요한 작업량은 해당 인덱스의 요소를 삭제하는 작업 1개, $N - 1$개의 요소를 하나씩 이동하는 작업 $N - 1$개로 최대 $N$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삭제 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:59:02\r\n */\r\npublic class ArrayDelete\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삭제할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\tremove(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번째 요소 삭제 \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삭제 함수\r\n\t *\r\n\t * @param index: [int] 삭제 위치\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void remove(int index)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = index; i < ARRAY.length - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i + 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tARRAY[ARRAY.length - 1] = -1;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번째 요소 삭제 [6, 43, 9, 94, -1, -1, -1, -1, -1, -1]\r\n```\r\n\r\n삭제 소스는 위와 같다.\r\n\r\n삭제는 삽입과 달리 배열의 크기가 증가할 필요가 없다. 마찬가지로 배열의 요소가 -1일 경우, 해당 요소는 삭제된 빈 요소로 간주한다.\r\n\r\n삽입과는 반대로, 삭제하려는 인덱스부터 배열의 끝까지 순차적으로 올라가며 현재 요소의 값을 이후 요소의 값으로 할당하여 요소를 이동시킨다. 이후 배열의 끝 요소를 제거함으로써 삭제가 완료된다.\r\n\r\n## 1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다\r\n\r\n배열의 경우 요소의 타입만 맞다면 별다른 신경을 쓰지 않는다. 이말인즉슨, 중복되는 요소에 대한 처리도 이루어지지 않는다. 하지만 종종 중복되는 값을 허용하지 않는 배열의 필요성이 생기기도 한다. 책에서는 이를 <span class=\"primary\">집합</span>이라는 개념으로 설명한다.\r\n\r\n배열에 요소를 삽입할 때, 중복여부를 확인하기 위해선 검색 작업이 선행되어야 한다. 검색을 통해 집합에 해당 요소가 없는 것이 확인될 경우에만 삽입이 이루어지는 방식이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111212-97634300-e120-11eb-8d2e-c024761e23ff.png\" width=\"600px\" />\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111220-992d0680-e120-11eb-97a2-3e1e8eda7518.png\" width=\"600px\" />\r\n</p>\r\n\r\n위의 두 그림은 집합 개념이 적용된 배열에서 존재하지 않는 값 55와, 존재하는 값 14를 삽입했을 때 나타나는 결과를 도식화한 것이다.\r\n\r\n55의 경우 기존에 존재하지 않았으므로 삽입이 가능하지만, 14의 경우 이미 2번 째 인덱스에 동일한 값이 있으므로 삽입이 불가능하다.\r\n\r\n검증이 완료된 이후의 삽입 과정은 기존의 삽입 과정과 동일하다. 단, 작업량은 달라진다. 기존의 삽입 작업량에서 검색의 작업량이 추가되기 때문이다.\r\n\r\n가장 최악의 케이스는 중복되지 않는 임의의 값을 배열의 0번 째 인덱스에 삽입하는 것이다. $N$개의 요소를 가진 배열에서 $N$개 요소를 검색하는 작업량 $N$개, $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $2N + 1$개의 작업량이 발생한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 집합 배열 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 01:30:56\r\n */\r\npublic class UniqueArray\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tboolean result = hasInserted(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입 결과: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [boolean] 삽입 결과\r\n\t */\r\n\tprivate static boolean hasInserted(int index, int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\t// 중복되지 않을 경우\r\n\t\tif (result == -1)\r\n\t\t{\r\n\t\t\tinsert(index, item);\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 중복될 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 인덱스에 55 삽입 결과: true\r\n```\r\n\r\n집합 배열의 삽입 소스는 위와 같다.\r\n\r\n`find`와 `insert` 함수는 검색과 삽입 파트에서 사용한 로직과 동일한 로직이다. 집합 배열은 반드시 고유한 요소만을 삽입해야 하므로, `hasInserted` 함수를 구성하여 중복 여부를 검증한 뒤 삽입을 진행한다.\r\n\r\n`find` 함수는 검색되는 요소가 없을 경우 -1을 반환한다. 즉, -1을 반환하는 숫자는 고유한 숫자다. `find`가 -1을 반환할 경우 `insert` 함수로 삽입을 진행한다.\r\n\r\n> **Set 객체는 중복을 허용하지 않아요**  \r\n> JAVA의 배열은 기본적으로 요소의 중복같은건 신경쓰지 않는다. 때문에, 요소의 중복을 감지하기 위해선 별도의 검증 로직을 구성해야한다.  \r\n> 하지만 `HashSet`과 같은 `Set` 객체를 활용하면 항상 고유한 값만 삽입할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 최대한 개념 위주로 설명하며, 설명에 어떠한 알고리즘 지식이 들어가지 않은 것으로 보인다. 이러한 저자의 의도를 최대한 반영하여, 내 로직 역시 가능한 기본 데이터 타입을 사용했으며, 복잡한 로직을 최대한 지양했다. 철저히 연산이 동작하는 기본 원리에 입각하도록 소스를 구성했다.\r\n\r\n다음 장에서는 알고리즘에 대한 본격적인 내용이 기술될 것이다.","url":["2021-07-10-about-algorithm-chapter01","2021","07","10","about-algorithm-chapter01"]}],"categories":{"All":{"count":70,"flag":true},"Ubuntu":{"count":2,"flag":true},"RaspberryPi":{"count":7,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"배열","page":1,"hash":"876c218d90a"},"__N_SSG":true}