{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"Tomcat(톰캣) 현재 콘솔창에서 구동하기","excerpt":"오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-26T16:32:16","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-26-tomcat-current-window.md","content":"\r\n# 왜 자꾸 꺼지는거야!\r\n\r\n오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?\r\n\r\n# 왜?\r\n\r\n톰캣이 콘솔 형태로 실행되는 것은 맞지만, 실행되는 프로세스를 보면 살짝 다르다. `startup.bat`을 실행하면 cmd창이 뜬 뒤 꺼지면서 곧바로 Tomcat 창이 표시된다. <span class=\"primary\">톰캣을 구동하면 항상 새로운 창이 뜨기 때문에, 톰캣이 오류로 인해 동작이 중지되면 창이 곧바로 닫히게 된다.</span>\r\n\r\n# 해결책?\r\n\r\n그렇다고 해결책이 없는 건 아니고, `startup.bat`의 간단한 수정을 통해 톰캣이 <span class=\"primary\">현재 창에서 동작</span>하도록 수정할 수 있다. \r\n\r\n`startup.bat`을 메모장으로 열면, 맨 아래에 `call \"%EXECUTABLE%\" run %CMD_LINE_ARGS%` 구문이 존재한다. 여기서 가운데 `run`을 `start`로 변경한다.\r\n\r\n즉 `call \"%EXECUTABLE%\" start %CMD_LINE_ARGS%`로 구문을 변경하고 저장하면 된다.\r\n\r\n이후 `startup.bat`을 클릭하여 실행하지 말고, `cmd`창 하나를 킨 다음에, 해당 콘솔에서 `startup.bat`을 호출하면 새 창이 뜨지 않고 호출한 콘솔에서 톰캣이 구동된다.  \r\n톰캣이 종료돼도 콘솔창이 꺼지지 않으므로, 편하게 메시지를 확인할 수 있다.","url":["2021-05-26-tomcat-current-window","2021","05","26","tomcat-current-window"]},"next":{"header":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true},"name":"2021-05-30-unsupported-version-error.md","content":"\r\n# Unsupported major.minor version\r\n\r\n간혹 JAVA 프로그램을 실행하다보면 <span class=\"error\">Unsupported major.minor version 52</span>(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다.  \r\n<span class=\"error\">Unsupported major.minor version</span> 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.\r\n\r\n# 원인\r\n\r\nJAVA는 컴파일 언어로, 개발자가 작성한 코드는 `.java` 파일이다. 이를 컴파일하면 JVM(Java Virtual Machine, 자바 가상머신)이 읽을 수 있는 `.class` 파일로 번역한다. 코딩은 사람이 이해할 수 있는 언어로 작성하고, 실제 동작은 컴파일을 통해 컴퓨터가 이해할 수 있는 언어를 사용하는 셈이다.  \r\nJAVA는 작성일 기준으로 16까지 릴리즈됐다. JAVA의 역사가 짧지 않고, 이 시간동안 크고작은 버전 업데이트가 지속적으로 이루어졌다.  \r\n문제는 이 과정에서 생긴 호환성 문제다. 1.5 버전으로 컴파일한 `.class` 파일을 1.8 버전의 환경에서 구동한다거나, 그 반대의 경우가 그 예시다. 다행스럽게도, JAVA는 하위 버전에 대한 호환성을 보장한다. 1.8 버전의 환경에서는 1.8 이하로 컴파일된 `.class` 파일의 실행을 보장한다. 하지만 반대로 상위 버전에 대한 호환성은 제공하지 않는다. 그도 그럴 것이, 호환성을 지키기 위해선, 각 버전 간의 구성을 알맞게 변환해야 하는데, 아직 개발되지 않은 미래 버전의 구성을 알 순 없는 노릇이니...\r\n\r\n| 프로그램 JAVA 버전 | PC JAVA 버전 | Unsupported 오류 발생여부 |              해결책              |\r\n| :----------------: | :----------: | :-----------------------: | :------------------------------: |\r\n|         14         |     1.8      |             O             | JAVA 14 버전 이상으로 업그레이드 |\r\n|        1.6         |     1.7      |             X             |              칼퇴근              |\r\n\r\n즉, <span class=\"green-A400\">Unsupported major.minor version 오류는 내가 실행하려는 JAVA 코드가 내 PC의 JAVA 환경보다 높은 버전에서 컴파일된 경우 발생</span>한다.\r\n\r\n# 해결\r\n\r\n결과적으로, JAVA 버전을 동등 혹은 그 이상의 상위버전으로 업그레이드하면 된다. 크게 두 가지 방법이 있다.\r\n\r\n## 프로그램 코드의 버전 다운그레이드\r\n\r\n만약 본인이 온전한 프로그램 코드를 갖고 있을 경우, 시도해볼 수 있는 방법이다.  \r\n<span class=\"green-A400\">JAVA 버전을 다운그레이드하고 컴파일을 진행</span>하면, 프로그램의 JAVA 버전이 낮아져 기존의 버전보다 훨씬 낮은 버전의 환경에서 구동이 가능하다.\r\n\r\n단, 조건이 있다. JAVA 버전이 업그레이드됨에 따라 여러 신규 패턴, 문법 등이 추가됐다. 만약 <span class=\"red-A400\">1.8 버전부터 새로 생긴 기능을 적극적으로 활용했다면, 1.7 이하의 버전에선 컴파일 오류가 발생</span>한다.  \r\n그도 그럴것이, 1.8 부터 생긴 기능은 1.7에서는 구현되지 않은 기능이기 때문.\r\n\r\n이 경우 프로그램의 코드를 좀더 범용적인 방식으로 리팩토링해야한다.\r\n\r\n## PC의 버전 업그레이드\r\n\r\n만약 본인이 `.class` 파일만 갖고있다거나, 상기한 문제로 다운그레이드가 어려울 경우 혹은 간단한 방법을 찾을 경우 시도해볼 수 있는 방법이다.\r\n<span class=\"green-A400\">PC의 JAVA 버전을 업그레이드하고 프로그램을 실행</span>하면 된다.\r\n\r\nJAVA는 하위 호환성을 지키기 때문에, 별다른 조건이 존재하지 않는다.\r\n\r\n# 아니 버전 맞췄다고 아ㅋㅋ\r\n\r\n톰캣을 사용하다보면, 이 오류가 뜨는 경우가 있다. 그런데 간혹 PC에 설치된 JAVA 버전에 맞게 컴파일을 해줬음에도 오류가 사라지지 않는 현상이 발생하기도 한다.  \r\n이 경우 동반되는 증상이, Servlet Context에 접근할 경우, 첫 접속시 500 에러(Unsupported major.minor version 오류로 인해 발생)가 발생하고, 이후부터는 404 에러만 발생한다. 이러한 현상을 겪어보지 않았거나, 경험이 적은 개발자가 이러한 문제에 부딪히면 십중팔구 고생한다. 원인인 Unsupported major.minor version 오류가 보이지 않아 Servlet 동작의 404 오류와 관련된 정보를 검색하거나 질문하기 때문. 당연히 이러한 사정을 모르는 다른 사람들은 404 오류에 관한 답변을 줄 수 밖에 없다. 이런 경우 정말 난감하기 그지없다. 절대 경험담이라서가 아니다.\r\n\r\n혹시 위 처럼 정상적인 Servlet(서블릿)임에도 불구하고 404 오류가 뜰 경우 아래의 환경변수에서 JRE_HOME이 설정돼있는지 확인해보자.  \r\n간혹 개발 프로그램 중 임의로 JRE_HOME을 설정해버리는 프로그램이 존재한다. 문제는 여기서 발생하는데, JAVA_HOME과 JRE_HOME 환경변수가 둘 다 설정되어있을 경우, <span class=\"red-A400\">톰캣은 JRE_HOME을 우선</span>한다. 즉 JRE의 버전이 적용된다.\r\n\r\n예를 들어, JAVA_HOME이 1.8 버전, JRE_HOME이 1.6 버전이라 가정하자. 컴파일은 반드시 JDK가 필요하므로 JAVA_HOME의 버전인 1.8로 컴파일이 수행된다. 그러나 톰캣 실행 시, JRE_HOME을 우선하는 특징으로 인해 1.6 버전으로 실행된다. 결과적으로 **1.8 버전으로 컴파일된 코드를 1.6으로 실행하는 셈**이니, 버전이 맞지 않아 오류가 발생한다.","url":["2021-05-30-unsupported-version-error","2021","05","30","unsupported-version-error"]}},"group":[],"data":{"header":{"title":"URI? URL? URN? 리소스 식별자 구분하기","excerpt":"우리가 인터넷 상에서 특정한 데이터에 접근할 때 URL이라는 것을 활용하여 접근한다. 원하는 자료의 URL을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 URL을 호출하여 응답을 얻는 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028437-a63ddc80-c02f-11eb-9d41-7c50d7002a42.png","date":"2021-05-29T03:30:17","type":"posts","category":"WEB","tag":["WEB(웹)","URI","URL","URN"],"comment":true,"publish":true},"name":"2021-05-29-uri-url-urn.md","content":"<h1 id=\"URL!-URI... URN??\">URL! URI... URN?? <a href=\"#URL!-URI... URN??\">🔗</a></h1><p>우리가 인터넷 상에서 <strong>특정한 데이터</strong>에 접근할 때 <span class=\"primary\">URL</span>이라는 것을 활용하여 접근한다.<br>원하는 자료의 <span class=\"primary\">URL</span>을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 <span class=\"primary\">URL</span>을 호출하여 응답을 얻는 것이다.</p>\n<p>개발자나, 굳이 개발자가 아니더라도 관련 정보를 찾다보면 심심치않게 <span class=\"primary\">URI</span>라는 용어를 접하게 된다.<br>I와 L의 오묘한 유사성 때문에 아예 <span class=\"primary\">URI</span>를 <span class=\"primary\">URL</span>로 오독하는가 하면, 오타라고 생각하는 사람도 더러 있을 것이다.<br>하지만 <span class=\"primary\">URL</span>과 <span class=\"primary\">URI</span>는 그 의미가 비슷하면서도 살짝 다르다.</p>\n<p>누구나 알고있는 <span class=\"primary\">URL</span>과 아리까리한 <span class=\"primary\">URI</span>, 생소한 <span class=\"primary\">URN</span>. 이들에 대해 알아보자</p>\n<h1 id=\"UR*-톱아보기\">UR* 톱아보기 <a href=\"#UR*-톱아보기\">🔗</a></h1><p><span class=\"primary\">URI</span>, <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>은 구조상 서로 연관이 있다.</p>\n<h2 id=\"URI(Uniform-Resource Identifier, 통합 자원 식별자)\">URI(Uniform Resource Identifier, 통합 자원 식별자) <a href=\"#URI(Uniform-Resource Identifier, 통합 자원 식별자)\">🔗</a></h2><p><span class=\"primary\">URI</span>는 우리말로 <strong>통합 자원 식별자</strong>라고 한다. <span class=\"primary\">URI</span>는 앞서 말한 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>을 포함하는 상위 개념으로, <span class=\"orange-400\">인터넷 상에 존재하는 <strong>자원을 구분</strong>하는 식별자</span>라 할 수 있다. 웹 상에서 자원을 식별하는 모든 수단이 곧 <span class=\"primary\">URI</span>이라 할 수 있다.</p>\n<h2 id=\"URL(Uniform-Resource Locater, 통합 자원 지시자)\">URL(Uniform Resource Locater, 통합 자원 지시자) <a href=\"#URL(Uniform-Resource Locater, 통합 자원 지시자)\">🔗</a></h2><p><span class=\"primary\">URL</span>은 굳이 우리말로 하자면 <strong>통합 자원 지시자</strong>라고 할 수 있겠지만, 흔히 인터넷 상에서 <strong>주소</strong>라 함은 99% 이 <span class=\"primary\">URL</span>을 의미한다. 1994년 <strong>RFC-1738</strong>에 정의되어있다.<br><span class=\"primary\">URL</span>은 <strong>Locater</strong>라는 키워드에 걸맞게 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 <strong>위치</strong>를 나타내는 식별자</span>라 할 수 있다. 여기서 <strong>위치</strong>라는 키워드에 주목하자. <span class=\"primary\">URL</span>은 자원의 위치정보를 가지므로, 어떠한 이유로든 자원의 위치가 변경되면 <span class=\"primary\">URL</span>은 자원을 찾을 수 없으며, 변경된 위치를 추적할 수도 없다. 이 때 맞이하게 되는 HTTP 오류가 누구나 알고있는 404 Not Found다.<br>당장 내가 이 게시물의 이름을 한 글자만 변경해도, 지금까지의 <span class=\"primary\">URL</span>은 아무 쓸모가 없어지며, 사용자들 또한 해당 <span class=\"primary\">URL</span>로 이 게시물에 접근할 수 없다. 또한, 이 <span class=\"primary\">URL</span>을 통해 원래 있던 게시물의 <span class=\"primary\">URL</span>을 논리적으로 유추할 수도 없다.</p>\n<h2 id=\"URN(Uniform-Resource Name, 통합 자원 이름)\">URN(Uniform Resource Name, 통합 자원 이름) <a href=\"#URN(Uniform-Resource Name, 통합 자원 이름)\">🔗</a></h2><p><span class=\"primary\">URN</span>은 <strong>통합 자원 이름</strong>이다. 눈치가 빠른 분들은 아시겠지만, <span class=\"primary\">URN</span>은 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 <strong>이름</strong>을 나타내는 식별자</span>다. 자원의 이름은 고유한 값을 가지므로, 인터넷 상의 수 많은 자원들 중 특정 자원을 식별할 수 있는 것이다.<br><span class=\"primary\">URN</span>은 대부분 위에 언급한 두 개념에 비해 생소할 것이다. 그도 그럴 것이, <span class=\"primary\">URN</span>은 위 두 개념보다 훨씬 뒤에 나온 개념이기 때문이다. 1997년 <strong>RFC-2141</strong>에 정의되어있다. <span class=\"primary\">URL</span>보다 3년 뒤에 출범하여 그 역사가 상대적으로 짧다.  </p>\n<p><span class=\"primary\">URL</span>의 치명적인 단점은 <strong>위치</strong>정보 외에 다른 정보를 저장하지 않는다. 이 상황에서 해당 자원을 찾아야 한다면? 안타깝게도 <span class=\"primary\">URL</span>만으로는 찾아낼 수 없다. 구글링해서 운 좋게 찾아낸다면 모를까.<br>반면 <span class=\"primary\">URN</span>을 사용한다면 어떨까? 위치가 아무리 변경된다 하더라도, 자원의 고유한 이름을 통해 찾기 때문에 자원이 웹 상에서 완전히 삭제된 게 아니라면 손쉽게 찾아낼 수 있을 것이다.</p>\n<h2 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h2><p>난 어려운 개념을 이해할 때 현실세계와 연관지어 이해하는 걸 좋아한다. 위 세 개념을 현실에서 특정 사람의 신원을 확인하는 과정과 접목해서 정리하면 아래와 같이 정리할 수 있을 것 같다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">구분</th>\n<th align=\"center\">현실</th>\n<th align=\"center\">값</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">자원</td>\n<td align=\"center\">나 자신</td>\n<td align=\"center\">나</td>\n</tr>\n<tr>\n<td align=\"center\">URI</td>\n<td align=\"center\">나를 식별할 수 있는 모든 식별자</td>\n<td align=\"center\">-</td>\n</tr>\n<tr>\n<td align=\"center\">URL</td>\n<td align=\"center\">내가 사는 주소</td>\n<td align=\"center\">서울특별시 A구 가동</td>\n</tr>\n<tr>\n<td align=\"center\">URN</td>\n<td align=\"center\">내 주민등록번호</td>\n<td align=\"center\">000000-0000000</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p><span class=\"small red-A400\">※ URN은 모든 자원의 고유값이므로, 사람과 연관지었을 때, 중복 가능성이 있는 이름 보다는 고유값인 주민등록번호가 더 적합하다.</span></p>\n<p>예를 들어, 내 정보가 위와 같다고 가정해보자. 내가 사는 주소 및 내 주민등록번호 모두 내 신원을 확인할 수 있는 방식(<span class=\"primary\">URI</span>)이므로, 나를 찾기에 적합하다.<br>만약 내 주소(<span class=\"primary\">URL</span>)를 통해 확인할 경우, 내가 이사(자원의 이동)를 가게 되면 해당 주소엔 아무것도 없으며, 날 찾을 수도 없다(404 HTTP 에러). 또한, 내가 예전에 살던 주소만으로 내가 이사간 주소를 유추해낼 수도 없을 것이다.</p>\n<p>반면, 내 주민등록번호(<span class=\"primary\">URN</span>)을 통해 확인할 경우, 내 주민등록번호와 매칭되는 사람을 찾는 것으로 나를 식별할 수 있다. 이 과정에서 내가 어디에 있는지는 전혀 중요치 않은 것이다. 주민등록번호 자체가 말소(자원 삭제)되지 않는 한, 내가 어디에서 무엇을 하고있든 내 신원을 확인할 수 있다.</p>\n<h1 id=\"구조\">구조 <a href=\"#구조\">🔗</a></h1><p>그렇다면 이들은 어떻게 생겼는지 알아보자. <span class=\"primary\">URI</span>는 자원의 식별자를 포괄하여 지칭하는 개념 그 자체이므로, 구조라고 할 건 없다. 하위 개념인 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>에 대해 알아보자.</p>\n<h2 id=\"URL-구조\">URL 구조 <a href=\"#URL-구조\">🔗</a></h2><p><span class=\"primary\">URL</span>은 아래와 같은 구조로 이루어진다. 매우 익숙할 것이다.</p>\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">https</span>://<span class=\"green-400\">rwb0104</span>.<span class=\"yellow-400\">github</span>.<span class=\"pink-400\">com</span>:<span class=\"amber-400\">443</span>/<span class=\"cyan-400\">posts</span><span class=\"teal-400\">?category=WEB&page=1</span></p>\n\n<p>구조별로 색상을 입혔으며, 순서대로 기술한다.</p>\n<h3 id=\"Protocol(프로토콜)\">Protocol(프로토콜) <a href=\"#Protocol(프로토콜)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"lightBlue-400\">https</span> 부분.</p>\n<p>통신규약을 의미한다. 작성일 기준으로, 이 규약엔 계층별로 많은 <span class=\"lightBlue-400\">프로토콜</span>이 존재하는데, 웹 통신을 수행할 땐 크게 두 가지로 나뉜다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">구분</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">HTTP</td>\n<td align=\"center\">W3 상에서의 HTML 문서 통신규약</td>\n</tr>\n<tr>\n<td align=\"center\">HTTPS</td>\n<td align=\"center\">암호화된 HTTP 통신 규약</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>현재는 포털, 쇼핑몰같은 대형 비즈니스 사이트나 블로그, 카페 등 중소규모의 개인 사이트까지 <span class=\"red-A400\">HTTPS의 사용이 반 강제적으로 권장</span>되어 있다. 특히 전자상거래가 접목된 비즈니스 사이트의 경우 필수로 적용해야 한다. 더군다나 <span class=\"red-A400\">HTTPS가 적용되지 않는 사이트(localhost 제외)에 접근할 경우 브라우저 측에서 보안 관련 경고 메시지</span>를 띄우니, 규모에 관계없이 웹 사이트를 운영할 경우 HTTPS는 필수로 적용하는 편이다.</p>\n<h3 id=\"SLD(Second-Level Domain, 서브도메인, 호스트)\">SLD(Second Level Domain, 서브도메인, 호스트) <a href=\"#SLD(Second-Level Domain, 서브도메인, 호스트)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"green-400\">rwb0104</span> 부분.</p>\n<p>도메인 앞에 붙으며, <span class=\"green-400\">서브도메인</span>을 통해 하나의 <span class=\"yellow-400\">도메인</span>으로 다중 서비스를 제공할 수 있다. 하나의 <span class=\"yellow-400\">도메인</span>에 여러 <span class=\"green-400\">서브도메인</span>을 생성할 수 있으며, 우리가 흔히 아는 <code class=\"inline-code\">www</code> 외에도 <code class=\"inline-code\">dev</code>, <code class=\"inline-code\">admin</code>, <code class=\"inline-code\">m</code> 용도에 따라 다양한 문자열을 지정할 수 있다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">URL</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\"><a href=\"https://naver.com\" target=\"_blank\">naver.com</a></td>\n<td align=\"center\">기본 네이버 홈페이지. 각 플랫폼(데스크탑, 모바일 등)에 가장 적합한 사이트로 리다이렉트</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://www.naver.com\" target=\"_blank\">www.naver.com</a></td>\n<td align=\"center\">데스크탑용 네이버 홈페이지</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://m.naver.com\" target=\"_blank\">m.naver.com</a></td>\n<td align=\"center\">모바일용 네이버 홈페이지</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://map.naver.com\" target=\"_blank\">map.naver.com</a></td>\n<td align=\"center\">네이버 지도</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>위는 네이버 서비스의 <span class=\"green-400\">서브도메인</span>으로, <code class=\"inline-code\">naver.com</code> <span class=\"yellow-400\">도메인</span>을 중심으로 각기 다른 서비스를 제공하는 것을 확인할 수 있다.</p>\n<h3 id=\"Domain(도메인)\">Domain(도메인) <a href=\"#Domain(도메인)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"yellow-400\">github</span> 부분.</p>\n<p>URL의 중심이 되는 부분으로, 제공하는 웹 서비스의 아이덴티티 역할을 겸한다. 때문에 <span class=\"yellow-400\">도메인</span>에는 대부분 해당 웹 서비스의 이름이 들어간다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">서비스</th>\n<th align=\"center\">URL</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">네이버</td>\n<td align=\"center\"><a href=\"https://naver.com\" target=\"_blank\">naver.com</a></td>\n</tr>\n<tr>\n<td align=\"center\">다음</td>\n<td align=\"center\"><a href=\"https://www.daum.com\" target=\"_blank\">www.daum.com</a></td>\n</tr>\n<tr>\n<td align=\"center\">GitHub</td>\n<td align=\"center\"><a href=\"https://github.com\" target=\"_blank\">github.com</a></td>\n</tr>\n<tr>\n<td align=\"center\">Instagram</td>\n<td align=\"center\"><a href=\"https://instagram.com\" target=\"_blank\">instagram.com</a></td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>대부분의 서비스가 <span class=\"yellow-400\">도메인</span>으로 서비스의 이름을 사용하고 있다.</p>\n<h3 id=\"TLD(Top-Level Domain, 최상위 도메인)\">TLD(Top Level Domain, 최상위 도메인) <a href=\"#TLD(Top-Level Domain, 최상위 도메인)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"pink-400\">com</span> 부분.</p>\n<p><span class=\"pink-400\">최상위 도메인</span>이란, 앞서 언급한 <span class=\"green-400\">서브도메인</span>, <span class=\"yellow-400\">도메인</span>을 관리하는 업체 혹은 기관이라고 볼 수 있다.<br>앞서 언급한 개념의 경우, 중복되지 않는 선에서 사용자가 임의로 지정할 수 있다. 하지만 <span class=\"pink-400\">최상위 도메인</span>의 경우 현재 운영 중인 업체나 기관 중 하나를 <strong>선택</strong>해서 등록해야 한다. <span class=\"pink-400\">최상위 도메인</span>을 선택할 경우, 당신의 도메인은 해당 <span class=\"pink-400\">최상위 도메인</span>을 운영하는 곳에서 관리하게 된다.  </p>\n<p><span class=\"pink-400\">최상위 도메인</span>은 운영 주체에 따라 두 가지로 나뉜다.</p>\n<h4 id=\"ccTLD(country-code TLD, 국가 코드 최상위 도메인)\">ccTLD(country code TLD, 국가 코드 최상위 도메인) <a href=\"#ccTLD(country-code TLD, 국가 코드 최상위 도메인)\">🔗</a></h4><p>국가를 나타내는 <span class=\"pink-400\">최상위 도메인</span>이다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">ccTLD</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">.kr</td>\n<td align=\"center\">한국(KISA)</td>\n</tr>\n<tr>\n<td align=\"center\">.us</td>\n<td align=\"center\">미국(LLC)</td>\n</tr>\n<tr>\n<td align=\"center\">.jp</td>\n<td align=\"center\">일본</td>\n</tr>\n<tr>\n<td align=\"center\">.io</td>\n<td align=\"center\">영국령 인도양</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p><span class=\"pink-400\">ccTLD</span>는 위 표와 같이 국가 코드 형태이며, 각 국가기관이 직접 관리한다. 즉, <code class=\"inline-code\">.kr</code>을 가진 모든 도메인은 <strong>한국의 KISA(한국 인터넷 진흥원)에서 관리</strong>한다.</p>\n<h4 id=\"gTLD(generic-TLD, 일반 최상위 도메인)\">gTLD(generic TLD, 일반 최상위 도메인) <a href=\"#gTLD(generic-TLD, 일반 최상위 도메인)\">🔗</a></h4><p>사이트 혹은 사이트를 소유한 조직, 기관의 특성에 따라 사용하는 <span class=\"pink-400\">최상위 도메인</span>이다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">gTLD</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">.com</td>\n<td align=\"center\">영리 단체 및 기관</td>\n</tr>\n<tr>\n<td align=\"center\">.net</td>\n<td align=\"center\">네트워크 관리기관</td>\n</tr>\n<tr>\n<td align=\"center\">.org</td>\n<td align=\"center\">비영리 기관</td>\n</tr>\n<tr>\n<td align=\"center\">.gov</td>\n<td align=\"center\">정부 기관</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p><span class=\"pink-400\">gTLD</span>는 위 표와 같이 다양한 종류가 있으며, 그 중 몇몇은 자주 접했을 것이다. 정부기관이 왜 여기있나 생각할 수도 있는데, <span class=\"pink-400\">ccTLD</span>는 <strong>국가 코드</strong>만 해당된다. 국가 예하의 정부기관, 군사조직 등은 구분 상 <span class=\"pink-400\">gTLD</span>로 분류된다.<br>마찬가지로, 각 <span class=\"pink-400\">최상위 도메인</span>은 <strong>해당 <span class=\"pink-400\">최상위 도메인</span>을 소유한 기관 혹은 기업에서 관리</strong>한다.</p>\n<blockquote>\n<p>현재 운영 중인 <span class=\"pink-400\">최상위 도메인</span>은 <a href=\"https://www.iana.org/domains/root/db\" target=\"_blank\">IANA</a>에서 확인할 수 있다.</p>\n</blockquote>\n<p>여담으로, <span class=\"pink-400\">최상위 도메인</span>에 중복된 <span class=\"yellow-400\">도메인</span>을 등록할 수 없다. 예를 들어, 내가 <code class=\"inline-code\">aaa.com</code> URL을 등록한다고 가정해보자.<br>우선 제일 먼저 <code class=\"inline-code\">.com</code>을 관리하는 업체에 <code class=\"inline-code\">aaa</code>라는 <span class=\"yellow-400\">도메인</span>을 등록해야 한다. 하지만, 이미 누군가가 <code class=\"inline-code\">aaa.com</code>을 등록했다면 해당 소유주가 <span class=\"yellow-400\">도메인</span>의 소유권을 포기하기 전까진 <code class=\"inline-code\">aaa.com</code> <span class=\"yellow-400\">도메인</span>을 소유할 수 없다.<br>물론 <code class=\"inline-code\">.com</code>이 아닌 <code class=\"inline-code\">.kr</code>이나 <code class=\"inline-code\">.net</code>에는 등록할 수 있다. 하지만 <code class=\"inline-code\">socket.io</code> 처럼 <span class=\"yellow-400\">도메인</span>과 <span class=\"pink-400\">최상위 도메인</span>까지 의미론적으로 구성했다면, 이러한 상황이 달갑지 않을 것이다. 때문에 일전에 이슈됐던 <span class=\"primary\">덮죽 상표권 선점</span>과 비슷한 일이 일어나기도 한다.</p>\n<h2 id=\"Port(포트)\">Port(포트) <a href=\"#Port(포트)\">🔗</a></h2><p><span class=\"primary\">URL</span>상의 <span class=\"amber-400\">443</span> 부분. 앞에 반드시 <code class=\"inline-code\">:</code>이 붙는다.</p>\n<p>인터넷에 연결된 모든 디바이스는 사용하는 네트워크의 IP를 할당받는다. 할당받은 IP 내에서 해당 디바이스가 수행 중인 모든 프로세스의 통신이 이루어진다. <span class=\"amber-400\">포트</span>는 프로세스의 데이터가 IO되는 통로다. 작업 시, 각 프로세스 별로 고유한 <span class=\"amber-400\">포트</span>를 할당받으며, 하나의 <span class=\"amber-400\">포트</span>는 반드시 하나의 프로세스와 1:1 매칭된다. 반면, 하나의 프로세스는 여러 <span class=\"amber-400\">포트</span>를 할당받을 수 있다.<br><strong>특정 프로세스와 통신하기 위해선 반드시 해당 프로세스가 할당받은 <span class=\"amber-400\">포트</span>에 데이터를 전송</strong>해야 한다. 때문에 <span class=\"amber-400\">포트</span> 통신은 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 크게 중요하지 않으며, 어떤 <span class=\"amber-400\">포트</span>로 보내는지가 중요하다.</p>\n<p>웹 통신에서의 기본<span class=\"amber-400\">포트</span>는 아래와 같다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">포트</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">80</td>\n<td align=\"center\">HTTP 기본 포트</td>\n</tr>\n<tr>\n<td align=\"center\">443</td>\n<td align=\"center\">HTTPS 기본 포트</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>아마 이러한 숫자를 처음 볼 수도 있는데, 대부분의 웹 사이트 <span class=\"primary\">URL</span>에는 <span class=\"amber-400\">포트</span>를 확인할 수 없다. 사이트가 <strong>각 프로토콜의 기본 <span class=\"amber-400\">포트</span>로 서비스될 경우, <span class=\"primary\">URL</span>에서 <span class=\"amber-400\">포트</span>를 생략</strong>할 수 있다. 즉, <code class=\"inline-code\">https://naver.com</code>의 <span class=\"amber-400\">포트</span>번호는 <code class=\"inline-code\">443</code>이지만, <code class=\"inline-code\">443</code>은 HTTPS의 기본 <span class=\"amber-400\">포트</span>이므로 생략된다. 만약, <code class=\"inline-code\">443</code>이 아닌 <code class=\"inline-code\">8080</code>, <code class=\"inline-code\">9200</code>과 같은 <strong>임의의 <span class=\"amber-400\">포트</span>로 서비스를 제공할 경우, <span class=\"amber-400\">포트</span>를 반드시 명시해야하므로 생략이 불가능</strong>하다. 이 경우 <span class=\"primary\">URL</span>은 <code class=\"inline-code\">https://naver.com:8080</code>이 될 것이다.<br>위와 같은 이유로, 대부분의 웹 사이트는 서비스하는 프로토콜에 맞는 기본 <span class=\"amber-400\">포트</span>를 사용한다.</p>\n<p><span class=\"amber-400\">포트</span>는 <strong>0 ~ 65535</strong>의 범위를 가지며, 크게 세 가지로 구분할 수 있다.</p>\n<h3 id=\"잘-알려진 포트(well-known Port)\">잘 알려진 포트(well-known Port) <a href=\"#잘-알려진 포트(well-known Port)\">🔗</a></h3><p><strong>0 ~ 1023</strong>의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터에서 기본적으로 사용되는 주요 프로세스에 기본적으로 할당되는 포트로, ICANN(Internet Corporation for Assigned Names and Numbers, 국제 인터넷주소 관리기구)에 의해 통제된다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">포트</th>\n<th align=\"center\">기능</th>\n<th align=\"center\">용도</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">20, 21</td>\n<td align=\"center\">FTP</td>\n<td align=\"center\">파일 송수신</td>\n</tr>\n<tr>\n<td align=\"center\">22</td>\n<td align=\"center\">SFTP</td>\n<td align=\"center\">파일 암호화 송수신</td>\n</tr>\n<tr>\n<td align=\"center\">23</td>\n<td align=\"center\">Telnet</td>\n<td align=\"center\">터미널 통신</td>\n</tr>\n<tr>\n<td align=\"center\">25</td>\n<td align=\"center\">SMTP</td>\n<td align=\"center\">메일 전송</td>\n</tr>\n<tr>\n<td align=\"center\">53</td>\n<td align=\"center\">DNS</td>\n<td align=\"center\">DNS 통신</td>\n</tr>\n<tr>\n<td align=\"center\">67</td>\n<td align=\"center\">DHCP</td>\n<td align=\"center\">DHCP 통신</td>\n</tr>\n<tr>\n<td align=\"center\">80</td>\n<td align=\"center\">HTTP</td>\n<td align=\"center\">HTML 통신</td>\n</tr>\n<tr>\n<td align=\"center\">443</td>\n<td align=\"center\">HTTPS</td>\n<td align=\"center\">HTML 암호화 통신</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>어디까지나 초기에 지정되는 <span class=\"amber-400\">포트</span>이므로, 추후 <strong>사용자의 의도에 따라 비어있는 다른 포트로 변경</strong>할 수도 있다. 즉, 초기값일뿐, 강제는 아니다.</p>\n<h3 id=\"등록된-포트(registered Port)\">등록된 포트(registered Port) <a href=\"#등록된-포트(registered Port)\">🔗</a></h3><p><strong>1024 ~ 49151</strong>의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터의 기본 프로세스는 아니지만, 주요 프로그램들이 기본으로 사용하고자 ICANN에 등록한 <span class=\"amber-400\">포트</span>다. <span class=\"amber-400\">잘 알려진 포트</span>와 마찬가지로 프로그램의 설정을 통해 <strong>사용자의 의도에 따라 비어있는 다른 포트로 변경</strong>할 수 있다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">포트</th>\n<th align=\"center\">기능</th>\n<th align=\"center\">용도</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">1433</td>\n<td align=\"center\">MSSQL</td>\n<td align=\"center\">MSSQL DB 통신</td>\n</tr>\n<tr>\n<td align=\"center\">3306</td>\n<td align=\"center\">MySQL</td>\n<td align=\"center\">MySQL DB 통신</td>\n</tr>\n<tr>\n<td align=\"center\">3389</td>\n<td align=\"center\">RDP</td>\n<td align=\"center\">원격 데스크톱 접근 (Windows)</td>\n</tr>\n<tr>\n<td align=\"center\">5432</td>\n<td align=\"center\">PostgreSQL</td>\n<td align=\"center\">PostgreSQL DB 통신</td>\n</tr>\n<tr>\n<td align=\"center\">8080</td>\n<td align=\"center\">HTTP 통신(Tomcat 등)</td>\n<td align=\"center\">HTTP 통신 (80포트 대용)</td>\n</tr>\n<tr>\n<td align=\"center\">27017</td>\n<td align=\"center\">MongoDB</td>\n<td align=\"center\">MongoDB 통신</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>주로 <span class=\"primary\">DB</span>같은 개발 관련 프로그램들이 많이 등록돼있다.</p>\n<h4 id=\"왜?-하필 개발 관련 프로그램들만?\">왜? 하필 개발 관련 프로그램들만? <a href=\"#왜?-하필 개발 관련 프로그램들만?\">🔗</a></h4><p>개발 관련 프로그램들은 그 특성 상 통신의 방식이 <strong>항상 일정</strong>해야 한다. 만약 DB의 <span class=\"amber-400\">포트</span>가 기동할 때마다 수시로 변경된다면 어떨까? 이유를 막론하고 DB가 재기동될 경우, 개발자는 DB가 사용 중인 임의의 <span class=\"amber-400\">포트</span>를 추적하여 프로그램의 DB 통신 코드를 변경해야하는 매우 불합리한 상황이 발생하게 된다.  </p>\n<p>이에 비해 게임이나 IDE 같은 일반적인 프로그램들은 굳이 통신의 방식이 일정할 필요는 없다. 어찌됐든 <strong>서버에 정보를 요청하는 순간, 서버는 자연스레 내 통신 정보를 알게되기 때문</strong>이다. 서버는 요청했던 경로로 다시 데이터를 반환해주면 된다. 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 별로 중요하지 않는 이유가 여기에 있다.</p>\n<h3 id=\"동적-포트(dynamic Port)\">동적 포트(dynamic Port) <a href=\"#동적-포트(dynamic Port)\">🔗</a></h3><p><strong>49152 ~ 65535</strong>의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 대다수의 프로그램들은 <span class=\"amber-400\">포트</span> 기본값이 지정되지 않는 경우가 대부분이다. 이러한 프로그램들은 <span class=\"amber-400\">동적 포트</span> 중 사용 가능한 임의의 빈 <span class=\"amber-400\">포트</span>를 자동으로 점유한다. 때문에 ICANN이 관리하지도 않으며, 특정 프로그램이 고유한 <span class=\"amber-400\">포트</span>로 등록되어있지도 않다. 자유석을 생각하면 편하다.</p>\n<h3 id=\"Path(경로)\">Path(경로) <a href=\"#Path(경로)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"cyan-400\">posts</span> 부분. 웹 사이트의 하위 경로를 의미한다. <span class=\"cyan-400\">경로</span>는 <code class=\"inline-code\">/</code>로 구분하며, 경로 입력을 통해 서버 내의 원하는 자원에 접근할 수 있다.</p>\n<ul>\n<li><a href=\"https://blog.itcode.dev\" target=\"_blank\">https://blog.itcode.dev</a><ul>\n<li>posts<ul>\n<li>index.html</li>\n<li>a1000<ul>\n<li>index.html</li>\n</ul>\n</li>\n<li>a1001<ul>\n<li>index.html</li>\n</ul>\n</li>\n<li>uri-url-urn<ul>\n<li>index.html</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>project<ul>\n<li>index.html</li>\n</ul>\n</li>\n<li>index.html</li>\n</ul>\n</li>\n</ul>\n<p>위 트리는 이 블로그의 단편적인 디렉토리 예시다. 이 중 해당 게시물에 접근하려면 <span class=\"cyan-400\">경로</span>는 <code class=\"inline-code\">/posts/uri-url-urn/index.html</code>와 같이 구성할 수 있다. <span class=\"primary\">index.html은 생략이 가능</span>하므로 <code class=\"inline-code\">/posts/uri-url-urn</code>로 접근해도 무방하다.</p>\n<blockquote>\n<p><strong>아시나요?</strong><br><strong>index.html</strong> 경로의 기본 HTML을 의미함. 더이상의 하위 경로를 표시하지 않을 경우, 해당 경로의 index.html를 응답한다.</p>\n</blockquote>\n<p><span class=\"cyan-400\">경로</span>는 서버의 구조에 따라 결정되므로, 사이트마다 천차만별이다.</p>\n<h3 id=\"Query-String(쿼리 문자열)\">Query String(쿼리 문자열) <a href=\"#Query-String(쿼리 문자열)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"teal-400\">?category=WEB&page=1</span> 부분. 해당 <span class=\"cyan-400\">경로</span>에 임의의 데이터를 같이 전송할 때 사용한다.<br><span class=\"primary\">key=value</span> 형태로 이루어지며, 각 <code class=\"inline-code\">key</code>는 <span class=\"purple-400\">Parameter(파라미터)</span>라 칭한다. 첫 <span class=\"purple-400\">파라미터</span>는 <code class=\"inline-code\">?</code>로 시작하며, 이후 각 <span class=\"purple-400\">파라미터</span>들은 <code class=\"inline-code\">&amp;</code>으로 구분된다. 즉 <code class=\"inline-code\">?key1=value1&amp;key2=value2&amp;key3=value3</code>과 같은 양식으로 전개된다.</p>\n<p>임의의 키워드를 전달하여 페이지의 동작을 제어할 수 있다. <span class=\"primary\">URL</span> 중 <strong>사용자의 니즈가 가장 활발하게 반영</strong>되는 부분. <span class=\"teal-400\">쿼리 문자열</span>은 각각의 <code class=\"inline-code\">key</code>에 대한 역할을 정의해야 하므로, 개발자가 각 <span class=\"purple-400\">파라미터</span>의 <code class=\"inline-code\">key</code>가 동작하는 로직을 작성했을 때 그 의미가 있다.</p>\n<h2 id=\"URN-구조\">URN 구조 <a href=\"#URN-구조\">🔗</a></h2><p>지금까지 <span class=\"primary\">URL</span>에 대해선 상당히 장황하게 설명했지만, <span class=\"primary\">URN</span>의 경우 <span class=\"primary\">URL</span>보다 역사가 짧다. 이미 3년이라는 시간 사이에 <span class=\"primary\">URL</span>이 표준으로 자리매김한 탓에, 현재까지도 비주류를 면치 못 해 구현된 예시도 그리 많지 않은게 현실이다.<br><span class=\"primary\">URL</span>이 위치만 바뀌어도 찾을 수 없다는 단점은, 오히려 제공중인 데이터를 은닉하는 측면 등 상황에 따라 오히려 유용하게 사용할 여지도 있다. 즉, <span class=\"primary\">URL</span>의 단점이 마냥 나쁜것만은 아닌 셈이다. 이는 곳 <span class=\"primary\">URN</span>의 장점이 현재 구축된 <span class=\"primary\">URL</span>체계를 갈아 엎을 정도로 매력적이지 않다는 주장을 뒷받침한다.</p>\n<p><span class=\"primary\">URN</span>은 아래와 같은 구조로 이루어진다. 각 요소는 <code class=\"inline-code\">:</code>으로 구분한다.</p>\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">urn</span>:<span class=\"green-400\">isbn</span>:<span class=\"yellow-400\">1234567890</span></p>\n\n<h3 id=\"Protocol(프로토콜)\">Protocol(프로토콜) <a href=\"#Protocol(프로토콜)\">🔗</a></h3><p><span class=\"primary\">URN</span>상의 <span class=\"lightBlue-400\">urn</span> 부분. <code class=\"inline-code\">urn</code>으로 시작하면 <span class=\"primary\">URN</span>체계로 보면 된다.</p>\n<h3 id=\"NID(Namespace-Identifier, 네임스페이스 지시자)\">NID(Namespace Identifier, 네임스페이스 지시자) <a href=\"#NID(Namespace-Identifier, 네임스페이스 지시자)\">🔗</a></h3><p><span class=\"primary\">URN</span>상의 <span class=\"green-400\">isbn</span> 부분. <strong>자원이 저장된 저장소</strong>를 표시한다.<br><code class=\"inline-code\">isbn</code>은 서지정보유통지원시스템으로 도서 일련번호에 대한 정보를 저장하는 저장소이다. 즉, <code class=\"inline-code\">isbn</code>을 <span class=\"green-400\">NID</span>로 지정하면 도서 관련 자원을 식별할 수 있다.</p>\n<h3 id=\"NSS(Namespace-Specific String, 네임스페이스 특정 문자)\">NSS(Namespace Specific String, 네임스페이스 특정 문자) <a href=\"#NSS(Namespace-Specific String, 네임스페이스 특정 문자)\">🔗</a></h3><p><span class=\"primary\">URN</span>상의 <span class=\"yellow-400\">1234567890</span> 부분. <strong>자원을 식별할 수 있는 고유값</strong>이다.<br><span class=\"green-400\">NID</span>가 <code class=\"inline-code\">isbn</code>으로 지정되어 있으므로, ISBN의 일련번호가 1234567890인 도서를 식별하는 <span class=\"primary\">URN</span>이라 볼 수 있다.</p>\n","url":["2021-05-29-uri-url-urn","2021","05","29","uri-url-urn"],"toc":[{"text":"URL! URI... URN??","tag":"URL!-URI... URN??","depth":1},{"text":"UR* 톱아보기","tag":"UR*-톱아보기","depth":1},{"text":"URI(Uniform Resource Identifier, 통합 자원 식별자)","tag":"URI(Uniform-Resource Identifier, 통합 자원 식별자)","depth":2},{"text":"URL(Uniform Resource Locater, 통합 자원 지시자)","tag":"URL(Uniform-Resource Locater, 통합 자원 지시자)","depth":2},{"text":"URN(Uniform Resource Name, 통합 자원 이름)","tag":"URN(Uniform-Resource Name, 통합 자원 이름)","depth":2},{"text":"정리","tag":"정리","depth":2},{"text":"구조","tag":"구조","depth":1},{"text":"URL 구조","tag":"URL-구조","depth":2},{"text":"Protocol(프로토콜)","tag":"Protocol(프로토콜)","depth":3},{"text":"SLD(Second Level Domain, 서브도메인, 호스트)","tag":"SLD(Second-Level Domain, 서브도메인, 호스트)","depth":3},{"text":"Domain(도메인)","tag":"Domain(도메인)","depth":3},{"text":"TLD(Top Level Domain, 최상위 도메인)","tag":"TLD(Top-Level Domain, 최상위 도메인)","depth":3},{"text":"ccTLD(country code TLD, 국가 코드 최상위 도메인)","tag":"ccTLD(country-code TLD, 국가 코드 최상위 도메인)","depth":4},{"text":"gTLD(generic TLD, 일반 최상위 도메인)","tag":"gTLD(generic-TLD, 일반 최상위 도메인)","depth":4},{"text":"Port(포트)","tag":"Port(포트)","depth":2},{"text":"잘 알려진 포트(well-known Port)","tag":"잘-알려진 포트(well-known Port)","depth":3},{"text":"등록된 포트(registered Port)","tag":"등록된-포트(registered Port)","depth":3},{"text":"왜? 하필 개발 관련 프로그램들만?","tag":"왜?-하필 개발 관련 프로그램들만?","depth":4},{"text":"동적 포트(dynamic Port)","tag":"동적-포트(dynamic Port)","depth":3},{"text":"Path(경로)","tag":"Path(경로)","depth":3},{"text":"Query String(쿼리 문자열)","tag":"Query-String(쿼리 문자열)","depth":3},{"text":"URN 구조","tag":"URN-구조","depth":2},{"text":"Protocol(프로토콜)","tag":"Protocol(프로토콜)","depth":3},{"text":"NID(Namespace Identifier, 네임스페이스 지시자)","tag":"NID(Namespace-Identifier, 네임스페이스 지시자)","depth":3},{"text":"NSS(Namespace Specific String, 네임스페이스 특정 문자)","tag":"NSS(Namespace-Specific String, 네임스페이스 특정 문자)","depth":3}]},"hash":"6f60782a5f3"},"__N_SSG":true}