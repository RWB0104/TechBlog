{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[프로그래머스 / JAVA] Level 1 음양 더하기 (76501)","excerpt":"어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T17:01:15+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0007.md","content":"\r\n# 음양 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [음양 더하기](https://programmers.co.kr/learn/courses/30/lessons/76501)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 `absolutes`와 이 정수들의 부호를 차례대로 담은 불리언 배열 `signs`가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `absolutes`의 길이는 1 이상 1,000 이하입니다.\r\n  * `absolutes`의 모든 수는 각각 1 이상 1,000 이하입니다.\r\n* `signs`의 길이는 `absolutes`의 길이와 같습니다.\r\n  * `signs[i]` 가 참이면 `absolutes[i]` 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  absolutes   |         signs          | result |\r\n| :----------: | :--------------------: | :----: |\r\n| { 4, 7, 12 } | { true, false, true }  |   9    |\r\n| { 1, 2, 3 }  | { false, false, true } |   0    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n`signs`가 { true, false, true } 이므로, 실제 수들의 값은 각각 4, -7, 12입니다.\r\n\r\n따라서 세 수의 합인 9를 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n`signs`가 { false, false, true } 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다.\r\n\r\n따라서 세 수의 합인 0을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`absolutes`는 수의 절대값을, `signs`은 수의 부호를 가진다. 인덱스별로 각 요소를 호출하여 `signs`의 값에 따라 `absolutes`를 가감하면 될 것이다.\r\n\r\n`absolutes`와 `signs` 크기는 동일하므로, 어떤 배열을 인덱스로 삼든 상관 없다.\r\n\r\n``` java\r\nfor (int i = 0; i < absolutes.length; i++)\r\n{\r\n\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n}\r\n```\r\n\r\n`signs[i]`의 값에 따라 `absolutes`를 가감하여 `answer`에 누적시키면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 음양 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:09:32\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param absolutes: [int[]] 정수 절대값 배열\r\n\t * @param signs: [boolean[]] 정수의 부호\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] absolutes, boolean[] signs)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < absolutes.length; i++)\r\n\t\t{\r\n\t\t\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0007","2021","12","14","programmers-a0007"]},"next":{"header":{"title":"[프로그래머스 / JAVA] Level 1 완주하지 못한 선수 (42576)","excerpt":"수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T20:33:25+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0010.md","content":"\r\n# 완주하지 못한 선수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [완주하지 못한 선수](https://programmers.co.kr/learn/courses/30/lessons/42576)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\r\n\r\n마라톤에 참여한 선수들의 이름이 담긴 배열 `participant`와 완주한 선수들의 이름이 담긴 배열 `completion`이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\r\n* `completion`의 길이는 `participant`의 길이보다 1 작습니다.\r\n* 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\r\n* 참가자 중에는 동명이인이 있을 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                     participant                     |                 completion                 |  return  |\r\n| :-------------------------------------------------: | :----------------------------------------: | :------: |\r\n|              { \"leo\", \"kiki\", \"eden\" }              |             { \"eden\", \"kiki\" }             |  \"leo\"   |\r\n| { \"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\" } | { \"josipa\", \"filipa\", \"marina\", \"nikola\" } | \"vinko\"  |\r\n|       { \"mislav\", \"stanko\", \"mislav\", \"ana\" }       |       { \"stanko\", \"ana\", \"mislav\" }        | \"mislav\" |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**예제 #1**\r\n\r\n\"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #2**\r\n\r\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #3**\r\n\r\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n마라톤 경기에서 완주하지 못한 선수를 구하는 문제. 완주자 `completion`은 참가자 `participant` 보다 반드시 길이가 1 짧다. 즉, 완주자는 무조건 한 명이라는 뜻이다.\r\n\r\n또한 동명이인이 있을 수 있으므로, `HashSet`과 같이 고유값을 저장하는 형식은 적절하지 못하다.\r\n\r\n완주하지 못 한 사람이 한 명이므로, 완주한 사람의 이름과 횟수를 `HashMap`에 카운팅하면 완주한 사람은 물론, 동명이인도 커버할 수 있을 것이다.\r\n\r\n``` java\r\nHashMap<String, Integer> map = new HashMap<>();\r\n\r\nfor (String name : participant)\r\n{\r\n\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n}\r\n\r\nfor (String name : completion)\r\n{\r\n\tmap.put(name, map.get(name) - 1);\r\n}\r\n```\r\n\r\n`String`을 키로, `Integer`를 값으로 받는 `HashMap`을 선언한다. `participant` 요소를 탐색하면서 참가자 이름을 키로 하여 값을 1씩 증가시킨다.\r\n\r\n기본적으로 참가자들은 값 1을 가지지만, nikola라는 동명이인이 있다면, `map`의 nikola는 값 2를 가지게 된다.\r\n\r\n이후 `completion` 요소를 탐색하면서 완주자 이름을 키로 하여 값을 1씩 감소시킨다. 이 과정에서 완주하지 못한 사람은 값이 감소되지 않아 1을 가지게 된다.\r\n\r\n`map`을 탐색하며 값이 1인 키를 찾아 반환하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 완주하지 못한 선수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:13:57\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param participant: [String[]] 참여한 선수\r\n\t * @param completion: [String[]] 완주한 선수\r\n\t *\r\n\t * @return [String] 완주하지 못한 선수 이름\r\n\t */\r\n\tpublic String solution(String[] participant, String[] completion)\r\n\t{\r\n\t\tString answer = \"\";\r\n\t\t\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\tfor (String name : participant)\r\n\t\t{\r\n\t\t\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String name : completion)\r\n\t\t{\r\n\t\t\tmap.put(name, map.get(name) - 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String key : map.keySet())\r\n\t\t{\r\n\t\t\t// 값이 하나 이상 있을 경우\r\n\t\t\tif (map.get(key) > 0)\r\n\t\t\t{\r\n\t\t\t\tanswer = key;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0010","2021","12","14","programmers-a0010"]}},"group":[{"header":{"title":"[프로그래머스 / JAVA] Level 1 폰켓몬 (1845)","excerpt":"당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T02:01:09+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0017.md","content":"\r\n# 폰켓몬\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [폰켓몬](https://programmers.co.kr/learn/courses/30/lessons/1845)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.\r\n홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.\r\n\r\n1. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택\r\n2. 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택\r\n3. 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택\r\n4. 두 번째(1번), 세 번째(2번) 폰켓몬을 선택\r\n5. 두 번째(1번), 네 번째(3번) 폰켓몬을 선택\r\n6. 세 번째(2번), 네 번째(3번) 폰켓몬을 선택\r\n\r\n이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.\r\n\r\n당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 `nums`가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `nums`는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.\r\n* `nums`의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.\r\n* 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.\r\n* 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         nums         | result |\r\n| :------------------: | :----: |\r\n|    { 3, 1, 2, 3 }    |   2    |\r\n| { 3, 3, 3, 2, 2, 4 } |   3    |\r\n| { 3, 3, 3, 2, 2, 2 } |   2    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\r\n가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.\r\n\r\n**입출력 예 #3**\r\n\r\n6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\r\n가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\nN개의 폰켓몬 중 그 절반인 N / 2개의 폰켓몬을 가져갈 수 있다. N개 중 N / 2의 폰켓몬을 고르는 경우의 수 중에서 가장 많은 종류의 폰켓몬을 선택했을 때, 폰켓몬 종류 갯수를 요구하는 알고리즘이다.\r\n\r\n얼핏 보면 복잡해보일 수 있으나, 조금만 생각해보면 매우 간단하게 풀 수 있는 문제다.\r\n\r\n서로 다른 종류의 폰켓몬 N개가 있을 경우, 취할 수 있는 가장 많은 종류의 폰켓몬은 N / 2다.\r\n\r\n반면, N개의 폰켓몬이 있고, 종류는 고작 두가지일 경우, 취할 수 있는 가장 많은 종류의 폰켓몬은 2가 한계다.\r\n\r\n즉, 폰켓몬 배열 `nums`에서 폰켓몬의 종류와 `nums.length / 2` 중 더 작은 값을 반환하면 된다.\r\n\r\n* [1, 2, 3, 4, 5, 1] - 종류는 5개, N / 2는 3이므로, 가져갈 수 있는 최대 종류는 3개\r\n* [1, 1, 1, 1, 2, 2, 3, 3] - 종류는 3개, N / 2는 4이므로, 가져갈 수 있는 최대 종류는 3개\r\n\r\n폰켓몬의 종류를 구하기 위해 고유값만을 저장하는 `HashSet`을 활용하는 것이 적절해보인다.\r\n\r\n`HashSet`에 폰켓몬을 삽입하여 종류의 갯수를 얻어내고, 배열의 길이 / 2와 비교하여 더 작은 값을 반환하자.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 폰켓몬 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.11 Sat 01:56:08\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param nums: [int[]] 폰켓몬 종류 배열\r\n\t *\r\n\t * @return [int] 폰켓몬 종류 갯수\r\n\t */\r\n\tpublic int solution(int[] nums)\r\n\t{\r\n\t\tHashSet<Integer> set = new HashSet<>();\r\n\t\t\r\n\t\tfor (int num : nums)\r\n\t\t{\r\n\t\t\tset.add(num);\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.min(set.size(), nums.length / 2);\r\n\t}\r\n}\r\n```","url":["2021-12-15-programmers-a0017","2021","12","15","programmers-a0017"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 이름이 없는 동물의 아이디 (59039)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:44:37+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0016.md","content":"\r\n# 이름이 없는 동물의 아이디\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [이름이 없는 동물의 아이디](https://programmers.co.kr/learn/courses/30/lessons/59039)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |    NAME    | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :--------: | :-------------: |\r\n|  A368930  |     Dog     | 2014-06-08 13:20:00 |      Normal      |    NULL    |  Spayed Female  |\r\n|  A524634  |     Dog     | 2015-01-02 18:54:00 |      Normal      |   *Belle   |  Intact Female  |\r\n|  A465637  |     Dog     | 2017-06-04 08:17:00 |     Injured      | *Commander |  Neutered Male  |\r\n\r\n가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n| ANIMAL_ID |\r\n| :-------: |\r\n|  A368930  |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `NAME`이 null인 데이터를 `ANIMAL_ID` 순으로 조회한다. 해당 데이터 중 `ANIMAL_ID`만을 조회한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT ANIMAL_ID FROM ANIMAL_INS WHERE NAME IS NULL ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0016","2021","12","15","programmers-a0016"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 최댓값 구하기 (59415)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:41:43+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0015.md","content":"\r\n# 최댓값 구하기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [최댓값 구하기](https://programmers.co.kr/learn/courses/30/lessons/59415)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n가장 최근에 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 예시\r\n\r\n예를 들어 `ANIMAL_INS` 테이블이 다음과 같다면\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |   NAME   | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :------: | :-------------: |\r\n|  A399552  |     Dog     | 2013-10-14 15:38:00 |      Normal      |   Jack   |  Neutered Male  |\r\n|  A379998  |     Dog     | 2013-10-23 11:42:00 |      Normal      | Disciple |   Intact Male   |\r\n|  A370852  |     Dog     | 2013-11-03 15:04:00 |      Normal      |  Katie   |  Spayed Female  |\r\n|  A403564  |     Dog     | 2013-11-18 17:03:00 |      Normal      |   Anna   |  Spayed Female  |\r\n\r\n가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.\r\n\r\n|        시간         |\r\n| :-----------------: |\r\n| 2013-11-18 17:03:00 |\r\n\r\n* 컬럼 이름(위 예제에서는 \"시간\")은 일치하지 않아도 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `DATETIME`이 가장 최근인 데이터 중 가장 상위의 데이터 하나만을 조회한다.\r\n\r\nMySQL에서 최상위 데이터 하나만 호출할 땐 `LIMIT 1`을 사용한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT DATETIME FROM ANIMAL_INS ORDER BY DATETIME DESC LIMIT 1;\r\n```","url":["2021-12-15-programmers-a0015","2021","12","15","programmers-a0015"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 모든 레코드 조회하기 (59034)","excerpt":"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-15T01:38:22+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","SQL","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-15-programmers-a0014.md","content":"\r\n# 모든 레코드 조회하기\r\n\r\n|  랭크   |                                                  사용 언어                                                  |\r\n| :-----: | :---------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![MySQL](https://shields.io/badge/MySQL-lightgrey?logo=mysql&style=plastic&logoColor=white&labelColor=blue) |\r\n\r\n🔗 [모든 레코드 조회하기](https://programmers.co.kr/learn/courses/30/lessons/59034)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. `ANIMAL_INS` 테이블 구조는 다음과 같으며, `ANIMAL_ID`, `ANIMAL_TYPE`, `DATETIME`, `INTAKE_CONDITION`, `NAME`, `SEX_UPON_INTAKE`는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.\r\n\r\n|       NAME       |    TYPE    | NULLABLE |\r\n| :--------------: | :--------: | :------: |\r\n|    ANIMAL_ID     | VARCHAR(N) |  FALSE   |\r\n|   ANIMAL_TYPE    | VARCHAR(N) |  FALSE   |\r\n|     DATETIME     |  DATETIME  |  FALSE   |\r\n| INTAKE_CONDITION | VARCHAR(N) |  FALSE   |\r\n|       NAME       | VARCHAR(N) |   TRUE   |\r\n| SEX_UPON_INTAKE  | VARCHAR(N) |  FALSE   |\r\n\r\n동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다.\r\n\r\n| ANIMAL_ID | ANIMAL_TYPE |      DATETIME       | INTAKE_CONDITION |  NAME  | SEX_UPON_INTAKE |\r\n| :-------: | :---------: | :-----------------: | :--------------: | :----: | :-------------: |\r\n|  A349996  |     Cat     | 2018-01-22 14:32:00 |      Normal      | Sugar  |  Neutered Male  |\r\n|  A350276  |     Cat     | 2017-08-13 13:50:00 |      Normal      | Jewel  |  Spayed Female  |\r\n|  A350375  |     Cat     | 2017-03-06 15:01:00 |      Normal      |  Meo   |  Neutered Male  |\r\n|  A352555  |     Dog     | 2014-08-08 04:20:00 |      Normal      | Harley |  Spayed Female  |\r\n\r\n..이하 생략\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`ANIMAL_INS`를 조회하는데, `ANIMAL_ID` 순으로 조회한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` sql\r\nSELECT * FROM ANIMAL_INS ORDER BY ANIMAL_ID;\r\n```","url":["2021-12-15-programmers-a0014","2021","12","15","programmers-a0014"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 체육복 (42862)","excerpt":"점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T22:18:41+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0013.md","content":"\r\n# 체육복\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.\r\n\r\n전체 학생의 수 `n`, 체육복을 도난당한 학생들의 번호가 담긴 배열 `lost`, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 `reserve`가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 전체 학생의 수는 2명 이상 30명 이하입니다.\r\n* 체육복을 도난당한 학생의 수는 1명 이상 `n`명 이하이고 중복되는 번호는 없습니다.\r\n* 여벌의 체육복을 가져온 학생의 수는 1명 이상 `n`명 이하이고 중복되는 번호는 없습니다.\r\n* 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\r\n* 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|   n   |   lost   |   reserve   | return |\r\n| :---: | :------: | :---------: | :----: |\r\n|   5   | { 2, 4 } | { 1, 3, 5 } |   5    |\r\n|   5   | { 2, 4 } |    { 3 }    |   4    |\r\n|   3   |  { 3 }   |    { 1 }    |   2    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**예제 #1**\r\n\r\n1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.\r\n\r\n**예제 #2**\r\n\r\n3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n본인 체육복만 가지고 있는 학생, 여벌 체육복을 가진 학생, 체육복을 도난당한 학생 세 가지로 나뉜다. 이 중 체육복을 도난당한 학생은 여벌을 가진 학생으로부터 체육복을 빌릴 수는 있지만, 자신의 앞뒤 학생에게만 빌릴 수 있다는 제한이 있다. 즉, 여벌이 남아도 서로 앞뒤에 위치하지 않는다면 빌려줄 수 없다.\r\n\r\n`lost`와 `reserve`엔 학생 번호가 기록되어 있는데, 이 문제에서는 학생의 순서가 매우 중요하므로 반드시 정렬이 필요하다.\r\n\r\n`clothes` 배열을 선언하여 체육복의 갯수를 카운팅한다.\r\n\r\n``` java\r\n// 여벌 체육복을 가진 학생을 카운팅\r\nfor (int item : reserve)\r\n{\r\n\tclothes[item - 1]++;\r\n}\r\n\r\n// 체육복을 도난당한 학생을 카운팅\r\nfor (int item : lost)\r\n{\r\n\tclothes[item - 1]--;\r\n}\r\n```\r\n\r\n`for`문으로 체육복의 여부를 가감한다. 학생의 번호는 배열의 인덱스 + 1과 동일하게 다루면 된다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 체육복 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 23:38:35\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param n: [int] 전체 학생 수\r\n\t * @param lost: [int[]] 체육복을 도난당한 학생\r\n\t * @param reserve: [int[]] 체육복 여벌을 가진 학생\r\n\t *\r\n\t * @return [int] 체육 수업을 들을 수 있는 학생의 최대값\r\n\t */\r\n\tpublic int solution(int n, int[] lost, int[] reserve)\r\n\t{\r\n\t\tint[] clothes = new int[n];\r\n\t\t\r\n\t\t// 자신의 앞뒤 사람에게만 빌려줄 수 있으므로 학생 번호 순서가 중요함\r\n\t\tArrays.sort(lost);\r\n\t\tArrays.sort(reserve);\r\n\t\t\r\n\t\t// 여벌 체육복을 가진 학생을 카운팅\r\n\t\tfor (int item : reserve)\r\n\t\t{\r\n\t\t\tclothes[item - 1]++;\r\n\t\t}\r\n\t\t\r\n\t\t// 체육복을 도난당한 학생을 카운팅\r\n\t\tfor (int item : lost)\r\n\t\t{\r\n\t\t\tclothes[item - 1]--;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < clothes.length; i++)\r\n\t\t{\r\n\t\t\t// 도난당한 학생일 경우\r\n\t\t\tif (clothes[i] == -1)\r\n\t\t\t{\r\n\t\t\t\t// 첫 학생이 아니고, 앞 학생이 여벌을 가질 경우\r\n\t\t\t\tif (i != 0 && clothes[i - 1] == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tclothes[i - 1]--;\r\n\t\t\t\t\tclothes[i]++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 마지막 학생이 아니고, 뒷 학생이 여벌을 가질 경우\r\n\t\t\t\telse if (i != clothes.length - 1 && clothes[i + 1] == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tclothes[i + 1]--;\r\n\t\t\t\t\tclothes[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Arrays.stream(clothes).filter(value -> value > -1).toArray().length;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0013","2021","12","14","programmers-a0013"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 모의고사 (42840)","excerpt":"수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ... 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ... 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ... 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T22:02:01+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0012.md","content":"\r\n# 모의고사\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [모의고사](https://programmers.co.kr/learn/courses/30/lessons/42840)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\r\n\r\n1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...\r\n\r\n2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...\r\n\r\n3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\r\n\r\n1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 `answers`가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 시험은 최대 10,000 문제로 구성되어있습니다.\r\n* 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.\r\n* 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|      answers      |   return    |\r\n| :---------------: | :---------: |\r\n| { 1, 2, 3, 4, 5 } |    { 1 }    |\r\n| { 1, 3, 2, 4, 2 } | { 1, 2, 3 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n* 수포자 1은 모든 문제를 맞혔습니다.\r\n* 수포자 2는 모든 문제를 틀렸습니다.\r\n* 수포자 3은 모든 문제를 틀렸습니다.\r\n\r\n따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n* 모든 사람이 2문제씩을 맞췄습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n* 1번 수포자 패턴 - `[ 1, 2, 3, 4, 5 ]`\r\n* 2번 수포자 패턴 - `[ 2, 1, 2, 3, 2, 4, 2, 5 ]`\r\n* 3번 수포자 패턴 - `[ 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 ]`\r\n\r\n수포자마다 패턴도 다르고, 길이도 달라서 생각없이 접근할 순 없다. 각 패턴의 길이가 다르므로 인덱스 방식은 적절하지 않다. 패턴을 컨테이너 벨트처럼 순환시켜, 가장 앞 쪽의 숫자를 비교하는 것이 더 효과적일 것이다.\r\n\r\n이를 위해선 각 수포자별로 패턴을 순환시키는 로직이 필요하다. `[ 1, 2, 3, 4, 5 ]` -> `[ 2, 3, 4, 5, 1 ]` 자료구조 중 큐의 특성과 매우 유사하므로, 이 문제는 큐를 적극적으로 활용해볼 생각이다.\r\n\r\n각 패턴을 정의할 큐 `ONE`, `TWO`, `THREE`가 있으며, 아래와 같이 초기화를 수행한다.\r\n\r\n``` java\r\nprivate void initQueue()\r\n{\r\n\tONE.clear();\r\n\tTWO.clear();\r\n\tTHREE.clear();\r\n\t\r\n\tONE.add(1);\r\n\tONE.add(2);\r\n\tONE.add(3);\r\n\tONE.add(4);\r\n\tONE.add(5);\r\n\t\r\n\tTWO.add(2);\r\n\tTWO.add(1);\r\n\tTWO.add(2);\r\n\tTWO.add(3);\r\n\tTWO.add(2);\r\n\tTWO.add(4);\r\n\tTWO.add(2);\r\n\tTWO.add(5);\r\n\t\r\n\tTHREE.add(3);\r\n\tTHREE.add(3);\r\n\tTHREE.add(1);\r\n\tTHREE.add(1);\r\n\tTHREE.add(2);\r\n\tTHREE.add(2);\r\n\tTHREE.add(4);\r\n\tTHREE.add(4);\r\n\tTHREE.add(5);\r\n\tTHREE.add(5);\r\n}\r\n```\r\n\r\n패턴 순서대로 큐에 데이터를 집어넣는다. `poll()` 메서드를 통해 가장 앞에 위치한 데이터를 꺼낼 수 있다. `poll()`의 경우 데이터 호출과 동시에 데이터가 삭제된다.\r\n\r\n정답 비교 후, 사용한 데이터는 다시 큐에 집어넣는다. 이런 구조는 문제의 길이에 관계없이 각 수포자 별로 지속적인 순환이 가능할 것이다.\r\n\r\n``` java\r\nfor (int item : answers)\r\n{\r\n\tint one = Objects.requireNonNull(ONE.poll());\r\n\tint two = Objects.requireNonNull(TWO.poll());\r\n\tint three = Objects.requireNonNull(THREE.poll());\r\n\t\r\n\tcounts[0] += item == one ? 1 : 0;\r\n\tcounts[1] += item == two ? 1 : 0;\r\n\tcounts[2] += item == three ? 1 : 0;\r\n\t\r\n\tONE.add(one);\r\n\tTWO.add(two);\r\n\tTHREE.add(three);\r\n}\r\n```\r\n\r\n정답 비교는 위와 같다. `Objects.requireNonNull`는 `poll()`이 `NullPointerException`을 유발할 가능성이 있으므로, 관련 경고를 제거하기 위한 조치다.\r\n\r\n각 수포자별 큐에서 패턴을 뽑고, 이를 문제의 정답과 비교하여 맞춘 경우 `counts` 배열에 카운팅한다.\r\n\r\n사용한 패턴은 `add` 메서드를 통해 큐에 다시 집어넣는 것을 확인할 수 있다.\r\n\r\n<br />\r\n\r\n점수를 모두 구했다면, 가장 고득점을 구하고, 고득점을 맞은 수포자를 반환하면 된다.\r\n\r\n`counts`에서 가장 큰 값을 구하면 아래와 같다.\r\n\r\n``` java\r\nint max = Arrays.stream(counts).max().getAsInt();\r\n```\r\n\r\n이후 `max`에 해당하는 점수를 받은 모든 인원을 탐색하여 배열로 나타내면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\nimport java.util.Objects;\r\nimport java.util.Queue;\r\n\r\n/**\r\n * 모의고사 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:43:26\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final Queue<Integer> ONE = new LinkedList<>();\r\n\tprivate static final Queue<Integer> TWO = new LinkedList<>();\r\n\tprivate static final Queue<Integer> THREE = new LinkedList<>();\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param answers: [int[]] 최고 득점자\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] answers)\r\n\t{\r\n\t\tinitQueue();\r\n\t\t\r\n\t\tint[] counts = { 0, 0, 0 };\r\n\t\t\r\n\t\tfor (int item : answers)\r\n\t\t{\r\n\t\t\tint one = Objects.requireNonNull(ONE.poll());\r\n\t\t\tint two = Objects.requireNonNull(TWO.poll());\r\n\t\t\tint three = Objects.requireNonNull(THREE.poll());\r\n\t\t\t\r\n\t\t\tcounts[0] += item == one ? 1 : 0;\r\n\t\t\tcounts[1] += item == two ? 1 : 0;\r\n\t\t\tcounts[2] += item == three ? 1 : 0;\r\n\t\t\t\r\n\t\t\tONE.add(one);\r\n\t\t\tTWO.add(two);\r\n\t\t\tTHREE.add(three);\r\n\t\t}\r\n\t\t\r\n\t\tint max = Arrays.stream(counts).max().getAsInt();\r\n\t\t\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int i = 0; i < counts.length; i++)\r\n\t\t{\r\n\t\t\t// 최고 점수를 얻었을 경우\r\n\t\t\tif (counts[i] == max)\r\n\t\t\t{\r\n\t\t\t\tlist.add(i + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 큐 초기화 메서드\r\n\t */\r\n\tprivate void initQueue()\r\n\t{\r\n\t\tONE.clear();\r\n\t\tTWO.clear();\r\n\t\tTHREE.clear();\r\n\t\t\r\n\t\tONE.add(1);\r\n\t\tONE.add(2);\r\n\t\tONE.add(3);\r\n\t\tONE.add(4);\r\n\t\tONE.add(5);\r\n\t\t\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(1);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(3);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(4);\r\n\t\tTWO.add(2);\r\n\t\tTWO.add(5);\r\n\t\t\r\n\t\tTHREE.add(3);\r\n\t\tTHREE.add(3);\r\n\t\tTHREE.add(1);\r\n\t\tTHREE.add(1);\r\n\t\tTHREE.add(2);\r\n\t\tTHREE.add(2);\r\n\t\tTHREE.add(4);\r\n\t\tTHREE.add(4);\r\n\t\tTHREE.add(5);\r\n\t\tTHREE.add(5);\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0012","2021","12","14","programmers-a0012"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 완주하지 못한 선수 (42576)","excerpt":"수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T20:33:25+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0010.md","content":"\r\n# 완주하지 못한 선수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [완주하지 못한 선수](https://programmers.co.kr/learn/courses/30/lessons/42576)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\r\n\r\n마라톤에 참여한 선수들의 이름이 담긴 배열 `participant`와 완주한 선수들의 이름이 담긴 배열 `completion`이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\r\n* `completion`의 길이는 `participant`의 길이보다 1 작습니다.\r\n* 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\r\n* 참가자 중에는 동명이인이 있을 수 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                     participant                     |                 completion                 |  return  |\r\n| :-------------------------------------------------: | :----------------------------------------: | :------: |\r\n|              { \"leo\", \"kiki\", \"eden\" }              |             { \"eden\", \"kiki\" }             |  \"leo\"   |\r\n| { \"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\" } | { \"josipa\", \"filipa\", \"marina\", \"nikola\" } | \"vinko\"  |\r\n|       { \"mislav\", \"stanko\", \"mislav\", \"ana\" }       |       { \"stanko\", \"ana\", \"mislav\" }        | \"mislav\" |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**예제 #1**\r\n\r\n\"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #2**\r\n\r\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\r\n\r\n**예제 #3**\r\n\r\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n마라톤 경기에서 완주하지 못한 선수를 구하는 문제. 완주자 `completion`은 참가자 `participant` 보다 반드시 길이가 1 짧다. 즉, 완주자는 무조건 한 명이라는 뜻이다.\r\n\r\n또한 동명이인이 있을 수 있으므로, `HashSet`과 같이 고유값을 저장하는 형식은 적절하지 못하다.\r\n\r\n완주하지 못 한 사람이 한 명이므로, 완주한 사람의 이름과 횟수를 `HashMap`에 카운팅하면 완주한 사람은 물론, 동명이인도 커버할 수 있을 것이다.\r\n\r\n``` java\r\nHashMap<String, Integer> map = new HashMap<>();\r\n\r\nfor (String name : participant)\r\n{\r\n\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n}\r\n\r\nfor (String name : completion)\r\n{\r\n\tmap.put(name, map.get(name) - 1);\r\n}\r\n```\r\n\r\n`String`을 키로, `Integer`를 값으로 받는 `HashMap`을 선언한다. `participant` 요소를 탐색하면서 참가자 이름을 키로 하여 값을 1씩 증가시킨다.\r\n\r\n기본적으로 참가자들은 값 1을 가지지만, nikola라는 동명이인이 있다면, `map`의 nikola는 값 2를 가지게 된다.\r\n\r\n이후 `completion` 요소를 탐색하면서 완주자 이름을 키로 하여 값을 1씩 감소시킨다. 이 과정에서 완주하지 못한 사람은 값이 감소되지 않아 1을 가지게 된다.\r\n\r\n`map`을 탐색하며 값이 1인 키를 찾아 반환하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 완주하지 못한 선수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:13:57\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param participant: [String[]] 참여한 선수\r\n\t * @param completion: [String[]] 완주한 선수\r\n\t *\r\n\t * @return [String] 완주하지 못한 선수 이름\r\n\t */\r\n\tpublic String solution(String[] participant, String[] completion)\r\n\t{\r\n\t\tString answer = \"\";\r\n\t\t\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\tfor (String name : participant)\r\n\t\t{\r\n\t\t\tmap.put(name, map.getOrDefault(name, 0) + 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String name : completion)\r\n\t\t{\r\n\t\t\tmap.put(name, map.get(name) - 1);\r\n\t\t}\r\n\t\t\r\n\t\tfor (String key : map.keySet())\r\n\t\t{\r\n\t\t\t// 값이 하나 이상 있을 경우\r\n\t\t\tif (map.get(key) > 0)\r\n\t\t\t{\r\n\t\t\t\tanswer = key;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0010","2021","12","14","programmers-a0010"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 음양 더하기 (76501)","excerpt":"어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T17:01:15+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0007.md","content":"\r\n# 음양 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [음양 더하기](https://programmers.co.kr/learn/courses/30/lessons/76501)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 `absolutes`와 이 정수들의 부호를 차례대로 담은 불리언 배열 `signs`가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `absolutes`의 길이는 1 이상 1,000 이하입니다.\r\n  * `absolutes`의 모든 수는 각각 1 이상 1,000 이하입니다.\r\n* `signs`의 길이는 `absolutes`의 길이와 같습니다.\r\n  * `signs[i]` 가 참이면 `absolutes[i]` 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  absolutes   |         signs          | result |\r\n| :----------: | :--------------------: | :----: |\r\n| { 4, 7, 12 } | { true, false, true }  |   9    |\r\n| { 1, 2, 3 }  | { false, false, true } |   0    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n`signs`가 { true, false, true } 이므로, 실제 수들의 값은 각각 4, -7, 12입니다.\r\n\r\n따라서 세 수의 합인 9를 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n`signs`가 { false, false, true } 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다.\r\n\r\n따라서 세 수의 합인 0을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n`absolutes`는 수의 절대값을, `signs`은 수의 부호를 가진다. 인덱스별로 각 요소를 호출하여 `signs`의 값에 따라 `absolutes`를 가감하면 될 것이다.\r\n\r\n`absolutes`와 `signs` 크기는 동일하므로, 어떤 배열을 인덱스로 삼든 상관 없다.\r\n\r\n``` java\r\nfor (int i = 0; i < absolutes.length; i++)\r\n{\r\n\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n}\r\n```\r\n\r\n`signs[i]`의 값에 따라 `absolutes`를 가감하여 `answer`에 누적시키면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 음양 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:09:32\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param absolutes: [int[]] 정수 절대값 배열\r\n\t * @param signs: [boolean[]] 정수의 부호\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] absolutes, boolean[] signs)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < absolutes.length; i++)\r\n\t\t{\r\n\t\t\tanswer += (signs[i] ? absolutes[i] : -absolutes[i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0007","2021","12","14","programmers-a0007"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 K번째수 (42748)","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0011.md","content":"\r\n# K번째수\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [K번째수](https://programmers.co.kr/learn/courses/30/lessons/42748)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n배열 `array`의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.\r\n\r\n예를 들어 `array`가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\r\n\r\n1. `array`의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.\r\n2. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.\r\n3. 2에서 나온 배열의 3번째 숫자는 5입니다.\r\n\r\n배열 `array`, [i, j, k]를 원소로 가진 2차원 배열 `commands`가 매개변수로 주어질 때, `commands`의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 `solution` 함수를 작성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `array`의 길이는 1 이상 100 이하입니다.\r\n* `array`의 각 원소는 1 이상 100 이하입니다.\r\n* `commands`의 길이는 1 이상 50 이하입니다.\r\n* `commands`의 각 원소는 길이가 3입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          array          |                 commands                  |   return    |\r\n| :---------------------: | :---------------------------------------: | :---------: |\r\n| { 1, 5, 2, 6, 3, 7, 4 } | { { 2, 5, 3 }, { 4, 4, 1 }, { 1, 7, 3 } } | { 5, 6, 3 } |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.\r\n\r\n[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. `commands` 요소별로 `i`, `j`, `k`를 구한다.\r\n2. `i`에서 `j`까지 `array`를 자른다.\r\n3. 자른 배열을 정렬한다.\r\n4. 자른 배열의 `k`번 째 요소를 찾는다.\r\n\r\n알고리즘 수행 과정은 위와 같을 것이다.\r\n\r\n``` java\r\nfor (int n = 0; n < answer.length; n++)\r\n{\r\n\tint i = commands[n][0];\r\n\tint j = commands[n][1];\r\n\tint k = commands[n][2];\r\n\t\r\n\tint length = j - i + 1;\r\n\t\r\n\tint[] temp = new int[length];\r\n\t\r\n\tSystem.arraycopy(array, i - 1, temp, 0, length);\r\n\t\r\n\tArrays.sort(temp);\r\n\t\r\n\tanswer[n] = temp[--k];\r\n}\r\n```\r\n\r\n`i`, `j`, `k`를 구하고, `i`와 `j` 사이의 거리를 구한다. 해당 길이만큼의 배열을 선언하여 자를 것이다.\r\n\r\n`System.arraycopy()` 메서드를 활용하여 `temp` 배열로 `array`의 원하는 부분만을 잘라서 할당하는 것이 가능하다.\r\n\r\n이후 정렬을 수행하고, `k`번 째 요소를 찾으면 된다. 배열은 0부터 시작하므로 실제 인덱스는 `k - 1`이 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * K번째수 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 21:28:35\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t * @param commands: [int[][]] 인덱스 배열\r\n\t *\r\n\t * @return [int[]] k번째의 수\r\n\t */\r\n\tpublic int[] solution(int[] array, int[][] commands)\r\n\t{\r\n\t\tint[] answer = new int[commands.length];\r\n\t\t\r\n\t\tfor (int n = 0; n < answer.length; n++)\r\n\t\t{\r\n\t\t\tint i = commands[n][0];\r\n\t\t\tint j = commands[n][1];\r\n\t\t\tint k = commands[n][2];\r\n\t\t\t\r\n\t\t\tint length = j - i + 1;\r\n\t\t\t\r\n\t\t\tint[] temp = new int[length];\r\n\t\t\t\r\n\t\t\tSystem.arraycopy(array, i - 1, temp, 0, length);\r\n\t\t\t\r\n\t\t\tArrays.sort(temp);\r\n\t\t\t\r\n\t\t\tanswer[n] = temp[--k];\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0011","2021","12","14","programmers-a0011"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 내적 (70128)","excerpt":"길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요. 이때, a와 b의 내적은 a[0] * b[0] + a[1] * b[1] + ... + a[n-1] * b[n-1] 입니다. (n은 a, b의 길이)","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0008.md","content":"\r\n# 내적\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [내적](https://programmers.co.kr/learn/courses/30/lessons/70128)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n길이가 같은 두 1차원 정수 배열 `a`, `b`가 매개변수로 주어집니다. `a`와 `b`의 내적을 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n이때, `a`와 `b`의 내적은 `a[0] * b[0] + a[1] * b[1] + ... + a[n-1] * b[n-1]` 입니다. (`n`은 `a`, `b`의 길이)\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `a`, `b`의 길이는 1 이상 1,000 이하입니다.\r\n* `a`, `b`의 모든 수는 -1,000 이상 1,000 이하입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|       a        |        b         | result |\r\n| :------------: | :--------------: | :----: |\r\n| { 1, 2, 3, 4 } | { -3, -1, 0, 2 } |   3    |\r\n|  { -1, 0, 1 }  |   { 1, 0, -1 }   |   -2   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n`a`와 `b`의 내적은 `1 * (-3) + 2 * (-1) + 3 * 0 + 4 * 2 = 3`입니다.\r\n\r\n**입출력 예 #2**\r\n\r\n`a`와 `b`의 내적은 `(-1) * 1 + 0 * 0 + 1 * (-1) = -2`입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n인덱스를 돌면서 `a`, `b` 요소를 곱한뒤 값을 누적시키면 될 것이다. `a`, `b`의 길이가 동일하므로 아무 배열이나 인덱스로 삼아도 된다.\r\n\r\n``` java\r\nfor (int i = 0; i < a.length; i++)\r\n{\r\n\tanswer += a[i] * b[i];\r\n}\r\n```\r\n\r\n위와 같이 각 요소별로 곱한 값을 `answer`에 누적한다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 내적 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:17:10\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param a: [int[]] 정수 배열\r\n\t * @param b: [int[]] 정수 배열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] a, int[] b)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < a.length; i++)\r\n\t\t{\r\n\t\t\tanswer += a[i] * b[i];\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0008","2021","12","14","programmers-a0008"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 없는 숫자 더하기 (86051)","excerpt":"0부터 9까지의 숫자 중 일부가 들어있는 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0006.md","content":"\r\n# 없는 숫자 더하기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [없는 숫자 더하기](https://programmers.co.kr/learn/courses/30/lessons/86051)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n0부터 9까지의 숫자 중 일부가 들어있는 배열 `numbers`가 매개변수로 주어집니다. `numbers`에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `numbers`의 길이 ≤ 9\r\n* 0 ≤ `numbers`의 모든 수 ≤ 9\r\n* `numbers`의 모든 수는 서로 다릅니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|          numbers           | result |\r\n| :------------------------: | :----: |\r\n| { 1, 2, 3, 4, 6, 7, 8, 0 } |   14   |\r\n|  { 5, 8, 4, 0, 6, 7, 9 }   |   6    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n5, 9가 `numbers`에 없으므로, 5 + 9 = 14를 return 해야 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n1, 2, 3이 `numbers`에 없으므로, 1 + 2 + 3 = 6을 return 해야 합니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n0 ~ 9의 숫자가 중복되지 않게 포함된 배열이 있다. 우리는 이 배열에 포함되지 않는 수들의 합을 구하는 것이 목적이다.\r\n\r\n숫자도 한 자리로 제한되어있고, 중복도 없으므로 매우 간단하게 풀 수 있다.\r\n\r\n0 ~ 9의 총 합은 45다. 45에서 `numbers`의 값들을 전부 빼주면 포함되지 않는 수들의 합을 쉽게 구할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 없는 숫자 더하기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.10 Fri 00:04:47\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 숫자 배열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[] numbers)\r\n\t{\r\n\t\tint answer = 45;\r\n\t\t\r\n\t\tfor (int number : numbers)\r\n\t\t{\r\n\t\t\tanswer -= number;\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0006","2021","12","14","programmers-a0006"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 크레인 인형뽑기 게임 (64061)","excerpt":"게임개발자인 \"죠르디\"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다. \"죠르디\"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T14:20:05+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0005.md","content":"\r\n# 크레인 인형뽑기 게임\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [크레인 인형뽑기 게임](https://programmers.co.kr/learn/courses/30/lessons/64061)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n게임개발자인 \"죠르디\"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.\r\n\"죠르디\"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png)\r\n\r\n게임 화면은 \"1 x 1\" 크기의 칸들로 이루어진 \"N x N\" 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 \"5 x 5\" 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 \"1 x 1\" 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png)\r\n\r\n만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif)\r\n\r\n크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)\r\n\r\n게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 `moves`가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `board` 배열은 2차원 배열로 크기는 \"5 x 5\" 이상 \"30 x 30\" 이하입니다.\r\n* `board`의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.\r\n  * 0은 빈 칸을 나타냅니다.\r\n  * 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.\r\n* `moves` 배열의 크기는 1 이상 1,000 이하입니다.\r\n* `moves` 배열 각 원소들의 값은 1 이상이며 `board` 배열의 가로 크기 이하인 자연수입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|                                               board                                               |           moves            | result |\r\n| :-----------------------------------------------------------------------------------------------: | :------------------------: | :----: |\r\n| { { 0, 0, 0, 0, 0 }, { 0, 0, 1, 0, 3 }, { 0, 2, 5, 0, 1 }, { 4, 2, 4, 4, 2 }, { 3, 5, 1, 3, 1 } } | { 1, 5, 3, 5, 1, 2, 1, 4 } |   4    |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/bb0f59c7-6b72-485a-8302-217fe53ea88f/crane_game_104.jpg)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1. 인형을 뽑는다. 만약 해당 위치에 인형이 없다면 아무것도 뽑지 않는다.\r\n2. 뽑은 인형을 바구니에 담는다.\r\n3. 방금 뽑은 인형과 마지막으로 뽑았던 인형이 동일하면 삭제한다.\r\n4. 삭제한 인형 갯수를 카운팅한다. (삭제 작업 당 +2)\r\n\r\n삭제 횟수가 아니라 삭제한 인형의 갯수다. 2개씩 삭제됨에 유의.\r\n\r\n크레인을 움직이면서 인형을 하나씩 담는다. 이를 담을 배열이 필요하며, `ArrayList` 같은 가변 배열이 적절해보인다. 가장 최근에 들어온 데이터로 연산하므로, `Stack`의 특성을 적극 활용하고자 한다.\r\n\r\n``` java\r\nfor (int move : moves)\r\n{\r\n\tint j = move - 1;\r\n\t\r\n\tfor (int i = 0; i < board.length; i++)\r\n\t{\r\n\t\t// 인형을 뽑을 경우\r\n\t\tif (board[i][j] > 0)\r\n\t\t{\r\n\t\t\t// 동작\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n인형을 뽑는 동작은 위와 같다. 열 `j`를 기준으로 한 행씩 내려오면서 `board[i][j] > 0`인지 확인한다.\r\n\r\n해당 인형은 `board`에서 제거하고 인형을 스택에 넣는다. 이 때, 스택의 마지막 인형과 뽑은 인형이 같을 경우, 스택의 마지막 인형을 제거하고 삭제한 인형 카운트를 추가한다.\r\n\r\n인형이 서로 다르다면, 삭제하지 않고 인형만 스택에 넣는다.\r\n\r\n<br />\r\n\r\n문제를 보다보면 *\"인형을 일단 다 뽑고 삭제는 마지막에 한꺼번에 하면 되지 않을까?\"*라고 생각하기 쉽지만, 실제로 이렇게 접근하면 더 어렵다.\r\n\r\n나중에 한꺼번에 삭제하게 되면, 인형을 삭제하는 순간 다른 인형이 연결될 가능성이 생기므로, 연결된 인형이 없을 때까지 반복적인 연산이 필요하다.\r\n\r\n예를 들어, `1 3 2 2 3`의 경우 동일하게 붙은 인형인 `2`를 삭제하면 `1 3 3`이 된다. `2`가 삭제되며 `3`이 붙어버리므로 반복적인 연산이 강제된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\nimport java.util.Stack;\r\n\r\n/**\r\n * 크레인 인형뽑기 게임 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.09 Thu 21:40:58\r\n */\r\nclass Solution\r\n{\r\n\tprivate final Stack<Integer> bag = new Stack<>();\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param board: [int[][]] 보드 크기\r\n\t * @param moves: [int[]] 크레인 작동 위치\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(int[][] board, int[] moves)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\t\r\n\t\tfor (int move : moves)\r\n\t\t{\r\n\t\t\tint j = move - 1;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < board.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 인형을 뽑을 경우\r\n\t\t\t\tif (board[i][j] > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 뽑은 인형이 있고, 마지막 인형과 방금 뽑은 인형이 동일할 경우\r\n\t\t\t\t\tif (!bag.isEmpty() && bag.peek() == board[i][j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbag.pop();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tanswer += 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 아닐 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbag.push(board[i][j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tboard[i][j] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```","url":["2021-12-14-programmers-a0005","2021","12","14","programmers-a0005"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 키패드 누르기 (67256)","excerpt":"스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다. 이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다. 맨 처음 왼손 엄지손가락은 `*`키패드에 오른손 엄지손가락은 `#`키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T12:46:59+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0004.md","content":"\r\n# 키패드 누르기\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [키패드 누르기](https://programmers.co.kr/learn/courses/30/lessons/67256)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b69a271-5f4a-4bf4-9ebf-6ebed5a02d8d/kakao_phone1.png)\r\n\r\n이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.\r\n맨 처음 왼손 엄지손가락은 `*`키패드에 오른손 엄지손가락은 `#`키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.\r\n\r\n1. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.\r\n2. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.\r\n3. 오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.\r\n4. 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.\r\n\t* 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.\r\n\r\n순서대로 누를 번호가 담긴 배열 `numbers`, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 `hand`가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `numbers` 배열의 크기는 1 이상 1,000 이하입니다.\r\n* `numbers` 배열 원소의 값은 0 이상 9 이하인 정수입니다.\r\n* `hand`는 \"left\" 또는 \"right\" 입니다.\r\n  * \"left\"는 왼손잡이, \"right\"는 오른손잡이를 의미합니다.\r\n* 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|              numbers              |  hand   |    result     |\r\n| :-------------------------------: | :-----: | :-----------: |\r\n| [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] | \"right\" | \"LRLLLRLLRRL\" |\r\n| [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] | \"left\"  | \"LRLLRRLLLRR\" |\r\n|  [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]   | \"right\" | \"LLRLLRLLRL\"  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다.\r\n\r\n| 왼손 위치 | 오른손 위치 | 눌러야 할 숫자 | 사용한 손 | 설명                                                             |\r\n| :-------: | :---------: | :------------: | :-------: | :--------------------------------------------------------------- |\r\n|     *     |      #      |       1        |     L     | 1은 왼손으로 누릅니다.                                           |\r\n|     1     |      #      |       3        |     R     | 3은 오른손으로 누릅니다.                                         |\r\n|     1     |      3      |       4        |     L     | 4는 왼손으로 누릅니다.                                           |\r\n|     4     |      3      |       5        |     L     | 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.      |\r\n|     5     |      3      |       8        |     L     | 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다.      |\r\n|     8     |      3      |       2        |     R     | 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다.    |\r\n|     8     |      2      |       1        |     L     | 1은 왼손으로 누릅니다.                                           |\r\n|     1     |      2      |       4        |     L     | 4는 왼손으로 누릅니다.                                           |\r\n|     4     |      2      |       5        |     R     | 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. |\r\n|     4     |      5      |       9        |     R     | 9는 오른손으로 누릅니다.                                         |\r\n|     4     |      9      |       5        |     L     | 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.      |\r\n|     5     |      9      |       -        |     -     |                                                                  |\r\n\r\n따라서 `LRLLLRLLRRL`를 return 합니다.\r\n\r\n**입출력 예 #2**\r\n\r\n왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 `LRLLRRLLLRR`이 됩니다.\r\n\r\n**입출력 예 #3**\r\n\r\n오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 `LLRLLRLLRL`이 됩니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n1, 4, 7은 왼손, 3, 6, 9는 오른손을 쓰면 되므로 큰 문제는 없지만, 2, 5, 8, 0은 누르려는 숫자와 가장 가까이 위치한 손을 써야한다.\r\n\r\n즉, 번호를 누를 때마다 왼손과 오른손의 위치를 기록하고, 2, 5, 8, 0 중 숫자가 나올 경우, 기록했던 각 손의 위치와 해당 숫자의 거리를 비교하여 계산한다.\r\n\r\n키패드를 구현하기 위해 2차원 배열을 구성한다.\r\n\r\n``` java\r\nprivate static final int[][] KEYPAD = new int[][] {\r\n\t\t{ 1, 2, 3 },\r\n\t\t{ 4, 5, 6 },\r\n\t\t{ 7, 8, 9 },\r\n\t\t{ -2, 0, -1 }\r\n};\r\n\r\nprivate int left = -2;\r\nprivate int right = -1;\r\n```\r\n\r\n키패드의 특수문자 `*`과 `#`은 각각 `-2`, `-1`로 다룬다.\r\n\r\n조건에 초기 각 손의 위치는 왼손 `*`, 오른손 `#`이므로, 초기 위치 또한 `-2`, `-1`로 지정한다.\r\n\r\n<br />\r\n<br />\r\n\r\n키패드의 위치를 계산할 수 있도록 메서드를 구성한다.\r\n\r\n``` java\r\nprivate int[] getPosition(int number)\r\n{\r\n\tint[] pos = new int[] { 0, 0 };\r\n\t\r\n\tfor (int i = 0; i < KEYPAD.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < KEYPAD[i].length; j++)\r\n\t\t{\r\n\t\t\tif (KEYPAD[i][j] == number)\r\n\t\t\t{\r\n\t\t\t\tpos[0] = i;\r\n\t\t\t\tpos[1] = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn pos;\r\n}\r\n```\r\n\r\n이중 배열을 탐색하여 입력한 키패드의 번호 `number`와 동일한 값을 가지는 배열의 인덱스를 반환한다.\r\n\r\n예를 들어, 키패드 5의 경우 `(1, 1)`의 위치를 가지며, 키패드 7의 경우 `(2, 0)`의 위치를 가진다.\r\n\r\n키패드 5와 7의 거리는 `|1 - 2| + |1 - 0| = 2`가 됨을 알 수 있다.\r\n\r\n``` java\r\nprivate int left = -2;\r\nprivate int right = -1;\r\n\r\nint[] lPos = getPosition(left);\r\nint[] rPos = getPosition(right);\r\nint[] toPos = getPosition(number);\r\n\r\nint lLength = Math.abs(lPos[0] - toPos[0]) + Math.abs(lPos[1] - toPos[1]);\r\nint rLength = Math.abs(rPos[0] - toPos[0]) + Math.abs(rPos[1] - toPos[1]);\r\n\r\n// 왼쪽 엄지가 더 가까울 경우\r\nif (lLength > rLength)\r\n{\r\n\t// 왼손 이동\r\n}\r\n\r\n// 오른쪽 엄지가 더 가까울 경우\r\nelse if (lLength < rLength)\r\n{\r\n\t// 오른손 이동\r\n}\r\n\r\n// 둘 다 동일할 경우\r\nelse\r\n{\r\n\t// 왼손잡이일 경우\r\n\tif (hand.equals(\"left\"))\r\n\t{\r\n\t\t// 왼손 이동\r\n\t}\r\n\t\r\n\t// 오른손잡이일 경우\r\n\telse\r\n\t{\r\n\t\t// 오른손 이동\r\n\t}\r\n}\r\n```\r\n\r\n만약 2, 5, 8, 0 중 하나에 해당하는 키패드가 입력되었을 경우, 위와 같이 구현할 수 있다.\r\n\r\n`lPos`, `rPos`는 왼손, 오른손의 위치이며, `toPos`는 이동해야할 키패드의 위치다.\r\n\r\n이를 통해 각 손과 키패드의 거리인 `lLength`, `rLength`를 계산하여 이를 비교하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 키패드 누르기 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.09 Thu 18:58:49\r\n */\r\nclass Solution\r\n{\r\n\tprivate static final int[][] KEYPAD = new int[][] {\r\n\t\t\t{ 1, 2, 3 },\r\n\t\t\t{ 4, 5, 6 },\r\n\t\t\t{ 7, 8, 9 },\r\n\t\t\t{ -2, 0, -1 }\r\n\t};\r\n\t\r\n\tprivate int left = -2;\r\n\tprivate int right = -1;\r\n\t\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param numbers: [int[]] 순서대로 누를 번호\r\n\t * @param hand: [String] 주 손잡이 (left, right)\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(int[] numbers, String hand)\r\n\t{\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int number : numbers)\r\n\t\t{\r\n\t\t\t// 왼쪽 번호일 경우\r\n\t\t\tif (number == 1 || number == 4 || number == 7)\r\n\t\t\t{\r\n\t\t\t\tleft = number;\r\n\t\t\t\t\r\n\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 오른쪽 번호일 경우\r\n\t\t\telse if (number == 3 || number == 6 || number == 9)\r\n\t\t\t{\r\n\t\t\t\tright = number;\r\n\t\t\t\t\r\n\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가운데 번호일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint[] lPos = getPosition(left);\r\n\t\t\t\tint[] rPos = getPosition(right);\r\n\t\t\t\tint[] toPos = getPosition(number);\r\n\t\t\t\t\r\n\t\t\t\tint lLength = Math.abs(lPos[0] - toPos[0]) + Math.abs(lPos[1] - toPos[1]);\r\n\t\t\t\tint rLength = Math.abs(rPos[0] - toPos[0]) + Math.abs(rPos[1] - toPos[1]);\r\n\t\t\t\t\r\n\t\t\t\t// 왼쪽 엄지가 더 가까울 경우\r\n\t\t\t\tif (lLength > rLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tright = number;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 오른쪽 엄지가 더 가까울 경우\r\n\t\t\t\telse if (lLength < rLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tleft = number;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 둘 다 동일할 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// 왼손잡이일 경우\r\n\t\t\t\t\tif (hand.equals(\"left\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tleft = number;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbuilder.append(\"L\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 오른손잡이일 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tright = number;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbuilder.append(\"R\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위치 반환 메서드\r\n\t *\r\n\t * @param number: [int] 키\r\n\t *\r\n\t * @return [int[]] 위치\r\n\t */\r\n\tprivate int[] getPosition(int number)\r\n\t{\r\n\t\tint[] pos = new int[] { 0, 0 };\r\n\t\t\r\n\t\tfor (int i = 0; i < KEYPAD.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < KEYPAD[i].length; j++)\r\n\t\t\t{\r\n\t\t\t\tif (KEYPAD[i][j] == number)\r\n\t\t\t\t{\r\n\t\t\t\t\tpos[0] = i;\r\n\t\t\t\t\tpos[1] = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn pos;\r\n\t}\r\n}\r\n```\r\n\r\n코드는 위와 같다.","url":["2021-12-14-programmers-a0004","2021","12","14","programmers-a0004"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 숫자 문자열과 영단어 (81301)","excerpt":"네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T11:21:04+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0003.md","content":"\r\n# 숫자 문자열과 영단어\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [숫자 문자열과 영단어](https://programmers.co.kr/learn/courses/30/lessons/81301)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n![image](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d31cb063-4025-4412-8cbc-6ac6909cf93e/img1.png)\r\n\r\n네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.\r\n\r\n다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\r\n\r\n* 1478 → `one4seveneight`\r\n* 234567 → `23four5six7`\r\n* 10203 → `1zerotwozero3`\r\n\r\n이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 `s`가 매개변수로 주어집니다. `s`가 의미하는 원래 숫자를 return 하도록 `solution` 함수를 완성해주세요.\r\n\r\n참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.\r\n\r\n| 숫자  | 영단어 |\r\n| :---: | :----: |\r\n|   0   |  zero  |\r\n|   1   |  one   |\r\n|   2   |  two   |\r\n|   3   | three  |\r\n|   4   |  four  |\r\n|   5   |  five  |\r\n|   6   |  six   |\r\n|   7   | seven  |\r\n|   8   | eight  |\r\n|   9   |  nine  |\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* 1 ≤ `s`의 길이 ≤ 50\r\n* `s`가 `zero` 또는 `0`으로 시작하는 경우는 주어지지 않습니다.\r\n* return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 `s`로 주어집니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|         s          | result |\r\n| :----------------: | :----: |\r\n|  `one4seveneight`  |  1478  |\r\n|   `23four5six7`    | 234567 |\r\n| `2three45sixseven` | 234567 |\r\n|       `123`        |  123   |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #3**\r\n\r\n\"three\"는 3, \"six\"는 6, \"seven\"은 7에 대응되기 때문에 정답은 **입출력 예 #2**와 같은 234567이 됩니다.\r\n\r\n**입출력 예 #2**와 **#3**과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\r\n\r\n**입출력 예 #4**\r\n\r\ns에는 영단어로 바뀐 부분이 없습니다.\r\n\r\n\r\n\r\n### 제한시간 안내\r\n\r\n* 정확성 테스트 : 10초\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n숫자의 영소문자를 전부 숫자로 변경하여, 최종적으로 `int` 형태로 반환하는 알고리즘을 구현해야한다.\r\n\r\n1. 문자열의 텍스트를 전부 숫자로 치환한다.\r\n2. 숫자화된 문자열을 `int`로 형변환한다.\r\n\r\n위 두 과정을 거치면 된다. 여러 방법이 있지만, 이왕 JAVA 쓰는거, `enum` 객체를 활용하여 구현하고자 한다.\r\n\r\n비교적 쉬운 로직에 생소한 패턴을 적용해보는 것도 연습에 도움이 된다.\r\n\r\n``` java\r\nprivate enum Number\r\n{\r\n\tZERO(\"0\"),\r\n\tONE(\"1\"),\r\n\tTWO(\"2\"),\r\n\tTHREE(\"3\"),\r\n\tFOUR(\"4\"),\r\n\tFIVE(\"5\"),\r\n\tSIX(\"6\"),\r\n\tSEVEN(\"7\"),\r\n\tEIGHT(\"8\"),\r\n\tNINE(\"9\");\r\n\t\r\n\tprivate final String num;\r\n\t\r\n\tNumber(String num)\r\n\t{\r\n\t\tthis.num = num;\r\n\t}\r\n\t\r\n\tpublic String getNum()\r\n\t{\r\n\t\treturn num;\r\n\t}\r\n}\r\n```\r\n\r\n`enum`은 위와 같이 설계한다. `Number.ONE.name().toLowerCase()`를 활용하여 `one` 문자열을 얻을 수 있다. 또한 `Number.ONE.getNum()`를 활용하여 이에 `one`에 매칭되는 숫자 `1`을 얻을 수 있다. 이 두 메서드를 활용하여 문자열을 치환한다.\r\n\r\n``` java\r\nfor (Number number : Number.values())\r\n{\r\n\tanswer = answer.replaceAll(number.name().toLowerCase(), number.getNum());\r\n}\r\n```\r\n\r\n`Number.values()`로 `Number`의 모든 요소를 배열 형태로 반환받을 수 있다. `for`문을 통해 각 숫자의 영문자에 해당하는 문자를 이에 매칭되는 숫자로 치환한다. `replaceAll`을 활용하여 해당하는 모든 문자들을 치환할 수 있다.\r\n\r\n`int` 변환은 `Integer.parseInt()` 메서드를 활용하자.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 숫자 문자열과 영단어 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.06 Thu 18:47:19\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param s: [String] 문자열\r\n\t *\r\n\t * @return [int] 해답\r\n\t */\r\n\tpublic int solution(String s)\r\n\t{\r\n\t\tString answer = s;\r\n\t\t\r\n\t\tfor (Number number : Number.values())\r\n\t\t{\r\n\t\t\tanswer = answer.replaceAll(number.name().toLowerCase(), number.getNum());\r\n\t\t}\r\n\t\t\r\n\t\treturn Integer.parseInt(answer);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 숫자 enum\r\n\t */\r\n\tprivate enum Number\r\n\t{\r\n\t\tZERO(\"0\"),\r\n\t\tONE(\"1\"),\r\n\t\tTWO(\"2\"),\r\n\t\tTHREE(\"3\"),\r\n\t\tFOUR(\"4\"),\r\n\t\tFIVE(\"5\"),\r\n\t\tSIX(\"6\"),\r\n\t\tSEVEN(\"7\"),\r\n\t\tEIGHT(\"8\"),\r\n\t\tNINE(\"9\");\r\n\t\t\r\n\t\tprivate final String num;\r\n\t\t\r\n\t\t/**\r\n\t\t * 생성자 메서드\r\n\t\t *\r\n\t\t * @param num: [String] 숫자\r\n\t\t */\r\n\t\tNumber(String num)\r\n\t\t{\r\n\t\t\tthis.num = num;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * 숫자 반환 메서드\r\n\t\t *\r\n\t\t * @return [String] 숫자\r\n\t\t */\r\n\t\tpublic String getNum()\r\n\t\t{\r\n\t\t\treturn num;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n`enum`이 싫다면 `Map`이나 배열 같이 친숙한 형태로도 구현할 수 있다.\r\n\r\n예를 들어, `int nums[] = new int[] { \"zero\", \"one\" ... \"nine\" };`과 같은 코드는 배열의 인덱스와 그 값을 통해 동일한 로직을 구성할 수 있다.\r\n\r\n`nums[0] = \"zero\"`이므로, 인덱스와 값을 적절히 사용하여 치환하는 것도 가능하다.","url":["2021-12-14-programmers-a0003","2021","12","14","programmers-a0003"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 신규 아이디 추천 (72410)","excerpt":"카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다. 다음은 카카오 아이디의 규칙입니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T09:11:28+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0002.md","content":"\r\n# 신규 아이디 추천\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [신규 아이디 추천](https://programmers.co.kr/learn/courses/30/lessons/72410)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.\r\n다음은 카카오 아이디의 규칙입니다.\r\n\r\n* 아이디의 길이는 3자 이상 15자 이하여야 합니다.\r\n* 아이디는 알파벳 소문자, 숫자, 빼기(`-`), 밑줄(`_`), 마침표(`.`) 문자만 사용할 수 있습니다.\r\n* 단, 마침표(`.`)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.\r\n\r\n\"네오\"는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.\r\n\r\n신규 유저가 입력한 아이디가 `new_id` 라고 한다면,\r\n\r\n* 1단계 `new_id`의 모든 대문자를 대응되는 소문자로 치환합니다.\r\n* 2단계 `new_id`에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\r\n* 3단계 `new_id`에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\r\n* 4단계 `new_id`에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\r\n* 5단계 `new_id`가 빈 문자열이라면, `new_id`에 \"a\"를 대입합니다.\r\n* 6단계 `new_id`의 길이가 16자 이상이면, `new_id`의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.  \r\n  만약 제거 후 마침표(.)가 `new_id`의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.\r\n* 7단계 `new_id`의 길이가 2자 이하라면, `new_id`의 마지막 문자를 `new_id`의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\r\n\r\n예를 들어, `new_id` 값이 `...!@BaT#*..y.abcdefghijklm` 라면, 위 7단계를 거치고 나면 `new_id`는 아래와 같이 변경됩니다.\r\n\r\n* 1단계 대문자 'B'와 'T'가 소문자 'b'와 't'로 바뀌었습니다.\r\n  * `...!@BaT#*..y.abcdefghijklm` → `...!@bat#*..y.abcdefghijklm`\r\n\r\n* 2단계 '!', '@', '#', '*' 문자가 제거되었습니다.\r\n  * `...!@bat#*..y.abcdefghijklm` → `...bat..y.abcdefghijklm`\r\n\r\n* 3단계 '...'와 '..' 가 '.'로 바뀌었습니다.\r\n  * `...bat..y.abcdefghijklm` → `.bat.y.abcdefghijklm`\r\n\r\n* 4단계 아이디의 처음에 위치한 '.'가 제거되었습니다.\r\n  * `.bat.y.abcdefghijklm` → `bat.y.abcdefghijklm`\r\n\r\n* 5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.\r\n  * `bat.y.abcdefghijklm` → `bat.y.abcdefghijklm`\r\n\r\n* 6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.\r\n  * `bat.y.abcdefghijklm` → `bat.y.abcdefghi`\r\n\r\n* 7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.\r\n  * `bat.y.abcdefghi` → `bat.y.abcdefghi`\r\n\r\n따라서 신규 유저가 입력한 `new_id`가 `...!@BaT#*..y.abcdefghijklm`일 때, 네오의 프로그램이 추천하는 새로운 아이디는 `bat.y.abcdefghi` 입니다.\r\n\r\n\r\n\r\n\r\n\r\n## 문제\r\n\r\n신규 유저가 입력한 아이디를 나타내는 `new_id`가 매개변수로 주어질 때, \"네오\"가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 `solution` 함수를 완성해 주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n`new_id`는 길이 1 이상 1,000 이하인 문자열입니다.\r\n\r\n`new_id`는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.\r\n\r\n`new_id`에 나타날 수 있는 특수문자는 `-_.~!@#$%^&*()=+[{]}:?,<>/` 로 한정됩니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|  no   |            new_id             |      result       |\r\n| :---: | :---------------------------: | :---------------: |\r\n|  예1  | `...!@BaT#*..y.abcdefghijklm` | `bat.y.abcdefghi` |\r\n|  예2  |           `z-+.^.`            |       `z--`       |\r\n|  예3  |             `=.=`             |       `aaa`       |\r\n|  예4  |          `123_.def`           |    `123_.def`     |\r\n|  예5  |      `abcdefghijklmn.p`       | `abcdefghijklmn`  |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제의 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n7단계를 거치는 동안 `new_id`가 변화하는 과정은 아래와 같습니다.\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 `z-+.^.` → `z-..`\r\n\r\n3단계 `z-..` → `z-.`\r\n\r\n4단계 `z-.` → `z-`\r\n\r\n5단계 변화 없습니다.\r\n\r\n6단계 변화 없습니다.\r\n\r\n7단계 `z-` → `z--`\r\n\r\n\r\n**입출력 예 #3**\r\n\r\n7단계를 거치는 동안 `new_id`가 변화하는 과정은 아래와 같습니다.\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 `=.=` → `.`\r\n\r\n3단계 변화 없습니다.\r\n\r\n4단계 `.` → `new_id`가 빈 문자열이 되었습니다.\r\n\r\n5단계 ` ` → `a`\r\n\r\n6단계 변화 없습니다.\r\n\r\n7단계 `a` → `aaa`\r\n\r\n\r\n**입출력 예 #4**\r\n\r\n1단계에서 7단계까지 거치는 동안 `new_id`(\"123_.def\")는 변하지 않습니다. 즉, `new_id`가 처음부터 카카오의 아이디 규칙에 맞습니다.\r\n\r\n**입출력 예 #5**\r\n\r\n1단계 변화 없습니다.\r\n\r\n2단계 변화 없습니다.\r\n\r\n3단계 변화 없습니다.\r\n\r\n4단계 변화 없습니다.\r\n\r\n5단계 변화 없습니다.\r\n\r\n6단계 `abcdefghijklmn.p` → `abcdefghijklmn.` → `abcdefghijklmn`\r\n\r\n7단계 변화 없습니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n문제에 각 단계별로 수행해야하는 로직이 제시되어 있으므로, 이를 메서드로 구분하여 설계하는 것이 적절해보인다.\r\n\r\n\r\n\r\n\r\n\r\n## 1단계 - 소문자 치환\r\n\r\n입력된 문자열을 소문자로 치환한다.\r\n\r\n``` java\r\nprivate String step1(String new_id)\r\n{\r\n\treturn new_id.toLowerCase();\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 2단계 - 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 문자 제거\r\n\r\n특정 문자만을 남기고 제외한다. 문자열을 `char[]`로 만들어 `for`문을 통해 비교하여 제거할 수도 있겠지만, 정규식을 활용하면 그보다 더 쉽고 간편하게 구현할 수 있다.\r\n\r\n``` java\r\nprivate String step2(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"[^a-z0-9-_.]\", \"\");\r\n}\r\n```\r\n\r\n* `[^]` - `[]` 내부에서 `^`는 부정(NOT)의 의미로 사용됨\r\n* `[a-z]` - 소문자 알파벳\r\n* `[0-9]` - 숫자\r\n\r\n`replaceAll`은 정규식을 사용할 수 있다. 위 정규식을 통해 영소문자, 숫자, 일부 특수문자에 해당하지 않는 숫자를 전부 지워버릴 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 3단계 - 두 개 이상 연속된 마침표(.)를 마침표 하나로 치환\r\n\r\n`...`이나 `....`을 전부 `.` 하나로 변경한다. 이 로직도 마찬가지로 정규식을 통해 쉽게 구현하자.\r\n\r\n``` java\r\nprivate String step3(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"\\\\.{2,}\", \".\");\r\n}\r\n```\r\n\r\n* `.{2,}` - 두 개 이상인 마침표\r\n\r\n`replaceAll`을 활용하여 마침표가 두 개 연속으로 이어진 문자열을 마침표 하나로 변경한다.\r\n\r\n\r\n\r\n\r\n\r\n## 4단계 - 마침표가 처음이나 끝에 위치할 경우 제거\r\n\r\n문자열 앞이나 뒤에 마침표가 있을 경우 제거한다.\r\n\r\n``` java\r\nprivate String step4(String new_id)\r\n{\r\n\treturn new_id.replaceAll(\"^[.]|[.]$\", \"\");\r\n}\r\n```\r\n\r\n* `^` - 문자열의 시작. `[]` 밖에서는 부정(NOT)이 아니다.\r\n* `$` - 문자열의 끝\r\n* `|` - OR 연산\r\n\r\n즉, 문자열 앞의 마침표나 문자열 끝의 마침표를 찾는 정규식이다. `replaceAll`을 활용하여 빈 문자로 치환하자.\r\n\r\n\r\n\r\n\r\n\r\n## 5단계 - 빈 문자열일 경우 a 대입\r\n\r\n문자열이 비었을 경우 `a`를 대입한다. 아닐 경우 그대로 둔다.\r\n\r\n``` java\r\nprivate String step5(String new_id)\r\n{\r\n\treturn new_id.equals(\"\") ? \"a\" : new_id;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 6단계 - 15자를 넘을 경우, 15자로 제한 후 4단계 적용\r\n\r\n글자수 제한과 동일한 개념이다. 단, 글자수를 자르면서 중간에 위치했던 마침표가 끝에 오게될 수도 있으므로, 4단계를 재젹용하라는 조건이 포함되어있다.\r\n\r\n예를 들어, 아이디 `aaaaaaaaaaaaaa.a`는 16글자로, 15자로 제한되면서 마침표가 끝에 오게 될 것이다.\r\n\r\n``` java\r\nprivate String step6(String new_id)\r\n{\r\n\treturn new_id.length() > 15 ? step4(new_id.substring(0, 15)) : new_id;\r\n}\r\n```\r\n\r\n`new_id`가 15자가 넘는다면, `substring` 메서드로 앞에서부터 15자까지 자른다. 이후 위에서 구현했던 `step4` 메서드를 호출하면 된다.\r\n\r\n이렇게 단계별로 메서드를 나누면 재사용에 유리하다.\r\n\r\n\r\n\r\n\r\n\r\n## 7단계 - 2자 이하일 경우, 3자가 될 때까지 마지막 글자 이어붙이기\r\n\r\n예를 들어, `ab`일 경우 글자가 3자가 될 때까지 마지막 글자 `b`를 이어붙인다. 결과는 `abb`가 될 것이다.\r\n\r\n``` java\r\nprivate String step7(String new_id)\r\n{\r\n\tint more = 3 - new_id.length();\r\n\t\r\n\t// 필요한 글자가 하나 이상 있을 경우\r\n\tif (more > 0)\r\n\t{\r\n\t\tchar last = new_id.charAt(new_id.length() - 1);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(new_id);\r\n\t\tbuilder.append(String.valueOf(last).repeat(more));\r\n\t\t\r\n\t\treturn builder.toString();\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\treturn new_id;\r\n\t}\r\n}\r\n```\r\n\r\n`more`로 3자가 되기 위해 필요한 자리수를 계산한다. 이후 `charAt`로 마지막 글자를 구한다.\r\n\r\n`repeat` 메서드로 해당 글자를 `more`만큼 반복한 뒤, `new_id`에 붙인다.\r\n\r\n문자열 연결 연산엔 개인적인 선호로 `StringBuilder`를 사용한다. `+`를 사용해도 결과를 도출하는데 지장은 없으니, 편한걸로 사용하면 된다.\r\n\r\n> **문자열 연결 연산(+)과 StringBuilder**  \r\n> JAVA에서 `String` 더하기 연산은 편하지만 상대적으로 메모리 소모가 심하다. `String`이 불변객체이므로, 연산 과정에서 새로운 객체를 생성하고, 해제하게된다.  \r\n> `StringBuilder`를 활용하면 우리가 생각했던대로 문자열을 연결하여 연산하므로 상대적으로 연산에 요구되는 자원이 적어진다.  \r\n> JAVA의 최적화 수준과 컴퓨터의 성능이 좋지 않았던 과거의 문제를 해결하기 위한 것으로, 물론 현재는 JAVA도 많은 최적화가 이루어졌고, 컴퓨터 성능은 수 천배로 좋아졌으니, 너무 연연하지 않아도 될 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 신규 아이디 추천 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.07 Tue 00:47:16\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 해답\r\n\t */\r\n\tpublic String solution(String new_id)\r\n\t{\r\n\t\tString answer = step1(new_id);\r\n\t\tanswer = step2(answer);\r\n\t\tanswer = step3(answer);\r\n\t\tanswer = step4(answer);\r\n\t\tanswer = step5(answer);\r\n\t\tanswer = step6(answer);\r\n\t\tanswer = step7(answer);\r\n\t\t\r\n\t\treturn answer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 1단계 결과 반환 메서드\r\n\t * 대문자를 모두 소문자로 치환\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 1단계 결과\r\n\t */\r\n\tprivate String step1(String new_id)\r\n\t{\r\n\t\treturn new_id.toLowerCase();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 2단계 결과 반환 메서드\r\n\t * 영문 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 문자 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 2단계 결과\r\n\t */\r\n\tprivate String step2(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"[^a-z0-9-_.]\", \"\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 3단계 결과 반환 메서드\r\n\t * 두번 이상 연속된 마침표 하나로 치환\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 3단계 결과\r\n\t */\r\n\tprivate String step3(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"\\\\.{2,}\", \".\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 4단계 결과 반환 메서드\r\n\t * 맨 앞이나 뒤에 마침표가 있을 경우 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 4단계 결과\r\n\t */\r\n\tprivate String step4(String new_id)\r\n\t{\r\n\t\treturn new_id.replaceAll(\"^[.]|[.]$\", \"\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 5단계 결과 반환 메서드\r\n\t * 빈 문자열일 경우 a 대입\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 5단계 결과\r\n\t */\r\n\tprivate String step5(String new_id)\r\n\t{\r\n\t\treturn new_id.equals(\"\") ? \"a\" : new_id;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 6단계 결과 반환 메서드\r\n\t * 16자 이상일 경우, 15자로 제한. 끝에 마침표가 오게 될 경우 제거\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 6단계 결과\r\n\t */\r\n\tprivate String step6(String new_id)\r\n\t{\r\n\t\treturn new_id.length() > 15 ? step4(new_id.substring(0, 15)) : new_id;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 7단계 결과 반환 메서드\r\n\t * 2자 이하일 경우, 길이가 3이 될 때까지 마지막 글자 이어붙이기\r\n\t *\r\n\t * @param new_id: [String] 새로운 아이디\r\n\t *\r\n\t * @return [String] 7단계 결과\r\n\t */\r\n\tprivate String step7(String new_id)\r\n\t{\r\n\t\tint more = 3 - new_id.length();\r\n\t\t\r\n\t\t// 필요한 글자가 하나 이상 있을 경우\r\n\t\tif (more > 0)\r\n\t\t{\r\n\t\t\tchar last = new_id.charAt(new_id.length() - 1);\r\n\t\t\t\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(new_id);\r\n\t\t\tbuilder.append(String.valueOf(last).repeat(more));\r\n\t\t\t\r\n\t\t\treturn builder.toString();\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn new_id;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n전체 코드는 위와 같다.\r\n\r\n정규식에 대한 기초적인 이해가 있다면 쉽게 풀 수 있지만, 그렇지 않다면 조금 귀찮은 과정을 거쳐야할 것이다.","url":["2021-12-14-programmers-a0002","2021","12","14","programmers-a0002"]},{"header":{"title":"[프로그래머스 / JAVA] Level 1 로또의 최고 순위와 최저 순위 (77484)","excerpt":"로또 6/45 (이하 '로또'로 표기)는 1부터 45까지 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T09:10:14+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0001.md","content":"\r\n# 로또의 최고 순위와 최저 순위\r\n\r\n|  랭크   |                                                      사용 언어                                                      |\r\n| :-----: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| Level 1 | ![JAVA](https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [로또의 최고 순위와 최저 순위](https://programmers.co.kr/learn/courses/30/lessons/77484)\r\n\r\n\r\n\r\n\r\n\r\n## 문제 설명\r\n\r\n로또 6/45 (이하 '로또'로 표기)는 1부터 45까지 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다.\r\n\r\n|   순위   |   당첨 내용   |\r\n| :------: | :-----------: |\r\n|    1     | 6개 번호 일치 |\r\n|    2     | 5개 번호 일치 |\r\n|    3     | 4개 번호 일치 |\r\n|    4     | 3개 번호 일치 |\r\n|    5     | 2개 번호 일치 |\r\n| 6 (낙첨) |     그 외     |\r\n\r\n로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.\r\n\r\n알아볼 수 없는 번호를 `0`으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 `44, 1, 0, 0, 31 25`라고 가정해보겠습니다. 당첨 번호 6개가 `31, 10, 45, 1, 6, 19`라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다.\r\n\r\n|   당첨 번호    |  31   |  10   |  45   |   1   |   6   |  19   |        결과        |\r\n| :------------: | :---: | :---: | :---: | :---: | :---: | :---: | :----------------: |\r\n| 최고 순위 번호 |  31   | 0→10  |  44   |   1   |  0→6  |  25   | 4개 번호 일치, 3등 |\r\n| 최저 순위 번호 |  31   | 0→11  |  44   |   1   |  0→7  |  25   | 2개 번호 일치, 5등 |\r\n\r\n* 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.\r\n* 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.\r\n  * 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.\r\n* 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.\r\n  * 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.\r\n\r\n민우가 구매한 로또 번호를 담은 배열 `lottos`, 당첨 번호를 담은 배열 `win_nums`가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.\r\n\r\n\r\n\r\n\r\n\r\n## 제한사항\r\n\r\n* `lottos`는 길이 6인 정수 배열입니다.\r\n* `lottos`의 모든 원소는 0 이상 45 이하인 정수입니다.\r\n  * 0은 알아볼 수 없는 숫자를 의미합니다.\r\n  * 0을 제외한 다른 숫자들은 `lottos`에 2개 이상 담겨있지 않습니다.\r\n  * `lottos`의 원소들은 정렬되어 있지 않을 수도 있습니다.\r\n* `win_nums`은 길이 6인 정수 배열입니다.\r\n* `win_nums`의 모든 원소는 1 이상 45 이하인 정수입니다.\r\n  * `win_nums`에는 같은 숫자가 2개 이상 담겨있지 않습니다.\r\n  * `win_nums`의 원소들은 정렬되어 있지 않을 수도 있습니다.\r\n\r\n\r\n\r\n\r\n\r\n## 입출력 예\r\n\r\n|        lottos         |         win_nums         | result |\r\n| :-------------------: | :----------------------: | :----: |\r\n| [44, 1, 0, 0, 31, 25] |  [31, 10, 45, 1, 6, 19]  | [3, 5] |\r\n|  [0, 0, 0, 0, 0, 0]   | [38, 19, 20, 40, 15, 25] | [1, 6] |\r\n| [45, 4, 35, 20, 3, 9] |  [20, 9, 3, 45, 4, 35]   | [1, 1] |\r\n\r\n\r\n\r\n### 입출력 예 설명\r\n\r\n**입출력 예 #1**\r\n\r\n문제 예시와 같습니다.\r\n\r\n**입출력 예 #2**\r\n\r\n알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다.\r\n\r\n|   당첨 번호    |  38   |  19   |  20   |  40   |  15   |  25   |        결과        |\r\n| :------------: | :---: | :---: | :---: | :---: | :---: | :---: | :----------------: |\r\n| 최고 순위 번호 | 0→38  | 0→19  | 0→20  | 0→40  | 0→15  | 0→25  | 6개 번호 일치, 1등 |\r\n| 최저 순위 번호 | 0→21  | 0→22  | 0→23  | 0→24  | 0→26  | 0→27  | 0개 번호 일치, 6등 |\r\n\r\n**입출력 예 #3**\r\n\r\n민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 풀이\r\n\r\n로또의 일부 번호가 지워져 있으며, 이 경우 가질 수 있는 가장 높은 등수와 낮은 등수를 구하는 문제.\r\n\r\n* **가장 높은 등수**\r\n  * 정확히 표시된 번호의 갯수 중 당첨된 갯수 + 지워진 번호의 갯수\r\n* **가장 낮은 등수**\r\n  * 정확히 표시된 번호의 갯수 중 당첨된 갯수\r\n\r\n즉, 정확히 표시된 번호 중 당첨된 번호와 지워진 번호를 구분하는 것이 관건이다. 이후 이 갯수를 연산하여 답을 도출할 수 있을 것이다.\r\n\r\n지워진 번호는 `0`으로 표시되므로, `0`일 경우 지워진 번호로 체크하고, 유효한 번호를 가질 경우 `win_nums`와 비교하여 당첨 여부를 확인한다.\r\n\r\n``` java\r\nfor (int lotto : lottos)\r\n{\r\n\t// 번호를 알아볼 수 있을 경우\r\n\tif (lotto > 0)\r\n\t{\r\n\t\tfor (int win_num : win_nums)\r\n\t\t{\r\n\t\t\t// 당첨된 번호일 경우\r\n\t\t\tif (lotto == win_num)\r\n\t\t\t{\r\n\t\t\t\t// 당첨된 번호 카운팅\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 없을 경우\r\n\telse\r\n\t{\r\n\t\t// 지워진 번호 카운팅\r\n\t}\r\n}\r\n```\r\n\r\n위와 같은 로직으로 구성하면 된다.\r\n\r\n\r\n\r\n\r\n\r\n## 코드\r\n\r\n``` java\r\n/**\r\n * 로또의 최고 순위와 최저 순위 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.12.06 Mon 23:35:13\r\n */\r\nclass Solution\r\n{\r\n\t/**\r\n\t * 해답 반환 메서드\r\n\t *\r\n\t * @param lottos: [int[]] 로또 번호\r\n\t * @param win_nums: [int[]] 당첨 번호\r\n\t *\r\n\t * @return [int[]] 해답\r\n\t */\r\n\tpublic int[] solution(int[] lottos, int[] win_nums)\r\n\t{\r\n\t\tint answer = 0;\r\n\t\tint zeros = 0;\r\n\t\t\r\n\t\tfor (int lotto : lottos)\r\n\t\t{\r\n\t\t\t// 번호를 알아볼 수 있을 경우\r\n\t\t\tif (lotto > 0)\r\n\t\t\t{\r\n\t\t\t\tfor (int win_num : win_nums)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 당첨된 번호일 경우\r\n\t\t\t\t\tif (lotto == win_num)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tanswer++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 없을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tzeros++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { prize(answer + zeros), prize(answer) };\r\n\t}\r\n\t\r\n\t/**\r\n\t * 순위 반환 메서드\r\n\t *\r\n\t * @param num: [int] 당첨 갯수\r\n\t *\r\n\t * @return [int] 등수\r\n\t */\r\n\tprivate int prize(int num)\r\n\t{\r\n\t\treturn switch (num)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 6 -> 1;\r\n\t\t\t\t\tcase 5 -> 2;\r\n\t\t\t\t\tcase 4 -> 3;\r\n\t\t\t\t\tcase 3 -> 4;\r\n\t\t\t\t\tcase 2 -> 5;\r\n\t\t\t\t\tdefault -> 6;\r\n\t\t\t\t};\r\n\t}\r\n}\r\n```\r\n\r\n코드는 위와 같다. 당첨된 번호를 `answer`에 카운팅하고, 지워진 번호를 `zeros`에 카운팅한다.\r\n\r\n이후 가장 높은 등수 `answer + zeros`, 가장 낮은 등수 `answer`를 계산하여 배열로 반환한다.\r\n\r\n등수는 `prize` 메서드를 사용하여 얻는다.","url":["2021-12-14-programmers-a0001","2021","12","14","programmers-a0001"]}],"data":{"header":{"title":"[프로그래머스 / JAVA] Level 1 소수 만들기 (12977)","excerpt":"0부터 9까지의 숫자 중 일부가 들어있는 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.","coverImage":"https://user-images.githubusercontent.com/50317129/145976356-6b5d1430-31c0-4c34-829e-6be8f747ab19.png","date":"2021-12-14T19:06:57+09:00","type":"posts","category":"Programmers","tag":["프로그래머스","알고리즘","JAVA(자바)","Level 1"],"group":"프로그래머스","comment":true,"publish":true},"name":"2021-12-14-programmers-a0009.md","content":"<h1 id=\"소수-만들기\">소수 만들기 <a href=\"#소수-만들기\">🔗</a></h1>\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">랭크</th>\n<th align=\"center\">사용 언어</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">Level 1</td>\n<td align=\"center\"><img src=\"https://shields.io/badge/java-JDK%2011-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange\" alt=\"JAVA\"></td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>🔗 <a href=\"https://programmers.co.kr/learn/courses/30/lessons/12977\" target=\"_blank\">소수 만들기</a></p>\n<h2 id=\"문제-설명\">문제 설명 <a href=\"#문제-설명\">🔗</a></h2><p>주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 <code class=\"inline-code\">nums</code>가 매개변수로 주어질 때, <code class=\"inline-code\">nums</code>에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 <code class=\"inline-code\">solution</code> 함수를 완성해주세요.</p>\n<h2 id=\"제한사항\">제한사항 <a href=\"#제한사항\">🔗</a></h2><ul>\n<li><code class=\"inline-code\">nums</code>에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.</li>\n<li><code class=\"inline-code\">nums</code>의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.</li>\n</ul>\n<h2 id=\"입출력-예\">입출력 예 <a href=\"#입출력-예\">🔗</a></h2>\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">nums</th>\n<th align=\"center\">result</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">{ 1, 2, 3, 4 }</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">{ 1, 2, 7, 6, 4 }</td>\n<td align=\"center\">4</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<h3 id=\"입출력-예 설명\">입출력 예 설명 <a href=\"#입출력-예 설명\">🔗</a></h3><p><strong>입출력 예 #1</strong></p>\n<p>[1,2,4]를 이용해서 7을 만들 수 있습니다.</p>\n<p><strong>입출력 예 #2</strong></p>\n<p>[1,2,4]를 이용해서 7을 만들 수 있습니다.</p>\n<p>[1,4,6]을 이용해서 11을 만들 수 있습니다.</p>\n<p>[2,4,7]을 이용해서 13을 만들 수 있습니다.</p>\n<p>[4,6,7]을 이용해서 17을 만들 수 있습니다.</p>\n<h1 id=\"풀이\">풀이 <a href=\"#풀이\">🔗</a></h1><p>배열에서 임의의 요소 3가지를 선택하여 해당 수의 합이 소수가 되는 경우의 수를 구하는 문제.</p>\n<ol>\n<li>임의의 요소 3가지 선택</li>\n<li>요소의 합의 소수 여부 판별</li>\n</ol>\n<p>이 두 로직을 구현하는 것이 알고리즘의 핵심이다.</p>\n<p>보통 조합을 이용하지만, 간단하게 중첩 <code class=\"inline-code\">for</code>문을 사용해 구현해보자.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>        <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>            <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>임의의 세 가지 요소는 이와 같이 3중첩 <code class=\"inline-code\">for</code>문을 통해 구할 수 있다. <code class=\"inline-code\">j</code>, <code class=\"inline-code\">k</code>의 인덱스를 유심히 살펴보자. 각 인덱스가 겹치지 않게끔 초기값이 구성되어있다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPrime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>        <span class=\"token comment\" data-tag=\"new\">// 나눠 떨어질 경우</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">%</span> i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>        <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>    </td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11>    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>소수는 이와 같이 구할 수 있다. 굳이 <code class=\"inline-code\">Math.sqrt(num)</code> 까지만 연산히는 이유는, 제곱근 이후로는 연산할 필요가 없다.</p>\n<p>예를 들어, 12의 경우 <code class=\"inline-code\">1, 2, 3, 4, 6, 12</code>의 약수를 가지는데, <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.13278em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">12</span></span></span><span style=\"top:-2.86722em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span></span></span></span>는 대략 3이다. 3 이후의 숫자인 4, 6은 각각 2와 3과 곱해져서 12를 만들게 되므로, 제곱근 이전에 나누어 떨어지는 수가 없다면 그 수는 소수라 봐도 무방하다.</p>\n<h2 id=\"코드\">코드 <a href=\"#코드\">🔗</a></h2>\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token comment\" data-tag=\"new\"> * 소수 만들기 클래스</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token comment\" data-tag=\"new\"> *</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3><span class=\"token comment\" data-tag=\"new\"> * @author RWB</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token comment\" data-tag=\"new\"> * @since 2021.12.10 Fri 00:21:09</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5><span class=\"token comment\" data-tag=\"new\"> */</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token comment\" data-tag=\"new\">     * 해답 반환 메서드</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11><span class=\"token comment\" data-tag=\"new\">     * @param nums: [int[]] 숫자 배열</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13><span class=\"token comment\" data-tag=\"new\">     * @return [int] 소수가 되는 경우의 수</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>        <span class=\"token keyword\">int</span> answer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>        </td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20>        <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21>            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=22><td class=\"line-number\" data-number=\"22\">22</td><td class=\"line-code\" data-number=22>            <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=23><td class=\"line-number\" data-number=\"23\">23</td><td class=\"line-code\" data-number=23>                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=24><td class=\"line-number\" data-number=\"24\">24</td><td class=\"line-code\" data-number=24>                <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=25><td class=\"line-number\" data-number=\"25\">25</td><td class=\"line-code\" data-number=25>                    <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=26><td class=\"line-number\" data-number=\"26\">26</td><td class=\"line-code\" data-number=26>                    </td></tr>\n<tr data-number=27><td class=\"line-number\" data-number=\"27\">27</td><td class=\"line-code\" data-number=27>                    answer <span class=\"token operator\">+=</span> <span class=\"token function\">isPrime</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=28><td class=\"line-number\" data-number=\"28\">28</td><td class=\"line-code\" data-number=28>                <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=29><td class=\"line-number\" data-number=\"29\">29</td><td class=\"line-code\" data-number=29>            <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=30><td class=\"line-number\" data-number=\"30\">30</td><td class=\"line-code\" data-number=30>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=31><td class=\"line-number\" data-number=\"31\">31</td><td class=\"line-code\" data-number=31>        </td></tr>\n<tr data-number=32><td class=\"line-number\" data-number=\"32\">32</td><td class=\"line-code\" data-number=32>        <span class=\"token keyword\">return</span> answer<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=33><td class=\"line-number\" data-number=\"33\">33</td><td class=\"line-code\" data-number=33>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=34><td class=\"line-number\" data-number=\"34\">34</td><td class=\"line-code\" data-number=34>    </td></tr>\n<tr data-number=35><td class=\"line-number\" data-number=\"35\">35</td><td class=\"line-code\" data-number=35>    <span class=\"token comment\" data-tag=\"new\">/**</span></td></tr>\n<tr data-number=36><td class=\"line-number\" data-number=\"36\">36</td><td class=\"line-code\" data-number=36><span class=\"token comment\" data-tag=\"new\">     * 소수 여부 반환 메서드</span></td></tr>\n<tr data-number=37><td class=\"line-number\" data-number=\"37\">37</td><td class=\"line-code\" data-number=37><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=38><td class=\"line-number\" data-number=\"38\">38</td><td class=\"line-code\" data-number=38><span class=\"token comment\" data-tag=\"new\">     * @param num: [int] 숫자</span></td></tr>\n<tr data-number=39><td class=\"line-number\" data-number=\"39\">39</td><td class=\"line-code\" data-number=39><span class=\"token comment\" data-tag=\"new\">     *</span></td></tr>\n<tr data-number=40><td class=\"line-number\" data-number=\"40\">40</td><td class=\"line-code\" data-number=40><span class=\"token comment\" data-tag=\"new\">     * @return [boolean] 소수 여부</span></td></tr>\n<tr data-number=41><td class=\"line-number\" data-number=\"41\">41</td><td class=\"line-code\" data-number=41><span class=\"token comment\" data-tag=\"new\">     */</span></td></tr>\n<tr data-number=42><td class=\"line-number\" data-number=\"42\">42</td><td class=\"line-code\" data-number=42>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPrime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=43><td class=\"line-number\" data-number=\"43\">43</td><td class=\"line-code\" data-number=43>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=44><td class=\"line-number\" data-number=\"44\">44</td><td class=\"line-code\" data-number=44>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=45><td class=\"line-number\" data-number=\"45\">45</td><td class=\"line-code\" data-number=45>        <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=46><td class=\"line-number\" data-number=\"46\">46</td><td class=\"line-code\" data-number=46>            <span class=\"token comment\" data-tag=\"new\">// 나눠 떨어질 경우</span></td></tr>\n<tr data-number=47><td class=\"line-number\" data-number=\"47\">47</td><td class=\"line-code\" data-number=47>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">%</span> i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=48><td class=\"line-number\" data-number=\"48\">48</td><td class=\"line-code\" data-number=48>            <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=49><td class=\"line-number\" data-number=\"49\">49</td><td class=\"line-code\" data-number=49>                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=50><td class=\"line-number\" data-number=\"50\">50</td><td class=\"line-code\" data-number=50>            <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=51><td class=\"line-number\" data-number=\"51\">51</td><td class=\"line-code\" data-number=51>        <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=52><td class=\"line-number\" data-number=\"52\">52</td><td class=\"line-code\" data-number=52>        </td></tr>\n<tr data-number=53><td class=\"line-number\" data-number=\"53\">53</td><td class=\"line-code\" data-number=53>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=54><td class=\"line-number\" data-number=\"54\">54</td><td class=\"line-code\" data-number=54>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=55><td class=\"line-number\" data-number=\"55\">55</td><td class=\"line-code\" data-number=55><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t","url":["2021-12-14-programmers-a0009","2021","12","14","programmers-a0009"],"toc":[{"text":"소수 만들기","tag":"소수-만들기","depth":1},{"text":"문제 설명","tag":"문제-설명","depth":2},{"text":"제한사항","tag":"제한사항","depth":2},{"text":"입출력 예","tag":"입출력-예","depth":2},{"text":"입출력 예 설명","tag":"입출력-예 설명","depth":3},{"text":"풀이","tag":"풀이","depth":1},{"text":"코드","tag":"코드","depth":2}]},"hash":"04cc14e4bf2"},"__N_SSG":true}