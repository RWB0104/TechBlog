{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 8. 프로세스 구현하기","excerpt":"4장부터 7장까지 진행하며 각 플랫폼의 인증 모듈을 구현했다. 이 장에서는 모듈을 사용하는 주체인 프로세스를 구현한다. 프로세스는 HTTP 메소드에 따라 구분하여 관리한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-24T23:58:10","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":"trueㄴ","publish":true},"name":"2021-10-24-oauth2-java-server-8.md","content":"\r\n# 개요\r\n\r\n4장부터 7장까지 진행하며 각 플랫폼의 인증 모듈을 구현했다. 이 장에서는 모듈을 사용하는 주체인 프로세스를 구현한다.\r\n\r\n프로세스는 HTTP 메소드에 따라 구분하여 관리한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 구조\r\n\r\n계정 관련 동작 이외엔 없으므로, 대분류는 `account` 하나 뿐이다.\r\n\r\n작업에 필요한 HTTP 메소는 `GET`, `POST`, `PUT`, `DELETE`이므로, 아래와 같이 구분한다.\r\n\r\n* `AccountGetProcess` - 계정 GET 프로세스 클래스\r\n* `AccountPostProcess` - 계정 POST 프로세스 클래스\r\n* `AccountPutProcess` - 계정 PUT 프로세스 클래스\r\n* `AccountDeleteProcess` - 계정 DELETE 프로세스 클래스\r\n\r\n`GET` 메소드에 사용하는 로직은 `AccountGetProcess`에 포함되는 식으로 구성한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 프로세스 구현\r\n\r\n\r\n\r\n\r\n\r\n## Process 추상 클래스 구현\r\n\r\n여러 프로세스에 공통 로직을 적용하기 위해, 모든 프로세스 객체에 상속할 Process 추상 클래스를 구현한다.\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport oauth.account.module.AuthModule;\r\nimport oauth.account.module.GithubAuthModule;\r\nimport oauth.account.module.GoogleAuthModule;\r\nimport oauth.account.module.KakaoAuthModule;\r\nimport oauth.account.module.NaverAuthModule;\r\n\r\n/**\r\n * 프로세스 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.30 Thu 01:14:25\r\n */\r\nabstract public class Process\r\n{\r\n\tprotected HttpServletRequest request;\r\n\tprotected HttpServletResponse response;\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletResponse 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tprotected Process(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tthis.request = request;\r\n\t\tthis.response = response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 모듈 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [AuthModule] AuthModule 객체\r\n\t *\r\n\t * @throws NullPointerException 유효하지 않은 플랫폼\r\n\t */\r\n\tprotected AuthModule getAuthModule(String platform) throws NullPointerException\r\n\t{\r\n\t\treturn switch (platform)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase \"naver\" -> NaverAuthModule.getInstance();\r\n\t\t\t\t\tcase \"google\" -> GoogleAuthModule.getInstance();\r\n\t\t\t\t\tcase \"kakao\" -> KakaoAuthModule.getInstance();\r\n\t\t\t\t\tcase \"github\" -> GithubAuthModule.getInstance();\r\n\t\t\t\t\tdefault -> throw new NullPointerException(Util.builder(\"'\", platform, \"' is invalid platform\"));\r\n\t\t\t\t};\r\n\t}\r\n}\r\n```\r\n\r\n서블릿 객체인 `HttpServletRequest`, `HttpServletResponse`에 쉽게 접근하기 위해 `protected` 접근 제어자로 각 지역변수를 선언한다.\r\n\r\n생성자 사용 시 반드시 `HttpServletRequest`, `HttpServletResponse`를 인수로 주도록 강제한다.\r\n\r\n이를 통해 `Process`를 상속하는 모든 하위 프로세스 클래스는 반드시 서블릿 객체를 인수로 받아야하며, 프로세스 내부에서 `request`, `response`로 서블릿 객체에 접근할 수 있다.\r\n\r\n<br />\r\n\r\n`getAuthModule`은 <span class=\"primary\">각 플랫폼 이름에 따라 해당하는 인스턴스를 반환</span>하는 메서드다. 인증 모듈은 주로 프로세스에서 많이 사용하게 되므로, `Process`에 선언하여 이를 상속하는 모든 프로세스 클래스가 해당 메서드에 접근할 수 있도록 구성한다.\r\n\r\n이러한 구성으로 동일한 프로세스에서 플랫폼별로 `AuthModule` 객체를 호출하여 플랫폼별로 선언한 메서드를 사용할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## GET 프로세스 구현\r\n\r\n계정 프로세스 중 `GET`에 해당하는 동작이 집합된 프로세스 클래스를 구현한다.\r\n\r\n* 인증 URL 응답 반환 메서드\r\n* 사용자 정보 응답 반환 메서드\r\n\r\n`GET`에 해당하는 동작은 위 두 메서드다. 단순히 데이터를 받아오는 작업들로 구성되어있다.\r\n\r\n\r\n\r\n### 인증 URL 응답 반환 메서드\r\n\r\n<span class=\"primary\">플랫폼 로그인을 위한 인증 URL을 반환</span>하는 메서드다.\r\n\r\n`AuthModule`의 `getAuthorizationUrl` 메서드를 통해 URL를 얻고, 이 내용을 담아 응답 객체로 만들어 반환한다.\r\n\r\n``` java\r\npublic Response getAuthorizationUrlResponse(String platform)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\r\n\t// 인증 URL 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tString state = UUID.randomUUID().toString();\r\n\t\t\r\n\t\trequest.getSession().setAttribute(\"state\", state);\r\n\t\t\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(Util.builder(platform, \" authrorization url response success\"));\r\n\t\tresponseBean.setBody(authModule.getAuthorizationUrl(state));\r\n\t\t\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\n동일한 세션인지 확인하기 위해 프로세스 수행 시 `state`를 생성하여 `getAuthorizationUrl`에 전달한다. 해당 메서드가 반환하는 URL에 전달한 `state`가 URL 파라미터로 입력되어있을 것이다.\r\n\r\n해당 `state`를 세션 애트리뷰트에도 등록한다.\r\n\r\n플랫폼 로그인은 여러 창을 거치기 때문에, 요청 하이재킹이 매우 쉽다. 이 과정에서 세션 정보가 손상되기 쉬우므로 `state`를 통해 로그인 과정 전체가 동일한 세션에서 이루어지고 있는지 검증할 수 있다.\r\n\r\n만약 URL의 `state`와 세션의 `state`가 일치하지 않거나, 세션 정보가 아예 없다면 정상적인 로그인 절차가 아니라고 판단할 수 있다.\r\n\r\n추후 이 세션값은 Access Token을 받아 로그인 작업을 수행할 때 사용한다.\r\n\r\n\r\n\r\n### 사용자 정보 응답 반환 메서드\r\n\r\n<span class=\"primary\">Access Token을 통해 사용자 응답</span>을 받는 메서드다.\r\n\r\n`AuthModule`의 `getUserInfoBean` 메서드를 통해 `UserInfoBean` 객체를 얻고, 이 내용을 담아 응답 객체로 만들어 반환한다.\r\n\r\n``` java\r\npublic Response getUserInfoResponse(String accessCookie)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<UserInfoBean> responseBean = new ResponseBean<>();\r\n\t\r\n\t// 사용자 정보 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\r\n\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\r\n\t\tcom.github.scribejava.core.model.Response userInfoResponse = authModule.getUserInfo(accessToken);\r\n\t\t\r\n\t\t// 응답이 정상적이지 않을 경우\r\n\t\tif (userInfoResponse.getCode() != 200)\r\n\t\t{\r\n\t\t\tthrow new OAuthResponseException(userInfoResponse);\r\n\t\t}\r\n\t\t\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(\"user info response success\");\r\n\t\tresponseBean.setBody(authModule.getUserInfoBean(userInfoResponse.getBody()));\r\n\t\t\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\n추후 설명하겠지만, <span class=\"green-600\">로그인 시 Access Token과 Refresh Token을 각각 플랫폼과 함께 JWT로 생성</span>하여 access, refresh 쿠키로 저장한다.\r\n\r\n각 JWT 쿠키에 플랫폼 정보가 있으므로, access 쿠키만 있어도 Access Token와 그 플랫폼을 찾을 수 있다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport com.github.scribejava.core.model.OAuthResponseException;\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport global.module.Util;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.bean.UserInfoBean;\r\nimport oauth.account.module.AuthModule;\r\n\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 계정 GET 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.30 Thu 21:00:48\r\n */\r\npublic class AccountGetProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountGetProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 URL 응답 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response getAuthorizationUrlResponse(String platform)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 인증 URL 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tString state = UUID.randomUUID().toString();\r\n\t\t\t\r\n\t\t\trequest.getSession().setAttribute(\"state\", state);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(Util.builder(platform, \" authrorization url response success\"));\r\n\t\t\tresponseBean.setBody(authModule.getAuthorizationUrl(state));\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response getUserInfoResponse(String accessCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<UserInfoBean> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 사용자 정보 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\t\r\n\t\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tcom.github.scribejava.core.model.Response userInfoResponse = authModule.getUserInfo(accessToken);\r\n\t\t\t\r\n\t\t\t// 응답이 정상적이지 않을 경우\r\n\t\t\tif (userInfoResponse.getCode() != 200)\r\n\t\t\t{\r\n\t\t\t\tthrow new OAuthResponseException(userInfoResponse);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"user info response success\");\r\n\t\t\tresponseBean.setBody(authModule.getUserInfoBean(userInfoResponse.getBody()));\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## POST 프로세스 구현\r\n\r\n계정 프로세스 중 `POST`에 해당하는 동작이 집합된 프로세스 클래스를 구현한다.\r\n\r\n* 로그인 응답 반환 메서드\r\n* 자동 로그인 응답 반환 메서드\r\n* 로그아웃 응답 반환 메서드\r\n\r\n`POST`에 해당하는 동작은 위 두 메서드다. 주로 로그인/로그아웃 작업으로 구성되어있다.\r\n\r\n\r\n\r\n### 로그인 응답 반환 메서드\r\n\r\n플랫폼 로그인 이후 발급되는 `code`를 통해 <span class=\"primary\">Access Token으로 교환하여 로그인을 수행</span>하는 메서드다.\r\n\r\n`AuthModule`의 `getAccessToken` 메서드를 통해 `OAuth2AccessToken` 객체를 반환받아 Access Token, Refresh Token을 추출한다.\r\n\r\n이 토큰들을 JWT 쿠키로 만들어 로그인 절차를 수행한다.\r\n\r\n``` java\r\npublic Response postLoginResponse(String platform, String code, String state)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\r\n\tHttpSession session = request.getSession();\r\n\t\r\n\t// 로그인 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tObject sessionState = Objects.requireNonNull(session.getAttribute(\"state\"));\r\n\t\t\r\n\t\t// 고유 상태값이 일치하지 않을 경우\r\n\t\tif (!state.equals(sessionState))\r\n\t\t{\r\n\t\t\tthrow new BadAttributeValueExpException(\"state is mismatched\");\r\n\t\t}\r\n\t\t\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\r\n\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getAccessToken(code);\r\n\t\t\r\n\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\tString refreshToken = oAuth2AccessToken.getRefreshToken();\r\n\t\t\r\n\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\taccessMap.put(\"access\", accessToken);\r\n\t\taccessMap.put(\"platform\", platform);\r\n\t\t\r\n\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\r\n\t\tString accessJwt = JwtModule.generateJwt(state, accessMap);\r\n\t\tString refreshJwt = JwtModule.generateJwt(state, refreshMap);\r\n\t\t\r\n\t\tNewCookie accessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", refreshToken == null ? 0 : 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(\"authorized success\");\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\t// 시도 후\r\n\tfinally\r\n\t{\r\n\t\tsession.invalidate();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\n`AccountGetProcess`의 `getAuthorizationUrlResponse` 동작 중 세션 애트리뷰트에 `state`를 입력했었는데, 여기서 그 <span class=\"orange-500\">세션값을 통해 검증을 수행</span>한다.\r\n\r\nURL을 통해 인수로 받은 `state`와 세션의 `state`를 추출하여 비교하고, 동일하지 않을 경우 예외를 발생시킨다. 중간에 URL을 탈취해서 전혀 다른 `code`를 삽입하여 요청을 보내도 이를 방지할 수 있는 보안책인 셈이다.\r\n\r\nAccess Token과 Refresh Token을 전달받아 JWT 쿠키로 만든다.\r\n\r\n<br />\r\n\r\n* Access Token JWT\r\n\r\n``` json\r\n{\r\n\t\"iss\": \"oauth2\",\r\n\t\"sub\": \"auth\",\r\n\t\"aud\": \"c9159786-40bf-4cf2-8c93-f683d1070137\",\r\n\t\"access\": \"{ACCESS_TOKEN}\",\r\n\t\"platform\": \"naver\",\r\n\t\"exp\": 1634986011,\r\n\t\"nbf\": 1634982411,\r\n\t\"iat\": 1634982411,\r\n\t\"jti\": \"c9159786-40bf-4cf2-8c93-f683d1070137\"\r\n}\r\n```\r\n\r\n* Refresh Token JWT\r\n\r\n``` json\r\n{\r\n\t\"iss\": \"oauth2\",\r\n\t\"sub\": \"auth\",\r\n\t\"aud\": \"c9159786-40bf-4cf2-8c93-f683d1070137\",\r\n\t\"refresh\": \"{REFRESH_TOKEN}\",\r\n\t\"platform\": \"naver\",\r\n\t\"exp\": 1634986011,\r\n\t\"nbf\": 1634982411,\r\n\t\"iat\": 1634982411,\r\n\t\"jti\": \"c9159786-40bf-4cf2-8c93-f683d1070137\"\r\n}\r\n```\r\n\r\n<br />\r\n\r\nJWT의 내용은 위와 같다. 쿠키에 해당 JWT를 담아 생성한다. <span class=\"green-400\">access 쿠키는 세션 쿠키로 생성하여 브라우저 종료 시 즉시 쿠키가 즉시 소멸</span>되도록 구성하고, <span class=\"green-400\">refresh 쿠키는 어느 정도 보관기간을 두어 추후 다시 사용할 수 있도록 구성</span>한다.\r\n\r\n쿠키 도메인은 `.itcode.dev`로 지정되어있는데, 그 이유는 프론트엔드와 백엔드가 전혀 다른 환경에서 동작하기 때문이다.\r\n\r\n* Frontend - `project.itcode.dev`\r\n* Backend - `api.itcode.dev`\r\n\r\n브라우저의 보안정책으로 다른 도메인에 쿠키를 생성할 수 없다. 때문에 `.itcode.dev`로 지정하여 모든 서브 도메인에 적용하도록 구성했다.\r\n\r\n만약 도메인을 지정하지 않으면 자동으로 `api.itcode.dev`를 대상으로 쿠키를 발급한다. 따라서 `project.itcode.dev` 도메인 서비스에서는 쿠키에 접근할 수 없다.\r\n\r\n\r\n\r\n### 자동 로그인 응답 반환 메서드\r\n\r\n만약 이전에 로그인을 수행한 이력이 있어, <span class=\"primary\">access, refresh 쿠키를 이미 가지고 있을 경우 이를 활용하여 자동 로그인을 수행</span>하는 메서드다.\r\n\r\n``` java\r\npublic Response postAutoLoginResponse(String accessCookie, String refreshCookie)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\r\n\t// 자동 로그인 시도\r\n\ttry\r\n\t{\r\n\t\t// 접근 토큰 쿠키가 있을 경우\r\n\t\tif (accessCookie != null)\r\n\t\t{\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 리프레쉬 토큰 쿠키가 없을 경우\r\n\t\telse if (refreshCookie == null)\r\n\t\t{\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(\"fail\");\r\n\t\t\tresponseBean.setMessage(\"refresh token is empty\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 리프레쉬 토큰 쿠키가 있을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tJws<Claims> refreshJws = JwtModule.openJwt(refreshCookie);\r\n\t\t\t\r\n\t\t\tString refreshToken = refreshJws.getBody().get(\"refresh\", String.class);\r\n\t\t\tString platform = refreshJws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getRefreshAccessToken(refreshToken);\r\n\t\t\t\r\n\t\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\t\taccessMap.put(\"access\", accessToken);\r\n\t\t\taccessMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tString uuid = UUID.randomUUID().toString();\r\n\t\t\t\r\n\t\t\tString accessJwt = JwtModule.generateJwt(uuid, accessMap);\r\n\t\t\tString refreshJwt = JwtModule.generateJwt(uuid, refreshMap);\r\n\t\t\t\r\n\t\t\tNewCookie newAccessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tNewCookie newAccessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\naccess 쿠키가 이미 있을 경우, 이미 인증 정보가 있기 때문에 별다른 동작을 취하지 않고 넘어간다.\r\n\r\n만약 access 쿠키는 없고 <span class=\"orange-400\">refresh 쿠키만 있다면, 이를 통해 Access Token을 재발급받아 인증 정보를 갱신</span>하여 자동으로 로그인을 수행한다.\r\n\r\n로그인 로직 자체는 기존 로그인 메서드와 동일하며, Access Token만 Refresh Token을 통해 갱신하여 사용한다.\r\n\r\n\r\n\r\n### 로그아웃 응답 반환 메서드\r\n\r\n<span class=\"primary\">인증 정보를 제거</span>하여 로그아웃을 수행하는 메서드.\r\n\r\n``` java\r\npublic Response postLogoutResponse()\r\n{\r\n\tResponse response;\r\n\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\r\n\t// 로그아웃 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tNewCookie accessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(\"logout success\");\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t}\r\n\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\treturn response;\r\n}\r\n```\r\n\r\n인증정보는 쿠키 기반이다. 서버에서 쿠키 생성 시 보안을 위해 `HttpOnly` 옵션을 활성화했기 때문에 JavaScript에선 access, refresh 쿠키를 다룰 수 없다.\r\n\r\n서버에서 쿠키 만료시간을 0으로 덮어씌워 인증쿠키를 제거한다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport com.github.scribejava.core.model.OAuth2AccessToken;\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.servlet.http.HttpSession;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.NewCookie;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.module.AuthModule;\r\n\r\nimport javax.management.BadAttributeValueExpException;\r\nimport java.util.HashMap;\r\nimport java.util.Objects;\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 계정 POST 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 00:53:52\r\n */\r\npublic class AccountPostProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountPostProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 로그인 응답 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t * @param code: [String] 인증 코드\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response postLoginResponse(String platform, String code, String state)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\tHttpSession session = request.getSession();\r\n\t\t\r\n\t\t// 로그인 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tObject sessionState = Objects.requireNonNull(session.getAttribute(\"state\"));\r\n\t\t\t\r\n\t\t\t// 고유 상태값이 일치하지 않을 경우\r\n\t\t\tif (!state.equals(sessionState))\r\n\t\t\t{\r\n\t\t\t\tthrow new BadAttributeValueExpException(\"state is mismatched\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getAccessToken(code);\r\n\t\t\t\r\n\t\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\t\tString refreshToken = oAuth2AccessToken.getRefreshToken();\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\t\taccessMap.put(\"access\", accessToken);\r\n\t\t\taccessMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tString accessJwt = JwtModule.generateJwt(state, accessMap);\r\n\t\t\tString refreshJwt = JwtModule.generateJwt(state, refreshMap);\r\n\t\t\t\r\n\t\t\tNewCookie accessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", refreshToken == null ? 0 : 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"authorized success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 시도 후\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tsession.invalidate();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 자동 로그인 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t * @param refreshCookie: [String] 리프레쉬 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response postAutoLoginResponse(String accessCookie, String refreshCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 자동 로그인 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// 접근 토큰 쿠키가 있을 경우\r\n\t\t\tif (accessCookie != null)\r\n\t\t\t{\r\n\t\t\t\tresponseBean.setFlag(true);\r\n\t\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t\t\r\n\t\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 리프레쉬 토큰 쿠키가 없을 경우\r\n\t\t\telse if (refreshCookie == null)\r\n\t\t\t{\r\n\t\t\t\tresponseBean.setFlag(false);\r\n\t\t\t\tresponseBean.setTitle(\"fail\");\r\n\t\t\t\tresponseBean.setMessage(\"refresh token is empty\");\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t\t\r\n\t\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 리프레쉬 토큰 쿠키가 있을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tJws<Claims> refreshJws = JwtModule.openJwt(refreshCookie);\r\n\t\t\t\t\r\n\t\t\t\tString refreshToken = refreshJws.getBody().get(\"refresh\", String.class);\r\n\t\t\t\tString platform = refreshJws.getBody().get(\"platform\", String.class);\r\n\t\t\t\t\r\n\t\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\t\r\n\t\t\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getRefreshAccessToken(refreshToken);\r\n\t\t\t\t\r\n\t\t\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\t\t\t\r\n\t\t\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\t\t\taccessMap.put(\"access\", accessToken);\r\n\t\t\t\taccessMap.put(\"platform\", platform);\r\n\t\t\t\t\r\n\t\t\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\t\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\t\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\t\t\r\n\t\t\t\tString uuid = UUID.randomUUID().toString();\r\n\t\t\t\t\r\n\t\t\t\tString accessJwt = JwtModule.generateJwt(uuid, accessMap);\r\n\t\t\t\tString refreshJwt = JwtModule.generateJwt(uuid, refreshMap);\r\n\t\t\t\t\r\n\t\t\t\tNewCookie newAccessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\t\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\t\t\r\n\t\t\t\tresponseBean.setFlag(true);\r\n\t\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t\t\r\n\t\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tNewCookie newAccessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 로그아웃 응답 반환 메서드\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response postLogoutResponse()\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 로그아웃 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tNewCookie accessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"logout success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## PUT 프로세스 구현\r\n\r\n계정 프로세스 중 `PUT`에 해당하는 동작이 집합된 프로세스를 구현한다.\r\n\r\n* 정보 제공 동의 갱신 URL 응답 반환 메서드\r\n\r\n`PUT`에 해당하는 메서드는 하나다. 데이터를 수정하는 작업들로 구성되어있다.\r\n\r\n\r\n\r\n### 정보 제공 동의 갱신 URL 응답 반환 메서드\r\n\r\n<span class=\"primary\">정보 제공 동의를 새로 갱신하는 URL을 반환</span>하는 메서드다.\r\n\r\n``` java\r\npublic Response putUpdateAuthorizationUrl(String accessCookie)\r\n{\r\n\tResponse response;\r\n\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\r\n\t// 정보 제공 동의 갱신 URL 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tString state = UUID.randomUUID().toString();\r\n\r\n\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\r\n\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\r\n\t\tString url = authModule.getUpdateAuthorizationUrl(state);\r\n\r\n\t\t// URL이 null일 경우\r\n\t\tif (url == null)\r\n\t\t{\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(\"skipped\");\r\n\t\t\tresponseBean.setMessage(Util.builder(platform, \" doesn't need that service\"));\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t}\r\n\r\n\t\t// URL이 유효할 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\trequest.getSession().setAttribute(\"state\", state);\r\n\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(Util.builder(platform, \" reauthrorization url response success\"));\r\n\t\t\tresponseBean.setBody(url);\r\n\t\t}\r\n\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\treturn response;\r\n}\r\n```\r\n\r\n첫 로그인 시, 서비스가 요구하는 정보에 대해 동의/거부하는 절차를 거친다. 이후 유저 정보 요청 시, 이 정보 제공 동의 여부에 의거하여 동의한 정보만을 제공한다.\r\n\r\n만약 서비스 운영 도중 요구 정보가 변경되어 추가적인 정보가 필요하다면, 정보 제공 동의를 갱신할 필요가 있다.\r\n\r\n서비스는 반환받은 URL로 리다이렉션하여 동의를 갱신한 뒤 갱신된 정보가 반영된 `code`를 반환한다. 이후의 과정은 로그인과 동일한 과정을 거친다.\r\n\r\n<br />\r\n\r\n즉, <span class=\"blue-400\">정보 제공 동의는 새로운 정보를 갱신하여 로그인을 다시 수행하는 것과 동일</span>하다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport global.module.Util;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.module.AuthModule;\r\n\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 계정 PUT 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.19 Tue 21:56:32\r\n */\r\npublic class AccountPutProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountPutProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response putUpdateAuthorizationUrl(String accessCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 정보 제공 동의 갱신 URL 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tString state = UUID.randomUUID().toString();\r\n\t\t\t\r\n\t\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\t\r\n\t\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tString url = authModule.getUpdateAuthorizationUrl(state);\r\n\t\t\t\r\n\t\t\t// URL이 null일 경우\r\n\t\t\tif (url == null)\r\n\t\t\t{\r\n\t\t\t\tresponseBean.setFlag(false);\r\n\t\t\t\tresponseBean.setTitle(\"skipped\");\r\n\t\t\t\tresponseBean.setMessage(Util.builder(platform, \" doesn't need that service\"));\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// URL이 유효할 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\trequest.getSession().setAttribute(\"state\", state);\r\n\t\t\t\t\r\n\t\t\t\tresponseBean.setFlag(true);\r\n\t\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\t\tresponseBean.setMessage(Util.builder(platform, \" reauthrorization url response success\"));\r\n\t\t\t\tresponseBean.setBody(url);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## DELETE 프로세스 구현\r\n\r\n계정 프로세스 중 `DELETE`에 해당하는 동작이 집합된 프로세스를 구현한다.\r\n\r\n* 연동 해제 응답 반환 메서드\r\n\r\n`DELETE`에 해당하는 메서드는 하나다. 주로 데이터를 삭제하는 작업들로 구성되어있다.\r\n\r\n\r\n\r\n### 연동 해제 응답 반환 메서드\r\n\r\n<span class=\"primary\">플랫폼과의 연동을 완전히 해제하고 로그아웃을 수행</span>하는 메서드다.\r\n\r\n``` java\r\npublic Response deleteInfoResponse(String accessCookie)\r\n{\r\n\tResponse response;\r\n\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\r\n\t// 연동 해제 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\r\n\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\r\n\t\t// 연동 해제에 성공할 경우\r\n\t\tif (authModule.deleteInfo(accessToken))\r\n\t\t{\r\n\t\t\tresponse = new AccountPostProcess(request, this.response).postLogoutResponse();\r\n\t\t}\r\n\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new RequestAuthenticationException(\"revoke fail\");\r\n\t\t}\r\n\t}\r\n\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\treturn response;\r\n}\r\n```\r\n\r\n플랫폼과의 연동을 해제하면 발급받았던 Access Token과 Refresh Token이 만료되어 더 이상 제 기능을 할 수 없게 된다.\r\n\r\n보통 회원탈퇴 시 이루어지는 과정이지만, 이 프로젝트는 별도의 회원가입이랄게 따로 없으므로, 자동으로 로그아웃을 시키는 것으로 끝난다.\r\n\r\n추후 재로그인 시 처음 로그인하는 것과 동일한 과정을 거치게 된다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.module.AuthModule;\r\nimport org.glassfish.jersey.client.authentication.RequestAuthenticationException;\r\n\r\n/**\r\n * 계정 DELETE 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 00:53:52\r\n */\r\npublic class AccountDeleteProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountDeleteProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 연동 해제 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response deleteInfoResponse(String accessCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 연동 해제 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\t\r\n\t\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\t// 연동 해제에 성공할 경우\r\n\t\t\tif (authModule.deleteInfo(accessToken))\r\n\t\t\t{\r\n\t\t\t\tresponse = new AccountPostProcess(request, this.response).postLogoutResponse();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthrow new RequestAuthenticationException(\"revoke fail\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\n이로써 프로젝트 구현을 완료했다. `NaverAuthModule`, `GoogleAuthModule` 같은 각기 다른 인증모듈을 `AuthModule`이라는 상위 객체로 반환받은 덕분에 복잡한 분기나 중복 코드를 막을 수 있었다.\r\n\r\n파이프라인이 나눠지는 순간, 이와 연결된 하위 파이프라인까지 강제로 분리되는 경향이 있다. 가장 밑단인 모듈을 적절히 설계한 덕분에, 그 상위 파이프라인들은 하나로 관리할 수 있음을 확인할 수 있다.\r\n\r\n다음 장에서는 Jersey를 통한 컨트롤러 구성 방법에 대해 다룬다.","url":["2021-10-24-oauth2-java-server-8","2021","10","24","oauth2-java-server-8"]},"next":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 10. 컨트롤러 구현하기","excerpt":"Jersey 라이브러리를 통해 요청을 받아 응답을 반환하는 컨트롤러를 구성해보자. Jersey에 대해 자세히 알아보고 싶다면 이전 글을 참고하자.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-25T02:24:17","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","Jersey"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-25-oauth2-java-server-10.md","content":"\r\n# 개요\r\n\r\nJersey 라이브러리를 통해 요청을 받아 응답을 반환하는 컨트롤러를 구성해보자.\r\n\r\nJersey에 대해 자세히 알아보고 싶다면 [이전 글](/2021/10/25/oauth2-java-server-9)을 참고하자.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 컨트롤러 기본 설정하기\r\n\r\n컨트롤러 구현에 앞서 몇 가지 설정을 수행한다.\r\n\r\n* Jersey 요청용 URL 지정\r\n* CORS 설정\r\n\r\n항목은 위와 같다.\r\n\r\n\r\n\r\n\r\n\r\n## Jersey 요청용 URL 지정\r\n\r\n이전 글에서도 다룬 내용이다. Jersey를 적용했다고 모든 요청을 Jersey가 받는 건 아니고, 직접 <span class=\"primary\">Jersey가 요청을 위임받도록 지정</span>해야한다.\r\n\r\n임의의 패키지에 클래스를 하나 생성한다. 이름은 상관없다. 이 프로젝트에선 `main.java.global.module` 패키지에 `App.java`로 생성했다.\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.ws.rs.ApplicationPath;\r\nimport jakarta.ws.rs.core.Application;\r\n\r\n/**\r\n * 애플리케이션 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 22:40:20\r\n */\r\n@ApplicationPath(\"/api\")\r\npublic class App extends Application\r\n{\r\n    // api 접두사 요청을 jersey가 담당\r\n}\r\n```\r\n\r\n위와 같이 클래스에 추상 클래스 `Application`을 상속하고 `@ApplicationPath`를 통해 원하는 URL의 접두어를 지정한다.\r\n\r\n`/api`로 지정했으므로, `{BASE_URL}/api`로 시작하는 모든 요청은 Jersey가 담당할 것이다. 이 패턴에 해당하지 않는 모든 요청은 정상적으로 Servlet이 담당한다.\r\n\r\n현재 시연용 프로젝트의 API 서버는 `https://api.itcode.dev/oauth2`이므로, `https://api.itcode.dev/oauth2/api`로 시작하는 모든 요청은 Jersey가 받는다.\r\n\r\nURL 설정은 위 코드 하나면 끝난다.\r\n\r\n\r\n\r\n\r\n\r\n## CORS 설정\r\n\r\n시연용 프로젝트의 각 주소는 아래와 같다.\r\n\r\n* Frontend - `https://project.itcode.dev/oauth2`\r\n* Backend - `https://api.itcode.dev/oauth2`\r\n\r\n보다시피, 요청자/응답자 간의 도메인이 달라서, 그냥 보냈다간 십중팔구 CORS의 늪에 빠지게 된다.\r\n\r\n이를 해결하기 위해 <span class=\"primary\">서버에 CORS 설정을 지정하여 원하는 도메인에 요청을 보낼 수 있도록 설정</span>한다.\r\n\r\n<br />\r\n\r\n마찬가지로 임의의 패키지에 클래스를 하나 생성한다. 이름은 상관없다. 이 프로젝트에선 `main.java.global.module` 패키지에 `CorsFilter.java`로 생성했다.\r\n\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.ws.rs.container.ContainerRequestContext;\r\nimport jakarta.ws.rs.container.ContainerResponseContext;\r\nimport jakarta.ws.rs.container.ContainerResponseFilter;\r\nimport jakarta.ws.rs.ext.Provider;\r\n\r\n/**\r\n * CORS 필터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 15:42:04\r\n */\r\n@Provider\r\npublic class CorsFilter implements ContainerResponseFilter\r\n{\r\n\t/**\r\n\t * 필터 메서드\r\n\t *\r\n\t * @param requestContext: [ContainerRequestContext] ContainerRequestContext 객체\r\n\t * @param responseContext: [ContainerResponseContext] ContainerResponseContext 객체\r\n\t */\r\n\t@Override\r\n\tpublic void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)\r\n\t{\r\n\t\tString origin = requestContext.getHeaderString(\"origin\");\r\n\t\t\r\n\t\t// origin이 유효하고, itcode.dev 계열의 URL일 경우\r\n\t\tif (origin != null && origin.contains(\"itcode.dev\"))\r\n\t\t{\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Origin\", origin);\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Credentials\", \"true\");\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Methods\", \"GET,POST,PUT,DELETE,OPTIONS\");\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Headers\", \"Content-Type\");\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n인터페이스 `ContainerResponseFilter`을 상속하고 `filter` 메소드를 오버라이딩한다. 이 설정은 Jersey가 수행하는 모든 작업에 전역으로 동작한다.\r\n\r\n`Origin` 헤더를 검증하여 `Origin`이 `itcode.dev` 도메인을 가질 경우 CORS 설정을 통해 응답을 허용한다.\r\n\r\n* `Access-Control-Allow-Origin` - 요청에 사용할 수 있는 도메인\r\n* `Access-Control-Allow-Credentials` - 자격증명이 포함된 요청 허용 여부\r\n* `Access-Control-Allow-Methods` - 요청에 사용할 수 있는 HTTP 메소드\r\n* `Access-Control-Allow-Headers` - 요청에 사용할 수 있는 헤더\r\n\r\n로그인, 로그아웃 작업 등에 쿠키를 생성하는 `Set-Cookie` 헤더가 포함되어있는데, 이렇게 서로 다른 도메인에서 쿠키를 사용해야할 경우, 서버에서 `Access-Control-Allow-Credentials`를 `true`로 지정해야하고, 마찬가지로 웹은 요청 시 `credentials`을 `true`로 지정하여 요청해야한다.\r\n\r\n> <b class=\"teal-500\">자격 증명 요청은 도메인을 명시해야해!</b>  \r\n> `Access-Control-Allow-Origin` 헤더는 와일트카드 `*`을 지원한다. 헤더를 `*`로 지정할 경우, 모든 도메인에 상관없이 응답을 허용한다. 하지만 `Access-Control-Allow-Credentials`을 `true`로 지정했을 경우, 보안 정책으로 인해 반드시 도메인을 명시해야만 한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# controller 구현하기\r\n\r\n구현해야할 controller는 총 7개다.\r\n\r\n* **LoginAPI** (/api/login)\r\n  * 인증 URL API\r\n  * 정보 제공 동의 갱신 URL API\r\n  * 로그인 API\r\n  * 자동 로그인 API\r\n* **LogoutAPI** (/api/logout)\r\n  * 로그아웃 API\r\n* **RevokeAPI** (/api/revoke)\r\n  * 연동 해제 API\r\n* **UserInfoAPI** (/api/userinfo)\r\n  * 사용자 정보 API\r\n\r\nAPI 역시 공통 로직을 관리하기위해 추상 클래스를 구현하여 모든 컨트롤러가 상속받도록 구성한다.\r\n\r\n\r\n\r\n\r\n\r\n## 추상 클래스 API 구현하기\r\n\r\n모든 컨트롤러가 상속받을 추상 클래스 `API`를 구현한다.\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.Context;\r\nimport jakarta.ws.rs.core.UriInfo;\r\n\r\n/**\r\n * API 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 22:34:27\r\n */\r\nabstract public class API\r\n{\r\n\t@Context\r\n\tprotected HttpServletRequest request;\r\n\t\r\n\t@Context\r\n\tprotected HttpServletResponse response;\r\n\t\r\n\t@Context\r\n\tprotected UriInfo uriInfo;\r\n}\r\n```\r\n\r\n프로젝트 특성 상 API가 사용해야할 공통로직은 따로 없으며, Servlet 객체에 효율적으로 접근하기 위해 `@Context` 애노테이션으로 Servlet 객체들을 선언한다.\r\n\r\n이를 상속받는 모든 컨트롤러는 Servle 객체에 마음껏 접근할 수 있을 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## LoginAPI 구현하기\r\n\r\nLoginAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **LoginAPI** (/api/login)\r\n  * 인증 URL API\r\n  * 정보 제공 동의 갱신 URL API\r\n  * 로그인 API\r\n  * 자동 로그인 API\r\n\r\n총 4개의 메서드가 선언되어야한다.\r\n\r\n``` java\r\n@Path(\"/login\")\r\npublic class LoginAPI extends API\r\n{\r\n\t// /api/login\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구현된다.\r\n\r\n\r\n\r\n### 플랫폼 인증 URL API\r\n\r\n플랫폼 로그인을 수행하기 위한 <span class=\"primary\">플랫폼별 인증 URL을 반환</span>하는 API.\r\n\r\n플랫폼별로 인증 객체가 다르므로, 플랫폼을 구별할 필요가 있다.\r\n\r\n`@PathParam`을 통해 플랫폼을 구분한다.\r\n\r\n``` java\r\n@GET\r\n@Path(\"/{platform}\")\r\npublic Response authorizationUrlResponse(@PathParam(\"platform\") String platform)\r\n{\r\n\treturn new AccountGetProcess(request, response).getAuthorizationUrlResponse(platform);\r\n}\r\n```\r\n\r\n`GET /api/login/{platform}` 요청은 `authorizationUrlResponse`가 담당할 것이다.\r\n\r\n`@PathParam`인 platform이 인수로 할당된다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nGET https://api.itcode.dev/oauth2/api/login/{platform}\r\n```\r\n\r\n|   구분   | 파라미터 형태 | 데이터 형식 |    내용     |\r\n| :------: | :-----------: | :---------: | :---------: |\r\n| platform |     Path      |  `String`   | 플랫폼 이름 |\r\n\r\n플랫폼 이름은 플랫폼의 소문자 표기와 동일하다.\r\n\r\n| 플랫폼 |   값   | URL                     |\r\n| :----: | :----: | :---------------------- |\r\n| NAVER  | naver  | GET `/api/login/naver`  |\r\n| Google | google | GET `/api/login/google` |\r\n| KAKAO  | kakao  | GET `/api/login/kakao`  |\r\n| GitHub | github | GET `/api/login/github` |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n    \"flag\": true,\r\n    \"title\": \"success\",\r\n    \"message\": \"naver authrorization url response success\",\r\n    \"body\": \"https://nid.naver.com/oauth2.0/authorize?response_type=code&client_id=czCaqAOB1aAjNRk6N_Oq&redirect_uri=https%3A%2F%2Fproject.itcode.dev%2Foauth2%2Fcallback%3Fplatform%3Dnaver&state=24ca41d9-f432-4e0d-9b48-e5fd4ba49e6e\"\r\n}\r\n```\r\n\r\n| 파라미터 | 데이터 형식 |      내용       |\r\n| :------: | :---------: | :-------------: |\r\n|   flag   |  `boolean`  | 응답 정상 여부  |\r\n|  title   |  `String`   |    응답 제목    |\r\n| message  |  `String`   |   응답 메세지   |\r\n|   body   |  `String`   | 플랫폼 인증 URL |\r\n\r\n위 요청은 `https://api.itcode.dev/oauth2/api/login/naver` 응답의 예시다.\r\n\r\n\r\n\r\n### 정보 제공 동의 갱신 URL API\r\n\r\n<span class=\"primary\">정보 제공 동의 갱신을 위한 URL을 반환</span>하는 API.\r\n\r\n``` java\r\n@PUT\r\n@Path(\"/put\")\r\npublic Response putAuthorizationUrlResponse(@CookieParam(\"access\") String accessCookie)\r\n{\r\n\treturn new AccountPutProcess(request, response).putUpdateAuthorizationUrl(accessCookie);\r\n}\r\n```\r\n\r\n`PUT /api/login/{platform}` 요청은 `putAuthorizationUrlResponse`가 담당할 것이다.\r\n\r\naccess란 이름을 가진 쿠키가 인수로 할당된다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPUT https://api.itcode.dev/oauth2/api/login/put\r\nCookie: access={:access};\r\n```\r\n\r\n| parameter |  type  |   data   | required | description |\r\n| :-------: | :----: | :------: | :------: | :---------: |\r\n| {:access} | Cookie | `String` |    Y     |  인증 쿠키  |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"naver reauthrorization url response success\",\r\n\t\"body\": \"https://nid.naver.com/oauth2.0/authorize?auth_type=reprompt&state=08199e0e-ef61-444a-8d4f-f3c048b771f0&response_type=code&client_id=czCaqAOB1aAjNRk6N_Oq&redirect_uri=https%3A%2F%2Fproject.itcode.dev%2Foauth2%2Fcallback%3Fplatform%3Dnaver\"\r\n}\r\n```\r\n\r\n위 응답은 `https://api.itcode.dev/oauth2/api/login/put`의 예시다.\r\n\r\naccess 쿠키의 인증정보 내부에 플랫폼이 이미 포함되어 있으므로, 별도로 플랫폼을 구분할 필요가 없다.\r\n\r\n| parameter |   data    |         description         |\r\n| :-------: | :-------: | :-------------------------: |\r\n|   flag    | `boolean` |          동작 결과          |\r\n|   title   | `String`  |            제목             |\r\n|  message  | `String`  |            내용             |\r\n|   body    | `String`  | 정보 제공 동의 갱신 URL URL |\r\n\r\n\r\n\r\n### 로그인 API\r\n\r\n<span class=\"primary\">로그인을 수행</span>하는 API.\r\n\r\n플랫폼을 구분한다.\r\n\r\n``` java\r\n@POST\r\n@Path(\"/{platform}\")\r\npublic Response loginResponse(@PathParam(\"platform\") String platform, LoginResponseBean loginResponseBean)\r\n{\r\n\treturn new AccountPostProcess(request, response).postLoginResponse(platform, loginResponseBean.getCode(), loginResponseBean.getState());\r\n}\r\n```\r\n\r\n`POST /api/login/{platform}` 요청은 `loginResponse`가 담당할 것이다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPOST https://api.itcode.dev/oauth2/api/login/{:platform}\r\n\r\n{\r\n    \"code\": {:code},\r\n    \"state\": {:state}\r\n}\r\n```\r\n\r\n|  parameter  | type  |   data   | required |     description      |\r\n| :---------: | :---: | :------: | :------: | :------------------: |\r\n| {:platform} | path  | `String` |    Y     | 플랫폼 (소문자 표기) |\r\n|   {:code}   | body  | `String` |    Y     |      접근 코드       |\r\n|  {:state}   | body  | `String` |    Y     |     고유 상태값      |\r\n\r\n플랫폼 이름은 플랫폼의 소문자 표기와 동일하다.\r\n\r\n| 플랫폼 |   값   | URL                      |\r\n| :----: | :----: | :----------------------- |\r\n| NAVER  | naver  | POST `/api/login/naver`  |\r\n| Google | google | POST `/api/login/google` |\r\n| KAKAO  | kakao  | POST `/api/login/kakao`  |\r\n| GitHub | github | POST `/api/login/github` |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` txt\r\nSet-Cookie: access={access}\r\nSet-Cookie: refresh={refresh}\r\n\r\n{\r\n    \"flag\": true,\r\n    \"title\": \"success\",\r\n    \"message\": \"authorized success\",\r\n    \"body\": null\r\n}\r\n```\r\n\r\n| 파라미터 | 데이터 형식 |      내용      |\r\n| :------: | :---------: | :------------: |\r\n|   flag   |  `boolean`  | 응답 정상 여부 |\r\n|  title   |  `String`   |   응답 제목    |\r\n| message  |  `String`   |  응답 메세지   |\r\n|   body   |   `null`    |      null      |\r\n\r\n`Set-Cookie` 헤더를 통해 자동으로 인증 정보가 담긴 토큰을 추가한다.\r\n\r\n\r\n\r\n### 자동 로그인 API\r\n\r\n기존에 남아있던 인증정보를 활용하여 <span class=\"primary\">상호작용 없이 로그인을 자동으로 수행</span>하는 API.\r\n\r\n``` java\r\n@POST\r\n@Path(\"/auto\")\r\npublic Response autoLoginResponse(@CookieParam(\"access\") String accessCookie, @CookieParam(\"refresh\") String refreshCookie)\r\n{\r\n\treturn new AccountPostProcess(request, response).postAutoLoginResponse(accessCookie, refreshCookie);\r\n}\r\n```\r\n\r\naccess 쿠키와 refresh 쿠키를 검증하여 이상이 없을 경우 쿠키 정보 확인 혹은 Access Token 재발급을 통해 로그인을 자동으로 수행한다.\r\n\r\n이미 쿠키 내부에 플랫폼 정보가 포함되어 있으므로, 플랫폼 구분은 필요 없다.\r\n\r\n`POST /api/login/auto` 요청은 `autoLoginResponse`가 담당할 것이다.\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPOST https://api.itcode.dev/oauth2/api/login/auto\r\nCookie: access={:access}; refresh={:refresh};\r\n```\r\n\r\n| parameter  |  type  |   data   | required |  description  |\r\n| :--------: | :----: | :------: | :------: | :-----------: |\r\n| {:access}  | Cookie | `String` |    N     |   인증 쿠키   |\r\n| {:refresh} | Cookie | `String` |    Y     | 리프레쉬 쿠키 |\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"auto authorized success\",\r\n\t\"body\": null\r\n}\r\n```\r\n\r\n``` txt\r\n# Header\r\nSet-Cookie: access={access JWT}\r\nSet-Cookie: refresh={refresh JWT}\r\n```\r\n\r\nrefresh 쿠키만을 보유하고 있어서 Access Token을 갱신한 경우에만 `Set-Cookie`가 포함된다.\r\n\r\n| parameter |   data    | description |\r\n| :-------: | :-------: | :---------: |\r\n|   flag    | `boolean` |  동작 결과  |\r\n|   title   | `String`  |    제목     |\r\n|  message  | `String`  |    내용     |\r\n|   body    |  `null`   |   `null`    |\r\n\r\n`Set-Cookie` 헤더를 통해 자동으로 인증 정보가 담긴 토큰을 추가한다.\r\n\r\n만약 아직 access 쿠키가 살아있다면, 별도의 쿠키를 생성하지 않아도 되므로 `Set-Cookie` 헤더는 전송되지 않는다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.CookieParam;\r\nimport jakarta.ws.rs.GET;\r\nimport jakarta.ws.rs.POST;\r\nimport jakarta.ws.rs.PUT;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.PathParam;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.bean.LoginResponseBean;\r\nimport oauth.account.process.AccountGetProcess;\r\nimport oauth.account.process.AccountPostProcess;\r\nimport oauth.account.process.AccountPutProcess;\r\n\r\n/**\r\n * 로그인 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.30 Thu 20:44:43\r\n */\r\n@Path(\"/login\")\r\npublic class LoginAPI extends API\r\n{\r\n\t/**\r\n\t * 인증 URL 응답 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@GET\r\n\t@Path(\"/{platform}\")\r\n\tpublic Response authorizationUrlResponse(@PathParam(\"platform\") String platform)\r\n\t{\r\n\t\treturn new AccountGetProcess(request, response).getAuthorizationUrlResponse(platform);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@PUT\r\n\t@Path(\"/put\")\r\n\tpublic Response putAuthorizationUrlResponse(@CookieParam(\"access\") String accessCookie)\r\n\t{\r\n\t\treturn new AccountPutProcess(request, response).putUpdateAuthorizationUrl(accessCookie);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 로그인 응답 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t * @param loginResponseBean: [LoginResponseBean] LoginResponseBean 객체\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@POST\r\n\t@Path(\"/{platform}\")\r\n\tpublic Response loginResponse(@PathParam(\"platform\") String platform, LoginResponseBean loginResponseBean)\r\n\t{\r\n\t\treturn new AccountPostProcess(request, response).postLoginResponse(platform, loginResponseBean.getCode(), loginResponseBean.getState());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 자동 로그인 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t * @param refreshCookie: [String] 리프레쉬 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@POST\r\n\t@Path(\"/auto\")\r\n\tpublic Response autoLoginResponse(@CookieParam(\"access\") String accessCookie, @CookieParam(\"refresh\") String refreshCookie)\r\n\t{\r\n\t\treturn new AccountPostProcess(request, response).postAutoLoginResponse(accessCookie, refreshCookie);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## LogoutAPI 구현하기\r\n\r\nLogoutAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **LogoutAPI** (/api/logout)\r\n  * 로그아웃 API\r\n\r\n총 하나의 메서드가 선언되어야 한다.\r\n\r\n``` java\r\n@Path(\"/logout\")\r\npublic class LogoutAPI extends API\r\n{\r\n\t// /api/logout\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구현된다.\r\n\r\n\r\n\r\n### 로그아웃 API\r\n\r\n<span class=\"primary\">로그아웃을 수행</span>하는 API.\r\n\r\n쿠키에 저장된 인증 정보를 삭제한다.\r\n\r\n``` java\r\n@POST\r\n@Path(\"\")\r\npublic Response logoutResponse()\r\n{\r\n\treturn new AccountPostProcess(request, response).postLogoutResponse();\r\n}\r\n```\r\n\r\n`POST /api/login/auto` 요청은 `autoLoginResponse`가 담당할 것이다.\r\n\r\n별도의 인수가 없는데, access, refresh 쿠키 둘 다 삭제할 예정이므로, 해당 쿠키의 존재 유무는 신경쓰지 않는다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPOST https://api.itcode.dev/oauth2/api/logout\r\n```\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"logout success\",\r\n\t\"body\": null\r\n}\r\n```\r\n\r\n``` txt\r\n# Header\r\nSet-Cookie: access={access JWT}\r\nSet-Cookie: refresh={refresh JWT}\r\n```\r\n\r\n| parameter |   data    | description |\r\n| :-------: | :-------: | :---------: |\r\n|   flag    | `boolean` |  동작 결과  |\r\n|   title   | `String`  |    제목     |\r\n|  message  | `String`  |    내용     |\r\n|   body    |  `null`   |   `null`    |\r\n\r\n`Max-Age` 0인 쿠키로 만들어 `Set-Cookie`로 덮어씌워 삭제한다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.POST;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.process.AccountPostProcess;\r\n\r\n/**\r\n * 로그아웃 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.04 Mon 21:19:00\r\n */\r\n@Path(\"/logout\")\r\npublic class LogoutAPI extends API\r\n{\r\n\t/**\r\n\t * 로그아웃 응답 메서드\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@POST\r\n\t@Path(\"\")\r\n\tpublic Response logoutResponse()\r\n\t{\r\n\t\treturn new AccountPostProcess(request, response).postLogoutResponse();\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## RevokeAPI 구현하기\r\n\r\nRevokeAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **RevokeAPI** (/api/revoke)\r\n  * 연동 해제 API\r\n\r\n총 하나의 메서드가 선언되어야 한다.\r\n\r\n``` java\r\n@Path(\"/revoke\")\r\npublic class RevokeAPI extends API\r\n{\r\n\t// /api/revoke\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구분된다.\r\n\r\n\r\n\r\n### 연동 해제 API\r\n\r\n<span class=\"primary\">플랫폼과의 연동을 완전히 해제</span>하는 API.\r\n\r\n``` java\r\n@DELETE\r\n@Path(\"\")\r\npublic Response deleteInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n{\r\n\treturn new AccountDeleteProcess(request, response).deleteInfoResponse(accessCookie);\r\n}\r\n```\r\n\r\n`DELETE /api/revoke` 요청은 `deleteInfoResponse`가 담당할 것이다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nDELETE https://api.itcode.dev/oauth2/api/revoke\r\nCookie: access={:access};\r\n```\r\n\r\n| parameter |  type  |   data   | required | description |\r\n| :-------: | :----: | :------: | :------: | :---------: |\r\n| {:access} | Cookie | `String` |    Y     |  인증 쿠키  |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"logout success\",\r\n\t\"body\": null\r\n}\r\n```\r\n\r\n``` txt\r\n# Header\r\nSet-Cookie: access={access JWT}\r\nSet-Cookie: refresh={refresh JWT}\r\n```\r\n\r\n| parameter |   data    | description |\r\n| :-------: | :-------: | :---------: |\r\n|   flag    | `boolean` |  동작 결과  |\r\n|   title   | `String`  |    제목     |\r\n|  message  | `String`  |    내용     |\r\n|   body    |  `null`   |   `null`    |\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.CookieParam;\r\nimport jakarta.ws.rs.DELETE;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.process.AccountDeleteProcess;\r\n\r\n/**\r\n * 연동 해제 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.18 Mon 01:19:30\r\n */\r\n@Path(\"/revoke\")\r\npublic class RevokeAPI extends API\r\n{\r\n\t/**\r\n\t * 연동 해제 URL 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@DELETE\r\n\t@Path(\"\")\r\n\tpublic Response deleteInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n\t{\r\n\t\treturn new AccountDeleteProcess(request, response).deleteInfoResponse(accessCookie);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## UserInfoAPI 구현하기\r\n\r\nUserInfoAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **UserInfoAPI** (/api/userinfo)\r\n  * 사용자 정보 API\r\n\r\n총 하나의 메서드가 선언되어야 한다.\r\n\r\n``` java\r\n@Path(\"/userinfo\")\r\npublic class UserInfoAPI extends API\r\n{\r\n\t// /api/userinfo\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구현된다.\r\n\r\n\r\n\r\n### 사용자 정보 API\r\n\r\nAccess Token을 토대로 <span class=\"primary\">사용자 정보를 반환</span>하는 API.\r\n\r\n``` java\r\n@GET\r\n@Path(\"\")\r\npublic Response userInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n{\r\n\treturn new AccountGetProcess(request, response).getUserInfoResponse(accessCookie);\r\n}\r\n```\r\n\r\n`GET /api/userinfo` 요청은 `userInfoResponse`가 담당할 것이다.\r\n\r\n플랫폼에서 응답한 내용을 그대로 반환하지는 않고, 플랫폼별 응답 스키마에 따라 적절히 가공하여 정형화된 응답을 제공한다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nGET https://api.itcode.dev/oauth2/api/userinfo\r\nCookie: access={:access};\r\n```\r\n\r\n| parameter |  type  |   data   | required | description |\r\n| :-------: | :----: | :------: | :------: | :---------: |\r\n| {:access} | Cookie | `String` |    Y     |  인증 쿠키  |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"user info response success\",\r\n\t\"body\": {\r\n\t\t\"email\": \"example@gmail.com\",\r\n\t\t\"name\": \"name\",\r\n\t\t\"profile\": \"https://phinf.pstatic.net/contact/PROFILE.png\",\r\n\t\t\"platform\": \"naver\"\r\n\t}\r\n}\r\n```\r\n\r\n위 응답은 네이버 사용자 정보 응답의 예시다.\r\n\r\n| parameter |   data    |   description    |\r\n| :-------: | :-------: | :--------------: |\r\n|   flag    | `boolean` |    동작 결과     |\r\n|   title   | `String`  |       제목       |\r\n|  message  | `String`  |       내용       |\r\n|   body    | `Object`  | 사용자 정보 JSON |\r\n|   email   | `String`  |      이메일      |\r\n|   name    | `String`  |       이름       |\r\n|  profile  | `String`  | 프로필 사진 URL  |\r\n| platform  | `String`  |      플랫폼      |\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.CookieParam;\r\nimport jakarta.ws.rs.GET;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.process.AccountGetProcess;\r\n\r\n/**\r\n * 사용자 정보 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 00:29:46\r\n */\r\n@Path(\"/userinfo\")\r\npublic class UserInfoAPI extends API\r\n{\r\n\t/**\r\n\t * 사용자 정보 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@GET\r\n\t@Path(\"\")\r\n\tpublic Response userInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n\t{\r\n\t\treturn new AccountGetProcess(request, response).getUserInfoResponse(accessCookie);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\n이 장을 끝으로 인증 서버의 주요 요소인 controller - process - module의 모든 구현을 완료했다.\r\n\r\n인증 서버의 구현이 완료되었으므로, 다음 장에선 프로젝트 마무리를 위한 심사 과정에 대해 다룬다.\r\n","url":["2021-10-25-oauth2-java-server-10","2021","10","25","oauth2-java-server-10"]}},"group":[{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 12. 마치며","excerpt":"그 동안 만들어 놓은건 많은데, 정작 정리같은 건 해두지 않았었다. GitHub를 활용하지 않기도 했고, 블로그도 딱히 운영하지 않고 있었으니.. 개인 서버도 샀겠다. 나름의 개발 포트폴리오를 위해 시험삼아 만든 프로젝트다. 개발부터 정리까지 차근차근 작성한 프로젝트는 이게 처음이 아닌가 싶다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-25T22:41:21","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-25-oauth2-java-server-12.md","content":"\r\n# 개요\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138708107-c6f86f3b-e599-4f99-8e61-5371ac7ecbed.png)\r\n\r\n<p align=\"center\"><b class=\"large\">OAuth Project</b></p>\r\n\r\n* [OAuth Project](https://project.itcode.dev/oauth2)\r\n* [API 명세서](https://github.com/RWB0104/api.itcode.dev-oauth2/wiki)\r\n* [OAuth Project - Frontend Repository](https://github.com/RWB0104/oauth2)\r\n* [OAuth Project - Backend Repository](https://github.com/RWB0104/api.itcode.dev-oauth2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 시연\r\n\r\n![animation](https://user-images.githubusercontent.com/50317129/138373743-ca6372cb-4c2e-4517-9190-4babdde6b98a.gif)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 마치며\r\n\r\n그 동안 만들어 놓은건 많은데, 정작 정리같은 건 해두지 않았었다. GitHub를 활용하지 않기도 했고, 블로그도 딱히 운영하지 않고 있었으니..\r\n\r\n개인 서버도 샀겠다. 나름의 개발 포트폴리오를 위해 시험삼아 만든 프로젝트다. 개발부터 정리까지 차근차근 작성한 프로젝트는 이게 처음이 아닌가 싶다.\r\n\r\n별 것 아닌 프로젝트지만, 혹시 모를 누군가가 OAuth를 이해하거나 인증 서버를 구축하는데 도움이 되었으면 좋겠다.\r\n\r\n<br />\r\n\r\n프로젝트 개발 자체는 오래 안 걸렸는데, 오히려 공부한 거 정리해서 블로그에 작성하는 게 더 오래 걸린 것 같다.\r\n\r\n처음 개발기를 작성한 날짜가 14일이니까.... 한 10일 정도 걸렸다. 하루에 평균 한 편 좀 넘게 쓴 셈이다.\r\n\r\n이거 어째 배보다 배꼽이 더 큰 것 같은데....\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n만들고 싶은 건 많고 꽤 구체적으로 구상한 것도 몇 개 있는데, 막상 하려고 하면 귀찮아서 큰일이다.","url":["2021-10-25-oauth2-java-server-12","2021","10","25","oauth2-java-server-12"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 11. OAuth 서비스 심사 신청하기","excerpt":"OAuth 서비스를 등록하고 인증 서버까지 별도로 구축했지만, 이렇게 했다고 해서 그 즉시 사용 가능한 것은 아니다. 이 장에서는 OAuth 서비스 심사를 신청하여 OAuth 서비스를 온전히 사용할 수 있도록 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-25T22:41:21","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-25-oauth2-java-server-11.md","content":"\r\n# 개요\r\n\r\nOAuth 서비스를 등록하고 인증 서버까지 별도로 구축했지만, 이렇게 했다고 해서 그 즉시 사용 가능한 것은 아니다.\r\n\r\n이 장에서는 OAuth 서비스 심사를 신청하여 OAuth 서비스를 온전히 사용할 수 있도록 한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# OAuth 서비스의 구분\r\n\r\nOAuth 서비스를 신청했다고 해서, 그 즉시 OAuth를 온전히 이용할 수 있는 것은 아니다. <span class=\"blue-500\">대부분의 Service Provider는 일종의 단계를 구분하여 서비스를 제공</span>한다.\r\n\r\n그 이유는 보안 때문이다. OAuth 서비스를 사용한다는 뜻은 사용자의 인증 정보를 받아 사용자의 정보를 호출할 수 있다는 뜻이다.\r\n\r\n<span class=\"red-600\">만약 비정상적인 사이트가 이를 악용한다면, 개인정보 보안 문제가 발생</span>하기 매우 쉽다.\r\n\r\n때문에 서비스 제공자들 대부분은 <span class=\"blue-500\">테스트 단계와 프로덕션 단계로 구분하여 서비스를 제공</span>한다.\r\n\r\n\r\n\r\n\r\n\r\n## 테스트 단계\r\n\r\n<span class=\"primary\">OAuth 서비스를 제한적으로 사용</span>할 수 있는 단계다.\r\n\r\n제공된 API 정보로 인증 서버를 구축하고, 수행하는덴 문제가 없지만 <span class=\"green-500\">반드시 정해진 계정으로만 OAuth 서비스를 이용</span>할 수 있다.\r\n\r\n위와 같은 특성으로 인해 불특정 다수를 타겟하는 서비스와는 맞지 않다.\r\n\r\n<br />\r\n\r\nOAuth를 신청하면 자동으로 테스트 단계로 구성되고, 이후 심사를 거쳐야만 프로덕션 단계로 이용할 수 있다.\r\n\r\n서비스 제공자에 따라서 테스트 단계를 세분화하거나, 아예 테스트 단계 자체를 제공하지 않는 경우도 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 프로덕션 단계\r\n\r\n<span class=\"primary\">OAuth 서비스를 제한없이 이용</span>할 수 있는 단계다.\r\n\r\n정해진 계정만 이용이 가능했던 테스트 단계와 달리 <span class=\"green-500\">모든 계정에서 사용</span>할 수 있다.\r\n\r\n서비스 제공자가 요구하는 심사 혹은 정책에 맞춰야만 프로덕션 단계로 이용할 수 있다.\r\n\r\n서비스 제공자들은 OAuth를 적용하는 서비스의 심사를 수행하여 OAuth를 사용할 정도로 신뢰할만한 서비스인지를 확인한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 심사 신청하기\r\n\r\n현재 OAuth 서비스를 적용한 플랫폼은 아래와 같다.\r\n\r\n* NAVER\r\n* Google\r\n* KAKAO\r\n* GitHub\r\n\r\n각 플랫폼별로 OAuth 서비스 심사를 신청하여 어떤 계정이든 OAuth 서비스에 접근할 수 있도록 제공하자.\r\n\r\n\r\n\r\n\r\n\r\n## 네이버\r\n\r\n네이버는 OAuth 서비스 등록 시 개발 중 단계로 등록된다.\r\n\r\n이 단계에선 등록된 계정만 로그인 수행이 가능하다.\r\n\r\n심사를 수행하여 배포 모드로 변경하자. 심사는 많이 까다로운 편이다.\r\n\r\n위 4개 플랫폼 중 요구하는 자료도 제일 많다.\r\n\r\n\r\n\r\n### 1. NAVER Developers 접속\r\n\r\n로그인 후 [네이버 개발자센터](https://developers.naver.com/main/)에 접속한다.\r\n\r\n상단 헤더의 [<span class=\"lightBlue-600\">Application</span> - <span class=\"lightBlue-600\">내 애플리케이션</span>] 메뉴로 접속하자.\r\n\r\n심사할 애플리케이션을 클릭하자.\r\n\r\n\r\n\r\n### 2. 로고 등록하기\r\n\r\n로고가 등록되어있지 않다면, 로고를 우선 등록하자. <span class=\"primary\">로고가 있어야 심사를 신청</span>할 수 있다.\r\n\r\n네이버 로그인 창에서 해당 로고 사진이 표시될 것이다.\r\n\r\n필수 사항이니, 마땅한 로고가 없다면 적당히 하나 만들어서 사용하자.\r\n\r\n[<span class=\"lightBlue-600\">API 설정</span>]에서 로고 이미지를 지정할 수 있다. 지원하는 확장자는 `jpg`, `png`, `gif`다.\r\n\r\n이후 수정 버튼을 눌러 완료하자.\r\n\r\n\r\n\r\n### 3. 자료 제출하기\r\n\r\n아래 두 사항에 대해 확인 및 증빙자료를 제출해야 한다.\r\n\r\n* 필수/추가로 지정한 정보를 제대로 활용하고 있는지\r\n* 서비스를 정상적으로 적용했는지\r\n* OAuth를 등록하려는 서비스의 종류가 적합한지\r\n\r\n\r\n\r\n#### 필수/추가로 지정한 정보를 제대로 활용하고 있는지\r\n\r\n<span class=\"primary\">필수/추가로 지정한 정보를 서비스에서 실제로 유의미하게 사용하고 있는지를 증빙</span>해야한다. 굳이 필요하지 않는 정보 요청을 막겠다는 취지로 보인다. 반드시 필요한 정보만을 필요한 곳에 사용하도록 강제하는 정책이다.\r\n\r\n이 프로젝트의 경우, 로그인 시 관련 정보를 출력하므로 <span class=\"blue-500\">해당 페이지의 스크린샷을 첨부</span>했다.\r\n\r\n\r\n\r\n#### 서비스를 정상적으로 적용했는지\r\n\r\n아래 항목 중 하나를 선택한다.\r\n\r\n* 네이버 아이디로 로그인을 통한 신규 회원 가입에 적용\r\n* <b class=\"green-600\">회원가입 없이 단순 로그인 인증에 적용</b>\r\n* 게시판 글쓰기 또는 댓글 작성 등 일부 메뉴에 적용\r\n* 기타\r\n\r\n이 프로젝트는 로그인만 수행하므로, 2번을 선택한다.\r\n\r\n<span class=\"primary\">네아로를 정상적으로 적용하고 사용할 수 있는지를 증빙</span>해야한다. 로그인 절차에 문제는 없는지 확인하는 취지로 보인다.\r\n\r\n로그인 절차에 따라 스크린샷을 찍어 제공하면 되며, 이 프로젝트의 경우 일련의 과정을 촬영하여 `gif`로 제공했다.\r\n\r\n\r\n\r\n#### OAuth를 등록하려는 서비스의 종류가 적합한지\r\n\r\n일부 민감한 서비스를 제공하는 사이트의 경우 추가 증빙 자료 제출을 요구한다.\r\n\r\n* 스포츠 게임 배팅, 투표권발행 유사행위를 제공하는 서비스\r\n* 온라인으로 주류를 판매하는 서비스\r\n* P2P 웹하드 서비스\r\n* 타투 시술 서비스\r\n* <b class=\"green-600\">없음</b>\r\n\r\n위 서비스 중 어느 것에도 해당되지 않으므로 5번을 선택한다.\r\n\r\n\r\n\r\n### 3. 심사 신청\r\n\r\n자료 업로드가 완료되었다면, 심사를 신청하자.\r\n\r\n심사는 통상 1 ~ 3일 정도가 소요된다.\r\n\r\n\r\n\r\n### 여담\r\n\r\n네이버는 심사하는 데 우여곡절이 좀 있었다.\r\n\r\n처음엔 단순히 OAuth 로그인만 수행하는 프로젝트라서 적을 것도 없고, 그냥 이메일이랑 이름 표출되는 페이지랑 로그인 절차 스크린샷만 잘 찍어서 보냈는데, 거절당했다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138678286-e20471c5-c385-4005-b9a1-6fc0dc5fc966.png)\r\n\r\n???: 사유 명확하게 적어와.\r\n\r\n<br />\r\n\r\n심사가 거부됐다.\r\n\r\n심사 사유를 같이 적어 보내라길래, 나름 필요한 사유를 잘 기입하여 재검토를 요청했다.\r\n\r\n<br />\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138678601-1eea1ba7-9926-4507-aec3-b61a2e32428d.png)\r\n\r\n???: 아 그딴 간단한 건 걍 개발 중으로 써^^\r\n\r\n<br />\r\n\r\n흠... 아무래도 프로젝트가 너무 간단하다보니, 네이버에서도 딱히 심사를 승인해줄 이유가 없는 듯 하다.\r\n\r\n그래도 다른 플랫폼은 전부 프로덕션 모드인데, 네이버만 테스트 모드인 것도 그림이 이상해서 다시 한 번 심사를 신청하기로 했다.\r\n\r\n지금과 같은 방식은 승산이 없다고 판단, 네이버가 원하는 방식대로 내 나름대로의 \"성의\"라는 것을 보여주기로 했다.\r\n\r\n<br />\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138678930-c2d93ae7-d449-414a-b66a-4a1db9eda49a.png)\r\n\r\n방법은 제안서의 정석 PPT. 내가 생각하기에도 반드시 OAuth 심사를 신청해야하는 마땅한 이유가 없어서, 반 장난식으로 \"다 활성화인데 너네만 이렇게 냅둘꺼야...?\"같은 뉘앙스를 잔뜩 담아 PPT로 제출했다.\r\n\r\n이 시도마저 무산된다면, 그냥 네이버는 깔끔하게 포기할 생각이고, PPT에도 이 마저도 안 된다면 더 귀찮게 굴지 않겠다는 언급도 했겠다. 이제 기다리는 수 밖에 없다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138703203-d9edc619-f4ec-4edf-8535-ad1db832b2f4.png)\r\n\r\n이왜진?\r\n\r\n<br />\r\n\r\n이게 통했다.\r\n\r\n왜 승인됐는진 잘 모르겠다. 나름 사유를 잘 적어서 그런건지, 원래 안 되는데 \"그래 걍 해준다 아ㅋㅋㅋㅋㅋㅋ\"로 된건지.\r\n\r\n어쨌든 네이버 신청은 완료됐고, 나름 재밌는 경험이지 않나 싶다. 여러분들도 심사 신청할 때 간단한 프로젝트라고 겁먹지 말고 최대한 성의를 담아 신청하도록 해보자.\r\n\r\n* [네아로 신청.pptx](https://github.com/RWB0104/Kapoo/files/7409284/default.pptx)\r\n\r\n내가 첨부했던 PPT다. 혹시 관심이 있다면 참고하길 바란다.\r\n\r\n\r\n\r\n\r\n\r\n## Google\r\n\r\n구글은 OAuth 서비스 신청 시 테스트 모드로 등록된다.\r\n\r\n프로덕션 모드로 변경하기 위해 아래의 절차를 수행한다.\r\n\r\n\r\n\r\n### 1. Google Cloud Platform 접속\r\n\r\nOAuth 서비스를 등록했던 [Google Cloud Platform](https://console.cloud.google.com/)에 접속한다. \r\n\r\n\r\n\r\n### 2. 로고 등록\r\n\r\n로고 이미지를 등록하지 않았다면, 등록하자.\r\n\r\n[<span class=\"lightBlue-600\">OAuth 동의 화면</span>]을 클릭하면 나오는 화면에서 [<span class=\"lightBlue-600\">앱 수정</span>]을 클릭하여 로고를 추가하면 된다.\r\n\r\n\r\n\r\n### 2. 게시하기\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138680360-a51a8830-ca37-4a93-8912-20f529199621.png)\r\n\r\n해당 페이지에서 [<span class=\"lightBlue-600\">게시</span>]를 클릭하여 프로덕션 모드로 전환한다.\r\n\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138680486-cd0d27a7-42f1-4b66-8abf-04bb2d0ce12c.png)\r\n\r\n이와 같이 변경된다. [<span class=\"lightBlue-600\">테스트로 돌아가기</span>]를 선택하면 다시 이전처럼 테스트 모드로 되돌릴 수 있다.\r\n\r\n\r\n\r\n### 3. 인증하기\r\n\r\n[<span class=\"lightBlue-600\">확인 준비</span>]를 클릭하여 애플리케이션을 인증하자.\r\n\r\n필요한 내용을 작성하고 제출하면 심사가 시작된다.\r\n\r\n구글은 약 4 ~ 6주간 소요된다고 하니, 천천히 기다리자.\r\n\r\n\r\n\r\n\r\n\r\n## KAKAO\r\n\r\n카카오는 OAuth 서비스 신청 시 제한적인 프로덕션 모드로 등록된다.\r\n\r\n카카오의 심사 방식은 조금 특이하다. <span class=\"blue-500\">별도의 심사를 거치지 않아도, 모든 카카오 계정이 제한없이 OAuth 서비스를 이용</span>할 수 있다.\r\n\r\n네이버나 구글같이 별도의 테스트모드를 두어 별도의 심사를 요구한 뒤 접근 권한을 열어주는 것과는 반대되는 방식이다.\r\n\r\n<br />\r\n\r\n카카오의 차이는 정보 제공 동의 선택에서 나타난다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138683825-b7442ce0-7afe-4179-bc10-c74d1dca822b.png)\r\n\r\n정보 제공 선택 시, 몇몇 정보는 검수가 필요하다는 이유로 필수 선택이 불가능하다.\r\n\r\n이러한 정보는 비즈니스 앱을 별도로 신청하여 심사를 통과해야만 필수 선택이 가능하다.\r\n\r\n그런데 문제는 이거, 비즈니스란 이름답게 <span class=\"red-600\">심사 시 사업자번호를 요구</span>한다...\r\n\r\n<br />\r\n\r\n그렇다고 개인은 신청이 불가능하냐? 그건 또 아니다. [이 링크](https://devtalk.kakao.com/t/how-can-i-switch-to-a-biz-app-if-i-do-not-have-any-business-registration-number/71983)에서 이와 관련한 카카오 개발자의 답변을 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138684484-c40a6381-1428-47ae-a056-7813be503492.png)\r\n\r\n* 앱 이름\r\n* 애플리케이션 ID\r\n* 애플리케이션 소유자 이메일\r\n* 본인 인증 완료 여부\r\n* 신청 목적\r\n\r\n위 항목을 빠짐없이 기입하여 데브톡에 글을 올리면 되는 것 같다.\r\n\r\n앱 이름은 애플리케이션의 성격에 맞게 등록하도록 권고하고 있다.\r\n\r\n* test\r\n* 테스트\r\n* oauth2\r\n* 로그인\r\n\r\n위와 같은 범용적인 이름은 등록을 가급적 지양하는 모양이니, 애플리케이션의 아이덴티티를 드러낼 수 있는 이름을 선택하자.\r\n\r\n<br />\r\n\r\n카카오는 반드시 심사를 신청하지 않더라도 로그인은 누구나 수행할 수 있으니 신청 유무는 자유다.\r\n\r\n* [신청 예시](https://devtalk.kakao.com/t/oauth/119006)\r\n\r\n필자는 위와 같이 신청했다.\r\n\r\n밤에 작성했는데, 그 다음날 아침에 바로 승인해줬다. 로그인 API는 별다른 서류나 증빙자료를 요구하지 않는 듯 하니, 원한다면 부담없이 신청하자.\r\n\r\n이제 이메일을 필수로 받을 수 있다!\r\n\r\n\r\n\r\n\r\n\r\n## GitHub\r\n\r\nGitHub는 서비스 등록 즉시 프로덕션 모드로 동작하므로 <span class=\"blue-500\">심사 과정이 없다.</span>\r\n\r\nOAuth App 생성 즉시 모든 GitHub 계정에서 사용이 가능하다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\n프로젝트에 적용된 플랫폼에 대한 OAuth 서비스 심사를 진행했다.\r\n\r\n심사가 모두 완료되면 누구나 제한없이 OAuth 로그인을 사용할 수 있을 것이다.\r\n\r\n<br />\r\n\r\n이 장을 끝으로 OAuth 인증 서버 개발기에 대한 기술적인 부분은 정리가 끝났다.","url":["2021-10-25-oauth2-java-server-11","2021","10","25","oauth2-java-server-11"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 10. 컨트롤러 구현하기","excerpt":"Jersey 라이브러리를 통해 요청을 받아 응답을 반환하는 컨트롤러를 구성해보자. Jersey에 대해 자세히 알아보고 싶다면 이전 글을 참고하자.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-25T02:24:17","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","Jersey"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-25-oauth2-java-server-10.md","content":"\r\n# 개요\r\n\r\nJersey 라이브러리를 통해 요청을 받아 응답을 반환하는 컨트롤러를 구성해보자.\r\n\r\nJersey에 대해 자세히 알아보고 싶다면 [이전 글](/2021/10/25/oauth2-java-server-9)을 참고하자.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 컨트롤러 기본 설정하기\r\n\r\n컨트롤러 구현에 앞서 몇 가지 설정을 수행한다.\r\n\r\n* Jersey 요청용 URL 지정\r\n* CORS 설정\r\n\r\n항목은 위와 같다.\r\n\r\n\r\n\r\n\r\n\r\n## Jersey 요청용 URL 지정\r\n\r\n이전 글에서도 다룬 내용이다. Jersey를 적용했다고 모든 요청을 Jersey가 받는 건 아니고, 직접 <span class=\"primary\">Jersey가 요청을 위임받도록 지정</span>해야한다.\r\n\r\n임의의 패키지에 클래스를 하나 생성한다. 이름은 상관없다. 이 프로젝트에선 `main.java.global.module` 패키지에 `App.java`로 생성했다.\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.ws.rs.ApplicationPath;\r\nimport jakarta.ws.rs.core.Application;\r\n\r\n/**\r\n * 애플리케이션 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 22:40:20\r\n */\r\n@ApplicationPath(\"/api\")\r\npublic class App extends Application\r\n{\r\n    // api 접두사 요청을 jersey가 담당\r\n}\r\n```\r\n\r\n위와 같이 클래스에 추상 클래스 `Application`을 상속하고 `@ApplicationPath`를 통해 원하는 URL의 접두어를 지정한다.\r\n\r\n`/api`로 지정했으므로, `{BASE_URL}/api`로 시작하는 모든 요청은 Jersey가 담당할 것이다. 이 패턴에 해당하지 않는 모든 요청은 정상적으로 Servlet이 담당한다.\r\n\r\n현재 시연용 프로젝트의 API 서버는 `https://api.itcode.dev/oauth2`이므로, `https://api.itcode.dev/oauth2/api`로 시작하는 모든 요청은 Jersey가 받는다.\r\n\r\nURL 설정은 위 코드 하나면 끝난다.\r\n\r\n\r\n\r\n\r\n\r\n## CORS 설정\r\n\r\n시연용 프로젝트의 각 주소는 아래와 같다.\r\n\r\n* Frontend - `https://project.itcode.dev/oauth2`\r\n* Backend - `https://api.itcode.dev/oauth2`\r\n\r\n보다시피, 요청자/응답자 간의 도메인이 달라서, 그냥 보냈다간 십중팔구 CORS의 늪에 빠지게 된다.\r\n\r\n이를 해결하기 위해 <span class=\"primary\">서버에 CORS 설정을 지정하여 원하는 도메인에 요청을 보낼 수 있도록 설정</span>한다.\r\n\r\n<br />\r\n\r\n마찬가지로 임의의 패키지에 클래스를 하나 생성한다. 이름은 상관없다. 이 프로젝트에선 `main.java.global.module` 패키지에 `CorsFilter.java`로 생성했다.\r\n\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.ws.rs.container.ContainerRequestContext;\r\nimport jakarta.ws.rs.container.ContainerResponseContext;\r\nimport jakarta.ws.rs.container.ContainerResponseFilter;\r\nimport jakarta.ws.rs.ext.Provider;\r\n\r\n/**\r\n * CORS 필터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 15:42:04\r\n */\r\n@Provider\r\npublic class CorsFilter implements ContainerResponseFilter\r\n{\r\n\t/**\r\n\t * 필터 메서드\r\n\t *\r\n\t * @param requestContext: [ContainerRequestContext] ContainerRequestContext 객체\r\n\t * @param responseContext: [ContainerResponseContext] ContainerResponseContext 객체\r\n\t */\r\n\t@Override\r\n\tpublic void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)\r\n\t{\r\n\t\tString origin = requestContext.getHeaderString(\"origin\");\r\n\t\t\r\n\t\t// origin이 유효하고, itcode.dev 계열의 URL일 경우\r\n\t\tif (origin != null && origin.contains(\"itcode.dev\"))\r\n\t\t{\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Origin\", origin);\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Credentials\", \"true\");\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Methods\", \"GET,POST,PUT,DELETE,OPTIONS\");\r\n\t\t\tresponseContext.getHeaders().add(\"Access-Control-Allow-Headers\", \"Content-Type\");\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n인터페이스 `ContainerResponseFilter`을 상속하고 `filter` 메소드를 오버라이딩한다. 이 설정은 Jersey가 수행하는 모든 작업에 전역으로 동작한다.\r\n\r\n`Origin` 헤더를 검증하여 `Origin`이 `itcode.dev` 도메인을 가질 경우 CORS 설정을 통해 응답을 허용한다.\r\n\r\n* `Access-Control-Allow-Origin` - 요청에 사용할 수 있는 도메인\r\n* `Access-Control-Allow-Credentials` - 자격증명이 포함된 요청 허용 여부\r\n* `Access-Control-Allow-Methods` - 요청에 사용할 수 있는 HTTP 메소드\r\n* `Access-Control-Allow-Headers` - 요청에 사용할 수 있는 헤더\r\n\r\n로그인, 로그아웃 작업 등에 쿠키를 생성하는 `Set-Cookie` 헤더가 포함되어있는데, 이렇게 서로 다른 도메인에서 쿠키를 사용해야할 경우, 서버에서 `Access-Control-Allow-Credentials`를 `true`로 지정해야하고, 마찬가지로 웹은 요청 시 `credentials`을 `true`로 지정하여 요청해야한다.\r\n\r\n> <b class=\"teal-500\">자격 증명 요청은 도메인을 명시해야해!</b>  \r\n> `Access-Control-Allow-Origin` 헤더는 와일트카드 `*`을 지원한다. 헤더를 `*`로 지정할 경우, 모든 도메인에 상관없이 응답을 허용한다. 하지만 `Access-Control-Allow-Credentials`을 `true`로 지정했을 경우, 보안 정책으로 인해 반드시 도메인을 명시해야만 한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# controller 구현하기\r\n\r\n구현해야할 controller는 총 7개다.\r\n\r\n* **LoginAPI** (/api/login)\r\n  * 인증 URL API\r\n  * 정보 제공 동의 갱신 URL API\r\n  * 로그인 API\r\n  * 자동 로그인 API\r\n* **LogoutAPI** (/api/logout)\r\n  * 로그아웃 API\r\n* **RevokeAPI** (/api/revoke)\r\n  * 연동 해제 API\r\n* **UserInfoAPI** (/api/userinfo)\r\n  * 사용자 정보 API\r\n\r\nAPI 역시 공통 로직을 관리하기위해 추상 클래스를 구현하여 모든 컨트롤러가 상속받도록 구성한다.\r\n\r\n\r\n\r\n\r\n\r\n## 추상 클래스 API 구현하기\r\n\r\n모든 컨트롤러가 상속받을 추상 클래스 `API`를 구현한다.\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.Context;\r\nimport jakarta.ws.rs.core.UriInfo;\r\n\r\n/**\r\n * API 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 22:34:27\r\n */\r\nabstract public class API\r\n{\r\n\t@Context\r\n\tprotected HttpServletRequest request;\r\n\t\r\n\t@Context\r\n\tprotected HttpServletResponse response;\r\n\t\r\n\t@Context\r\n\tprotected UriInfo uriInfo;\r\n}\r\n```\r\n\r\n프로젝트 특성 상 API가 사용해야할 공통로직은 따로 없으며, Servlet 객체에 효율적으로 접근하기 위해 `@Context` 애노테이션으로 Servlet 객체들을 선언한다.\r\n\r\n이를 상속받는 모든 컨트롤러는 Servle 객체에 마음껏 접근할 수 있을 것이다.\r\n\r\n\r\n\r\n\r\n\r\n## LoginAPI 구현하기\r\n\r\nLoginAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **LoginAPI** (/api/login)\r\n  * 인증 URL API\r\n  * 정보 제공 동의 갱신 URL API\r\n  * 로그인 API\r\n  * 자동 로그인 API\r\n\r\n총 4개의 메서드가 선언되어야한다.\r\n\r\n``` java\r\n@Path(\"/login\")\r\npublic class LoginAPI extends API\r\n{\r\n\t// /api/login\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구현된다.\r\n\r\n\r\n\r\n### 플랫폼 인증 URL API\r\n\r\n플랫폼 로그인을 수행하기 위한 <span class=\"primary\">플랫폼별 인증 URL을 반환</span>하는 API.\r\n\r\n플랫폼별로 인증 객체가 다르므로, 플랫폼을 구별할 필요가 있다.\r\n\r\n`@PathParam`을 통해 플랫폼을 구분한다.\r\n\r\n``` java\r\n@GET\r\n@Path(\"/{platform}\")\r\npublic Response authorizationUrlResponse(@PathParam(\"platform\") String platform)\r\n{\r\n\treturn new AccountGetProcess(request, response).getAuthorizationUrlResponse(platform);\r\n}\r\n```\r\n\r\n`GET /api/login/{platform}` 요청은 `authorizationUrlResponse`가 담당할 것이다.\r\n\r\n`@PathParam`인 platform이 인수로 할당된다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nGET https://api.itcode.dev/oauth2/api/login/{platform}\r\n```\r\n\r\n|   구분   | 파라미터 형태 | 데이터 형식 |    내용     |\r\n| :------: | :-----------: | :---------: | :---------: |\r\n| platform |     Path      |  `String`   | 플랫폼 이름 |\r\n\r\n플랫폼 이름은 플랫폼의 소문자 표기와 동일하다.\r\n\r\n| 플랫폼 |   값   | URL                     |\r\n| :----: | :----: | :---------------------- |\r\n| NAVER  | naver  | GET `/api/login/naver`  |\r\n| Google | google | GET `/api/login/google` |\r\n| KAKAO  | kakao  | GET `/api/login/kakao`  |\r\n| GitHub | github | GET `/api/login/github` |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n    \"flag\": true,\r\n    \"title\": \"success\",\r\n    \"message\": \"naver authrorization url response success\",\r\n    \"body\": \"https://nid.naver.com/oauth2.0/authorize?response_type=code&client_id=czCaqAOB1aAjNRk6N_Oq&redirect_uri=https%3A%2F%2Fproject.itcode.dev%2Foauth2%2Fcallback%3Fplatform%3Dnaver&state=24ca41d9-f432-4e0d-9b48-e5fd4ba49e6e\"\r\n}\r\n```\r\n\r\n| 파라미터 | 데이터 형식 |      내용       |\r\n| :------: | :---------: | :-------------: |\r\n|   flag   |  `boolean`  | 응답 정상 여부  |\r\n|  title   |  `String`   |    응답 제목    |\r\n| message  |  `String`   |   응답 메세지   |\r\n|   body   |  `String`   | 플랫폼 인증 URL |\r\n\r\n위 요청은 `https://api.itcode.dev/oauth2/api/login/naver` 응답의 예시다.\r\n\r\n\r\n\r\n### 정보 제공 동의 갱신 URL API\r\n\r\n<span class=\"primary\">정보 제공 동의 갱신을 위한 URL을 반환</span>하는 API.\r\n\r\n``` java\r\n@PUT\r\n@Path(\"/put\")\r\npublic Response putAuthorizationUrlResponse(@CookieParam(\"access\") String accessCookie)\r\n{\r\n\treturn new AccountPutProcess(request, response).putUpdateAuthorizationUrl(accessCookie);\r\n}\r\n```\r\n\r\n`PUT /api/login/{platform}` 요청은 `putAuthorizationUrlResponse`가 담당할 것이다.\r\n\r\naccess란 이름을 가진 쿠키가 인수로 할당된다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPUT https://api.itcode.dev/oauth2/api/login/put\r\nCookie: access={:access};\r\n```\r\n\r\n| parameter |  type  |   data   | required | description |\r\n| :-------: | :----: | :------: | :------: | :---------: |\r\n| {:access} | Cookie | `String` |    Y     |  인증 쿠키  |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"naver reauthrorization url response success\",\r\n\t\"body\": \"https://nid.naver.com/oauth2.0/authorize?auth_type=reprompt&state=08199e0e-ef61-444a-8d4f-f3c048b771f0&response_type=code&client_id=czCaqAOB1aAjNRk6N_Oq&redirect_uri=https%3A%2F%2Fproject.itcode.dev%2Foauth2%2Fcallback%3Fplatform%3Dnaver\"\r\n}\r\n```\r\n\r\n위 응답은 `https://api.itcode.dev/oauth2/api/login/put`의 예시다.\r\n\r\naccess 쿠키의 인증정보 내부에 플랫폼이 이미 포함되어 있으므로, 별도로 플랫폼을 구분할 필요가 없다.\r\n\r\n| parameter |   data    |         description         |\r\n| :-------: | :-------: | :-------------------------: |\r\n|   flag    | `boolean` |          동작 결과          |\r\n|   title   | `String`  |            제목             |\r\n|  message  | `String`  |            내용             |\r\n|   body    | `String`  | 정보 제공 동의 갱신 URL URL |\r\n\r\n\r\n\r\n### 로그인 API\r\n\r\n<span class=\"primary\">로그인을 수행</span>하는 API.\r\n\r\n플랫폼을 구분한다.\r\n\r\n``` java\r\n@POST\r\n@Path(\"/{platform}\")\r\npublic Response loginResponse(@PathParam(\"platform\") String platform, LoginResponseBean loginResponseBean)\r\n{\r\n\treturn new AccountPostProcess(request, response).postLoginResponse(platform, loginResponseBean.getCode(), loginResponseBean.getState());\r\n}\r\n```\r\n\r\n`POST /api/login/{platform}` 요청은 `loginResponse`가 담당할 것이다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPOST https://api.itcode.dev/oauth2/api/login/{:platform}\r\n\r\n{\r\n    \"code\": {:code},\r\n    \"state\": {:state}\r\n}\r\n```\r\n\r\n|  parameter  | type  |   data   | required |     description      |\r\n| :---------: | :---: | :------: | :------: | :------------------: |\r\n| {:platform} | path  | `String` |    Y     | 플랫폼 (소문자 표기) |\r\n|   {:code}   | body  | `String` |    Y     |      접근 코드       |\r\n|  {:state}   | body  | `String` |    Y     |     고유 상태값      |\r\n\r\n플랫폼 이름은 플랫폼의 소문자 표기와 동일하다.\r\n\r\n| 플랫폼 |   값   | URL                      |\r\n| :----: | :----: | :----------------------- |\r\n| NAVER  | naver  | POST `/api/login/naver`  |\r\n| Google | google | POST `/api/login/google` |\r\n| KAKAO  | kakao  | POST `/api/login/kakao`  |\r\n| GitHub | github | POST `/api/login/github` |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` txt\r\nSet-Cookie: access={access}\r\nSet-Cookie: refresh={refresh}\r\n\r\n{\r\n    \"flag\": true,\r\n    \"title\": \"success\",\r\n    \"message\": \"authorized success\",\r\n    \"body\": null\r\n}\r\n```\r\n\r\n| 파라미터 | 데이터 형식 |      내용      |\r\n| :------: | :---------: | :------------: |\r\n|   flag   |  `boolean`  | 응답 정상 여부 |\r\n|  title   |  `String`   |   응답 제목    |\r\n| message  |  `String`   |  응답 메세지   |\r\n|   body   |   `null`    |      null      |\r\n\r\n`Set-Cookie` 헤더를 통해 자동으로 인증 정보가 담긴 토큰을 추가한다.\r\n\r\n\r\n\r\n### 자동 로그인 API\r\n\r\n기존에 남아있던 인증정보를 활용하여 <span class=\"primary\">상호작용 없이 로그인을 자동으로 수행</span>하는 API.\r\n\r\n``` java\r\n@POST\r\n@Path(\"/auto\")\r\npublic Response autoLoginResponse(@CookieParam(\"access\") String accessCookie, @CookieParam(\"refresh\") String refreshCookie)\r\n{\r\n\treturn new AccountPostProcess(request, response).postAutoLoginResponse(accessCookie, refreshCookie);\r\n}\r\n```\r\n\r\naccess 쿠키와 refresh 쿠키를 검증하여 이상이 없을 경우 쿠키 정보 확인 혹은 Access Token 재발급을 통해 로그인을 자동으로 수행한다.\r\n\r\n이미 쿠키 내부에 플랫폼 정보가 포함되어 있으므로, 플랫폼 구분은 필요 없다.\r\n\r\n`POST /api/login/auto` 요청은 `autoLoginResponse`가 담당할 것이다.\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPOST https://api.itcode.dev/oauth2/api/login/auto\r\nCookie: access={:access}; refresh={:refresh};\r\n```\r\n\r\n| parameter  |  type  |   data   | required |  description  |\r\n| :--------: | :----: | :------: | :------: | :-----------: |\r\n| {:access}  | Cookie | `String` |    N     |   인증 쿠키   |\r\n| {:refresh} | Cookie | `String` |    Y     | 리프레쉬 쿠키 |\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"auto authorized success\",\r\n\t\"body\": null\r\n}\r\n```\r\n\r\n``` txt\r\n# Header\r\nSet-Cookie: access={access JWT}\r\nSet-Cookie: refresh={refresh JWT}\r\n```\r\n\r\nrefresh 쿠키만을 보유하고 있어서 Access Token을 갱신한 경우에만 `Set-Cookie`가 포함된다.\r\n\r\n| parameter |   data    | description |\r\n| :-------: | :-------: | :---------: |\r\n|   flag    | `boolean` |  동작 결과  |\r\n|   title   | `String`  |    제목     |\r\n|  message  | `String`  |    내용     |\r\n|   body    |  `null`   |   `null`    |\r\n\r\n`Set-Cookie` 헤더를 통해 자동으로 인증 정보가 담긴 토큰을 추가한다.\r\n\r\n만약 아직 access 쿠키가 살아있다면, 별도의 쿠키를 생성하지 않아도 되므로 `Set-Cookie` 헤더는 전송되지 않는다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.CookieParam;\r\nimport jakarta.ws.rs.GET;\r\nimport jakarta.ws.rs.POST;\r\nimport jakarta.ws.rs.PUT;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.PathParam;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.bean.LoginResponseBean;\r\nimport oauth.account.process.AccountGetProcess;\r\nimport oauth.account.process.AccountPostProcess;\r\nimport oauth.account.process.AccountPutProcess;\r\n\r\n/**\r\n * 로그인 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.30 Thu 20:44:43\r\n */\r\n@Path(\"/login\")\r\npublic class LoginAPI extends API\r\n{\r\n\t/**\r\n\t * 인증 URL 응답 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@GET\r\n\t@Path(\"/{platform}\")\r\n\tpublic Response authorizationUrlResponse(@PathParam(\"platform\") String platform)\r\n\t{\r\n\t\treturn new AccountGetProcess(request, response).getAuthorizationUrlResponse(platform);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@PUT\r\n\t@Path(\"/put\")\r\n\tpublic Response putAuthorizationUrlResponse(@CookieParam(\"access\") String accessCookie)\r\n\t{\r\n\t\treturn new AccountPutProcess(request, response).putUpdateAuthorizationUrl(accessCookie);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 로그인 응답 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t * @param loginResponseBean: [LoginResponseBean] LoginResponseBean 객체\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@POST\r\n\t@Path(\"/{platform}\")\r\n\tpublic Response loginResponse(@PathParam(\"platform\") String platform, LoginResponseBean loginResponseBean)\r\n\t{\r\n\t\treturn new AccountPostProcess(request, response).postLoginResponse(platform, loginResponseBean.getCode(), loginResponseBean.getState());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 자동 로그인 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t * @param refreshCookie: [String] 리프레쉬 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@POST\r\n\t@Path(\"/auto\")\r\n\tpublic Response autoLoginResponse(@CookieParam(\"access\") String accessCookie, @CookieParam(\"refresh\") String refreshCookie)\r\n\t{\r\n\t\treturn new AccountPostProcess(request, response).postAutoLoginResponse(accessCookie, refreshCookie);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## LogoutAPI 구현하기\r\n\r\nLogoutAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **LogoutAPI** (/api/logout)\r\n  * 로그아웃 API\r\n\r\n총 하나의 메서드가 선언되어야 한다.\r\n\r\n``` java\r\n@Path(\"/logout\")\r\npublic class LogoutAPI extends API\r\n{\r\n\t// /api/logout\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구현된다.\r\n\r\n\r\n\r\n### 로그아웃 API\r\n\r\n<span class=\"primary\">로그아웃을 수행</span>하는 API.\r\n\r\n쿠키에 저장된 인증 정보를 삭제한다.\r\n\r\n``` java\r\n@POST\r\n@Path(\"\")\r\npublic Response logoutResponse()\r\n{\r\n\treturn new AccountPostProcess(request, response).postLogoutResponse();\r\n}\r\n```\r\n\r\n`POST /api/login/auto` 요청은 `autoLoginResponse`가 담당할 것이다.\r\n\r\n별도의 인수가 없는데, access, refresh 쿠키 둘 다 삭제할 예정이므로, 해당 쿠키의 존재 유무는 신경쓰지 않는다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nPOST https://api.itcode.dev/oauth2/api/logout\r\n```\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"logout success\",\r\n\t\"body\": null\r\n}\r\n```\r\n\r\n``` txt\r\n# Header\r\nSet-Cookie: access={access JWT}\r\nSet-Cookie: refresh={refresh JWT}\r\n```\r\n\r\n| parameter |   data    | description |\r\n| :-------: | :-------: | :---------: |\r\n|   flag    | `boolean` |  동작 결과  |\r\n|   title   | `String`  |    제목     |\r\n|  message  | `String`  |    내용     |\r\n|   body    |  `null`   |   `null`    |\r\n\r\n`Max-Age` 0인 쿠키로 만들어 `Set-Cookie`로 덮어씌워 삭제한다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.POST;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.process.AccountPostProcess;\r\n\r\n/**\r\n * 로그아웃 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.04 Mon 21:19:00\r\n */\r\n@Path(\"/logout\")\r\npublic class LogoutAPI extends API\r\n{\r\n\t/**\r\n\t * 로그아웃 응답 메서드\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@POST\r\n\t@Path(\"\")\r\n\tpublic Response logoutResponse()\r\n\t{\r\n\t\treturn new AccountPostProcess(request, response).postLogoutResponse();\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## RevokeAPI 구현하기\r\n\r\nRevokeAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **RevokeAPI** (/api/revoke)\r\n  * 연동 해제 API\r\n\r\n총 하나의 메서드가 선언되어야 한다.\r\n\r\n``` java\r\n@Path(\"/revoke\")\r\npublic class RevokeAPI extends API\r\n{\r\n\t// /api/revoke\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구분된다.\r\n\r\n\r\n\r\n### 연동 해제 API\r\n\r\n<span class=\"primary\">플랫폼과의 연동을 완전히 해제</span>하는 API.\r\n\r\n``` java\r\n@DELETE\r\n@Path(\"\")\r\npublic Response deleteInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n{\r\n\treturn new AccountDeleteProcess(request, response).deleteInfoResponse(accessCookie);\r\n}\r\n```\r\n\r\n`DELETE /api/revoke` 요청은 `deleteInfoResponse`가 담당할 것이다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nDELETE https://api.itcode.dev/oauth2/api/revoke\r\nCookie: access={:access};\r\n```\r\n\r\n| parameter |  type  |   data   | required | description |\r\n| :-------: | :----: | :------: | :------: | :---------: |\r\n| {:access} | Cookie | `String` |    Y     |  인증 쿠키  |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"logout success\",\r\n\t\"body\": null\r\n}\r\n```\r\n\r\n``` txt\r\n# Header\r\nSet-Cookie: access={access JWT}\r\nSet-Cookie: refresh={refresh JWT}\r\n```\r\n\r\n| parameter |   data    | description |\r\n| :-------: | :-------: | :---------: |\r\n|   flag    | `boolean` |  동작 결과  |\r\n|   title   | `String`  |    제목     |\r\n|  message  | `String`  |    내용     |\r\n|   body    |  `null`   |   `null`    |\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.CookieParam;\r\nimport jakarta.ws.rs.DELETE;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.process.AccountDeleteProcess;\r\n\r\n/**\r\n * 연동 해제 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.18 Mon 01:19:30\r\n */\r\n@Path(\"/revoke\")\r\npublic class RevokeAPI extends API\r\n{\r\n\t/**\r\n\t * 연동 해제 URL 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@DELETE\r\n\t@Path(\"\")\r\n\tpublic Response deleteInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n\t{\r\n\t\treturn new AccountDeleteProcess(request, response).deleteInfoResponse(accessCookie);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## UserInfoAPI 구현하기\r\n\r\nUserInfoAPI가 담당하는 API는 아래와 같다.\r\n\r\n* **UserInfoAPI** (/api/userinfo)\r\n  * 사용자 정보 API\r\n\r\n총 하나의 메서드가 선언되어야 한다.\r\n\r\n``` java\r\n@Path(\"/userinfo\")\r\npublic class UserInfoAPI extends API\r\n{\r\n\t// /api/userinfo\r\n}\r\n```\r\n\r\n컨트롤러 객체는 위와 같이 구현된다.\r\n\r\n\r\n\r\n### 사용자 정보 API\r\n\r\nAccess Token을 토대로 <span class=\"primary\">사용자 정보를 반환</span>하는 API.\r\n\r\n``` java\r\n@GET\r\n@Path(\"\")\r\npublic Response userInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n{\r\n\treturn new AccountGetProcess(request, response).getUserInfoResponse(accessCookie);\r\n}\r\n```\r\n\r\n`GET /api/userinfo` 요청은 `userInfoResponse`가 담당할 것이다.\r\n\r\n플랫폼에서 응답한 내용을 그대로 반환하지는 않고, 플랫폼별 응답 스키마에 따라 적절히 가공하여 정형화된 응답을 제공한다.\r\n\r\n\r\n\r\n#### 요청\r\n\r\n``` txt\r\nGET https://api.itcode.dev/oauth2/api/userinfo\r\nCookie: access={:access};\r\n```\r\n\r\n| parameter |  type  |   data   | required | description |\r\n| :-------: | :----: | :------: | :------: | :---------: |\r\n| {:access} | Cookie | `String` |    Y     |  인증 쿠키  |\r\n\r\n\r\n\r\n#### 응답\r\n\r\n``` json\r\n{\r\n\t\"flag\": true,\r\n\t\"title\": \"success\",\r\n\t\"message\": \"user info response success\",\r\n\t\"body\": {\r\n\t\t\"email\": \"example@gmail.com\",\r\n\t\t\"name\": \"name\",\r\n\t\t\"profile\": \"https://phinf.pstatic.net/contact/PROFILE.png\",\r\n\t\t\"platform\": \"naver\"\r\n\t}\r\n}\r\n```\r\n\r\n위 응답은 네이버 사용자 정보 응답의 예시다.\r\n\r\n| parameter |   data    |   description    |\r\n| :-------: | :-------: | :--------------: |\r\n|   flag    | `boolean` |    동작 결과     |\r\n|   title   | `String`  |       제목       |\r\n|  message  | `String`  |       내용       |\r\n|   body    | `Object`  | 사용자 정보 JSON |\r\n|   email   | `String`  |      이메일      |\r\n|   name    | `String`  |       이름       |\r\n|  profile  | `String`  | 프로필 사진 URL  |\r\n| platform  | `String`  |      플랫폼      |\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.controller;\r\n\r\nimport global.module.API;\r\nimport jakarta.ws.rs.CookieParam;\r\nimport jakarta.ws.rs.GET;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.process.AccountGetProcess;\r\n\r\n/**\r\n * 사용자 정보 API 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 00:29:46\r\n */\r\n@Path(\"/userinfo\")\r\npublic class UserInfoAPI extends API\r\n{\r\n\t/**\r\n\t * 사용자 정보 응답 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\t@GET\r\n\t@Path(\"\")\r\n\tpublic Response userInfoResponse(@CookieParam(\"access\") String accessCookie)\r\n\t{\r\n\t\treturn new AccountGetProcess(request, response).getUserInfoResponse(accessCookie);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\n이 장을 끝으로 인증 서버의 주요 요소인 controller - process - module의 모든 구현을 완료했다.\r\n\r\n인증 서버의 구현이 완료되었으므로, 다음 장에선 프로젝트 마무리를 위한 심사 과정에 대해 다룬다.\r\n","url":["2021-10-25-oauth2-java-server-10","2021","10","25","oauth2-java-server-10"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 8. 프로세스 구현하기","excerpt":"4장부터 7장까지 진행하며 각 플랫폼의 인증 모듈을 구현했다. 이 장에서는 모듈을 사용하는 주체인 프로세스를 구현한다. 프로세스는 HTTP 메소드에 따라 구분하여 관리한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-24T23:58:10","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":"trueㄴ","publish":true},"name":"2021-10-24-oauth2-java-server-8.md","content":"\r\n# 개요\r\n\r\n4장부터 7장까지 진행하며 각 플랫폼의 인증 모듈을 구현했다. 이 장에서는 모듈을 사용하는 주체인 프로세스를 구현한다.\r\n\r\n프로세스는 HTTP 메소드에 따라 구분하여 관리한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 구조\r\n\r\n계정 관련 동작 이외엔 없으므로, 대분류는 `account` 하나 뿐이다.\r\n\r\n작업에 필요한 HTTP 메소는 `GET`, `POST`, `PUT`, `DELETE`이므로, 아래와 같이 구분한다.\r\n\r\n* `AccountGetProcess` - 계정 GET 프로세스 클래스\r\n* `AccountPostProcess` - 계정 POST 프로세스 클래스\r\n* `AccountPutProcess` - 계정 PUT 프로세스 클래스\r\n* `AccountDeleteProcess` - 계정 DELETE 프로세스 클래스\r\n\r\n`GET` 메소드에 사용하는 로직은 `AccountGetProcess`에 포함되는 식으로 구성한다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 프로세스 구현\r\n\r\n\r\n\r\n\r\n\r\n## Process 추상 클래스 구현\r\n\r\n여러 프로세스에 공통 로직을 적용하기 위해, 모든 프로세스 객체에 상속할 Process 추상 클래스를 구현한다.\r\n\r\n``` java\r\npackage global.module;\r\n\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport oauth.account.module.AuthModule;\r\nimport oauth.account.module.GithubAuthModule;\r\nimport oauth.account.module.GoogleAuthModule;\r\nimport oauth.account.module.KakaoAuthModule;\r\nimport oauth.account.module.NaverAuthModule;\r\n\r\n/**\r\n * 프로세스 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.30 Thu 01:14:25\r\n */\r\nabstract public class Process\r\n{\r\n\tprotected HttpServletRequest request;\r\n\tprotected HttpServletResponse response;\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletResponse 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tprotected Process(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tthis.request = request;\r\n\t\tthis.response = response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 모듈 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [AuthModule] AuthModule 객체\r\n\t *\r\n\t * @throws NullPointerException 유효하지 않은 플랫폼\r\n\t */\r\n\tprotected AuthModule getAuthModule(String platform) throws NullPointerException\r\n\t{\r\n\t\treturn switch (platform)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase \"naver\" -> NaverAuthModule.getInstance();\r\n\t\t\t\t\tcase \"google\" -> GoogleAuthModule.getInstance();\r\n\t\t\t\t\tcase \"kakao\" -> KakaoAuthModule.getInstance();\r\n\t\t\t\t\tcase \"github\" -> GithubAuthModule.getInstance();\r\n\t\t\t\t\tdefault -> throw new NullPointerException(Util.builder(\"'\", platform, \"' is invalid platform\"));\r\n\t\t\t\t};\r\n\t}\r\n}\r\n```\r\n\r\n서블릿 객체인 `HttpServletRequest`, `HttpServletResponse`에 쉽게 접근하기 위해 `protected` 접근 제어자로 각 지역변수를 선언한다.\r\n\r\n생성자 사용 시 반드시 `HttpServletRequest`, `HttpServletResponse`를 인수로 주도록 강제한다.\r\n\r\n이를 통해 `Process`를 상속하는 모든 하위 프로세스 클래스는 반드시 서블릿 객체를 인수로 받아야하며, 프로세스 내부에서 `request`, `response`로 서블릿 객체에 접근할 수 있다.\r\n\r\n<br />\r\n\r\n`getAuthModule`은 <span class=\"primary\">각 플랫폼 이름에 따라 해당하는 인스턴스를 반환</span>하는 메서드다. 인증 모듈은 주로 프로세스에서 많이 사용하게 되므로, `Process`에 선언하여 이를 상속하는 모든 프로세스 클래스가 해당 메서드에 접근할 수 있도록 구성한다.\r\n\r\n이러한 구성으로 동일한 프로세스에서 플랫폼별로 `AuthModule` 객체를 호출하여 플랫폼별로 선언한 메서드를 사용할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## GET 프로세스 구현\r\n\r\n계정 프로세스 중 `GET`에 해당하는 동작이 집합된 프로세스 클래스를 구현한다.\r\n\r\n* 인증 URL 응답 반환 메서드\r\n* 사용자 정보 응답 반환 메서드\r\n\r\n`GET`에 해당하는 동작은 위 두 메서드다. 단순히 데이터를 받아오는 작업들로 구성되어있다.\r\n\r\n\r\n\r\n### 인증 URL 응답 반환 메서드\r\n\r\n<span class=\"primary\">플랫폼 로그인을 위한 인증 URL을 반환</span>하는 메서드다.\r\n\r\n`AuthModule`의 `getAuthorizationUrl` 메서드를 통해 URL를 얻고, 이 내용을 담아 응답 객체로 만들어 반환한다.\r\n\r\n``` java\r\npublic Response getAuthorizationUrlResponse(String platform)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\r\n\t// 인증 URL 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tString state = UUID.randomUUID().toString();\r\n\t\t\r\n\t\trequest.getSession().setAttribute(\"state\", state);\r\n\t\t\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(Util.builder(platform, \" authrorization url response success\"));\r\n\t\tresponseBean.setBody(authModule.getAuthorizationUrl(state));\r\n\t\t\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\n동일한 세션인지 확인하기 위해 프로세스 수행 시 `state`를 생성하여 `getAuthorizationUrl`에 전달한다. 해당 메서드가 반환하는 URL에 전달한 `state`가 URL 파라미터로 입력되어있을 것이다.\r\n\r\n해당 `state`를 세션 애트리뷰트에도 등록한다.\r\n\r\n플랫폼 로그인은 여러 창을 거치기 때문에, 요청 하이재킹이 매우 쉽다. 이 과정에서 세션 정보가 손상되기 쉬우므로 `state`를 통해 로그인 과정 전체가 동일한 세션에서 이루어지고 있는지 검증할 수 있다.\r\n\r\n만약 URL의 `state`와 세션의 `state`가 일치하지 않거나, 세션 정보가 아예 없다면 정상적인 로그인 절차가 아니라고 판단할 수 있다.\r\n\r\n추후 이 세션값은 Access Token을 받아 로그인 작업을 수행할 때 사용한다.\r\n\r\n\r\n\r\n### 사용자 정보 응답 반환 메서드\r\n\r\n<span class=\"primary\">Access Token을 통해 사용자 응답</span>을 받는 메서드다.\r\n\r\n`AuthModule`의 `getUserInfoBean` 메서드를 통해 `UserInfoBean` 객체를 얻고, 이 내용을 담아 응답 객체로 만들어 반환한다.\r\n\r\n``` java\r\npublic Response getUserInfoResponse(String accessCookie)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<UserInfoBean> responseBean = new ResponseBean<>();\r\n\t\r\n\t// 사용자 정보 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\r\n\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\r\n\t\tcom.github.scribejava.core.model.Response userInfoResponse = authModule.getUserInfo(accessToken);\r\n\t\t\r\n\t\t// 응답이 정상적이지 않을 경우\r\n\t\tif (userInfoResponse.getCode() != 200)\r\n\t\t{\r\n\t\t\tthrow new OAuthResponseException(userInfoResponse);\r\n\t\t}\r\n\t\t\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(\"user info response success\");\r\n\t\tresponseBean.setBody(authModule.getUserInfoBean(userInfoResponse.getBody()));\r\n\t\t\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\n추후 설명하겠지만, <span class=\"green-600\">로그인 시 Access Token과 Refresh Token을 각각 플랫폼과 함께 JWT로 생성</span>하여 access, refresh 쿠키로 저장한다.\r\n\r\n각 JWT 쿠키에 플랫폼 정보가 있으므로, access 쿠키만 있어도 Access Token와 그 플랫폼을 찾을 수 있다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport com.github.scribejava.core.model.OAuthResponseException;\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport global.module.Util;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.bean.UserInfoBean;\r\nimport oauth.account.module.AuthModule;\r\n\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 계정 GET 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.30 Thu 21:00:48\r\n */\r\npublic class AccountGetProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountGetProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 URL 응답 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response getAuthorizationUrlResponse(String platform)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 인증 URL 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tString state = UUID.randomUUID().toString();\r\n\t\t\t\r\n\t\t\trequest.getSession().setAttribute(\"state\", state);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(Util.builder(platform, \" authrorization url response success\"));\r\n\t\t\tresponseBean.setBody(authModule.getAuthorizationUrl(state));\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response getUserInfoResponse(String accessCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<UserInfoBean> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 사용자 정보 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\t\r\n\t\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tcom.github.scribejava.core.model.Response userInfoResponse = authModule.getUserInfo(accessToken);\r\n\t\t\t\r\n\t\t\t// 응답이 정상적이지 않을 경우\r\n\t\t\tif (userInfoResponse.getCode() != 200)\r\n\t\t\t{\r\n\t\t\t\tthrow new OAuthResponseException(userInfoResponse);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"user info response success\");\r\n\t\t\tresponseBean.setBody(authModule.getUserInfoBean(userInfoResponse.getBody()));\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## POST 프로세스 구현\r\n\r\n계정 프로세스 중 `POST`에 해당하는 동작이 집합된 프로세스 클래스를 구현한다.\r\n\r\n* 로그인 응답 반환 메서드\r\n* 자동 로그인 응답 반환 메서드\r\n* 로그아웃 응답 반환 메서드\r\n\r\n`POST`에 해당하는 동작은 위 두 메서드다. 주로 로그인/로그아웃 작업으로 구성되어있다.\r\n\r\n\r\n\r\n### 로그인 응답 반환 메서드\r\n\r\n플랫폼 로그인 이후 발급되는 `code`를 통해 <span class=\"primary\">Access Token으로 교환하여 로그인을 수행</span>하는 메서드다.\r\n\r\n`AuthModule`의 `getAccessToken` 메서드를 통해 `OAuth2AccessToken` 객체를 반환받아 Access Token, Refresh Token을 추출한다.\r\n\r\n이 토큰들을 JWT 쿠키로 만들어 로그인 절차를 수행한다.\r\n\r\n``` java\r\npublic Response postLoginResponse(String platform, String code, String state)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\r\n\tHttpSession session = request.getSession();\r\n\t\r\n\t// 로그인 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tObject sessionState = Objects.requireNonNull(session.getAttribute(\"state\"));\r\n\t\t\r\n\t\t// 고유 상태값이 일치하지 않을 경우\r\n\t\tif (!state.equals(sessionState))\r\n\t\t{\r\n\t\t\tthrow new BadAttributeValueExpException(\"state is mismatched\");\r\n\t\t}\r\n\t\t\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\r\n\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getAccessToken(code);\r\n\t\t\r\n\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\tString refreshToken = oAuth2AccessToken.getRefreshToken();\r\n\t\t\r\n\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\taccessMap.put(\"access\", accessToken);\r\n\t\taccessMap.put(\"platform\", platform);\r\n\t\t\r\n\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\r\n\t\tString accessJwt = JwtModule.generateJwt(state, accessMap);\r\n\t\tString refreshJwt = JwtModule.generateJwt(state, refreshMap);\r\n\t\t\r\n\t\tNewCookie accessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", refreshToken == null ? 0 : 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(\"authorized success\");\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\t\r\n\t// 시도 후\r\n\tfinally\r\n\t{\r\n\t\tsession.invalidate();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\n`AccountGetProcess`의 `getAuthorizationUrlResponse` 동작 중 세션 애트리뷰트에 `state`를 입력했었는데, 여기서 그 <span class=\"orange-500\">세션값을 통해 검증을 수행</span>한다.\r\n\r\nURL을 통해 인수로 받은 `state`와 세션의 `state`를 추출하여 비교하고, 동일하지 않을 경우 예외를 발생시킨다. 중간에 URL을 탈취해서 전혀 다른 `code`를 삽입하여 요청을 보내도 이를 방지할 수 있는 보안책인 셈이다.\r\n\r\nAccess Token과 Refresh Token을 전달받아 JWT 쿠키로 만든다.\r\n\r\n<br />\r\n\r\n* Access Token JWT\r\n\r\n``` json\r\n{\r\n\t\"iss\": \"oauth2\",\r\n\t\"sub\": \"auth\",\r\n\t\"aud\": \"c9159786-40bf-4cf2-8c93-f683d1070137\",\r\n\t\"access\": \"{ACCESS_TOKEN}\",\r\n\t\"platform\": \"naver\",\r\n\t\"exp\": 1634986011,\r\n\t\"nbf\": 1634982411,\r\n\t\"iat\": 1634982411,\r\n\t\"jti\": \"c9159786-40bf-4cf2-8c93-f683d1070137\"\r\n}\r\n```\r\n\r\n* Refresh Token JWT\r\n\r\n``` json\r\n{\r\n\t\"iss\": \"oauth2\",\r\n\t\"sub\": \"auth\",\r\n\t\"aud\": \"c9159786-40bf-4cf2-8c93-f683d1070137\",\r\n\t\"refresh\": \"{REFRESH_TOKEN}\",\r\n\t\"platform\": \"naver\",\r\n\t\"exp\": 1634986011,\r\n\t\"nbf\": 1634982411,\r\n\t\"iat\": 1634982411,\r\n\t\"jti\": \"c9159786-40bf-4cf2-8c93-f683d1070137\"\r\n}\r\n```\r\n\r\n<br />\r\n\r\nJWT의 내용은 위와 같다. 쿠키에 해당 JWT를 담아 생성한다. <span class=\"green-400\">access 쿠키는 세션 쿠키로 생성하여 브라우저 종료 시 즉시 쿠키가 즉시 소멸</span>되도록 구성하고, <span class=\"green-400\">refresh 쿠키는 어느 정도 보관기간을 두어 추후 다시 사용할 수 있도록 구성</span>한다.\r\n\r\n쿠키 도메인은 `.itcode.dev`로 지정되어있는데, 그 이유는 프론트엔드와 백엔드가 전혀 다른 환경에서 동작하기 때문이다.\r\n\r\n* Frontend - `project.itcode.dev`\r\n* Backend - `api.itcode.dev`\r\n\r\n브라우저의 보안정책으로 다른 도메인에 쿠키를 생성할 수 없다. 때문에 `.itcode.dev`로 지정하여 모든 서브 도메인에 적용하도록 구성했다.\r\n\r\n만약 도메인을 지정하지 않으면 자동으로 `api.itcode.dev`를 대상으로 쿠키를 발급한다. 따라서 `project.itcode.dev` 도메인 서비스에서는 쿠키에 접근할 수 없다.\r\n\r\n\r\n\r\n### 자동 로그인 응답 반환 메서드\r\n\r\n만약 이전에 로그인을 수행한 이력이 있어, <span class=\"primary\">access, refresh 쿠키를 이미 가지고 있을 경우 이를 활용하여 자동 로그인을 수행</span>하는 메서드다.\r\n\r\n``` java\r\npublic Response postAutoLoginResponse(String accessCookie, String refreshCookie)\r\n{\r\n\tResponse response;\r\n\t\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\r\n\t// 자동 로그인 시도\r\n\ttry\r\n\t{\r\n\t\t// 접근 토큰 쿠키가 있을 경우\r\n\t\tif (accessCookie != null)\r\n\t\t{\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 리프레쉬 토큰 쿠키가 없을 경우\r\n\t\telse if (refreshCookie == null)\r\n\t\t{\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(\"fail\");\r\n\t\t\tresponseBean.setMessage(\"refresh token is empty\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 리프레쉬 토큰 쿠키가 있을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tJws<Claims> refreshJws = JwtModule.openJwt(refreshCookie);\r\n\t\t\t\r\n\t\t\tString refreshToken = refreshJws.getBody().get(\"refresh\", String.class);\r\n\t\t\tString platform = refreshJws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getRefreshAccessToken(refreshToken);\r\n\t\t\t\r\n\t\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\t\taccessMap.put(\"access\", accessToken);\r\n\t\t\taccessMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tString uuid = UUID.randomUUID().toString();\r\n\t\t\t\r\n\t\t\tString accessJwt = JwtModule.generateJwt(uuid, accessMap);\r\n\t\t\tString refreshJwt = JwtModule.generateJwt(uuid, refreshMap);\r\n\t\t\t\r\n\t\t\tNewCookie newAccessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t\t\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\t\t\r\n\t\tNewCookie newAccessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\t\t\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t}\r\n\t\r\n\treturn response;\r\n}\r\n```\r\n\r\naccess 쿠키가 이미 있을 경우, 이미 인증 정보가 있기 때문에 별다른 동작을 취하지 않고 넘어간다.\r\n\r\n만약 access 쿠키는 없고 <span class=\"orange-400\">refresh 쿠키만 있다면, 이를 통해 Access Token을 재발급받아 인증 정보를 갱신</span>하여 자동으로 로그인을 수행한다.\r\n\r\n로그인 로직 자체는 기존 로그인 메서드와 동일하며, Access Token만 Refresh Token을 통해 갱신하여 사용한다.\r\n\r\n\r\n\r\n### 로그아웃 응답 반환 메서드\r\n\r\n<span class=\"primary\">인증 정보를 제거</span>하여 로그아웃을 수행하는 메서드.\r\n\r\n``` java\r\npublic Response postLogoutResponse()\r\n{\r\n\tResponse response;\r\n\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\r\n\t// 로그아웃 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tNewCookie accessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\r\n\t\tresponseBean.setFlag(true);\r\n\t\tresponseBean.setTitle(\"success\");\r\n\t\tresponseBean.setMessage(\"logout success\");\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t}\r\n\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\treturn response;\r\n}\r\n```\r\n\r\n인증정보는 쿠키 기반이다. 서버에서 쿠키 생성 시 보안을 위해 `HttpOnly` 옵션을 활성화했기 때문에 JavaScript에선 access, refresh 쿠키를 다룰 수 없다.\r\n\r\n서버에서 쿠키 만료시간을 0으로 덮어씌워 인증쿠키를 제거한다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport com.github.scribejava.core.model.OAuth2AccessToken;\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.servlet.http.HttpSession;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.NewCookie;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.module.AuthModule;\r\n\r\nimport javax.management.BadAttributeValueExpException;\r\nimport java.util.HashMap;\r\nimport java.util.Objects;\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 계정 POST 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 00:53:52\r\n */\r\npublic class AccountPostProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountPostProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 로그인 응답 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t * @param code: [String] 인증 코드\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response postLoginResponse(String platform, String code, String state)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\tHttpSession session = request.getSession();\r\n\t\t\r\n\t\t// 로그인 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tObject sessionState = Objects.requireNonNull(session.getAttribute(\"state\"));\r\n\t\t\t\r\n\t\t\t// 고유 상태값이 일치하지 않을 경우\r\n\t\t\tif (!state.equals(sessionState))\r\n\t\t\t{\r\n\t\t\t\tthrow new BadAttributeValueExpException(\"state is mismatched\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getAccessToken(code);\r\n\t\t\t\r\n\t\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\t\tString refreshToken = oAuth2AccessToken.getRefreshToken();\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\t\taccessMap.put(\"access\", accessToken);\r\n\t\t\taccessMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\t\r\n\t\t\tString accessJwt = JwtModule.generateJwt(state, accessMap);\r\n\t\t\tString refreshJwt = JwtModule.generateJwt(state, refreshMap);\r\n\t\t\t\r\n\t\t\tNewCookie accessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", refreshToken == null ? 0 : 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"authorized success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 시도 후\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tsession.invalidate();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 자동 로그인 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t * @param refreshCookie: [String] 리프레쉬 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response postAutoLoginResponse(String accessCookie, String refreshCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 자동 로그인 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// 접근 토큰 쿠키가 있을 경우\r\n\t\t\tif (accessCookie != null)\r\n\t\t\t{\r\n\t\t\t\tresponseBean.setFlag(true);\r\n\t\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t\t\r\n\t\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 리프레쉬 토큰 쿠키가 없을 경우\r\n\t\t\telse if (refreshCookie == null)\r\n\t\t\t{\r\n\t\t\t\tresponseBean.setFlag(false);\r\n\t\t\t\tresponseBean.setTitle(\"fail\");\r\n\t\t\t\tresponseBean.setMessage(\"refresh token is empty\");\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t\t\r\n\t\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 리프레쉬 토큰 쿠키가 있을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tJws<Claims> refreshJws = JwtModule.openJwt(refreshCookie);\r\n\t\t\t\t\r\n\t\t\t\tString refreshToken = refreshJws.getBody().get(\"refresh\", String.class);\r\n\t\t\t\tString platform = refreshJws.getBody().get(\"platform\", String.class);\r\n\t\t\t\t\r\n\t\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\t\r\n\t\t\t\tOAuth2AccessToken oAuth2AccessToken = authModule.getRefreshAccessToken(refreshToken);\r\n\t\t\t\t\r\n\t\t\t\tString accessToken = oAuth2AccessToken.getAccessToken();\r\n\t\t\t\t\r\n\t\t\t\tHashMap<String, Object> accessMap = new HashMap<>();\r\n\t\t\t\taccessMap.put(\"access\", accessToken);\r\n\t\t\t\taccessMap.put(\"platform\", platform);\r\n\t\t\t\t\r\n\t\t\t\tHashMap<String, Object> refreshMap = new HashMap<>();\r\n\t\t\t\trefreshMap.put(\"refresh\", refreshToken);\r\n\t\t\t\trefreshMap.put(\"platform\", platform);\r\n\t\t\t\t\r\n\t\t\t\tString uuid = UUID.randomUUID().toString();\r\n\t\t\t\t\r\n\t\t\t\tString accessJwt = JwtModule.generateJwt(uuid, accessMap);\r\n\t\t\t\tString refreshJwt = JwtModule.generateJwt(uuid, refreshMap);\r\n\t\t\t\t\r\n\t\t\t\tNewCookie newAccessCookie = new NewCookie(\"access\", accessJwt, \"/oauth2\", \".itcode.dev\", \"access token\", -1, true, true);\r\n\t\t\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", refreshJwt, \"/oauth2\", \".itcode.dev\", \"refresh token\", 86400 * 7 + 3600 * 9, true, true);\r\n\t\t\t\t\r\n\t\t\t\tresponseBean.setFlag(true);\r\n\t\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\t\tresponseBean.setMessage(\"auto authorized success\");\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t\t\r\n\t\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tNewCookie newAccessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\t\tNewCookie newRefreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).cookie(newAccessCookie, newRefreshCookie).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 로그아웃 응답 반환 메서드\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response postLogoutResponse()\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 로그아웃 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tNewCookie accessCookie = new NewCookie(\"access\", null, \"/oauth2\", \".itcode.dev\", \"access token\", 0, true, true);\r\n\t\t\tNewCookie refreshCookie = new NewCookie(\"refresh\", null, \"/oauth2\", \".itcode.dev\", \"refresh token\", 0, true, true);\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(\"logout success\");\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).cookie(accessCookie, refreshCookie).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## PUT 프로세스 구현\r\n\r\n계정 프로세스 중 `PUT`에 해당하는 동작이 집합된 프로세스를 구현한다.\r\n\r\n* 정보 제공 동의 갱신 URL 응답 반환 메서드\r\n\r\n`PUT`에 해당하는 메서드는 하나다. 데이터를 수정하는 작업들로 구성되어있다.\r\n\r\n\r\n\r\n### 정보 제공 동의 갱신 URL 응답 반환 메서드\r\n\r\n<span class=\"primary\">정보 제공 동의를 새로 갱신하는 URL을 반환</span>하는 메서드다.\r\n\r\n``` java\r\npublic Response putUpdateAuthorizationUrl(String accessCookie)\r\n{\r\n\tResponse response;\r\n\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\r\n\t// 정보 제공 동의 갱신 URL 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tString state = UUID.randomUUID().toString();\r\n\r\n\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\r\n\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\r\n\t\tString url = authModule.getUpdateAuthorizationUrl(state);\r\n\r\n\t\t// URL이 null일 경우\r\n\t\tif (url == null)\r\n\t\t{\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(\"skipped\");\r\n\t\t\tresponseBean.setMessage(Util.builder(platform, \" doesn't need that service\"));\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t}\r\n\r\n\t\t// URL이 유효할 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\trequest.getSession().setAttribute(\"state\", state);\r\n\r\n\t\t\tresponseBean.setFlag(true);\r\n\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\tresponseBean.setMessage(Util.builder(platform, \" reauthrorization url response success\"));\r\n\t\t\tresponseBean.setBody(url);\r\n\t\t}\r\n\r\n\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\treturn response;\r\n}\r\n```\r\n\r\n첫 로그인 시, 서비스가 요구하는 정보에 대해 동의/거부하는 절차를 거친다. 이후 유저 정보 요청 시, 이 정보 제공 동의 여부에 의거하여 동의한 정보만을 제공한다.\r\n\r\n만약 서비스 운영 도중 요구 정보가 변경되어 추가적인 정보가 필요하다면, 정보 제공 동의를 갱신할 필요가 있다.\r\n\r\n서비스는 반환받은 URL로 리다이렉션하여 동의를 갱신한 뒤 갱신된 정보가 반영된 `code`를 반환한다. 이후의 과정은 로그인과 동일한 과정을 거친다.\r\n\r\n<br />\r\n\r\n즉, <span class=\"blue-400\">정보 제공 동의는 새로운 정보를 갱신하여 로그인을 다시 수행하는 것과 동일</span>하다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport global.module.Util;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.module.AuthModule;\r\n\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 계정 PUT 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.19 Tue 21:56:32\r\n */\r\npublic class AccountPutProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountPutProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response putUpdateAuthorizationUrl(String accessCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 정보 제공 동의 갱신 URL 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tString state = UUID.randomUUID().toString();\r\n\t\t\t\r\n\t\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\t\r\n\t\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\tString url = authModule.getUpdateAuthorizationUrl(state);\r\n\t\t\t\r\n\t\t\t// URL이 null일 경우\r\n\t\t\tif (url == null)\r\n\t\t\t{\r\n\t\t\t\tresponseBean.setFlag(false);\r\n\t\t\t\tresponseBean.setTitle(\"skipped\");\r\n\t\t\t\tresponseBean.setMessage(Util.builder(platform, \" doesn't need that service\"));\r\n\t\t\t\tresponseBean.setBody(null);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// URL이 유효할 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\trequest.getSession().setAttribute(\"state\", state);\r\n\t\t\t\t\r\n\t\t\t\tresponseBean.setFlag(true);\r\n\t\t\t\tresponseBean.setTitle(\"success\");\r\n\t\t\t\tresponseBean.setMessage(Util.builder(platform, \" reauthrorization url response success\"));\r\n\t\t\t\tresponseBean.setBody(url);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresponse = Response.ok(responseBean, MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## DELETE 프로세스 구현\r\n\r\n계정 프로세스 중 `DELETE`에 해당하는 동작이 집합된 프로세스를 구현한다.\r\n\r\n* 연동 해제 응답 반환 메서드\r\n\r\n`DELETE`에 해당하는 메서드는 하나다. 주로 데이터를 삭제하는 작업들로 구성되어있다.\r\n\r\n\r\n\r\n### 연동 해제 응답 반환 메서드\r\n\r\n<span class=\"primary\">플랫폼과의 연동을 완전히 해제하고 로그아웃을 수행</span>하는 메서드다.\r\n\r\n``` java\r\npublic Response deleteInfoResponse(String accessCookie)\r\n{\r\n\tResponse response;\r\n\r\n\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\r\n\t// 연동 해제 응답 생성 시도\r\n\ttry\r\n\t{\r\n\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\r\n\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\r\n\t\tAuthModule authModule = getAuthModule(platform);\r\n\r\n\t\t// 연동 해제에 성공할 경우\r\n\t\tif (authModule.deleteInfo(accessToken))\r\n\t\t{\r\n\t\t\tresponse = new AccountPostProcess(request, this.response).postLogoutResponse();\r\n\t\t}\r\n\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new RequestAuthenticationException(\"revoke fail\");\r\n\t\t}\r\n\t}\r\n\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\r\n\t\tresponseBean.setFlag(false);\r\n\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\tresponseBean.setMessage(e.getMessage());\r\n\t\tresponseBean.setBody(null);\r\n\r\n\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t}\r\n\r\n\treturn response;\r\n}\r\n```\r\n\r\n플랫폼과의 연동을 해제하면 발급받았던 Access Token과 Refresh Token이 만료되어 더 이상 제 기능을 할 수 없게 된다.\r\n\r\n보통 회원탈퇴 시 이루어지는 과정이지만, 이 프로젝트는 별도의 회원가입이랄게 따로 없으므로, 자동으로 로그아웃을 시키는 것으로 끝난다.\r\n\r\n추후 재로그인 시 처음 로그인하는 것과 동일한 과정을 거치게 된다.\r\n\r\n\r\n\r\n### 전체 코드\r\n\r\n``` java\r\npackage oauth.account.process;\r\n\r\nimport global.bean.ResponseBean;\r\nimport global.module.JwtModule;\r\nimport global.module.Process;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport oauth.account.module.AuthModule;\r\nimport org.glassfish.jersey.client.authentication.RequestAuthenticationException;\r\n\r\n/**\r\n * 계정 DELETE 프로세스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.02 Sat 00:53:52\r\n */\r\npublic class AccountDeleteProcess extends Process\r\n{\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param request: [HttpServletRequest] HttpServletRequest 객체\r\n\t * @param response: [HttpServletResponse] HttpServletResponse 객체\r\n\t */\r\n\tpublic AccountDeleteProcess(HttpServletRequest request, HttpServletResponse response)\r\n\t{\r\n\t\tsuper(request, response);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 연동 해제 응답 반환 메서드\r\n\t *\r\n\t * @param accessCookie: [String] 접근 토큰 쿠키\r\n\t *\r\n\t * @return [Response] 응답 객체\r\n\t */\r\n\tpublic Response deleteInfoResponse(String accessCookie)\r\n\t{\r\n\t\tResponse response;\r\n\t\t\r\n\t\tResponseBean<String> responseBean = new ResponseBean<>();\r\n\t\t\r\n\t\t// 연동 해제 응답 생성 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tJws<Claims> jws = JwtModule.openJwt(accessCookie);\r\n\t\t\t\r\n\t\t\tString accessToken = jws.getBody().get(\"access\", String.class);\r\n\t\t\tString platform = jws.getBody().get(\"platform\", String.class);\r\n\t\t\t\r\n\t\t\tAuthModule authModule = getAuthModule(platform);\r\n\t\t\t\r\n\t\t\t// 연동 해제에 성공할 경우\r\n\t\t\tif (authModule.deleteInfo(accessToken))\r\n\t\t\t{\r\n\t\t\t\tresponse = new AccountPostProcess(request, this.response).postLogoutResponse();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthrow new RequestAuthenticationException(\"revoke fail\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t\t\r\n\t\t\tresponseBean.setFlag(false);\r\n\t\t\tresponseBean.setTitle(e.getClass().getSimpleName());\r\n\t\t\tresponseBean.setMessage(e.getMessage());\r\n\t\t\tresponseBean.setBody(null);\r\n\t\t\t\r\n\t\t\tresponse = Response.status(Response.Status.BAD_REQUEST).entity(responseBean).type(MediaType.APPLICATION_JSON).build();\r\n\t\t}\r\n\t\t\r\n\t\treturn response;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\n이로써 프로젝트 구현을 완료했다. `NaverAuthModule`, `GoogleAuthModule` 같은 각기 다른 인증모듈을 `AuthModule`이라는 상위 객체로 반환받은 덕분에 복잡한 분기나 중복 코드를 막을 수 있었다.\r\n\r\n파이프라인이 나눠지는 순간, 이와 연결된 하위 파이프라인까지 강제로 분리되는 경향이 있다. 가장 밑단인 모듈을 적절히 설계한 덕분에, 그 상위 파이프라인들은 하나로 관리할 수 있음을 확인할 수 있다.\r\n\r\n다음 장에서는 Jersey를 통한 컨트롤러 구성 방법에 대해 다룬다.","url":["2021-10-24-oauth2-java-server-8","2021","10","24","oauth2-java-server-8"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 7. GitHub OAuth 서비스 신청 및 모듈 구현하기","excerpt":"마지막 플랫폼으로, GitHub에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-23T05:08:46","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","scribeJAVA"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-23-oauth2-java-server-7.md","content":"\r\n# 개요\r\n\r\n마지막 플랫폼으로, GitHub에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.\r\n\r\n\r\n\r\n\r\n\r\n# GitHub OAuth 서비스 신청하기\r\n\r\nAPI 정보를 얻기 위해 GitHub OAuth 서비스를 신청하자.\r\n\r\n\r\n\r\n## 1. OAuth Apps 생성하기\r\n\r\n로그인 후 [GitHub Developer Settings](https://github.com/settings/developers)에 접속하자.\r\n\r\n상단 프로필 메뉴에서 [<span class=\"lightBlue-600\">Setting</span> - <span class=\"lightBlue-600\">Developer Settings</span> - <span class=\"lightBlue-600\">OAuth Apps</span>]를 클릭하여 접속할 수도 있다.\r\n\r\n[<span class=\"lightBlue-600\">New OAuth App</span>]을 클릭하여 새로운 애플리케이션을 생성하자.\r\n\r\n<br />\r\n\r\n필수사항을 입력하면 된다. GitHub는 Callback URL를 하나만 입력할 수 있는 것 같다.\r\n\r\n\r\n\r\n## 2. Client Secret 생성하기\r\n\r\n생성한 애플리케이션을 클릭한다. [<span class=\"lightBlue-600\">Generate a new client secret</span>]을 클릭하여 새로운 Client Secret을 발급받는다. 암호 확인 과정이 필요하다.\r\n\r\n생성 직후 키를 보여주며, 창을 닫게 되면 해당 키는 다시 확인할 수 없으므로 적당한 곳에 임시로 기록해두던지 하자.\r\n\r\n잊어버릴 경우 다시 발급받아야한다.\r\n\r\n\r\n\r\n## 3. API 키 확인\r\n\r\n메인 화면인 [<span class=\"lightBlue-600\">General</span>]에서 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138511105-63c370c1-2131-4ab7-871d-9eb023ea1374.png)\r\n\r\n<span class=\"primary\">Client ID</span>는 상시 확인 가능하고, <span class=\"primary\">Client Secret</span>은 발급 직후에만 일시적으로 확인 가능하다는 점을 주의하자\r\n\r\nGitHub OAuth는 이게 끝이다. <span class=\"red-400\">별도의 정보 동의 과정도 요구하지 않는다.</span> 그도 그럴 것이, GitHub의 OAuth 키는 프로필 정보만 불러올 수 있기 때문.\r\n\r\n\r\n\r\n# GitHub 인증 모듈 구현하기\r\n\r\n필요한 모든 준비가 갖춰졌으니, GitHub 인증 모듈을 구현해보자. 이전에 구현한 `AuthModule`을 상속받아 구현할 것이다.\r\n\r\n``` java\r\npublic class GithubAuthModule extends AuthModule\r\n{\r\n\t// GitHub 인증 모듈\r\n}\r\n```\r\n\r\n객체의 기본 형식은 위와 같다.\r\n\r\n|           메서드            | 메서드 타입 |                 내용                  | 구현 필요 여부 |\r\n| :-------------------------: | :---------: | :-----------------------------------: | :------------: |\r\n|    `getAuthorizationUrl`    |    추상     |         인증 URL 반환 메서드          |       Y        |\r\n|      `getAccessToken`       |             |         접근 토큰 반환 메서드         |       Y        |\r\n|   `getRefreshAccessToken`   |             |     접근 토큰 갱신 및 반환 메서드     |                |\r\n|        `getUserInfo`        |             |     사용자 정보 응답 반환 메서드      |       Y        |\r\n|  `getRefreshTokenEndpoint`  |             | 접근 토큰 재발급 요청 URL 반환 메서드 |                |\r\n|       `getApiKeyBean`       |             |        API 키 객체 반환 메서드        |                |\r\n|    `getUserInfoEndPoint`    |             |   사용자 정보 요청 URL 반환 메서드    |                |\r\n|      `getUserInfoBean`      |    추상     |      유저 정보 객체 반환 메서드       |       Y        |\r\n|        `deleteInfo`         |    추상     |      연동 해제 결과 반환 메서드       |       Y        |\r\n| `getUpdateAuthorizationUrl` |    추상     |  정보 제공 동의 갱신 URL 반환 메서드  |       Y        |\r\n|  `getAccessTokenEndpoint`   |    추상     |    접근 토큰 요청 URL 반환 메서드     |       Y        |\r\n|  `getAuthorizationBaseUrl`  |    추상     |     인증 API 요청 URL 반환 메서드     |       Y        |\r\n\r\nGutHub 모듈이 구현해야하는 대상은 위와 같다. 이전 플랫폼과 다르게 `getAccessToken`, `getUserInfo`의 오버라이딩이 필요하다.\r\n\r\n\r\n\r\n## properties 파일 생성하기\r\n\r\n`WEB-INF` 아래 `github.properties` 파일을 생성한다. 기 생성된 `sample.properties`를 복사해서 사용해도 된다.\r\n\r\n``` properties\r\napi=API_KEY\r\nsecret=SECRET_KEY\r\ncallback=CALLBACK_URL\r\n```\r\n\r\n기본적인 형식은 위와 같으며, 각 항목에 해당하는 값을 입력하면 된다.\r\n\r\n\r\n\r\n## 인증 모듈 기본 메서드 및 변수 할당하기\r\n\r\n인증 모듈이 정상적으로 동작하기 위해선 기본적으로 지정해줘야할 메서드와 변수들이 존재한다. API 정보 설정, 인스턴스 반환같은 것들이다.\r\n\r\n``` java\r\nprivate static final String MODULE_NAME = \"github\";\r\n\t\r\nprivate static final String API_KEY;\r\nprivate static final String SECRET_KEY;\r\nprivate static final String CALLBACK_URL;\r\n\r\nstatic\r\n{\r\n\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\r\n\tAPI_KEY = apiKeyBean.getApi();\r\n\tSECRET_KEY = apiKeyBean.getSecret();\r\n\tCALLBACK_URL = apiKeyBean.getCallback();\r\n}\r\n\r\nprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL);\r\n\r\nprivate static final GithubAuthModule INSTANCE = new GithubAuthModule(SERVICE_BUILDER);\r\n\r\nprivate GithubAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n{\r\n\tsuper(serviceBuilder);\r\n}\r\n\r\npublic static GithubAuthModule getInstance()\r\n{\r\n\treturn INSTANCE;\r\n}\r\n```\r\n\r\n|       구분        |          형식           |         내용         |\r\n| :---------------: | :---------------------: | :------------------: |\r\n|   `MODULE_NAME`   |        `String`         |      모듈 이름       |\r\n|     `API_KEY`     |        `String`         |        API키         |\r\n|   `SECRET_KEY`    |        `String`         |       Secret키       |\r\n|  `CALLBACK_URL`   |        `String`         |       콜백 URL       |\r\n| `SERVICE_BUILDER` | `ServiceBuilderOAuth20` | OAuth2.0 서비스 빌더 |\r\n|    `INSTANCE`     |   `GithubAuthModule`    |       인스턴스       |\r\n\r\n정의된 변수는 전부 `static final`로 선언되어 있어서, 인스턴스 생성 시 한 번만 선언되며 재할당이 불가능하도록 관리한다.\r\n\r\n`static{ }` 구문을 통해 인스턴스 생성 시 API 정보를 할당하도록 구성했다.\r\n\r\nAPI 할당 시 `getApiKeyBean()` 메서드를 통해 제공된 이름을 갖는 properties를 분석하여 `ApiKeyBean` 객체를 반환받아 사용한다.\r\n\r\n\r\n\r\n## API URL 할당하기\r\n\r\n각 API 별 요청 URL을 반환하는 메서드를 구현하자.\r\n\r\n``` java\r\n@Override\r\npublic String getAccessTokenEndpoint()\r\n{\r\n\treturn \"https://github.com/login/oauth/access_token\";\r\n}\r\n\r\n@Override\r\nprotected String getAuthorizationBaseUrl()\r\n{\r\n\treturn \"https://github.com/login/oauth/authorize\";\r\n}\r\n\r\n@Override\r\nprotected String getUserInfoEndPoint()\r\n{\r\n\treturn \"https://api.github.com/users/RWB0104\";\r\n}\r\n```\r\n\r\n* `getAccessTokenEndpoint()` - 토큰과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getAuthorizationBaseUrl()` - 인증과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getUserInfoEndPoint()` - 사용자 정보와 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n\r\nOAuth2.0 서비스를 수행함에 있어서 필요한 URL은 위와 같다. 이 중 `getAccessTokenEndpoint()`과 `getAuthorizationBaseUrl()`는 scribeJAVA 라이브러리의 객체인 `DefaultApi20`의 추상 메서드고 나머지 하나가 `AuthModule`의 추상 메서드다.\r\n\r\n`DefaultApi20`는 사용자 계정 API에 관련된 메서드를 별도로 제공하지 않는다. 하지만 `AuthModule`에서 사용자 정보 확인 공통 메서드를 사용할 때 사용자 계정 API가 반드시 필요하므로 `AuthModule`의 추상 메서드로 관리한다.\r\n\r\n\r\n\r\n## 인증 URL 반환 메서드\r\n\r\n<span class=\"blue-500\">GitHub 플랫폼 로그인 URL을 반환하는 기능</span>을 구현한다.\r\n\r\n우선 API를 살펴보자.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET https://github.com/login/oauth/authorize?response_type=code&client_id={:client_id}&redirect_uri={:redirect_uri}&state={:state}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |       description        |\r\n| :--------------: | :---: | :------: | :------: | :----------------------: |\r\n| {:response_type} | path  | `String` |    Y     | 응답 타입. `code`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |          API키           |\r\n| {:redirect_uri}  | path  | `String` |    Y     |       Callback URL       |\r\n|     {:state}     | path  | `String` |    Y     |       고유 상태값        |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\nGitHub 플랫폼 로그인 페이지\r\n\r\n<br />\r\n\r\nGitHub 플랫폼 로그인 API는 위와 같다. 메서드가 요청의 URL을 반환하도록 설계하면 된다.\r\n\r\n문자열 연산으로 URL을 직접 설계할 수도 있지만, `service.getAuthorizationUrl()` 메서드를 통해 URL을 간편하게 생성할 수 있다.\r\n\r\n<br />\r\n\r\n이미 `AuthModule`에 공통 메서드로 선언된 게 있으므로, <span class=\"red-400\">따로 구현하지 않아도 된다.</span>\r\n\r\n\r\n\r\n## 접근 토큰 반환 메서드\r\n\r\n로그인 결과로 Code를 전달받으므로 <span class=\"blue-500\">Access Token으로 교환하는 기능</span>을 구현한다.\r\n\r\nGitHub는 `Accept` 헤더로 JSON MIME를 지정해야하는데, 아쉽게도 scribeJAVA에는 임의 헤더를 넣어 인증 URL을 생성하는 API는 존재하지 않는다.\r\n\r\nAccess Token도 없으므로 <span class=\"red-400\">HttpURLConnection으로 직접 구현</span>해야한다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nPOST https://kauth.kakao.com/oauth/token?grant_type=authorization_code&client_id={:client_id}&client_secret={:client_secret}&redirect_uri={:redirect_uri}&code={:code}\r\nAccept: application/json\r\n```\r\n\r\n|    parameter     | type  |   data   | required |              description               |\r\n| :--------------: | :---: | :------: | :------: | :------------------------------------: |\r\n|  {:grant_type}   | path  | `String` |    Y     | 인증 타입. `authorization_code`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |                 API키                  |\r\n| {:client_secret} | path  | `String` |    Y     |                Secret키                |\r\n| {:redirect_uri}  | path  | `String` |    Y     |              Callback URL              |\r\n|     {:code}      | path  | `String` |    Y     |               인가 코드                |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"access_token\": \"gho_16C7e42F292c6912E7710c838347Ae178B4a\",\r\n\t\"scope\": \"repo,gist\",\r\n\t\"token_type\": \"bearer\"\r\n}\r\n```\r\n\r\n|  parameter   |   data   | description |\r\n| :----------: | :------: | :---------: |\r\n| access_token | `String` |  인증 토큰  |\r\n|  token_type  | `String` |  토큰 타입  |\r\n|    scope     | `String` |  접근 권한  |\r\n\r\n<br />\r\n\r\n`AccessTokenRequestParams` 객체로 요청을 생성하여 `service.getAccessToken`으로 응답을 받는다.\r\n\r\n특이하게 응답 헤더를 반드시 지정해야하므로, <span class=\"red-600\">별도로 오버라이딩해서 사용</span>한다.\r\n\r\n\r\n\r\n## 접근 토큰 갱신 및 반환 메서드\r\n\r\n위 응답을 보면 알 수 있듯이, <span class=\"orange-600\">GitHub는 Refresh Token이 따로 존재하지 않는다.</span> Access Token의 만료시간도 없다. GitHub는 그냥 Access Token 하나만 다루게 된다.\r\n\r\nRefresh Token이 없으므로 기능 자체가 쓸모가 없다. 따라서 Github에선 건들지 않는다.\r\n\r\n\r\n\r\n## 사용자 정보 응답 반환 메서드\r\n\r\n<span class=\"blue-500\">Access Token으로 유저 정보를 호출하는 기능</span>을 구현한다. 발급받은 Access Token을 실제로 유의미하게 쓰는 부분이다.\r\n\r\nGitHub API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://api.github.com/user\r\nAuthorization: token {:access_token}\r\n```\r\n\r\n|    parameter    |  type  |   data   | required | description |\r\n| :-------------: | :----: | :------: | :------: | :---------: |\r\n| {:access_token} | header | `String` |    Y     |  접근 토큰  |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"login\": \"octocat\",\r\n\t\"id\": 1,\r\n\t\"node_id\": \"MDQ6VXNlcjE=\",\r\n\t\"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\",\r\n\t\"gravatar_id\": \"\",\r\n\t\"url\": \"https://api.github.com/users/octocat\",\r\n\t\"html_url\": \"https://github.com/octocat\",\r\n\t\"followers_url\": \"https://api.github.com/users/octocat/followers\",\r\n\t\"following_url\": \"https://api.github.com/users/octocat/following{/other_user}\",\r\n\t\"gists_url\": \"https://api.github.com/users/octocat/gists{/gist_id}\",\r\n\t\"starred_url\": \"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\r\n\t\"subscriptions_url\": \"https://api.github.com/users/octocat/subscriptions\",\r\n\t\"organizations_url\": \"https://api.github.com/users/octocat/orgs\",\r\n\t\"repos_url\": \"https://api.github.com/users/octocat/repos\",\r\n\t\"events_url\": \"https://api.github.com/users/octocat/events{/privacy}\",\r\n\t\"received_events_url\": \"https://api.github.com/users/octocat/received_events\",\r\n\t\"type\": \"User\",\r\n\t\"site_admin\": false,\r\n\t\"name\": \"monalisa octocat\",\r\n\t\"company\": \"GitHub\",\r\n\t\"blog\": \"https://github.com/blog\",\r\n\t\"location\": \"San Francisco\",\r\n\t\"email\": \"octocat@github.com\",\r\n\t\"hireable\": false,\r\n\t\"bio\": \"There once was...\",\r\n\t\"twitter_username\": \"monatheoctocat\",\r\n\t\"public_repos\": 2,\r\n\t\"public_gists\": 1,\r\n\t\"followers\": 20,\r\n\t\"following\": 0,\r\n\t\"created_at\": \"2008-01-14T04:33:35Z\",\r\n\t\"updated_at\": \"2008-01-14T04:33:35Z\",\r\n\t\"private_gists\": 81,\r\n\t\"total_private_repos\": 100,\r\n\t\"owned_private_repos\": 100,\r\n\t\"disk_usage\": 10000,\r\n\t\"collaborators\": 8,\r\n\t\"two_factor_authentication\": true,\r\n\t\"plan\": {\r\n\t\t\"name\": \"Medium\",\r\n\t\t\"space\": 400,\r\n\t\t\"private_repos\": 20,\r\n\t\t\"collaborators\": 0\r\n\t}\r\n}\r\n```\r\n\r\n응답 명세는 GitHub에서 명확하게 제공하지 않는다. 확실한건 `email`, `login`, `avatar_url`를 쓰면 될 것 같다.\r\n\r\n\r\n\r\n## 유저 정보 객체 반환 메서드\r\n\r\n<span class=\"blue-500\">GitHub의 유저 정보 호출 API 응답 형식에 맞게끔 응답을 파싱</span>하여 `UserInfoBean`로 반환하는 메서드를 구현한다.\r\n\r\n이 프로젝트에선 이름, 이메일, 프로필사진 URL만을 사용하므로, 응답에서 해당 값을 빼내어 객체에 담는다.\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n{\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tJsonNode node = mapper.readTree(body);\r\n\t\r\n\tString email = node.get(\"email\") == null ? \"미동의\" : node.get(\"email\").textValue();\r\n\tString name = node.get(\"name\") == null ? \"미동의\" : node.get(\"name\").textValue();\r\n\tString picture = node.get(\"avatar_url\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"avatar_url\").textValue();\r\n\t\r\n\treturn new UserInfoBean(email, name, picture, MODULE_NAME);\r\n}\r\n```\r\n\r\n<br />\r\n\r\n응답 형식에 맞추어 필요한 값을 추출한다. 만약, 사용자가 정보 제공에 동의하지 않았을 경우 대상 객체가 `null`을 반환한다. 데이터의 누락 시 오류를 방지하기 위해 데이터에 대한 `null` 처리를 반드시 해야한다.\r\n\r\n\r\n\r\n## 연동 해제 결과 반환 메서드\r\n\r\n카카오 아이디로 처음 로그인을 하면 정보 제공 동의를 수행하는데, 나중에 다시 로그인을 하면 이러한 동의 과정이 생략된다. 즉, 플랫폼에서 첫 로그인 시 정보 제공 동의를 받아 어딘가로부터 저장한다는 뜻이다. 만약 사용자가 서비스로부터 회원 탈퇴를 수행한다면 <span class=\"blue-500\">GitHub와의 연동을 해제하여 정보를 완전히 삭제</span>할 필요가 있다.\r\n\r\nGitHub API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nDELETE https://api.github.com/applications/{:client_id}/grant\r\nAuthorization: Basic {:auth}\r\nAccept: application/vnd.github.v3+json\r\nContent-Type: application/x-www-form-urlencoded\r\n```\r\n\r\n|  parameter   |  type  |   data   | required |           description           |\r\n| :----------: | :----: | :------: | :------: | :-----------------------------: |\r\n| {:client_id} |  path  | `String` |    Y     |             API 키              |\r\n|   {:auth}    | header | `String` |    Y     | API 키와 Secret 키의 Basic 인증 |\r\n\r\n> <b class=\"orange-600\">ID:PW 기반의 Basic 헤더</b>  \r\n> Basic 헤더는 ID:PW 기반의 인증 방식이다. ID와 PW를 [ID:PW]와 같이 `:`로 조인한 하나의 문자열로 만든다. 해당 텍스트를 헤더에 사용한다.\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n응답은 204로, 아무도 오지 않는다.\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n{\r\n\tHashMap<String, String> params = new HashMap<>();\r\n\tparams.put(\"access_token\", access);\r\n\t\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tbyte[] paramBytes = mapper.writeValueAsString(params).getBytes(StandardCharsets.UTF_8);\r\n\t\r\n\tURL url = new URL(Util.builder(\"https://api.github.com/applications/\", API_KEY, \"/grant\"));\r\n\t\r\n\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\tconnection.setRequestMethod(\"DELETE\");\r\n\tconnection.addRequestProperty(\"Authorization\", Util.builder(\"Basic \", Base64.getEncoder().encodeToString(Util.builder(API_KEY, \":\", SECRET_KEY).getBytes())));\r\n\tconnection.addRequestProperty(\"Accept\", \"application/vnd.github.v3+json\");\r\n\tconnection.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\tconnection.setDoOutput(true);\r\n\tconnection.getOutputStream().write(paramBytes);\r\n\t\r\n\tint status = connection.getResponseCode();\r\n\t\r\n\tconnection.disconnect();\r\n\t\r\n\treturn status == 204;\r\n}\r\n```\r\n\r\n구현은 간단하다. `OAuthRequest` 객체를 활용하면 요청을 쉽게 생성할 수 있다. 응답 자체는 중요하지 않다. 이번엔 응답이 204이므로, 응답 상태값이 204인지 비교하여 결과를 반환한다.\r\n\r\n\r\n\r\n## 정보 제공 동의 갱신 URL 반환 메서드\r\n\r\n<span class=\"red-400\">GitHub는 별도의 동의가 이루어지지 않으므로 무시</span>한다.\r\n\r\n\r\n\r\n\r\n## 전체 코드\r\n\r\n``` java\r\npackage oauth.account.module;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.github.scribejava.core.builder.ServiceBuilder;\r\nimport com.github.scribejava.core.builder.ServiceBuilderOAuth20;\r\nimport com.github.scribejava.core.model.OAuth2AccessToken;\r\nimport com.github.scribejava.core.model.OAuthRequest;\r\nimport com.github.scribejava.core.model.Response;\r\nimport com.github.scribejava.core.model.Verb;\r\nimport global.module.Util;\r\nimport oauth.account.bean.ApiKeyBean;\r\nimport oauth.account.bean.UserInfoBean;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URL;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.Base64;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n/**\r\n * GitHub 인증 모듈 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.05 Tue 00:22:10\r\n */\r\npublic class GithubAuthModule extends AuthModule\r\n{\r\n\tprivate static final String MODULE_NAME = \"github\";\r\n\t\r\n\tprivate static final String API_KEY;\r\n\tprivate static final String SECRET_KEY;\r\n\tprivate static final String CALLBACK_URL;\r\n\t\r\n\tstatic\r\n\t{\r\n\t\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\t\r\n\t\tAPI_KEY = apiKeyBean.getApi();\r\n\t\tSECRET_KEY = apiKeyBean.getSecret();\r\n\t\tCALLBACK_URL = apiKeyBean.getCallback();\r\n\t}\r\n\t\r\n\tprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL);\r\n\t\r\n\tprivate static final GithubAuthModule INSTANCE = new GithubAuthModule(SERVICE_BUILDER);\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param serviceBuilder: [ServiceBuilderOAuth20] API 서비스 빌더\r\n\t */\r\n\tprivate GithubAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n\t{\r\n\t\tsuper(serviceBuilder);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인스턴스 반환 메서드\r\n\t *\r\n\t * @return [GithubAuthModule] 인스턴스\r\n\t */\r\n\tpublic static GithubAuthModule getInstance()\r\n\t{\r\n\t\treturn INSTANCE;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param code: [String] 인증 코드\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\t@Override\r\n\tpublic OAuth2AccessToken getAccessToken(String code) throws IOException\r\n\t{\r\n\t\tHashMap<String, String> params = new HashMap<>();\r\n\t\tparams.put(\"client_id\", API_KEY);\r\n\t\tparams.put(\"client_secret\", SECRET_KEY);\r\n\t\tparams.put(\"redirect_uri\", CALLBACK_URL);\r\n\t\tparams.put(\"code\", code);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (Map.Entry<String, String> param : params.entrySet())\r\n\t\t{\r\n\t\t\tString pre = builder.length() == 0 ? \"\" : \"&\";\r\n\t\t\t\r\n\t\t\tbuilder.append(pre).append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8)).append(\"=\").append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\r\n\t\t}\r\n\t\t\r\n\t\tbyte[] paramBytes = builder.toString().getBytes(StandardCharsets.UTF_8);\r\n\t\t\r\n\t\tURL url = new URL(getAccessTokenEndpoint());\r\n\t\t\r\n\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\t\tconnection.setRequestMethod(\"POST\");\r\n\t\tconnection.setRequestProperty(\"Accept\", \"application/json\");\r\n\t\tconnection.setDoOutput(true);\r\n\t\tconnection.getOutputStream().write(paramBytes);\r\n\t\t\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\r\n\t\t\r\n\t\tStringBuilder responseBuilder = new StringBuilder();\r\n\t\tString temp;\r\n\t\t\r\n\t\twhile ((temp = reader.readLine()) != null)\r\n\t\t{\r\n\t\t\tresponseBuilder.append(temp);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t\tconnection.disconnect();\r\n\t\t\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(responseBuilder.toString());\r\n\t\t\r\n\t\tString access_token = node.get(\"access_token\") == null ? \"미동의\" : node.get(\"access_token\").textValue();\r\n\t\tString token_type = node.get(\"token_type\") == null ? \"미동의\" : node.get(\"token_type\").textValue();\r\n\t\tString scope = node.get(\"scope\") == null ? \"미동의\" : node.get(\"scope\").textValue();\r\n\t\t\r\n\t\treturn new OAuth2AccessToken(access_token, token_type, 0, null, scope, responseBuilder.toString());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 응답 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [Response] 사용자 정보 응답\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\t@Override\r\n\tpublic Response getUserInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getUserInfoEndPoint());\r\n\t\toAuthRequest.addHeader(\"Authorization\", Util.builder(\"token \", access));\r\n\t\t\r\n\t\tservice.signRequest(access, oAuthRequest);\r\n\t\t\r\n\t\treturn service.execute(oAuthRequest);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 유저 정보 객체 반환 메서드\r\n\t *\r\n\t * @param body: [String] OAuth 응답 내용\r\n\t *\r\n\t * @return [UserInfoBean] 유저 정보 객체\r\n\t *\r\n\t * @throws JsonProcessingException JSON 파싱 예외\r\n\t */\r\n\t@Override\r\n\tpublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n\t{\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(body);\r\n\t\t\r\n\t\tString email = node.get(\"email\") == null ? \"미동의\" : node.get(\"email\").textValue();\r\n\t\tString name = node.get(\"name\") == null ? \"미동의\" : node.get(\"name\").textValue();\r\n\t\tString picture = node.get(\"avatar_url\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"avatar_url\").textValue();\r\n\t\t\r\n\t\treturn new UserInfoBean(email, name, picture, MODULE_NAME);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 연동 해제 결과 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [boolean] 연동 해제 결과\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\t@Override\r\n\tpublic boolean deleteInfo(String access) throws IOException\r\n\t{\r\n\t\tHashMap<String, String> params = new HashMap<>();\r\n\t\tparams.put(\"access_token\", access);\r\n\t\t\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tbyte[] paramBytes = mapper.writeValueAsString(params).getBytes(StandardCharsets.UTF_8);\r\n\t\t\r\n\t\tURL url = new URL(Util.builder(\"https://api.github.com/applications/\", API_KEY, \"/grant\"));\r\n\t\t\r\n\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\t\tconnection.setRequestMethod(\"DELETE\");\r\n\t\tconnection.addRequestProperty(\"Authorization\", Util.builder(\"Basic \", Base64.getEncoder().encodeToString(Util.builder(API_KEY, \":\", SECRET_KEY).getBytes())));\r\n\t\tconnection.addRequestProperty(\"Accept\", \"application/vnd.github.v3+json\");\r\n\t\tconnection.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\t\tconnection.setDoOutput(true);\r\n\t\tconnection.getOutputStream().write(paramBytes);\r\n\t\t\r\n\t\tint status = connection.getResponseCode();\r\n\t\t\r\n\t\tconnection.disconnect();\r\n\t\t\r\n\t\treturn status == 204;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 반환 메서드\r\n\t *\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [String] 정보 제공 동의 갱신 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getUpdateAuthorizationUrl(String state)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 접근 토큰 요청 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getAccessTokenEndpoint()\r\n\t{\r\n\t\treturn \"https://github.com/login/oauth/access_token\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 API 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 인증 API 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getAuthorizationBaseUrl()\r\n\t{\r\n\t\treturn \"https://github.com/login/oauth/authorize\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 사용자 정보 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getUserInfoEndPoint()\r\n\t{\r\n\t\treturn \"https://api.github.com/user\";\r\n\t}\r\n}\r\n```\r\n\r\n정리한 전체 코드는 위와 같다.\r\n\r\n\r\n\r\n# 정리\r\n\r\n이로써 모든 플랫폼에 대한 인증 모듈 구현이 끝났다. `AuthModule`를 활용함으로써 최소한의 코드로 각 플랫폼에 대응하는 모듈을 구현했다. 만약 추후 다른 OAuth를 붙일 경우, 위와 같은 방식으로 모듈을 추가 구성하면 된다.\r\n\r\n다음 장에서는 모듈을 호출해서 사용하는 영역인 프로세스를 구현할 예정이다.","url":["2021-10-23-oauth2-java-server-7","2021","10","23","oauth2-java-server-7"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 6. KAKAO OAuth 서비스 신청 및 모듈 구현하기","excerpt":"세 번째 플랫폼으로, KAKAO에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-23T03:51:04","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","scribeJAVA"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-23-oauth2-java-server-6.md","content":"\r\n# 개요\r\n\r\n세 번째 플랫폼으로, KAKAO에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.\r\n\r\n\r\n\r\n\r\n\r\n# KAKAO OAuth 서비스 신청하기\r\n\r\nAPI 정보를 얻기 위해 KAKAO OAuth 서비스를 신청하자.\r\n\r\n\r\n\r\n## 1. Kakao Developers 접속하기\r\n\r\n로그인 후 [Kakao Developers](https://developers.kakao.com/)에 접속하자.\r\n\r\n상단 메뉴의 [내 애플리케이션]에서 애플리케이션 목록을 확인할 수 있다.\r\n\r\n\r\n\r\n## 2. 애플리케이션 추가하기\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138494125-ad0ea449-5ebc-4584-a861-54143fefc20a.png)\r\n\r\nOAuth 정보를 관리하게 될 애플리케이션을 생성하자. 이름은 아무렇게나 지어도 상관없다. 사업자 정보도 필수사항이므로, 사업자가 아니라면 무작위로 입력하거나 이름과 동일하게 입력하자. 로고는 추후 등록해도 무방하다.\r\n\r\n\r\n\r\n## 3. 동의 화면 구성하기\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138501347-233f8568-5131-46fc-964f-dce0c623cc45.png)\r\n\r\nOAuth API를 생성하기 위해선 먼저 동의 화면을 구성해야한다. 정보 제공 동의 그거 맞다.\r\n\r\n좌측 사이드바의 [<span class=\"lightBlue-600\">카카오 로그인</span> - <span class=\"lightBlue-600\">동의항목</span>] 메뉴에서 구성 가능하다. 설정 가능한 상태는 아래와 같다.\r\n\r\n* <span class=\"teal-500\">필수 동의</span> - 반드시 동의해야하는 항목. 해당 항목을 동의하지 않으면 로그인 불가능.\r\n* <span class=\"teal-500\">선택 동의</span> - 사용자의 선택에 따라 동의하는 항목. 동의 여부가 로그인에 영향을 미치지 않음\r\n* <span class=\"teal-500\">이용 중 동의</span> - 로그인 시에는 표출되지 않음. 추후 API를 통해 필요할 때 별도로 동의 요청\r\n* <span class=\"teal-500\">사용 안함</span> - 사용하지 않음\r\n\r\n사용자에게 어떤 항목도 동의를 강제하지 않는 네이버와 달리, 카카오는 필수 사항에 대해선 반드시 동의를 받아야만 로그인이 가능하도록 구성되어있다.\r\n\r\n닉네임, 프로필사진, 이메일을 지정한다. 이메일의 경우 비즈니스 앱만 필수로 지정 가능하다.\r\n\r\n> <b class=\"orange-600\">비즈니스 앱?</b>  \r\n> KAKAO의 OAuth 애플리케이션 심사와 같은 개념이다. 단, 기본적으로 사업자 등록 번호 등을 요구하는데, 사업자 등록번호가 없는 개인의 경우 별도로 신청해야한다. 이는 차후 심사 단계에서 자세히 다룬다.\r\n\r\n\r\n\r\n## 4. Redirect URI 등록\r\n\r\n로그인 후 `code`를 전달할 리다이렉트 URI를 지정한다.\r\n\r\n좌측 사이드바의 [<span class=\"lightBlue-600\">카카오 로그인</span>] 메뉴에서 구성 가능하다.\r\n\r\n줄바꿈으로 구분하여 여러 URL을 등록할 수 있다.\r\n\r\n\r\n\r\n## 5. 보안 활성화\r\n\r\n좌측 사이드바의 [<span class=\"lightBlue-600\">카카오 로그인</span> - <span class=\"lightBlue-600\">보안</span>] 메뉴에서 Client Secret를 활성화한다.\r\n\r\n이를 활성화해야 Secret키를 사용할 수 있다.\r\n\r\n\r\n\r\n## 6. 카카오 로그인 활성화\r\n\r\n좌측 사이드바의 [<span class=\"lightBlue-600\">카카오 로그인</span>] 메뉴에서 활성화로 체크하여 애플리케이션을 활성화할 수 있다.\r\n\r\n\r\n\r\n## 7. API 키 확인\r\n\r\n애플리케이션 메인인 [<span class=\"lightBlue-600\">요약 정보</span>]에서 바로 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138510821-9bfd446e-3912-4f17-8bc3-8e746818cce7.png)\r\n\r\n* 네이티브 앱 키 - 모바일용\r\n* REST API 키 - HTTP 요청용\r\n* JavaScript 키 - SDK용\r\n* Admin 키 - 위 기능을 전부 통합한 관리자용\r\n\r\nREST API 키를 사용하면 된다.\r\n\r\n\r\n\r\n# KAKAO 인증 모듈 구현하기\r\n\r\n필요한 모든 준비가 갖춰졌으니, 카카오 인증 모듈을 구현해보자. 이전에 구현한 `AuthModule`을 상속받아 구현할 것이다.\r\n\r\n``` java\r\npublic class KakaoAuthModule extends AuthModule\r\n{\r\n\t// KAKAO 인증 모듈\r\n}\r\n```\r\n\r\n객체의 기본 형식은 위와 같다.\r\n\r\n|           메서드            | 메서드 타입 |                 내용                  | 구현 필요 여부 |\r\n| :-------------------------: | :---------: | :-----------------------------------: | :------------: |\r\n|    `getAuthorizationUrl`    |    추상     |         인증 URL 반환 메서드          |       Y        |\r\n|      `getAccessToken`       |             |         접근 토큰 반환 메서드         |       Y        |\r\n|   `getRefreshAccessToken`   |             |     접근 토큰 갱신 및 반환 메서드     |                |\r\n|        `getUserInfo`        |             |     사용자 정보 응답 반환 메서드      |                |\r\n|  `getRefreshTokenEndpoint`  |             | 접근 토큰 재발급 요청 URL 반환 메서드 |                |\r\n|       `getApiKeyBean`       |             |        API 키 객체 반환 메서드        |                |\r\n|    `getUserInfoEndPoint`    |             |   사용자 정보 요청 URL 반환 메서드    |                |\r\n|      `getUserInfoBean`      |    추상     |      유저 정보 객체 반환 메서드       |       Y        |\r\n|        `deleteInfo`         |    추상     |      연동 해제 결과 반환 메서드       |       Y        |\r\n| `getUpdateAuthorizationUrl` |    추상     |  정보 제공 동의 갱신 URL 반환 메서드  |       Y        |\r\n|  `getAccessTokenEndpoint`   |    추상     |    접근 토큰 요청 URL 반환 메서드     |       Y        |\r\n|  `getAuthorizationBaseUrl`  |    추상     |     인증 API 요청 URL 반환 메서드     |       Y        |\r\n\r\n카카오 모듈이 구현해야하는 대상은 위와 같다. 이전 플랫폼과 다르게 `getAccessToken`의 오버라이딩이 필요하다.\r\n\r\n\r\n\r\n## properties 파일 생성하기\r\n\r\n`WEB-INF` 아래 `kakao.properties` 파일을 생성한다. 기 생성된 `sample.properties`를 복사해서 사용해도 된다.\r\n\r\n``` properties\r\napi=API_KEY\r\nsecret=SECRET_KEY\r\ncallback=CALLBACK_URL\r\n```\r\n\r\n기본적인 형식은 위와 같으며, 각 항목에 해당하는 값을 입력하면 된다.\r\n\r\n\r\n\r\n## 인증 모듈 기본 메서드 및 변수 할당하기\r\n\r\n인증 모듈이 정상적으로 동작하기 위해선 기본적으로 지정해줘야할 메서드와 변수들이 존재한다. API 정보 설정, 인스턴스 반환같은 것들이다.\r\n\r\n``` java\r\nprivate static final String MODULE_NAME = \"kakao\";\r\n\r\nprivate static final String API_KEY;\r\nprivate static final String SECRET_KEY;\r\nprivate static final String CALLBACK_URL;\r\n\r\nstatic\r\n{\r\n\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\r\n\tAPI_KEY = apiKeyBean.getApi();\r\n\tSECRET_KEY = apiKeyBean.getSecret();\r\n\tCALLBACK_URL = apiKeyBean.getCallback();\r\n}\r\n\r\nprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL);\r\n\r\nprivate static final KakaoAuthModule INSTANCE = new KakaoAuthModule(SERVICE_BUILDER);\r\n\r\nprivate KakaoAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n{\r\n\tsuper(serviceBuilder);\r\n}\r\n\r\npublic static KakaoAuthModule getInstance()\r\n{\r\n\treturn INSTANCE;\r\n}\r\n```\r\n\r\nGoogle은 반드시 `scope`를 특정해야한다. 사용하는 `scope`는 [3-3. 범위 지정](#3-3-범위-지정)에서 선택한 그 범위를 집어넣으면 된다.\r\n\r\n|       구분        |          형식           |         내용         |\r\n| :---------------: | :---------------------: | :------------------: |\r\n|   `MODULE_NAME`   |        `String`         |      모듈 이름       |\r\n|     `API_KEY`     |        `String`         |        API키         |\r\n|   `SECRET_KEY`    |        `String`         |       Secret키       |\r\n|  `CALLBACK_URL`   |        `String`         |       콜백 URL       |\r\n| `SERVICE_BUILDER` | `ServiceBuilderOAuth20` | OAuth2.0 서비스 빌더 |\r\n|    `INSTANCE`     |    `KakaoAuthModule`    |       인스턴스       |\r\n\r\n정의된 변수는 전부 `static final`로 선언되어 있어서, 인스턴스 생성 시 한 번만 선언되며 재할당이 불가능하도록 관리한다.\r\n\r\n`static{ }` 구문을 통해 인스턴스 생성 시 API 정보를 할당하도록 구성했다.\r\n\r\nAPI 할당 시 `getApiKeyBean()` 메서드를 통해 제공된 이름을 갖는 properties를 분석하여 `ApiKeyBean` 객체를 반환받아 사용한다.\r\n\r\n\r\n\r\n## API URL 할당하기\r\n\r\n각 API 별 요청 URL을 반환하는 메서드를 구현하자.\r\n\r\n``` java\r\n@Override\r\npublic String getAccessTokenEndpoint()\r\n{\r\n\treturn \"https://kauth.kakao.com/oauth/token\";\r\n}\r\n\r\n@Override\r\nprotected String getAuthorizationBaseUrl()\r\n{\r\n\treturn \"https://kauth.kakao.com/oauth/authorize\";\r\n}\r\n\r\n@Override\r\nprotected String getUserInfoEndPoint()\r\n{\r\n\treturn \"https://kapi.kakao.com/v2/user/me\";\r\n}\r\n```\r\n\r\n* `getAccessTokenEndpoint()` - 토큰과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getAuthorizationBaseUrl()` - 인증과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getUserInfoEndPoint()` - 사용자 정보와 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n\r\nOAuth2.0 서비스를 수행함에 있어서 필요한 URL은 위와 같다. 이 중 `getAccessTokenEndpoint()`과 `getAuthorizationBaseUrl()`는 scribeJAVA 라이브러리의 객체인 `DefaultApi20`의 추상 메서드고 나머지 하나가 `AuthModule`의 추상 메서드다.\r\n\r\n`DefaultApi20`는 사용자 계정 API에 관련된 메서드를 별도로 제공하지 않는다. 하지만 `AuthModule`에서 사용자 정보 확인 공통 메서드를 사용할 때 사용자 계정 API가 반드시 필요하므로 `AuthModule`의 추상 메서드로 관리한다.\r\n\r\n\r\n\r\n## 인증 URL 반환 메서드\r\n\r\n<span class=\"blue-500\">카카오 플랫폼 로그인 URL을 반환하는 기능</span>을 구현한다.\r\n\r\n우선 API를 살펴보자.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET https://kauth.kakao.com/oauth/authorize?response_type=code&client_id={:client_id}&redirect_uri={:redirect_uri}&state={:state}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |       description        |\r\n| :--------------: | :---: | :------: | :------: | :----------------------: |\r\n| {:response_type} | path  | `String` |    Y     | 응답 타입. `code`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |          API키           |\r\n| {:redirect_uri}  | path  | `String` |    Y     |       Callback URL       |\r\n|     {:state}     | path  | `String` |    Y     |       고유 상태값        |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n카카오 플랫폼 로그인 페이지\r\n\r\n<br />\r\n\r\n카카오 플랫폼 로그인 API는 위와 같다. 메서드가 요청의 URL을 반환하도록 설계하면 된다.\r\n\r\n문자열 연산으로 URL을 직접 설계할 수도 있지만, `service.getAuthorizationUrl()` 메서드를 통해 URL을 간편하게 생성할 수 있다.\r\n\r\n<br />\r\n\r\n이미 `AuthModule`에 공통 메서드로 선언된 게 있으므로, <span class=\"red-400\">따로 구현하지 않아도 된다.</span>\r\n\r\n\r\n\r\n## 접근 토큰 반환 메서드\r\n\r\n로그인 결과로 Code를 전달받으므로 <span class=\"blue-500\">Access Token으로 교환하는 기능</span>을 구현한다.\r\n\r\n카카오 API는 아래와 같다. scribeJAVA가 카카오에 대한 처리를 잘 못 하는건지, 동일한 인터페이스를 사용하면 파라미터를 제대로 입력하지 않아 오류가 뜬다. 때문에 어쩔 수 없이 <span class=\"red-400\">직접 요청을 생성하여 사용</span>해야한다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nPOST https://kauth.kakao.com/oauth/token?grant_type=authorization_code&client_id={:client_id}&client_secret={:client_secret}&redirect_uri={:redirect_uri}&code={:code}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |              description               |\r\n| :--------------: | :---: | :------: | :------: | :------------------------------------: |\r\n|  {:grant_type}   | path  | `String` |    Y     | 인증 타입. `authorization_code`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |                 API키                  |\r\n| {:client_secret} | path  | `String` |    Y     |                Secret키                |\r\n| {:redirect_uri}  | path  | `String` |    Y     |              Callback URL              |\r\n|     {:code}      | path  | `String` |    Y     |               인가 코드                |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"token_type\": \"bearer\",\r\n\t\"access_token\": \"{ACCESS_TOKEN}\",\r\n\t\"expires_in\": 43199,\r\n\t\"refresh_token\": \"{REFRESH_TOKEN}\",\r\n\t\"refresh_token_expires_in\": 25184000,\r\n\t\"scope\": \"account_email profile\"\r\n}\r\n```\r\n\r\n|        parameter         |   data   |           description            |\r\n| :----------------------: | :------: | :------------------------------: |\r\n|       access_token       | `String` |            인증 토큰             |\r\n|      refresh_token       | `String` |          리프레쉬 토큰           |\r\n| refresh_token_expires_in |  `int`   | 리프레쉬 토큰 만료일자 (초 단위) |\r\n|        token_type        | `String` |            토큰 타입             |\r\n|        expires_in        |  `int`   |        만료일자 (초 단위)        |\r\n|          scope           | `String` |            접근 권한             |\r\n\r\n<br />\r\n\r\n`AccessTokenRequestParams` 객체로 요청을 생성하여 `service.getAccessToken`으로 응답을 받는다.\r\n\r\n라이브러리의 처리 문제로 `AuthModule`의 공통 메서드가 아닌, <span class=\"red-600\">별도로 오버라이딩한 메서드를 사용</span>해야한다.\r\n\r\n\r\n\r\n## 접근 토큰 갱신 및 반환 메서드\r\n\r\nAccess Token은 만료시간이 한시간 정도로 매우 짧다. Access Token이 만료될 경우, 사용자에게 플랫폼 로그인을 통해 인증 정보를 다시 요구해야하지만 Refresh Token이 있다면 별도의 절차 없이 서비스 내부에서 <span class=\"blue-500\">Access Token을 재발급</span> 받을 수 있다.\r\n\r\n이 Refresh Token은 인증 권한은 없지만, Access Token을 재발급받는 권한을 가진다.\r\n\r\n이를 구현한 카카오 API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nPOST https://kauth.kakao.com/oauth/token?grant_type=refresh_token&client_id={:client_id}&client_secret={:client_secret}&refresh_token=${:refresh_token}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |            description            |\r\n| :--------------: | :---: | :------: | :------: | :-------------------------------: |\r\n|  {:grant_type}   | path  | `String` |    Y     | 인증 타입. `refresh_token`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |               API키               |\r\n| {:client_secret} | path  | `String` |    Y     |             Secret키              |\r\n| {:refresh_token} | path  | `String` |    Y     |           리프레쉬 토큰           |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"access_token\": \"{ACCESS_TOKEN}\",\r\n\t\"token_type\": \"bearer\",\r\n\t\"refresh_token\": \"{REFRESH_TOKEN}\",\r\n\t\"refresh_token_expires_in\": 25184000,\r\n\t\"expires_in\": 43199,\r\n}\r\n```\r\n\r\n|        parameter         |   data   |           description            |\r\n| :----------------------: | :------: | :------------------------------: |\r\n|       access_token       | `String` |            인증 토큰             |\r\n|        token_type        | `String` |            토큰 타입             |\r\n|      refresh_token       | `String` |          리프레쉬 토큰           |\r\n| refresh_token_expires_in |  `int`   | 리프레쉬 토큰 만료일자 (초 단위) |\r\n|        expires_in        |  `int`   |        만료일자 (초 단위)        |\r\n\r\n<br />\r\n\r\n`AuthModule`의 공통 메서드로 대체 가능하므로 <span class=\"red-400\">별도로 구현하지 않는다.</span>\r\n\r\n\r\n\r\n## 사용자 정보 응답 반환 메서드\r\n\r\n<span class=\"blue-500\">Access Token으로 유저 정보를 호출하는 기능</span>을 구현한다. 발급받은 Access Token을 실제로 유의미하게 쓰는 부분이다.\r\n\r\n카카오 API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://kapi.kakao.com/v2/user/me\r\nAuthorization: Bearer {:access_token}\r\n```\r\n\r\n|    parameter    |  type  |   data   | required | description |\r\n| :-------------: | :----: | :------: | :------: | :---------: |\r\n| {:access_token} | header | `String` |    Y     |  접근 토큰  |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"id\":123456789,\r\n\t\"kakao_account\": { \r\n\t\t\"profile_needs_agreement\": false,\r\n\t\t\"profile\": {\r\n\t\t\t\"nickname\": \"홍길동\",\r\n\t\t\t\"thumbnail_image_url\": \"http://yyy.kakao.com/.../img_110x110.jpg\",\r\n\t\t\t\"profile_image_url\": \"http://yyy.kakao.com/dn/.../img_640x640.jpg\",\r\n\t\t\t\"is_default_image\": false\r\n\t\t},\r\n\t\t\"email_needs_agreement\": false, \r\n\t\t\"is_email_valid\": true,   \r\n\t\t\"is_email_verified\": true,   \r\n\t\t\"email\": \"sample@sample.com\",\r\n\t\t\"age_range_needs_agreement\": false,\r\n\t\t\"age_range\": \"20~29\",\r\n\t\t\"birthday_needs_agreement\": false,\r\n\t\t\"birthday\": \"1130\",\r\n\t\t\"gender_needs_agreement\": false,\r\n\t\t\"gender\": \"female\"\r\n\t},  \r\n\t\"properties\": {\r\n\t\t\"nickname\": \"홍길동카톡\",\r\n\t\t\"thumbnail_image\": \"http://xxx.kakao.co.kr/.../aaa.jpg\",\r\n\t\t\"profile_image\": \"http://xxx.kakao.co.kr/.../bbb.jpg\",\r\n\t\t\"custom_field1\": \"23\",\r\n\t\t\"custom_field2\": \"여\"\r\n\t}\r\n}\r\n```\r\n\r\n응답 명세는 길이가 매우 방대한 관계로 생략한다. [카카오 개발자 docs](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#req-user-info)를 참고하자.\r\n\r\n<br />\r\n\r\nid는 우리가 생각하는 `xxx@google.com` 형태의 아이디가 아니라 아이디별로 부여받는 고유 해쉬값이다.\r\n\r\n`AuthModule`의 공통 메서드로 대체 가능하므로 <span class=\"red-400\">별도로 구현하지 않는다.</span>\r\n\r\n\r\n\r\n## 유저 정보 객체 반환 메서드\r\n\r\n<span class=\"blue-500\">카카오의 유저 정보 호출 API 응답 형식에 맞게끔 응답을 파싱</span>하여 `UserInfoBean`로 반환하는 메서드를 구현한다.\r\n\r\n이 프로젝트에선 이름, 이메일, 프로필사진 URL만을 사용하므로, 응답에서 해당 값을 빼내어 객체에 담는다.\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n{\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tJsonNode node = mapper.readTree(body);\r\n\t\r\n\tString email = node.get(\"kakao_account\").get(\"email\") == null ? \"미동의\" : node.get(\"kakao_account\").get(\"email\").textValue();\r\n\tString name = node.get(\"kakao_account\").get(\"profile\").get(\"nickname\") == null ? \"미동의\" : node.get(\"kakao_account\").get(\"profile\").get(\"nickname\").textValue();\r\n\tString picture = node.get(\"kakao_account\").get(\"profile\").get(\"profile_image_url\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"kakao_account\").get(\"profile\").get(\"profile_image_url\").textValue();\r\n\t\r\n\treturn new UserInfoBean(email, name, picture, MODULE_NAME);\r\n}\r\n```\r\n\r\n<br />\r\n\r\n응답 형식에 맞추어 필요한 값을 추출한다. 만약, 사용자가 정보 제공에 동의하지 않았을 경우 대상 객체가 `null`을 반환한다. 데이터의 누락 시 오류를 방지하기 위해 데이터에 대한 `null` 처리를 반드시 해야한다.\r\n\r\n\r\n\r\n## 연동 해제 결과 반환 메서드\r\n\r\n카카오 아이디로 처음 로그인을 하면 정보 제공 동의를 수행하는데, 나중에 다시 로그인을 하면 이러한 동의 과정이 생략된다. 즉, 플랫폼에서 첫 로그인 시 정보 제공 동의를 받아 어딘가로부터 저장한다는 뜻이다. 만약 사용자가 서비스로부터 회원 탈퇴를 수행한다면 <span class=\"blue-500\">카카오와의 연동을 해제하여 정보를 완전히 삭제</span>할 필요가 있다.\r\n\r\n카카오 API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nPOST https://kapi.kakao.com/v1/user/unlink\r\nAuthorization: Bearer {:access}\r\nContent-Type: application/x-www-form-urlencoded\r\n```\r\n\r\n| parameter |  type  |   data   | required | description |\r\n| :-------: | :----: | :------: | :------: | :---------: |\r\n| {:access} | header | `String` |    Y     |  접근 토큰  |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"id\": 123456789\r\n}\r\n```\r\n\r\n| parameter |  data  | description |\r\n| :-------: | :----: | :---------: |\r\n|    id     | `long` |  회원 번호  |\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n{\r\n\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.POST, \"https://kapi.kakao.com/v1/user/unlink\");\r\n\toAuthRequest.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\toAuthRequest.addHeader(\"Authorization\", Util.builder(\"Bearer \", access));\r\n\t\r\n\tservice.signRequest(access, oAuthRequest);\r\n\t\r\n\treturn service.execute(oAuthRequest).isSuccessful();\r\n}\r\n```\r\n\r\n구현은 간단하다. `OAuthRequest` 객체를 활용하면 요청을 쉽게 생성할 수 있다. 응답 자체는 중요하지 않다. `response.isSuccessful()` 메서드로 응답이 정상적인지 여부만 판단하여 `boolean`으로 반환한다.\r\n\r\n\r\n\r\n## 정보 제공 동의 갱신 URL 반환 메서드\r\n\r\n서비스 운영 중 추가적인 사용자 정보가 필요하거나 필요 없을 때, <span class=\"blue-500\">사용자 정보 동의 갱신을 통해 동의 정보를 다시 지정</span>할 수 있다.\r\n\r\n카카오의 경우, 동의하지않은 선택 정보에 대해서만 동의가 가능하며, 이미 동의한 데이터는 별도의 API로 해제해야한다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET https://kauth.kakao.com/oauth/authorize?response_type=code&client_id={:client_id}&redirect_uri={:redirect_uri}&state={:state}&scope={:scope}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |       description        |\r\n| :--------------: | :---: | :------: | :------: | :----------------------: |\r\n| {:response_type} | path  | `String` |    Y     | 응답 타입. `code`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |          API키           |\r\n| {:redirect_uri}  | path  | `String` |    Y     |       Callback URL       |\r\n|     {:state}     | path  | `String` |    Y     |       고유 상태값        |\r\n|     {:scope}     | path  | `String` |    Y     |        접근 권한         |\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n\r\n``` java\r\n@Override\r\npublic String getUpdateAuthorizationUrl(String state)\r\n{\r\n\tHashMap<String, String> params = new HashMap<>();\r\n\tparams.put(\"state\", state);\r\n\tparams.put(\"scope\", \"profile_nickname,profile_image,account_email\");\r\n\t\r\n\treturn service.getAuthorizationUrl(params);\r\n}\r\n```\r\n\r\n<br />\r\n\r\nnull을 반환하여 동작을 수행하지 않도록 처리한다. 추후 프로세스에서 `null`값이 반환될 경우 별도의 처리를 따른다.\r\n\r\n\r\n\r\n## 전체 코드\r\n\r\n``` java\r\npackage oauth.account.module;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.github.scribejava.core.builder.ServiceBuilder;\r\nimport com.github.scribejava.core.builder.ServiceBuilderOAuth20;\r\nimport com.github.scribejava.core.model.OAuth2AccessToken;\r\nimport com.github.scribejava.core.model.OAuthRequest;\r\nimport com.github.scribejava.core.model.Verb;\r\nimport com.github.scribejava.core.oauth.AccessTokenRequestParams;\r\nimport global.module.Util;\r\nimport oauth.account.bean.ApiKeyBean;\r\nimport oauth.account.bean.UserInfoBean;\r\n\r\nimport java.io.IOException;\r\nimport java.util.HashMap;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n/**\r\n * 카카오 인증 모듈 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.10.04 Mon 21:30:49\r\n */\r\npublic class KakaoAuthModule extends AuthModule\r\n{\r\n\tprivate static final String MODULE_NAME = \"kakao\";\r\n\t\r\n\tprivate static final String API_KEY;\r\n\tprivate static final String SECRET_KEY;\r\n\tprivate static final String CALLBACK_URL;\r\n\t\r\n\tstatic\r\n\t{\r\n\t\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\t\r\n\t\tAPI_KEY = apiKeyBean.getApi();\r\n\t\tSECRET_KEY = apiKeyBean.getSecret();\r\n\t\tCALLBACK_URL = apiKeyBean.getCallback();\r\n\t}\r\n\t\r\n\tprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL);\r\n\t\r\n\tprivate static final KakaoAuthModule INSTANCE = new KakaoAuthModule(SERVICE_BUILDER);\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param serviceBuilder: [ServiceBuilderOAuth20] API 서비스 빌더\r\n\t */\r\n\tprivate KakaoAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n\t{\r\n\t\tsuper(serviceBuilder);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인스턴스 반환 메서드\r\n\t *\r\n\t * @return [KakaoAuthModule] 인스턴스\r\n\t */\r\n\tpublic static KakaoAuthModule getInstance()\r\n\t{\r\n\t\treturn INSTANCE;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param code: [String] 인증 코드\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\t@Override\r\n\tpublic OAuth2AccessToken getAccessToken(String code) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tAccessTokenRequestParams params = new AccessTokenRequestParams(code);\r\n\t\tparams.addExtraParameter(\"client_id\", API_KEY);\r\n\t\tparams.addExtraParameter(\"client_secret\", SECRET_KEY);\r\n\t\t\r\n\t\treturn getAccessToken(params);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 유저 정보 객체 반환 메서드\r\n\t *\r\n\t * @param body: [String] OAuth 응답 내용\r\n\t *\r\n\t * @return [UserInfoBean] 유저 정보 객체\r\n\t *\r\n\t * @throws JsonProcessingException JSON 파싱 예외\r\n\t */\r\n\t@Override\r\n\tpublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n\t{\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(body);\r\n\t\t\r\n\t\tString email = node.get(\"kakao_account\").get(\"email\") == null ? \"미동의\" : node.get(\"kakao_account\").get(\"email\").textValue();\r\n\t\tString name = node.get(\"kakao_account\").get(\"profile\").get(\"nickname\") == null ? \"미동의\" : node.get(\"kakao_account\").get(\"profile\").get(\"nickname\").textValue();\r\n\t\tString picture = node.get(\"kakao_account\").get(\"profile\").get(\"profile_image_url\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"kakao_account\").get(\"profile\").get(\"profile_image_url\").textValue();\r\n\t\t\r\n\t\treturn new UserInfoBean(email, name, picture, MODULE_NAME);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 연동 해제 결과 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [boolean] 연동 해제 결과\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\t@Override\r\n\tpublic boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.POST, \"https://kapi.kakao.com/v1/user/unlink\");\r\n\t\toAuthRequest.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\t\toAuthRequest.addHeader(\"Authorization\", Util.builder(\"Bearer \", access));\r\n\t\t\r\n\t\tservice.signRequest(access, oAuthRequest);\r\n\t\t\r\n\t\treturn service.execute(oAuthRequest).isSuccessful();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 반환 메서드\r\n\t *\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [String] 정보 제공 동의 갱신 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getUpdateAuthorizationUrl(String state)\r\n\t{\r\n\t\tHashMap<String, String> params = new HashMap<>();\r\n\t\tparams.put(\"state\", state);\r\n\t\tparams.put(\"scope\", \"profile_nickname,profile_image,account_email\");\r\n\t\t\r\n\t\treturn service.getAuthorizationUrl(params);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 접근 토큰 요청 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getAccessTokenEndpoint()\r\n\t{\r\n\t\treturn \"https://kauth.kakao.com/oauth/token\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 API 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 인증 API 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getAuthorizationBaseUrl()\r\n\t{\r\n\t\treturn \"https://kauth.kakao.com/oauth/authorize\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 사용자 정보 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getUserInfoEndPoint()\r\n\t{\r\n\t\treturn \"https://kapi.kakao.com/v2/user/me\";\r\n\t}\r\n}\r\n```\r\n\r\n정리한 전체 코드는 위와 같다.\r\n\r\n\r\n\r\n# 정리\r\n\r\n네이버의 인증 모듈 구현과 매우 흡사하다. 구현, 오버라이딩해야하는 메서드 모두 동일하다. `AuthModule`을 통해 공통 모듈로 대체함과 필요 시 오버라이딩을 함으로써 여러 플랫폼에 효과적으로 대응이 가능함을 느낄 수 있다. 객체지향이 왜 유지보수에 유용한지 새삼 깨달을 수 있었다.\r\n\r\n이로써 Google 인증 모듈 구현이 완료됐다. 현재까지는 개발 중 단계라 정해진 아이디로만 사용할 수 있다. API 설정에서 테스트 계정을 등록해야 해당 계정으로 로그인 테스트가 가능하다. 심사 이후 애플리케이션이 승인되면 모든 아이디에서 로그인이 가능하다.","url":["2021-10-23-oauth2-java-server-6","2021","10","23","oauth2-java-server-6"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 5. Google OAuth 서비스 신청 및 모듈 구현하기","excerpt":"두 번째 플랫폼으로, Google에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-23T01:51:53","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","scribeJAVA"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-23-oauth2-java-server-5.md","content":"\r\n# 개요\r\n\r\n두 번째 플랫폼으로, Google에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.\r\n\r\n\r\n\r\n\r\n\r\n# Google OAuth 서비스 신청하기\r\n\r\nAPI 정보를 얻기 위해 Google OAuth 서비스를 신청하자.\r\n\r\n\r\n\r\n## 1. Google Cloud Platform 접속하기\r\n\r\n로그인 후 [Google Cloud Platform](https://console.cloud.google.com/home/dashboard)에 접속하자.\r\n\r\nGoogle은 <span class=\"lightBlue-600\">Google Cloud Platform(GCP)</span>에서 OAuth 서비스를 신청할 수 있다.\r\n\r\n<br />\r\n\r\n좌측 사이드바의 [<span class=\"lightBlue-600\">API 및 서비스</span>]를 클릭하여 관련 메뉴에 접근할 수 있다.\r\n\r\n\r\n\r\n## 2. 프로젝트 만들기\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138465442-6c4691b1-e5a3-4920-98fa-16bcf80c178a.png)\r\n\r\nOAuth 정보를 관리하게 될 프로젝트를 생성하자. 이름은 아무렇게나 지어도 상관없다.\r\n\r\n\r\n\r\n## 3. 동의 화면 구성하기\r\n\r\nOAuth API를 생성하기 위해선 먼저 동의 화면을 구성해야한다. 정보 제공 동의 그거 맞다.\r\n\r\n좌측 사이드바의 [<span class=\"lightBlue-600\">OAuth 동의 화면</span>] 메뉴에서 구성 가능하다.\r\n\r\n\r\n\r\n### 3-1. UserType 설정\r\n\r\n* 내부 - <span class=\"teal-500\">정해진 그룹에서만 사용</span> 가능. 폐쇄적이므로 앱 심사 과정을 생략할 수 있음.\r\n* 외부 - <span class=\"teal-500\">모든 사용자가 사용</span> 가능. 개방적이므로 앱 심사 과정이 필요함.\r\n\r\n원하는 타입으로 선택한다. 이 프로젝트에선 [<span class=\"lightBlue-600\">외부</span>]로 선택한다.\r\n\r\n\r\n\r\n### 3-2. 애플리케이션 정보 작성\r\n\r\n애플리케이션에 대한 정보를 작성한다.\r\n\r\n필수 정보를 작성하고 넘어가자.\r\n\r\n\r\n\r\n### 3-3. 범위 지정\r\n\r\nAccess Token이 가지는 범위를 지정한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138469867-30c70149-a919-4583-9105-5817e7ba5dd4.png)\r\n\r\n이 프로젝트에선 프로필 정보 정도만 사용할 계획이므로 `/auth/userinfo.email`, `/auth/userinfo.profile`을 선택한다.\r\n\r\n위 두 정보는 매우 기본적인 정보라 [<span class=\"red-300\">민감하지 않은 범위</span>]로 표시된다. 다른 범위를 추가할 수도 있지만, [<span class=\"red-500\">민감한 범위</span>] 혹은 [<span class=\"red-700\">제한된 범위</span>]를 선택할 경우 앱 심사 시 추가 자료를 제출해야할 수도 있다는 점을 감안하자.\r\n\r\n\r\n\r\n### 3-4. 테스트 사용자\r\n\r\n개발 단계에서 해당 OAuth API를 사용할 수 있는 계정을 등록한다. 애플리케이션 소유자는 관리자이므로, 별도로 등록할 필요 없다. 협업 등의 이유로 다수의 계정이 사용해야한다면 등록하자.\r\n\r\n\r\n\r\n### 3-5. 요약\r\n\r\n작성한 정보를 확인할 수 있다. 작성한 내용은 추후 동일한 메뉴에서 얼마든지 동일한 절차를 통해 수정이 가능하다.\r\n\r\n\r\n\r\n## 4. API 생성하기\r\n\r\n좌측 사이드바에서 [<span class=\"lightBlue-600\">사용자 인증 정보</span>] 메뉴로 들어가자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138471904-75045dc5-9a8b-4323-8af9-01c41d1292f0.png)\r\n\r\n[<span class=\"lightBlue-600\">OAuth 클라이언트 ID</span>]를 선택하여 API키를 하나 생성하자.\r\n\r\n<br />\r\n\r\n애플리케이션의 유형을 선택하자. 여기서는 [웹 애플리케이션]을 선택한다.\r\n\r\n이름은 원하는대로 입력한다.\r\n\r\n* <span class=\"teal-500\">승인된 자바스크립트 원본</span> - `Implicit Grant` 전용. Google API SDK로 JavaScript에서 API를 직접 호출할 경우, 호출을 수행하는 URL을 입력한다.\r\n* <span class=\"teal-500\">승인된 리디렉션 URI</span> - `Authorization Code Grant` 전용. 인증 후 리다이렉션할 URI를 입력한다.\r\n\r\n이 프로젝트는 `Authorization Code Grant`를 차용하므로 [<span class=\"lightBlue-600\">승인된 리디렉션 URI</span>]를 선택하고 리다이렉션할 URI를 지정한다.\r\n\r\n플랫폼 로그인 창 호출 시 등록된 URI가 아니라면 오류를 표시하니 정확하게 입력할 것.\r\n\r\n저장을 완료하면 API키가 생성된다.\r\n\r\n\r\n\r\n## 5. API 확인\r\n\r\n생성된 API 리스트를 클릭하여 API를 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138473426-3429bf2b-0c5b-49a2-a7cc-b209cf9f126f.png)\r\n\r\n상단의 [<span class=\"lightBlue-600\">보안 비밀 재설정</span>]을 통해 클라이언트 보안 비밀키를 갱신할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n# Google 인증 모듈 구현하기\r\n\r\n필요한 모든 준비가 갖춰졌으니, Google 인증 모듈을 구현해보자. 이전에 구현한 `AuthModule`을 상속받아 구현할 것이다.\r\n\r\n``` java\r\npublic class GoogleAuthModule extends AuthModule\r\n{\r\n\t// Google 인증 모듈\r\n}\r\n```\r\n\r\n객체의 기본 형식은 위와 같다.\r\n\r\n|           메서드            | 메서드 타입 |                 내용                  | 구현 필요 여부 |\r\n| :-------------------------: | :---------: | :-----------------------------------: | :------------: |\r\n|    `getAuthorizationUrl`    |    추상     |         인증 URL 반환 메서드          |       Y        |\r\n|      `getAccessToken`       |             |         접근 토큰 반환 메서드         |                |\r\n|   `getRefreshAccessToken`   |             |     접근 토큰 갱신 및 반환 메서드     |                |\r\n|        `getUserInfo`        |             |     사용자 정보 응답 반환 메서드      |                |\r\n|  `getRefreshTokenEndpoint`  |             | 접근 토큰 재발급 요청 URL 반환 메서드 |                |\r\n|       `getApiKeyBean`       |             |        API 키 객체 반환 메서드        |                |\r\n|    `getUserInfoEndPoint`    |             |   사용자 정보 요청 URL 반환 메서드    |                |\r\n|      `getUserInfoBean`      |    추상     |      유저 정보 객체 반환 메서드       |       Y        |\r\n|        `deleteInfo`         |    추상     |      연동 해제 결과 반환 메서드       |       Y        |\r\n| `getUpdateAuthorizationUrl` |    추상     |  정보 제공 동의 갱신 URL 반환 메서드  |       Y        |\r\n|  `getAccessTokenEndpoint`   |    추상     |    접근 토큰 요청 URL 반환 메서드     |       Y        |\r\n|  `getAuthorizationBaseUrl`  |    추상     |     인증 API 요청 URL 반환 메서드     |       Y        |\r\n\r\nGoogle 모듈이 구현해야하는 대상은 위와 같으며, 네이버와 동일하다.\r\n\r\n\r\n\r\n## properties 파일 생성하기\r\n\r\n`WEB-INF` 아래 `google.properties` 파일을 생성한다. 기 생성된 `sample.properties`를 복사해서 사용해도 된다.\r\n\r\n``` properties\r\napi=API_KEY\r\nsecret=SECRET_KEY\r\ncallback=CALLBACK_URL\r\n```\r\n\r\n기본적인 형식은 위와 같으며, 각 항목에 해당하는 값을 입력하면 된다.\r\n\r\n\r\n\r\n## 인증 모듈 기본 메서드 및 변수 할당하기\r\n\r\n인증 모듈이 정상적으로 동작하기 위해선 기본적으로 지정해줘야할 메서드와 변수들이 존재한다. API 정보 설정, 인스턴스 반환같은 것들이다.\r\n\r\n``` java\r\nprivate static final String MODULE_NAME = \"google\";\r\n\r\nprivate static final String API_KEY;\r\nprivate static final String SECRET_KEY;\r\nprivate static final String CALLBACK_URL;\r\n\r\nstatic\r\n{\r\n\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\r\n\tAPI_KEY = apiKeyBean.getApi();\r\n\tSECRET_KEY = apiKeyBean.getSecret();\r\n\tCALLBACK_URL = apiKeyBean.getCallback();\r\n}\r\n\r\nprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL).defaultScope(\"https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile\");\r\n\r\nprivate static final GoogleAuthModule INSTANCE = new GoogleAuthModule(SERVICE_BUILDER);\r\n\r\nprivate GoogleAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n{\r\n\tsuper(serviceBuilder);\r\n}\r\n\r\npublic static GoogleAuthModule getInstance()\r\n{\r\n\treturn INSTANCE;\r\n}\r\n```\r\n\r\nGoogle은 반드시 `scope`를 특정해야한다. 사용하는 `scope`는 [3-3. 범위 지정](#3-3-범위-지정)에서 선택한 그 범위를 집어넣으면 된다.\r\n\r\n|       구분        |          형식           |         내용         |\r\n| :---------------: | :---------------------: | :------------------: |\r\n|   `MODULE_NAME`   |        `String`         |      모듈 이름       |\r\n|     `API_KEY`     |        `String`         |        API키         |\r\n|   `SECRET_KEY`    |        `String`         |       Secret키       |\r\n|  `CALLBACK_URL`   |        `String`         |       콜백 URL       |\r\n| `SERVICE_BUILDER` | `ServiceBuilderOAuth20` | OAuth2.0 서비스 빌더 |\r\n|    `INSTANCE`     |   `GoogleAuthModule`    |       인스턴스       |\r\n\r\n정의된 변수는 전부 `static final`로 선언되어 있어서, 인스턴스 생성 시 한 번만 선언되며 재할당이 불가능하도록 관리한다.\r\n\r\n`static{ }` 구문을 통해 인스턴스 생성 시 API 정보를 할당하도록 구성했다.\r\n\r\nAPI 할당 시 `getApiKeyBean()` 메서드를 통해 제공된 이름을 갖는 properties를 분석하여 `ApiKeyBean` 객체를 반환받아 사용한다.\r\n\r\n\r\n\r\n## API URL 할당하기\r\n\r\n각 API 별 요청 URL을 반환하는 메서드를 구현하자.\r\n\r\n``` java\r\n@Override\r\npublic String getAccessTokenEndpoint()\r\n{\r\n\treturn \"https://oauth2.googleapis.com/token\";\r\n}\r\n\r\n@Override\r\nprotected String getAuthorizationBaseUrl()\r\n{\r\n\treturn \"https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent\";\r\n}\r\n\r\n@Override\r\nprotected String getUserInfoEndPoint()\r\n{\r\n\treturn \"https://www.googleapis.com/oauth2/v2/userinfo\";\r\n}\r\n```\r\n\r\n* `getAccessTokenEndpoint()` - 토큰과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getAuthorizationBaseUrl()` - 인증과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getUserInfoEndPoint()` - 사용자 정보와 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n\r\nOAuth2.0 서비스를 수행함에 있어서 필요한 URL은 위와 같다. 이 중 `getAccessTokenEndpoint()`과 `getAuthorizationBaseUrl()`는 scribeJAVA 라이브러리의 객체인 `DefaultApi20`의 추상 메서드고 나머지 하나가 `AuthModule`의 추상 메서드다.\r\n\r\n`DefaultApi20`는 사용자 계정 API에 관련된 메서드를 별도로 제공하지 않는다. 하지만 `AuthModule`에서 사용자 정보 확인 공통 메서드를 사용할 때 사용자 계정 API가 반드시 필요하므로 `AuthModule`의 추상 메서드로 관리한다.\r\n\r\n\r\n\r\n## 인증 URL 반환 메서드\r\n\r\n<span class=\"blue-500\">Google 플랫폼 로그인 URL을 반환하는 기능</span>을 구현한다.\r\n\r\n우선 API를 살펴보자.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent&response_type=code&client_id=${:client_id}&redirect_uri={:redirect_uri}&scope={:scope}&state={:state}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |                     description                      |\r\n| :--------------: | :---: | :------: | :------: | :--------------------------------------------------: |\r\n| {:response_type} | path  | `String` |    Y     |               응답 타입. `code`로 고정               |\r\n|   {:client_id}   | path  | `String` |    Y     |                        API키                         |\r\n| {:redirect_uri}  | path  | `String` |    Y     |                     Callback URL                     |\r\n|     {:state}     | path  | `String` |    Y     |                     고유 상태값                      |\r\n|     {:scope}     | path  | `String` |          | 접근 허용 범위. 선택한 범위를 공백으로 구분하여 입력 |\r\n|  {:access_type}  | path  | `String` |          |        브라우저 환경 여부. `offline`으로 고정        |\r\n|    {:prompt}     | path  | `String` |          |           프롬프트 모드. `consent`로 고정            |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\nGoogle 플랫폼 로그인 페이지\r\n\r\n<br />\r\n\r\nGoogle 플랫폼 로그인 API는 위와 같다. 메서드가 요청의 URL을 반환하도록 설계하면 된다.\r\n\r\n문자열 연산으로 URL을 직접 설계할 수도 있지만, `service.getAuthorizationUrl()` 메서드를 통해 URL을 간편하게 생성할 수 있다.\r\n\r\n<br />\r\n\r\n여기서 다른 플랫폼과 Google만의 차이가 하나 있는데, 바로 `access_type`과 `prompt`의 존재다.\r\n\r\nGoogle은 일반적인 URL로 로그인을 수행하면 첫 로그인 시에만 Refresh Token을 제공한다. 즉, 첫 로그인 시 Refresh Token을 어딘가에 저장해야만한다.\r\n\r\n이 정보는 손실되면 안 되므로 쿠키나 로컬 스토리지가 아닌 DB에 저장하는 것이 적합하다. 하지만 이 프로젝트는 사용자의 정보를 따로 저장하지 않는다.\r\n\r\n이 때 <span class=\"orange-500\">로그인 URL에 위 파라미터를 붙이면 항상 새로 인증을 수행하므로 Refresh Token을 로그인 시마다 제공</span>한다.\r\n\r\n<br />\r\n\r\n이미 `AuthModule`에 공통 메서드로 선언된 게 있으므로, <span class=\"red-400\">따로 구현하지 않아도 된다.</span>\r\n\r\n\r\n\r\n## 접근 토큰 반환 메서드\r\n\r\n로그인 결과로 Code를 전달받으므로 <span class=\"blue-500\">Access Token으로 교환하는 기능</span>을 구현한다.\r\n\r\nGoogle API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nPOST https://oauth2.googleapis.com/token?grant_type=authorization_code&client_id={:client_id}&client_secret={:client_secret}&code={:code}&state={:state}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |              description               |\r\n| :--------------: | :---: | :------: | :------: | :------------------------------------: |\r\n|  {:grant_type}   | path  | `String` |    Y     | 인증 타입. `authorization_code`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |                 API키                  |\r\n| {:client_secret} | path  | `String` |    Y     |                Secret키                |\r\n|     {:code}      | path  | `String` |    Y     |               인가 코드                |\r\n|     {:state}     | path  | `String` |          |              고유 상태값               |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\r\n\t\"expires_in\": 3920,\r\n\t\"token_type\": \"Bearer\",\r\n\t\"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\r\n\t\"refresh_token\": \"1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI\"\r\n}\r\n```\r\n\r\n|   parameter   |   data   |    description     |\r\n| :-----------: | :------: | :----------------: |\r\n| access_token  | `String` |     인증 토큰      |\r\n| refresh_token | `String` |   리프레쉬 토큰    |\r\n|  token_type   | `String` |     토큰 타입      |\r\n|  expires_in   |  `int`   | 만료일자 (초 단위) |\r\n|     scope     | `String` |     접근 권한      |\r\n\r\n<br />\r\n\r\n`service.getAccessToken()` 메서드의 응답으로 위 JSON 응답의 DTO 객체인 `OAuth2AccessToken`를 얻을 수 있다.\r\n\r\n마찬가지로 `AuthModule`에 선언된 공통 메서드를 활용하면 되므로, 굳이 <span class=\"red-400\">구현할 필요 없다.</span>\r\n\r\n\r\n\r\n## 접근 토큰 갱신 및 반환 메서드\r\n\r\nAccess Token은 만료시간이 한시간 정도로 매우 짧다. Access Token이 만료될 경우, 사용자에게 플랫폼 로그인을 통해 인증 정보를 다시 요구해야하지만 Refresh Token이 있다면 별도의 절차 없이 서비스 내부에서 <span class=\"blue-500\">Access Token을 재발급</span> 받을 수 있다.\r\n\r\n이 Refresh Token은 인증 권한은 없지만, Access Token을 재발급받는 권한을 가진다.\r\n\r\n이를 구현한 Google API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nPOST https://oauth2.googleapis.com/token?grant_type=refresh_token&client_id={:client_id}&client_secret={:client_secret}&refresh_token=${:refresh_token}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |            description            |\r\n| :--------------: | :---: | :------: | :------: | :-------------------------------: |\r\n|  {:grant_type}   | path  | `String` |    Y     | 인증 타입. `refresh_token`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |               API키               |\r\n| {:client_secret} | path  | `String` |    Y     |             Secret키              |\r\n| {:refresh_token} | path  | `String` |    Y     |           리프레쉬 토큰           |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\r\n\t\"expires_in\": 3920,\r\n\t\"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\r\n\t\"token_type\": \"Bearer\"\r\n}\r\n```\r\n\r\n|  parameter   |   data   |    description     |\r\n| :----------: | :------: | :----------------: |\r\n| access_token | `String` |     인증 토큰      |\r\n|  token_type  | `String` |     토큰 타입      |\r\n|  expires_in  | `String` | 만료일자 (초 단위) |\r\n|    scope     | `String` |     접근 권한      |\r\n\r\n<br />\r\n\r\n`AuthModule`의 공통 메서드로 대체 가능하므로 <span class=\"red-400\">별도로 구현하지 않는다.</span>\r\n\r\n\r\n\r\n## 사용자 정보 응답 반환 메서드\r\n\r\n<span class=\"blue-500\">Access Token으로 유저 정보를 호출하는 기능</span>을 구현한다. 발급받은 Access Token을 실제로 유의미하게 쓰는 부분이다.\r\n\r\nGoogle API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET https://www.googleapis.com/oauth2/v3/userinfo\r\nAuthorization: Bearer {:access_token}\r\n```\r\n\r\n|    parameter    |  type  |   data   | required | description |\r\n| :-------------: | :----: | :------: | :------: | :---------: |\r\n| {:access_token} | header | `String` |    Y     |  접근 토큰  |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"sub\": \"90234582532742\",\r\n\t\"name\": \"First Last\",\r\n\t\"given_name\": \"First\",\r\n\t\"family_name\": \"Last\",\r\n\t\"picture\": \"https://lh3.googleusercontent.com/a-/hash\",\r\n\t\"email\": \"example@gmail.com\",\r\n\t\"email_verified\": true,\r\n\t\"locale\": \"ko\"\r\n}\r\n```\r\n\r\n|   parameter    |   data    |          description           |\r\n| :------------: | :-------: | :----------------------------: |\r\n|      sub       | `String`  | 동일인 식별 정보 (고유 해쉬값) |\r\n|      name      | `String`  |           전체 이름            |\r\n|   given_name   | `String`  |              이름              |\r\n|  family_name   | `String`  |               성               |\r\n|    picture     | `String`  |        프로필 사진 URL         |\r\n|     email      | `String`  |        사용자 메일 주소        |\r\n| email_verified | `boolean` |        이메일 인증 여부        |\r\n|     locale     | `String`  |              언어              |\r\n\r\n<br />\r\n\r\n구글 Profile 응답은 명확하게 제공된 docs를 찾을 수 없어서, 필자의 Access Token을 요청하여 얻은 응답을 기준으로 작성한다. 위 표 외에도 `scope`에 따라 더욱 많은 데이터가 전송될 수 있으니 참고하기 바란다.\r\n\r\nid는 우리가 생각하는 `xxx@google.com` 형태의 아이디가 아니라 아이디별로 부여받는 고유 해쉬값이다.\r\n\r\n`AuthModule`의 공통 메서드로 대체 가능하므로 <span class=\"red-400\">별도로 구현하지 않는다.</span>\r\n\r\n\r\n\r\n## 유저 정보 객체 반환 메서드\r\n\r\n<span class=\"blue-500\">Google의 유저 정보 호출 API 응답 형식에 맞게끔 응답을 파싱</span>하여 `UserInfoBean`로 반환하는 메서드를 구현한다.\r\n\r\n이 프로젝트에선 이름, 이메일, 프로필사진 URL만을 사용하므로, 응답에서 해당 값을 빼내어 객체에 담는다.\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n{\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tJsonNode node = mapper.readTree(body);\r\n\t\r\n\tString email = node.get(\"email\") == null ? \"미동의\" : node.get(\"email\").textValue();\r\n\tString name = node.get(\"name\") == null ? \"미동의\" : node.get(\"name\").textValue();\r\n\tString picture = node.get(\"picture\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"picture\").textValue();\r\n\t\r\n\treturn new UserInfoBean(email, name, picture, MODULE_NAME);\r\n}\r\n```\r\n\r\n<br />\r\n\r\n응답 형식에 맞추어 필요한 값을 추출한다. 만약, 사용자가 정보 제공에 동의하지 않았을 경우 대상 객체가 `null`을 반환한다. 데이터의 누락 시 오류를 방지하기 위해 데이터에 대한 `null` 처리를 반드시 해야한다.\r\n\r\n\r\n\r\n## 연동 해제 결과 반환 메서드\r\n\r\nGoogle 아이디로 처음 로그인을 하면 정보 제공 동의를 수행하는데, 나중에 다시 로그인을 하면 이러한 동의 과정이 생략된다. 즉, 플랫폼에서 첫 로그인 시 정보 제공 동의를 받아 어딘가로부터 저장한다는 뜻이다. 만약 사용자가 서비스로부터 회원 탈퇴를 수행한다면 <span class=\"blue-500\">Google과의 연동을 해제하여 정보를 완전히 삭제</span>할 필요가 있다.\r\n\r\nGoogle API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nPOST https://oauth2.googleapis.com/revoke?token={:token}\r\n```\r\n\r\n| parameter | type  |   data   | required | description |\r\n| :-------: | :---: | :------: | :------: | :---------: |\r\n| {:token}  | path  | `String` |    Y     |  접근 토큰  |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{}\r\n```\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n{\r\n\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.POST, \"https://oauth2.googleapis.com/revoke\");\r\n\toAuthRequest.addBodyParameter(\"token\", access);\r\n\t\r\n\tservice.signRequest(access, oAuthRequest);\r\n\t\r\n\treturn service.execute(oAuthRequest).isSuccessful();\r\n}\r\n```\r\n\r\n<br />\r\n\r\n구현은 간단하다. `OAuthRequest` 객체를 활용하면 요청을 쉽게 생성할 수 있다. 응답 자체는 중요하지 않은데다, Google의 경우 응답코드 200은 내용이 아예 없는 204와 동일하다. `response.isSuccessful()` 메서드로 응답이 정상적인지 여부만 판단하여 `boolean`으로 반환한다.\r\n\r\n\r\n\r\n## 정보 제공 동의 갱신 URL 반환 메서드\r\n\r\nGoogle의 경우, 프로필 정보는 별도의 동의를 요구하지 않는다. 따라서 해당 기능은 <span class=\"red-400\">구현에서 제외</span>한다.\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n\r\n``` java\r\n@Override\r\npublic String getUpdateAuthorizationUrl(String state)\r\n{\r\n\treturn null;\r\n}\r\n```\r\n\r\n<br />\r\n\r\nnull을 반환하여 동작을 수행하지 않도록 처리한다. 추후 프로세스에서 `null`값이 반환될 경우 별도의 처리를 따른다.\r\n\r\n\r\n\r\n## 전체 코드\r\n\r\n``` java\r\npackage oauth.account.module;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.github.scribejava.core.builder.ServiceBuilder;\r\nimport com.github.scribejava.core.builder.ServiceBuilderOAuth20;\r\nimport com.github.scribejava.core.model.OAuthRequest;\r\nimport com.github.scribejava.core.model.Verb;\r\nimport oauth.account.bean.ApiKeyBean;\r\nimport oauth.account.bean.UserInfoBean;\r\n\r\nimport java.io.IOException;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n/**\r\n * Google 인증 모듈 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 23:45:27\r\n */\r\npublic class GoogleAuthModule extends AuthModule\r\n{\r\n\tprivate static final String MODULE_NAME = \"google\";\r\n\t\r\n\tprivate static final String API_KEY;\r\n\tprivate static final String SECRET_KEY;\r\n\tprivate static final String CALLBACK_URL;\r\n\t\r\n\tstatic\r\n\t{\r\n\t\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\t\r\n\t\tAPI_KEY = apiKeyBean.getApi();\r\n\t\tSECRET_KEY = apiKeyBean.getSecret();\r\n\t\tCALLBACK_URL = apiKeyBean.getCallback();\r\n\t}\r\n\t\r\n\tprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL).defaultScope(\"https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile\");\r\n\t\r\n\tprivate static final GoogleAuthModule INSTANCE = new GoogleAuthModule(SERVICE_BUILDER);\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param serviceBuilder: [ServiceBuilderOAuth20] API 서비스 빌더\r\n\t */\r\n\tprivate GoogleAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n\t{\r\n\t\tsuper(serviceBuilder);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인스턴스 반환 메서드\r\n\t *\r\n\t * @return [GoogleAuthModule] 인스턴스\r\n\t */\r\n\tpublic static GoogleAuthModule getInstance()\r\n\t{\r\n\t\treturn INSTANCE;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 유저 정보 객체 반환 메서드\r\n\t *\r\n\t * @param body: [String] OAuth 응답 내용\r\n\t *\r\n\t * @return [UserInfoBean] 유저 정보 객체\r\n\t *\r\n\t * @throws JsonProcessingException JSON 파싱 예외\r\n\t */\r\n\t@Override\r\n\tpublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n\t{\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(body);\r\n\t\t\r\n\t\tString email = node.get(\"email\") == null ? \"미동의\" : node.get(\"email\").textValue();\r\n\t\tString name = node.get(\"name\") == null ? \"미동의\" : node.get(\"name\").textValue();\r\n\t\tString picture = node.get(\"picture\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"picture\").textValue();\r\n\t\t\r\n\t\treturn new UserInfoBean(email, name, picture, MODULE_NAME);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 연동 해제 결과 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [boolean] 연동 해제 결과\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\t@Override\r\n\tpublic boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.POST, \"https://oauth2.googleapis.com/revoke\");\r\n\t\toAuthRequest.addBodyParameter(\"token\", access);\r\n\t\t\r\n\t\tservice.signRequest(access, oAuthRequest);\r\n\t\t\r\n\t\treturn service.execute(oAuthRequest).isSuccessful();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 반환 메서드\r\n\t *\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [String] 정보 제공 동의 갱신 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getUpdateAuthorizationUrl(String state)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 접근 토큰 요청 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getAccessTokenEndpoint()\r\n\t{\r\n\t\treturn \"https://oauth2.googleapis.com/token\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 API 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 인증 API 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getAuthorizationBaseUrl()\r\n\t{\r\n\t\treturn \"https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 사용자 정보 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getUserInfoEndPoint()\r\n\t{\r\n\t\treturn \"https://www.googleapis.com/oauth2/v3/userinfo\";\r\n\t}\r\n}\r\n```\r\n\r\n정리한 전체 코드는 위와 같다.\r\n\r\n\r\n\r\n# 정리\r\n\r\n네이버의 인증 모듈 구현과 매우 흡사하다. 구현, 오버라이딩해야하는 메서드 모두 동일하다. `AuthModule`을 통해 공통 모듈로 대체함과 필요 시 오버라이딩을 함으로써 여러 플랫폼에 효과적으로 대응이 가능함을 느낄 수 있다. 객체지향이 왜 유지보수에 유용한지 새삼 깨달을 수 있었다.\r\n\r\n이로써 Google 인증 모듈 구현이 완료됐다. 현재까지는 개발 중 단계라 정해진 아이디로만 사용할 수 있다. API 설정에서 테스트 계정을 등록해야 해당 계정으로 로그인 테스트가 가능하다. 심사 이후 애플리케이션이 승인되면 모든 아이디에서 로그인이 가능하다.\r\n\r\n구글은 개발하는데 살짝 난감했다. 구글이 워낙 제공하는 서비스가 많다보니, 문서도 방대한데다 간단명료하게 설명해주는 문서도 없어서 여기저기 많이 찾아다녀야했다.","url":["2021-10-23-oauth2-java-server-5","2021","10","23","oauth2-java-server-5"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 4. NAVER OAuth 서비스 신청 및 모듈 구현하기","excerpt":"첫 번째 플랫폼으로, NAVER에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-22T22:25:16","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","scribeJAVA"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-22-oauth2-java-server-4.md","content":"\r\n# 개요\r\n\r\n첫 번째 플랫폼으로, NAVER에 OAuth 서비스를 신청하고 인증 모듈을 구현한다.\r\n\r\n\r\n\r\n\r\n\r\n# NAVER OAuth 서비스 신청하기\r\n\r\nAPI 정보를 얻기 위해 NAVER OAuth 서비스를 신청하자.\r\n\r\n\r\n\r\n## 1. 네이버 개발자 센터 접속하기\r\n\r\n로그인 후 [네이버 개발자 센터](https://developers.naver.com/main/)에 접속하자.\r\n\r\nNAVER의 OAuth는 네이버 아이디로 로그인. 속칭 네아로라는 명칭으로 서비스를 제공하고 있다.\r\n\r\n네이버 개발자 센터에서 해당 서비스를 사용하는 애플리케이션을 등록하면 된다.\r\n\r\n<br />\r\n\r\n상단 헤더의 [<span class=\"lightBlue-600\">Application</span> - <span class=\"lightBlue-600\">애플리케이션 등록</span>] 메뉴로 접속하자.\r\n\r\n\r\n\r\n## 2. 애플리케이션 등록\r\n\r\nOAuth 정보를 관리하게 될 애플리케이션을 등록하자.\r\n\r\n아래의 항목을 모두 입력해야하며, 해당 항목들은 심사 후에도 언제든지 변경이 가능하다.\r\n\r\n\r\n\r\n### 애플리케이션 이름\r\n\r\n해당 애플리케이션의 이름이다. 이 이름은 네이버 로그인 창에도 표시가 된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138466274-8c7dff01-7aaf-4911-a2c6-874caa418122.png)\r\n\r\n필자의 네아로 창 예시. 필자의 애플리케이션 이름은 OAuth2로, 위 창의 OAuth2 부분에 지정한 이름이 표시된다.\r\n\r\n\r\n\r\n### 사용 API\r\n\r\n사용할 API를 선택한다.\r\n\r\n네이버와 관련된 여러 API를 제공하지만, 지금은 프로젝트의 목적에 맞게 <span class=\"primary\">네아로 서비스</span>를 선택한다.\r\n\r\n<br />\r\n\r\n네아로 서비스를 선택하면 제공 정보를 선택하는 폼이 추가된다.\r\n\r\n이는 사용자의 인증 정보로 얻을 수 있는 정보를 선별하는 것으로, 필수와 추가로 구분하여 선택할 수 있다.\r\n\r\n필수 혹은 추가로 지정된 정보는 추후 사용자의 정보 호출 시 접근이 가능하다.\r\n\r\n<br />\r\n\r\n> <b class=\"red-600\">🛑 주의!!</b>  \r\n> 네이버는 필수 정보조차도 사용자가 임의로 거부할 수 있다. 즉, 서비스 운영에 있어서 이 정보가 필수라는 사항은 사용자에게 고지하더라도, 사용자가 이를 거부해버리면 서비스 입장에선 방법이 없다.  \r\n> 상기한 이유로, 네이버는 사용자 정보 검증의 중요도가 타 플랫폼보다 높다. 필수와 추가의 차이점은 체크박스의 기본값이 체크냐 해제냐로 갈린다. 필수의 경우 기본적으로 체크하나, 추가의 경우 기본적으로 해제된 채 사용자에게 제공된다.\r\n\r\n원하는 정보를 선택하자. 반드시 필요하다면 필수를, 그렇지 않다면 추가로 두자. 혹시 모른답시고 전체 데이터를 체크하지 말자. 물론 불가능한 건 아니지만, 추후 OAuth 키 배포 활성화 심사에서 불필요하거나 과도한 데이터 접근 허가를 요구할 경우 심사를 반려할 수도 있다. 반드시 필요한 최소한의 정보만을 요구하자.\r\n\r\n\r\n\r\n### 로그인 오픈 API 서비스 환경\r\n\r\nOAuth를 사용할 환경에 대해 입력한다.\r\n\r\n해당 프로젝트는 웹을 대상으로 구축되었으므로, PC 웹으로 선택한다. Android나 iOS를 추가할 수도 있다. 여러 환경을 동시에 추가하여 하나의 키로 여러 플랫폼에 접근하는 식의 통합 관리도 가능하다.\r\n\r\n<br />\r\n\r\n서비스 URL은 네아로를 적용하려는 서비스의 URL이다.\r\n\r\nCallback URL은 로그인 후 결과를 전달할 URL이다. 최대 5개까지 지정할 수 있으며, 추후 설정할 `naver.properties` 파일의 `callback`은 이 Callback URL 중 하나가 입력되어야 한다. 플랫폼 로그인 과정에서 등록되지 않은 Callback URL이 감지될 경우 오류를 출력한다.\r\n\r\n`https://example.com/oauth2` 같은 URL의 영식을 입력하며, `https://example.com/oauth2?key=value`와 같이 임의의 URL 파라미터를 붙여도 된다.\r\n\r\n모든 항목에 이상이 없으면 애플리케이션을 만들자.\r\n\r\n\r\n\r\n### API 정보 확인\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/138097785-f918f5b3-2d9f-49c0-82b6-09f95c64242c.png)\r\n\r\n애플리케이션을 만들면 API와 Secret을 확인할 수 있다. Secret은 기본적으로 마스킹되어있으며, 별도의 버튼을 눌러 확인할 수 있다. Secret이 유출되었다고 판단될 경우, 재발급을 할 수도 있다. 이 경우 당연히도 인증 서버에 변경된 Secret을 적용해야한다.\r\n\r\n\r\n\r\n\r\n\r\n# NAVER 인증 모듈 구현하기\r\n\r\n필요한 모든 준비가 갖춰졌으니, NAVER 인증 모듈을 구현해보자. 이전에 구현한 `AuthModule`을 상속받아 구현할 것이다.\r\n\r\n``` java\r\npublic class NaverAuthModule extends AuthModule\r\n{\r\n\t// NAVER 인증 모듈\r\n}\r\n```\r\n\r\n객체의 기본 형식은 위와 같다.\r\n\r\n|           메서드            | 메서드 타입 |                 내용                  | 구현 필요 여부 |\r\n| :-------------------------: | :---------: | :-----------------------------------: | :------------: |\r\n|    `getAuthorizationUrl`    |    추상     |         인증 URL 반환 메서드          |       Y        |\r\n|      `getAccessToken`       |             |         접근 토큰 반환 메서드         |                |\r\n|   `getRefreshAccessToken`   |             |     접근 토큰 갱신 및 반환 메서드     |                |\r\n|        `getUserInfo`        |             |     사용자 정보 응답 반환 메서드      |                |\r\n|  `getRefreshTokenEndpoint`  |             | 접근 토큰 재발급 요청 URL 반환 메서드 |                |\r\n|       `getApiKeyBean`       |             |        API 키 객체 반환 메서드        |                |\r\n|    `getUserInfoEndPoint`    |             |   사용자 정보 요청 URL 반환 메서드    |                |\r\n|      `getUserInfoBean`      |    추상     |      유저 정보 객체 반환 메서드       |       Y        |\r\n|        `deleteInfo`         |    추상     |      연동 해제 결과 반환 메서드       |       Y        |\r\n| `getUpdateAuthorizationUrl` |    추상     |  정보 제공 동의 갱신 URL 반환 메서드  |       Y        |\r\n|  `getAccessTokenEndpoint`   |    추상     |    접근 토큰 요청 URL 반환 메서드     |       Y        |\r\n|  `getAuthorizationBaseUrl`  |    추상     |     인증 API 요청 URL 반환 메서드     |       Y        |\r\n\r\nNAVER 모듈이 구현해야하는 대상은 위와 같다.\r\n\r\n\r\n\r\n## properties 파일 생성하기\r\n\r\n`WEB-INF` 아래 `naver.properties` 파일을 생성한다. 기 생성된 `sample.properties`를 복사해서 사용해도 된다.\r\n\r\n``` properties\r\napi=API_KEY\r\nsecret=SECRET_KEY\r\ncallback=CALLBACK_URL\r\n```\r\n\r\n기본적인 형식은 위와 같으며, 각 항목에 해당하는 값을 입력하면 된다.\r\n\r\n\r\n\r\n## 인증 모듈 기본 메서드 및 변수 할당하기\r\n\r\n인증 모듈이 정상적으로 동작하기 위해선 기본적으로 지정해줘야할 메서드와 변수들이 존재한다. API 정보 설정, 인스턴스 반환같은 것들이다.\r\n\r\n``` java\r\nprivate static final String MODULE_NAME = \"naver\";\r\n\r\nprivate static final String API_KEY;\r\nprivate static final String SECRET_KEY;\r\nprivate static final String CALLBACK_URL;\r\n\r\nstatic\r\n{\r\n\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\r\n\tAPI_KEY = apiKeyBean.getApi();\r\n\tSECRET_KEY = apiKeyBean.getSecret();\r\n\tCALLBACK_URL = apiKeyBean.getCallback();\r\n}\r\n\r\nprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL);\r\n\r\nprivate static final NaverAuthModule INSTANCE = new NaverAuthModule(SERVICE_BUILDER);\r\n\r\nprivate NaverAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n{\r\n\tsuper(serviceBuilder);\r\n}\r\n\r\npublic static NaverAuthModule getInstance()\r\n{\r\n\treturn INSTANCE;\r\n}\r\n```\r\n\r\n|       구분        |          형식           |         내용         |\r\n| :---------------: | :---------------------: | :------------------: |\r\n|   `MODULE_NAME`   |        `String`         |      모듈 이름       |\r\n|     `API_KEY`     |        `String`         |        API키         |\r\n|   `SECRET_KEY`    |        `String`         |       Secret키       |\r\n|  `CALLBACK_URL`   |        `String`         |       콜백 URL       |\r\n| `SERVICE_BUILDER` | `ServiceBuilderOAuth20` | OAuth2.0 서비스 빌더 |\r\n|    `INSTANCE`     |    `NaverAuthModule`    |       인스턴스       |\r\n\r\n정의된 변수는 전부 `static final`로 선언되어 있어서, <span class=\"red-400\">인스턴스 생성 시 한 번만 선언되며 재할당이 불가능</span>하도록 관리한다.\r\n\r\n`static{ }` 구문을 통해 인스턴스 생성 시 API 정보를 할당하도록 구성했다.\r\n\r\nAPI 할당 시 `getApiKeyBean()` 메서드를 통해 제공된 이름을 갖는 properties를 분석하여 `ApiKeyBean` 객체를 반환받아 사용한다.\r\n\r\n\r\n\r\n## API URL 할당하기\r\n\r\n각 API 별 요청 URL을 반환하는 메서드를 구현하자.\r\n\r\n``` java\r\n@Override\r\npublic String getAccessTokenEndpoint()\r\n{\r\n\treturn \"https://nid.naver.com/oauth2.0/token\";\r\n}\r\n\r\n@Override\r\nprotected String getAuthorizationBaseUrl()\r\n{\r\n\treturn \"https://nid.naver.com/oauth2.0/authorize\";\r\n}\r\n\r\n@Override\r\nprotected String getUserInfoEndPoint()\r\n{\r\n\treturn \"https://openapi.naver.com/v1/nid/me\";\r\n}\r\n```\r\n\r\n* `getAccessTokenEndpoint()` - 토큰과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getAuthorizationBaseUrl()` - 인증과 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n* `getUserInfoEndPoint()` - 사용자 정보와 관련된 API는 해당 메소드가 반환하는 URL을 토대로 사용한다.\r\n\r\nOAuth2.0 서비스를 수행함에 있어서 필요한 URL은 위와 같다. 이 중 `getAccessTokenEndpoint()`과 `getAuthorizationBaseUrl()`는 scribeJAVA 라이브러리의 객체인 `DefaultApi20`의 추상 메서드고 나머지 하나가 `AuthModule`의 추상 메서드다.\r\n\r\n`DefaultApi20`는 사용자 계정 API에 관련된 메서드를 별도로 제공하지 않는다. 하지만 `AuthModule`에서 사용자 정보 확인 공통 메서드를 사용할 때 사용자 계정 API가 반드시 필요하므로 `AuthModule`의 추상 메서드로 관리한다.\r\n\r\n\r\n\r\n## 인증 URL 반환 메서드\r\n\r\n<span class=\"blue-500\">네이버 플랫폼 로그인 URL을 반환하는 기능</span>을 구현한다.\r\n\r\n우선 API를 살펴보자.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://nid.naver.com/oauth2.0/authorize?response_type=code&client_id={:client_id}&redirect_uri={:redirect_uri}&state={:state}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |           description           |\r\n| :--------------: | :---: | :------: | :------: | :-----------------------------: |\r\n| {:response_type} | path  | `String` |    Y     |    응답 타입. `code`로 고정     |\r\n|   {:client_id}   | path  | `String` |    Y     |              API키              |\r\n| {:redirect_uri}  | path  | `String` |    Y     |          Callback URL           |\r\n|     {:state}     | path  | `String` |    Y     |           고유 상태값           |\r\n|     {:scope}     | path  | `String` |          | 접근 허용 범위로, 사용하지 않음 |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n네이버 플랫폼 로그인 페이지\r\n\r\n<br />\r\n\r\n네이버 플랫폼 로그인 API는 위와 같다. 메서드가 요청의 URL을 반환하도록 설계하면 된다.\r\n\r\n문자열 연산으로 URL을 직접 설계할 수도 있지만, `service.getAuthorizationUrl()` 메서드를 통해 URL을 간편하게 생성할 수 있다.\r\n\r\n이미 `AuthModule`에 공통 메서드로 선언된 게 있으므로, <span class=\"red-400\">따로 구현하지 않아도 된다.</span>\r\n\r\n\r\n\r\n## 접근 토큰 반환 메서드\r\n\r\n로그인 결과로 Code를 전달받으므로 <span class=\"blue-500\">Access Token으로 교환하는 기능</span>을 구현한다.\r\n\r\n네이버 API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://nid.naver.com/oauth2.0/token?grant_type=authorization_code&client_id={:client_id}&client_secret={:client_secret}&code={:code}&state={:state}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |              description               |\r\n| :--------------: | :---: | :------: | :------: | :------------------------------------: |\r\n|  {:grant_type}   | path  | `String` |    Y     | 인증 타입. `authorization_code`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |                 API키                  |\r\n| {:client_secret} | path  | `String` |    Y     |                Secret키                |\r\n|     {:code}      | path  | `String` |    Y     |               인가 코드                |\r\n|     {:state}     | path  | `String` |          |              고유 상태값               |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"access_token\": \"AAAAQosjWDJieBiQZc3to9YQp6HDLvrmyKC+6+iZ3gq7qrkqf50ljZC+Lgoqrg\",\r\n\t\"refresh_token\": \"c8ceMEJisO4Se7uGisHoX0f5JEii7JnipglQipkOn5Zp3tyP7dHQoP0zNKHUq2gY\",\r\n\t\"token_type\": \"bearer\",\r\n\t\"expires_in\": \"3600\"\r\n}\r\n```\r\n\r\n|   parameter   |   data   |    description     |\r\n| :-----------: | :------: | :----------------: |\r\n| access_token  | `String` |     인증 토큰      |\r\n| refresh_token | `String` |   리프레쉬 토큰    |\r\n|  token_type   | `String` |     토큰 타입      |\r\n|  expires_in   | `String` | 만료일자 (초 단위) |\r\n\r\n<br />\r\n\r\n`service.getAccessToken()` 메서드의 응답으로 위 JSON 응답의 DTO 객체인 `OAuth2AccessToken`를 얻을 수 있다.\r\n\r\n마찬가지로 `AuthModule`에 선언된 공통 메서드를 활용하면 되므로, 굳이 <span class=\"red-400\">구현할 필요 없다.</span>\r\n\r\n\r\n\r\n## 접근 토큰 갱신 및 반환 메서드\r\n\r\nAccess Token은 만료시간이 한시간 정도로 매우 짧다. Access Token이 만료될 경우, 사용자에게 플랫폼 로그인을 통해 인증 정보를 다시 요구해야하지만 Refresh Token이 있다면 별도의 절차 없이 서비스 내부에서 <span class=\"blue-500\">Access Token을 재발급</span> 받을 수 있다.\r\n\r\n이 Refresh Token은 인증 권한은 없지만, Access Token을 재발급받는 권한을 가진다.\r\n\r\n이를 구현한 네이버 API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://nid.naver.com/oauth2.0/token?grant_type=refresh_token&client_id={:client_id}&client_secret={:client_secret}&refresh_token=${:refresh_token}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |            description            |\r\n| :--------------: | :---: | :------: | :------: | :-------------------------------: |\r\n|  {:grant_type}   | path  | `String` |    Y     | 인증 타입. `refresh_token`로 고정 |\r\n|   {:client_id}   | path  | `String` |    Y     |               API키               |\r\n| {:client_secret} | path  | `String` |    Y     |             Secret키              |\r\n| {:refresh_token} | path  | `String` |    Y     |           리프레쉬 토큰           |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n    \"access_token\":\"AAAAQjbRkysCNmMdQ7kmowPrjyRNIRYKG2iGHhbGawP0xfuYwjrE2WTI3p44SNepkFXME/NlxfamcJKPmUU4dSUhz+R2CmUqnN0lGuOcbEw6iexg\",\r\n    \"token_type\":\"bearer\",\r\n    \"expires_in\":\"3600\"\r\n}\r\n```\r\n\r\n|  parameter   |   data   |    description     |\r\n| :----------: | :------: | :----------------: |\r\n| access_token | `String` |     인증 토큰      |\r\n|  token_type  | `String` |     토큰 타입      |\r\n|  expires_in  | `String` | 만료일자 (초 단위) |\r\n\r\n<br />\r\n\r\n`AuthModule`의 공통 메서드로 대체 가능하므로 <span class=\"red-400\">별도로 구현하지 않는다.</span>\r\n\r\n\r\n\r\n## 사용자 정보 응답 반환 메서드\r\n\r\n<span class=\"blue-500\">Access Token으로 유저 정보를 호출하는 기능</span>을 구현한다. 발급받은 Access Token을 실제로 유의미하게 쓰는 부분이다.\r\n\r\n네이버 API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET https://openapi.naver.com/v1/nid/me\r\nAuthorization: Bearer {:access_token}\r\n```\r\n\r\n|    parameter    |  type  |   data   | required | description |\r\n| :-------------: | :----: | :------: | :------: | :---------: |\r\n| {:access_token} | header | `String` |    Y     |  접근 토큰  |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"resultcode\": \"00\",\r\n\t\"message\": \"success\",\r\n\t\"response\": {\r\n\t\t\"email\": \"openapi@naver.com\",\r\n\t\t\"nickname\": \"OpenAPI\",\r\n\t\t\"profile_image\": \"https://ssl.pstatic.net/static/pwe/address/nodata_33x33.gif\",\r\n\t\t\"age\": \"40-49\",\r\n\t\t\"gender\": \"F\",\r\n\t\t\"id\": \"32742776\",\r\n\t\t\"name\": \"오픈 API\",\r\n\t\t\"birthday\": \"10-01\",\r\n\t\t\"birthyear\": \"1900\",\r\n\t\t\"mobile\": \"010-0000-0000\"\r\n\t}\r\n}\r\n```\r\n\r\n|       parameter        |   data   |                                       description                                        |\r\n| :--------------------: | :------: | :--------------------------------------------------------------------------------------: |\r\n|       resultcode       | `String` | [API 호출 결과 코드](https://developers.naver.com/docs/common/openapiguide/errorcode.md) |\r\n|        message         | `String` |                                     호출 결과 메시지                                     |\r\n|      response.id       | `String` |                              동일인 식별 정보 (고유 해쉬값)                              |\r\n|   response.nickname    | `String` |                              사용자 별명 (없을 경우 id***)                               |\r\n|     response.name      | `String` |                                       사용자 이름                                        |\r\n|     response.email     | `String` |                      사용자 메일 주소 (내 정보의 이메일 주소 기준)                       |\r\n|    response.gender     | `String` |                         성별 (F - 여성, M - 남성, U - 확인불가)                          |\r\n|      response.age      | `String` |                                          연령대                                          |\r\n|   response.birthday    | `String` |                                       생일 (MM-DD)                                       |\r\n| response.profile_image | `String` |                                  사용자 프로필 사진 URL                                  |\r\n|   response.birthyear   | `String` |                                         출생연도                                         |\r\n|    response.mobile     | `String` |                                       휴대전화번호                                       |\r\n\r\n<br />\r\n\r\nid는 우리가 생각하는 `xxx@naver.com` 형태의 아이디가 아니라 아이디별로 부여받는 고유 해쉬값이다.\r\n\r\n네이버 아이디는 `response.email`로 얻을 수 있지만, 제한적이다. 만약 [<span class=\"lightBlue-600\">내 정보</span> - <span class=\"lightBlue-600\">연락처 이메일</span>]을 다른 메일로 변경했다면 네이버 메일이 아닌 해당 메일이 표시된다. <span class=\"red-400\">공식적으로 프로필 API에서 네이버 메일을 확정적으로 얻을 수 있는 방법은 없다.</span>\r\n\r\n`AuthModule`의 공통 메서드로 대체 가능하므로 <span class=\"red-400\">별도로 구현하지 않는다.</span>\r\n\r\n\r\n\r\n## 유저 정보 객체 반환 메서드\r\n\r\n<span class=\"blue-500\">네이버의 유저 정보 호출 API 응답 형식에 맞게끔 응답을 파싱</span>하여 `UserInfoBean`로 반환하는 메서드를 구현한다.\r\n\r\n이 프로젝트에선 이름, 이메일, 프로필사진 URL만을 사용하므로, 응답에서 해당 값을 빼내어 객체에 담는다.\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n{\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tJsonNode node = mapper.readTree(body);\r\n\t\r\n\tString email = node.get(\"response\").get(\"email\") == null ? \"미동의\" : node.get(\"response\").get(\"email\").textValue();\r\n\tString name = node.get(\"response\").get(\"name\") == null ? \"미동의\" : node.get(\"response\").get(\"name\").textValue();\r\n\tString profile_image = node.get(\"response\").get(\"profile_image\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"response\").get(\"profile_image\").textValue();\r\n\t\r\n\treturn new UserInfoBean(email, name, profile_image, MODULE_NAME);\r\n}\r\n```\r\n\r\n<br />\r\n\r\n응답 형식에 맞추어 필요한 값을 추출한다. 만약, 사용자가 정보 제공에 동의하지 않았을 경우 대상 객체가 `null`을 반환한다. <span class=\"red-600\">네이버는 필수/추가에 상관없이 동의/거부를 할 수 있기 때문</span>에 데이터에 대한 `null` 처리를 반드시 해야한다.\r\n\r\n\r\n\r\n## 연동 해제 결과 반환 메서드\r\n\r\n네이버 아이디로 처음 로그인을 하면 정보 제공 동의를 수행하는데, 나중에 다시 로그인을 하면 이러한 동의 과정이 생략된다. 즉, 플랫폼에서 첫 로그인 시 정보 제공 동의를 받아 어딘가로부터 저장한다는 뜻이다. 만약 사용자가 서비스로부터 회원 탈퇴를 수행한다면 <span class=\"blue-500\">네이버와의 연동을 해제하여 정보를 완전히 삭제</span>할 필요가 있다.\r\n\r\n네이버 API는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://nid.naver.com/oauth2.0/token?grant_type=delete&client_id={:client_id}&client_secret={:client_secret}&access_token={:access_token}&service_provider=NAVER\r\n```\r\n\r\n|      parameter      | type  |   data   | required |          description          |\r\n| :-----------------: | :---: | :------: | :------: | :---------------------------: |\r\n|    {:grant_type}    | path  | `String` |    Y     |  인증 타입. `delete`로 고정   |\r\n|    {:client_id}     | path  | `String` |    Y     |             API키             |\r\n|  {:client_secret}   | path  | `String` |    Y     |           Secret키            |\r\n|   {:access_token}   | path  | `String` |    Y     |           접근 토큰           |\r\n| {:service_provider} | path  | `String` |    Y     | 서비스 제공자. `NAVER`로 고정 |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n``` json\r\n{\r\n\t\"access_token\": \"c8ceMEjfnorlQwEisqemfpM1Wzw7aGp7JnipglQipkOn5Zp3tyP7dHQoP0zNKHUq2gY\",\r\n\t\"result\": \"success\"\r\n}\r\n```\r\n\r\n|  parameter   |   data   |            description             |\r\n| :----------: | :------: | :--------------------------------: |\r\n| access_token | `String` |      삭제 처리된 접근 토큰값       |\r\n|    result    | `String` | 처리결과. 성공일 경우 success 반환 |\r\n\r\n<br />\r\n\r\n* 코드\r\n\r\n``` java\r\n@Override\r\npublic boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n{\r\n\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getAccessTokenEndpoint());\r\n\toAuthRequest.addQuerystringParameter(\"client_id\", API_KEY);\r\n\toAuthRequest.addQuerystringParameter(\"client_secret\", SECRET_KEY);\r\n\toAuthRequest.addQuerystringParameter(\"access_token\", access);\r\n\toAuthRequest.addQuerystringParameter(\"grant_type\", \"delete\");\r\n\toAuthRequest.addQuerystringParameter(\"service_provider\", \"NAVER\");\r\n\t\r\n\tservice.signRequest(access, oAuthRequest);\r\n\t\r\n\tResponse response = service.execute(oAuthRequest);\r\n\t\r\n\treturn response.isSuccessful();\r\n}\r\n```\r\n\r\n<br />\r\n\r\n구현은 간단하다. `OAuthRequest` 객체를 활용하면 요청을 쉽게 생성할 수 있다. 응답 자체는 중요하지 않으므로 `response.isSuccessful()` 메서드로 응답이 정상적인지 여부만 판단하여 `boolean`으로 반환한다.\r\n\r\n\r\n\r\n## 정보 제공 동의 갱신 URL 반환 메서드\r\n\r\n서비스 운영 중 추가적인 사용자 정보가 필요하거나 필요 없을 때, <span class=\"blue-500\">사용자 정보 동의 갱신을 통해 동의 정보를 다시 지정</span>할 수 있다.\r\n\r\nAPI는 아래와 같다.\r\n\r\n<br />\r\n\r\n* 요청\r\n\r\n``` txt\r\nGET/POST https://nid.naver.com/oauth2.0/authorize?auth_type=reprompt&state=${:state}&response_type=code&client_id=${:client_id}&redirect_uri=${:redirect_uri}\r\n```\r\n\r\n|    parameter     | type  |   data   | required |         description          |\r\n| :--------------: | :---: | :------: | :------: | :--------------------------: |\r\n| {:response_type} | path  | `String` |    Y     |   응답 타입. `code`로 고정   |\r\n|   {:client_id}   | path  | `String` |    Y     |            API키             |\r\n| {:redirect_uri}  | path  | `String` |    Y     |         Callback URL         |\r\n|     {:state}     | path  | `String` |    Y     |         고유 상태값          |\r\n|   {:auth_type}   | path  | `String` |          | 인증 타입. `reprompt`로 고정 |\r\n\r\n<br />\r\n\r\n* 응답\r\n\r\n네이버 플랫폼 정보 제공 동의 페이지\r\n\r\n<br />\r\n\r\n해당 페이지에서 정보 제공 동의여부를 재선택할 수 있다. 이후 로그인과 동일하게 `code`와 `state`를 리다이렉션 URL로 보낸다. 이후 동작은 로그인과 동일하다.\r\n\r\n\r\n\r\n## 전체 코드\r\n\r\n``` java\r\npackage oauth.account.module;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.github.scribejava.core.builder.ServiceBuilder;\r\nimport com.github.scribejava.core.builder.ServiceBuilderOAuth20;\r\nimport com.github.scribejava.core.model.OAuthRequest;\r\nimport com.github.scribejava.core.model.Response;\r\nimport com.github.scribejava.core.model.Verb;\r\nimport oauth.account.bean.ApiKeyBean;\r\nimport oauth.account.bean.UserInfoBean;\r\n\r\nimport java.io.IOException;\r\nimport java.util.HashMap;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n/**\r\n * Naver 인증 모듈 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 23:45:49\r\n */\r\npublic class NaverAuthModule extends AuthModule\r\n{\r\n\tprivate static final String MODULE_NAME = \"naver\";\r\n\t\r\n\tprivate static final String API_KEY;\r\n\tprivate static final String SECRET_KEY;\r\n\tprivate static final String CALLBACK_URL;\r\n\t\r\n\tstatic\r\n\t{\r\n\t\tApiKeyBean apiKeyBean = getApiKeyBean(MODULE_NAME);\r\n\t\t\r\n\t\tAPI_KEY = apiKeyBean.getApi();\r\n\t\tSECRET_KEY = apiKeyBean.getSecret();\r\n\t\tCALLBACK_URL = apiKeyBean.getCallback();\r\n\t}\r\n\t\r\n\tprivate static final ServiceBuilderOAuth20 SERVICE_BUILDER = new ServiceBuilder(API_KEY).apiSecret(SECRET_KEY).callback(CALLBACK_URL);\r\n\t\r\n\tprivate static final NaverAuthModule INSTANCE = new NaverAuthModule(SERVICE_BUILDER);\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param serviceBuilder: [ServiceBuilderOAuth20] API 서비스 빌더\r\n\t */\r\n\tprivate NaverAuthModule(ServiceBuilderOAuth20 serviceBuilder)\r\n\t{\r\n\t\tsuper(serviceBuilder);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인스턴스 반환 메서드\r\n\t *\r\n\t * @return [NaverAuthModule] 인스턴스\r\n\t */\r\n\tpublic static NaverAuthModule getInstance()\r\n\t{\r\n\t\treturn INSTANCE;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 유저 정보 객체 반환 메서드\r\n\t *\r\n\t * @param body: [String] OAuth 응답 내용\r\n\t *\r\n\t * @return [UserInfoBean] 유저 정보 객체\r\n\t *\r\n\t * @throws JsonProcessingException JSON 파싱 예외\r\n\t */\r\n\t@Override\r\n\tpublic UserInfoBean getUserInfoBean(String body) throws JsonProcessingException\r\n\t{\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(body);\r\n\t\t\r\n\t\tString email = node.get(\"response\").get(\"email\") == null ? \"미동의\" : node.get(\"response\").get(\"email\").textValue();\r\n\t\tString name = node.get(\"response\").get(\"name\") == null ? \"미동의\" : node.get(\"response\").get(\"name\").textValue();\r\n\t\tString profile_image = node.get(\"response\").get(\"profile_image\") == null ? \"/oauth2/assets/images/logo.png\" : node.get(\"response\").get(\"profile_image\").textValue();\r\n\t\t\r\n\t\treturn new UserInfoBean(email, name, profile_image, MODULE_NAME);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 연동 해제 결과 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [boolean] 연동 해제 결과\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\t@Override\r\n\tpublic boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getAccessTokenEndpoint());\r\n\t\toAuthRequest.addQuerystringParameter(\"client_id\", API_KEY);\r\n\t\toAuthRequest.addQuerystringParameter(\"client_secret\", SECRET_KEY);\r\n\t\toAuthRequest.addQuerystringParameter(\"access_token\", access);\r\n\t\toAuthRequest.addQuerystringParameter(\"grant_type\", \"delete\");\r\n\t\toAuthRequest.addQuerystringParameter(\"service_provider\", \"NAVER\");\r\n\t\t\r\n\t\tservice.signRequest(access, oAuthRequest);\r\n\t\t\r\n\t\tResponse response = service.execute(oAuthRequest);\r\n\t\t\r\n\t\treturn response.isSuccessful();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정보 제공 동의 갱신 URL 반환 메서드\r\n\t *\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [String] 정보 제공 동의 갱신 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getUpdateAuthorizationUrl(String state)\r\n\t{\r\n\t\tHashMap<String, String> params = new HashMap<>();\r\n\t\tparams.put(\"state\", state);\r\n\t\tparams.put(\"auth_type\", \"reprompt\");\r\n\t\t\r\n\t\treturn service.getAuthorizationUrl(params);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 접근 토큰 요청 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getAccessTokenEndpoint()\r\n\t{\r\n\t\treturn \"https://nid.naver.com/oauth2.0/token\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 인증 API 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 인증 API 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getAuthorizationBaseUrl()\r\n\t{\r\n\t\treturn \"https://nid.naver.com/oauth2.0/authorize\";\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 사용자 정보 요청 URL\r\n\t */\r\n\t@Override\r\n\tprotected String getUserInfoEndPoint()\r\n\t{\r\n\t\treturn \"https://openapi.naver.com/v1/nid/me\";\r\n\t}\r\n}\r\n```\r\n\r\n정리한 전체 코드는 위와 같다.\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\n이로써 네이버 인증 모듈 구현이 완료됐다. 현재까지는 개발 중 단계라 정해진 아이디로만 사용할 수 있다. API 설정에서 테스트 계정을 등록해야 해당 계정으로 로그인 테스트가 가능하다. 심사 이후 애플리케이션이 승인되면 모든 아이디에서 로그인이 가능하다.","url":["2021-10-22-oauth2-java-server-4","2021","10","22","oauth2-java-server-4"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 3. scribeJAVA로 OAuth2.0 인증 모듈 구현하기","excerpt":"OAuth 라이브러리인 scribeJAVA를 통해 인증 모듈을 구현해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-20T01:26:40","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","Jersey"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-20-oauth2-java-server-3.md","content":"\r\n# 개요\r\n\r\nOAuth 라이브러리인 scribeJAVA를 통해 인증 모듈을 구현해보자.\r\n\r\n\r\n\r\n\r\n\r\n# OAuth 인증 모듈 구현하기\r\n\r\n이전 장에서도 언급했듯이, OAuth 인증 모듈은 그 공통된 특성으로 인해 추상 객체가 적합하다.\r\n\r\nscribeJAVA 모듈을 사용하여 추상 객체를 구현한다.\r\n\r\n\r\n\r\n## scribeJAVA 적용하기\r\n\r\n프로젝트에 scribeJAVA를 적용해보자.\r\n\r\n``` groovy\r\nimplementation group: 'com.github.scribejava', name: 'scribejava-apis', version: '8.3.1'\r\n```\r\n\r\n`build.gradle`의 dependencies에 위 의존성을 추가하는 것으로 scribeJAVA를 적용할 수 있다.\r\n\r\n\r\n\r\n## scribeJAVA 사용하기\r\n\r\n본격적으로 scribeJAVA를 사용해보자.\r\n\r\nscribeJAVA는 `OAuth20Service`라는 객체를 중심으로 동작한다. `OAuth20Service` 객체를 통해 아래의 로직을 수행할 수 있다.\r\n\r\n* 플랫폼 로그인 URL 생성\r\n* 인가 코드를 Access, Refresh Token으로 교환\r\n* Refresh Token을 통해 Access Token 갱신\r\n* 기타 OAuth 관련 요청 생성\r\n\r\n즉, OAuth 인증에 있어서 핵심이 되는 동작은 모두 이 `OAuth20Service` 객체를 중심으로 이루어진다.\r\n\r\n\r\n### OAuth20Service 객체 생성하기\r\n\r\n`OAuth20Service` 객체를 생성한다. 필요한 요소는 아래와 같다.\r\n\r\n|      구분      |     필수 여부     |           내용           |\r\n| :------------: | :---------------: | :----------------------: |\r\n|    API Key     |         Y         |          API 키          |\r\n| API Secret Key |         Y         |      API 시크릿 키       |\r\n|  Callback URL  |         Y         | 로그인 결과를 반환할 URL |\r\n|     Scope      | N (일부 플랫폼 Y) |           권한           |\r\n\r\nAPI Key, API Secret Key, Callback URL은 기본적으로 반드시 필요하며, 몇몇 플랫폼의 경우 Scope도 필수 사양으로 지정하는 경우가 있다. 이 프로젝트에 적용할 플랫폼들 중 Google이 그렇다. 구글은 후술할 플랫폼 로그인 URL 생성 시 Scope를 지정하지 않으면 오류를 출력한다.\r\n\r\nAPI Key, API Secret Key는 각 플랫폼에 OAuth 서비스 등록 시 부여해주며, Callback URL은 본인이 직접 정해서 입력하면 된다. 등록되지 않은 Callback URL로 로그인을 수행하면 오류가 출력된다. Callback URL은 여러개를 지정할 수 있다.\r\n\r\n> <b class=\"orange-600\">Callback URL의 등록 이유</b>  \r\n> Callback URL이 사전에 등록된 URL이 아닐경우 오류가 뜨는 이유는 보안 때문이다. 플랫폼 로그인 URL은 Callback URL이 URL 파라미터 형태로 입력되어있어서 탈취 및 변조가 매우 간단하다. 이러한 상황에서 Callback URL의 적절한 검증을 수행하지 않는다면 Callback URL을 임의 URL로 변경하여 code 혹은 Access Token을 탈취할 수 있게 된다.\r\n\r\n각 플랫폼 별 OAuth 서비스를 등록하는 방법은 추후에 다루고, 일단 이런 부가적인 부분들은 준비가 됐다고 가정한다.\r\n\r\n``` java\r\nOAuth20Service service = new ServiceBuilder(\"{API_KEY}\").apiSecret(\"{SECRET_KEY}\").callback(\"{CALLBACK_URL}\").build(this);\r\n```\r\n\r\n이와 같이 생성할 수 있다. `build(this)`에서 `this`는 `DefaultApi20` 객체다. 아래는 `OAuth20Service` 객체의 메서드와 그 기능들이다.\r\n\r\n|         구분          |             내용              |\r\n| :-------------------: | :---------------------------: |\r\n| `getAuthorizationUrl` | 플랫폼 로그인 URL 반환 메서드 |\r\n|   `getAccessToken`    | OAuth2AccessToken 반환 메서드 |\r\n|     `signRequest`     |    OAuth 요청 등록 메서드     |\r\n|       `execute`       |    등록된 요청 수행 메서드    |\r\n\r\n이 프로젝트에선 위 4가지 용도만 알아도 무방하다.\r\n\r\n\r\n\r\n\r\n## AuthModule 생성하기\r\n\r\n이제 본격적으로 모듈 객체를 구현해보자. 인증 모듈은 반드시 `DefaultApi20`을 상속받아 구현해야한다.\r\n\r\n``` java\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n\t// 구현 예정\r\n}\r\n```\r\n\r\n`DefaultApi20` 추상 객체는 두 개의 추상 메서드를 가지고 있다. 즉, 이를 상속하는 `AuthModule`는 이 두 메서드를 구현해야할 책임이 있다.\r\n\r\n* `getAccessTokenEndpoint` - 접근 토큰 요청 URL 반환 메서드\r\n* `getAuthorizationBaseUrl` - 인증 URL 반환 메서드\r\n\r\n하지만 `AuthModule` 역시 추상 객체이므로, 이를 상속받아 사용할 하위 플랫폼 인증 모듈에게 이 책임을 위임할 수 있다. 즉, `DefaultApi20`의 추상 메서드는 `AuthModule`에서 구현하지 않고 이를 상속하는 하위 플랫폼 인증 모듈에서 구현할 것이다.\r\n\r\n인증 모듈 추상 객체는 위와 같은 형태를 가진다. NAVER, Google 등 플랫폼별 인증 모듈은 위 `AuthModule`을 상속받아 사용할 것이다. 인증 모듈의 핵심 동작은 대부분 `OAuth20Service` 객체로부터 이루어지니, `AuthModule`을 상속할 때 반드시 관련 객체를 받도록 명시하는 것이 좋아보인다.\r\n\r\n``` java\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n    protected OAuth20Service service;\r\n\t\r\n\t@Getter\r\n\tprotected String unique;\r\n\r\n    protected AuthModule(ServiceBuilderOAuth20 serviceBuilder, String unique)\r\n\t{\r\n\t\tservice = serviceBuilder.build(this);\r\n\t\t\r\n\t\tthis.unique = unique;\r\n\t}\r\n}\r\n```\r\n\r\n|      구분      |       데이터 형식       |                                  내용                                   |\r\n| :------------: | :---------------------: | :---------------------------------------------------------------------: |\r\n| serviceBuilder | `ServiceBuilderOAuth20` |                      `OAuth20Service` 객체의 빌더                       |\r\n|     unique     |        `String`         | 인증 모듈의 고유값. 플랫폼의 소문자 표기와 동일 (ex. NAVER -> naver 등) |\r\n\r\n생성자와 멤버 변수를 위와 같이 지정한다. 전부 `protected` 접근 제어자를 가지므로, `AuthModule`을 상속받은 객체에서만 생성자를 사용할 수 있으며, `service`, `unique` 파라미터 역시 마찬가지다.\r\n\r\n`ServiceBuilderOAuth20`를 인수로 할당받아 생성자에서 `OAuth20Service`로 빌드하여 멤버 변수 `service`에 할당한다. `AuthModule` 상속받은 객체의 어느 곳에서든 `service`와 `unique`에 접근할 수 있다.\r\n\r\n이 모듈에 기본적인 로직을 작성하고, 플랫폼마다 구현이 모두 다를 경우, 추상 메서드를 선언하여 이를 상속받는 객체가 이를 직접 구현하도록 위임한다.\r\n\r\n\r\n### 인증 URL 반환 메서드\r\n\r\nscribeJAVA를 통해 인증 URL 반환 메서드를 구현해보자. 예를 들어, 네이버 아이디로 로그인 버튼을 클릭하면 네이버 로그인 창이 뜰 것이다. 이 과정은 앞선 예시와 같은 플랫폼 로그인 창의 URL을 생성하는 것이다.\r\n\r\n`service`의 `getAuthorizationUrl` 메서드를 사용하는 것만으로 간단히 구현할 수 있다. `ServiceBuilderOAuth20`에 입력했던 API Key, Secret Key, Callback URL을 토대로 플랫폼 인증 URL을 생성하여 반환한다.\r\n\r\n``` java\r\npublic String getAuthorizationUrl(String state)\r\n{\r\n\treturn service.getAuthorizationUrl(state);\r\n}\r\n```\r\n\r\n`getAuthorizationBaseUrl`의 반환 URL을 기준으로 생성한다.\r\n\r\n인수인 `state`는 고유 상태값으로, 서버에서 임의의 UUID를 하나 생성해서 사용한다. 이는 보안을 위한 세션 체크용으로 사용하는 값이다.\r\n\r\n\r\n### 접근 토큰 반환 메서드\r\n\r\n이번엔 `OAuth2AccessToken` 접근 토큰 객체를 반환하는 메서드를 구현해보자. `OAuth2AccessToken`는 Access, Refresh Token. 토큰 종류, 유효시간을 가지는 scribeJAVA의 객체다.\r\n\r\n``` java\r\npublic OAuth2AccessToken getAccessToken(String code) throws IOException, ExecutionException, InterruptedException\r\n{\r\n    return service.getAccessToken(code);\r\n}\r\n```\r\n\r\n마찬가지로 `service`의 `getAccessToken` 메서드를 사용하여 간단히 구현할 수 있다. 인수인 `code`를 Service Provider에 전달하면, Access, Refresh Token을 제공한다.\r\n\r\n\r\n### 접근 토큰 갱신 및 반환 메서드\r\n\r\nAccess Token은 보안을 위해 만료시간이 굉장히 짧거나 세션 만료 시 같이 만료되는 것이 보통이다. 이 경우 원래대로라면 다시 인증을 받아야하고, 경우에 따라 사용자에게 플랫폼 로그인 수행을 다시 요구할 수도 있다.\r\n\r\n대부분의 OAuth 플랫폼은 인증 시 Access Token과 함께 Refresh Token을 같이 제공한다.\r\n\r\n|     구분      |   만료시간    | 인증 가능 여부 |                                               내용                                               |\r\n| :-----------: | :-----------: | :------------: | :----------------------------------------------------------------------------------------------: |\r\n| Access Token  | 짧거나 일시적 |      가능      |   인증을 담당하는 토큰. Access Token 존재 자체만으로 사용자가 인증 정보를 제공한다고 가정한다.   |\r\n| Refresh Token | 길거나 영구적 |     불가능     | Access Token을 재발급하는 토큰. Refresh Token 자체만으론 재발급 외의 유의미한 작업이 불가능하다. |\r\n\r\n두 토큰의 차이는 위와 같다.\r\n\r\nscribeJAVA에서 Refresh Token으로 Access Token을 재발급 받아보자.\r\n\r\n``` java\r\npublic OAuth2AccessToken getRefreshAccessToken(String refresh) throws IOException\r\n{\r\n\tHashMap<String, String> params = new HashMap<>();\r\n\tparams.put(\"client_id\", service.getApiKey());\r\n\tparams.put(\"client_secret\", service.getApiSecret());\r\n\tparams.put(\"refresh_token\", refresh);\r\n\t\r\n\tStringBuilder builder = new StringBuilder();\r\n\t\r\n\tfor (Map.Entry<String, String> param : params.entrySet())\r\n\t{\r\n\t\tbuilder.append(\"&\").append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8)).append(\"=\").append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\r\n\t}\r\n\t\r\n\tbyte[] paramBytes = builder.toString().getBytes(StandardCharsets.UTF_8);\r\n\t\r\n\tURL url = new URL(getRefreshTokenEndpoint());\r\n\t\r\n\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\tconnection.setRequestMethod(\"POST\");\r\n\tconnection.setDoOutput(true);\r\n\tconnection.getOutputStream().write(paramBytes);\r\n\t\r\n\tBufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\r\n\t\r\n\tStringBuilder responseBuilder = new StringBuilder();\r\n\tString temp;\r\n\t\r\n\twhile ((temp = reader.readLine()) != null)\r\n\t{\r\n\t\tresponseBuilder.append(temp);\r\n\t}\r\n\t\r\n\treader.close();\r\n\t\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tJsonNode node = mapper.readTree(responseBuilder.toString());\r\n\t\r\n\tString access_token = node.get(\"access_token\").textValue();\r\n\tString token_type = node.get(\"token_type\").textValue();\r\n\tint expires_in = node.get(\"expires_in\").intValue();\r\n\t\r\n\treturn new OAuth2AccessToken(access_token, token_type, expires_in, null, null, responseBuilder.toString());\r\n}\r\n\r\n@Override\r\npublic String getRefreshTokenEndpoint()\r\n{\r\n\treturn Util.builder(getAccessTokenEndpoint(), \"?grant_type=refresh_token\");\r\n}\r\n```\r\n\r\nAccess Token 재발급 코드는 위와 같다. 원래 `service.refreshAccessToken()` 메서드가 있긴 한데, `getRefreshTokenEndpoint` 처리가 플랫폼별로 다른건지, 제대로 동작이 안 되는 것 같다. 필자는 그냥 `HttpURLConnection`을 활용하여 OAuth2.0 스펙에 맞게끔 요청을 설계했다.\r\n\r\n`getRefreshTokenEndpoint` 메서드는 Refresh Token 관련 작업을 수행할 때 베이스가 되는 URL을 반환하는 메서드다. `getAccessTokenEndpoint` URL 뒤에 `?grant_type=refresh_token` 파라미터를 붙여 반환한다.\r\n\r\n`getRefreshTokenEndpoint`이 반환하는 URL을 기준삼아 `client_id`, `client_secret`, `refresh_token`을 파라미터로 담아 전송하여 응답을 받고, 여기서 필요한 내용을 추출하여 `OAuth2AccessToken` 객체를 생성하여 반환한다.\r\n\r\n\r\n### 사용자 정보 응답 반환 메서드\r\n\r\nAccess Token을 성공적으로 받아왔다면, 이를 통해 사용자 정보를 불러올 수 있다.\r\n\r\n``` java\r\npublic Response getUserInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n{\r\n\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getUserInfoEndPoint());\r\n\tservice.signRequest(access, oAuthRequest);\r\n\t\r\n\treturn service.execute(oAuthRequest);\r\n}\r\n\r\nabstract protected String getUserInfoEndPoint();\r\n\t\r\nabstract public UserInfoBean getUserInfoBean(String body) throws JsonProcessingException;\r\n```\r\n\r\n총 세 가지 메서드를 정의해야하는데, 하나는 직접 구현이고 나머지 두 개는 추상 메서드다.\r\n\r\n`getUserInfo` 메서드는 Access Token을 활용하여 해당 플랫폼의 UserInfo API로 요청을 보내 응답을 반환한다.\r\n\r\n`OAuthRequest` 객체를 선언하여 요청 메서드와 대상 URL을 지정한다. 이후 `service.signRequest`를 통해 `service`에 요청을 등록하고, `service.execute`로 해당 요청을 수행한다.\r\n\r\n`getUserInfoEndPoint` 메서드는 각 플랫폼의 UserInfo API URL을 반환하는 추상 메서드로, 플랫폼마다 URL이 다르기 때문에 추상 객체로 선언하여 하위 플랫폼 인증 모듈에게 구현 책임을 위임한다.\r\n\r\n`getUserInfoBean`는 `getUserInfo`의 응답을 받아 `UserInfoBean` DTO로 변환하여 이를 반환하는 추상 메서드다. 참고로 `UserInfoBean`은 scribeJAVA에 포함된 것이 아니라, 직접 작성한 DTO 객체다.\r\n\r\n플랫폼마다 사용자 정보의 응답값이 다르기 때문에, 이를 적절히 대응하고 값을 반환하고자 설계된 메서드다. 이 역시 하위 플랫폼 인증 모듈에게 구현을 위임한다.\r\n\r\n\r\n### 연동 해제 결과 반환 메서드\r\n\r\n플랫폼으로부터 완전히 연동을 해제하는 메서드가 필요하다.\r\n\r\n이는 단순히 로그아웃이 아니라, 플랫폼과 해당 사용자의 연결을 완전히 파기한다. 이 과정에서 사용자의 관련 데이터 및 정보 제공 동의 이력 역시 같이 파기된다.\r\n\r\n연동 해제 후 다시 로그인을 하게 되면, 처음 로그인을 수행하는 것 처럼 약관과 정보 제공 동의를 다시 선택해야한다.\r\n\r\n``` java\r\nabstract public boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException;\r\n```\r\n\r\n연동 해제의 경우 OAuth의 범주에선 살짝 벗어나있어서, 이 역시도 동일한 인터페이스를 가지진 않는다. 각 플랫폼마다의 구현이 천차만별이므로 추상 메서드로 정의한다.\r\n\r\n\r\n### 정보 제공 동의 갱신 URL 반환 메서드\r\n\r\n서비스를 운영하다보면 사용자에게 요구할 정보가 변경되기도 한다.\r\n\r\n만약 한참 잘 운영하다가 사용자에게 추가적인 정보를 받아야만 한다면? 정보를 호출해도 동의 내역 자체가 없으니 관련 정보는 얻을 수조차 없다.\r\n\r\n이러한 상황에 대비해 정보 제공 동의를 갱신하는 기능이 필요하다.\r\n\r\n``` java\r\nabstract public String getUpdateAuthorizationUrl(String state);\r\n```\r\n\r\n정보 제공 동의 갱신 역시 플랫폼마다 천차만별로 조금씩 다른 것 같다. 마찬가지로 추상 메서드로 정의하자.\r\n\r\n\r\n### API 객체 반환 메서드\r\n\r\n마지막으로 scribeJAVA와 직접적인 관련은 없지만, API 관련 요소를 불러오기위한 메서드가 필요하다.\r\n\r\nOAuth2.0을 사용하기 위해 필요한 3가지 요소는 API Key, API Secret Key, Callback URL이 필요하다. 이를 하드코딩해서 코드 안에 녹이는 건 그리 좋은 방법은 아니다.\r\n\r\n플랫폼별 API 요소를 `.properties` 파일로 관리하여 `WEB-INF/` 아래에서 관리할 것이다.\r\n\r\n> <b class=\"orange-400\">WEB-INF의 특별함</b>  \r\n> Tomcat의 `WEB-INF`는 조금 특별하다. 기본적으로 대상 경로 아래의 모든 폴더 및 파일은 웹 형태로 접근이 가능하지만, `WEB-INF` 아래에 위치하는 폴더 및 파일은 배포 대상에서 제외되므로 접근할 수 없다. 하지만 파일 시스템엔 여전히 존재하고 있으므로, 이에 구애받지 않는 JAVA 등 Backend에서의 접근엔 지장이 없다.  \r\n> API 키, 암호화 키 등 보안에 웹 서버 운영에 필요하면서도 각별한 보안이 요구되는 파일은 `WEB-INF` 아래에 관리하는 것이 좋다.\r\n\r\n이렇게 관리하고 `gitignore`에서 각 플랫폼의 설정파일을 제외하면 GitHub에 올려도 해당 파일을 제외하고 올린다. 따라서 이렇게 코드를 오픈해도 API 유출을 막을 수 있다.\r\n\r\n코드는 아래와 같다.\r\n\r\n``` java\r\nprotected static ApiKeyBean getApiKeyBean(String platform)\r\n{\r\n\tApiKeyBean apiKeyBean;\r\n\tapiKeyBean = new ApiKeyBean();\r\n\t\r\n\t// API 키 획득 시도\r\n\ttry\r\n\t{\r\n\t\tHashMap<String, String> map = Util.getProperties(platform);\r\n\t\t\r\n\t\tapiKeyBean.setApi(map.get(\"api\"));\r\n\t\tapiKeyBean.setSecret(map.get(\"secret\"));\r\n\t\tapiKeyBean.setCallback(map.get(\"callback\"));\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t}\r\n\t\r\n\treturn apiKeyBean;\r\n}\r\n```\r\n\r\n``` java\r\n@Getter\r\n@Setter\r\npublic class ApiKeyBean\r\n{\r\n\t// API 키\r\n\tprivate String api;\r\n\t\r\n\t// API SECRET 키\r\n\tprivate String secret;\r\n\t\r\n\t// 콜백 URL\r\n\tprivate String callback;\r\n}\r\n```\r\n\r\n`ApiKeyBean`은 직접 설계한 객체로, 위 코드와 같다. `lombok`이 적용되어 있다.\r\n\r\nJAVA는 `.properties` 파일을 읽어 key-value 형태의 HashMap으로 변환해주는 기능이 있다.\r\n\r\n``` properties\r\napi={API_KEY}\r\nsecret={SECRET_KEY}\r\ncallback={CALLBACK_URL}\r\n```\r\n\r\n설정 파일은 위와 같다. 이 메서드를 활용하여 각 플랫폼별 API 설정파일을 불러오도록 구성한다.\r\n\r\n\r\n\r\n## AuthModule 전체 코드\r\n\r\n``` java\r\npackage oauth.account.module;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.github.scribejava.core.builder.ServiceBuilderOAuth20;\r\nimport com.github.scribejava.core.builder.api.DefaultApi20;\r\nimport com.github.scribejava.core.model.OAuth2AccessToken;\r\nimport com.github.scribejava.core.model.OAuthRequest;\r\nimport com.github.scribejava.core.model.Response;\r\nimport com.github.scribejava.core.model.Verb;\r\nimport com.github.scribejava.core.oauth.AccessTokenRequestParams;\r\nimport com.github.scribejava.core.oauth.OAuth20Service;\r\nimport global.module.Util;\r\nimport lombok.Getter;\r\nimport oauth.account.bean.ApiKeyBean;\r\nimport oauth.account.bean.UserInfoBean;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URL;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n/**\r\n * 인증 모듈 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 23:30:47\r\n */\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n\tprotected OAuth20Service service;\r\n\t\r\n\t@Getter\r\n\tprotected String unique;\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param serviceBuilder: [ServiceBuilderOAuth20] API 서비스 빌더\r\n\t * @param unique: [String] 유니크 키\r\n\t */\r\n\tprotected AuthModule(ServiceBuilderOAuth20 serviceBuilder, String unique)\r\n\t{\r\n\t\tservice = serviceBuilder.build(this);\r\n\t\t\r\n\t\tthis.unique = unique;\r\n\t}\r\n\t\r\n\tabstract protected String getUserInfoEndPoint();\r\n\t\r\n\tabstract public UserInfoBean getUserInfoBean(String body) throws JsonProcessingException;\r\n\t\r\n\tabstract public boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException;\r\n\t\r\n\tabstract public String getUpdateAuthorizationUrl(String state);\r\n\t\r\n\t/**\r\n\t * 인증 URL 반환 메서드\r\n\t *\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [String] 인증 URL\r\n\t */\r\n\tpublic String getAuthorizationUrl(String state)\r\n\t{\r\n\t\treturn service.getAuthorizationUrl(state);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param code: [String] 인증 코드\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getAccessToken(String code) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\treturn service.getAccessToken(code);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param params: [AccessTokenRequestParams] AccessTokenRequestParams 객체\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getAccessToken(AccessTokenRequestParams params) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\treturn service.getAccessToken(params);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 갱신 및 반환 메서드\r\n\t *\r\n\t * @param refresh: [String] 리프레쉬 토큰\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getRefreshAccessToken(String refresh) throws IOException\r\n\t{\r\n\t\tHashMap<String, String> params = new HashMap<>();\r\n\t\tparams.put(\"client_id\", service.getApiKey());\r\n\t\tparams.put(\"client_secret\", service.getApiSecret());\r\n\t\tparams.put(\"refresh_token\", refresh);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (Map.Entry<String, String> param : params.entrySet())\r\n\t\t{\r\n\t\t\tbuilder.append(\"&\").append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8)).append(\"=\").append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\r\n\t\t}\r\n\t\t\r\n\t\tbyte[] paramBytes = builder.toString().getBytes(StandardCharsets.UTF_8);\r\n\t\t\r\n\t\tURL url = new URL(getRefreshTokenEndpoint());\r\n\t\t\r\n\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\t\tconnection.setRequestMethod(\"POST\");\r\n\t\tconnection.setDoOutput(true);\r\n\t\tconnection.getOutputStream().write(paramBytes);\r\n\t\t\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\r\n\t\t\r\n\t\tStringBuilder responseBuilder = new StringBuilder();\r\n\t\tString temp;\r\n\t\t\r\n\t\twhile ((temp = reader.readLine()) != null)\r\n\t\t{\r\n\t\t\tresponseBuilder.append(temp);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t\t\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(responseBuilder.toString());\r\n\t\t\r\n\t\tString access_token = node.get(\"access_token\").textValue();\r\n\t\tString token_type = node.get(\"token_type\").textValue();\r\n\t\tint expires_in = node.get(\"expires_in\").intValue();\r\n\t\t\r\n\t\treturn new OAuth2AccessToken(access_token, token_type, expires_in, refresh, null, responseBuilder.toString());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 응답 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [Response] 사용자 정보 응답\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic Response getUserInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getUserInfoEndPoint());\r\n\t\tservice.signRequest(access, oAuthRequest);\r\n\t\t\r\n\t\treturn service.execute(oAuthRequest);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 재발급 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 접근 토큰 재발급 요청 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getRefreshTokenEndpoint()\r\n\t{\r\n\t\treturn Util.builder(getAccessTokenEndpoint(), \"?grant_type=refresh_token\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * API 키 객체 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [ApiKeyBean] API 키 객체\r\n\t */\r\n\tprotected static ApiKeyBean getApiKeyBean(String platform)\r\n\t{\r\n\t\tApiKeyBean apiKeyBean;\r\n\t\tapiKeyBean = new ApiKeyBean();\r\n\t\t\r\n\t\t// API 키 획득 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tHashMap<String, String> map = Util.getProperties(platform);\r\n\t\t\t\r\n\t\t\tapiKeyBean.setApi(map.get(\"api\"));\r\n\t\t\tapiKeyBean.setSecret(map.get(\"secret\"));\r\n\t\t\tapiKeyBean.setCallback(map.get(\"callback\"));\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\treturn apiKeyBean;\r\n\t}\r\n}\r\n```\r\n\r\n전체 소스는 위와 같다.\r\n\r\n중간에 한 번씩 사용되는 `Util` 객체는 해당 프로젝트에서 범용적으로 사용되는 메서드를 모아놓은 공통 모듈이다.\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\nscribeJAVA를 통해 인증 모듈의 원형이되는 추상 객체를 구현했다. 해당 모듈을 토대로 각 플랫폼별 인증 모듈을 확장하여 개발할 수 있을 것이다.\r\n\r\n다음 장에서는 본격적으로 플랫폼별 OAuth 서비스 신청과 인증 모듈 구현에 대해 다룬다.","url":["2021-10-20-oauth2-java-server-3","2021","10","20","oauth2-java-server-3"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 2. 인증서버 설계하기","excerpt":"OAuth2.0 프로토콜에 대한 사전 지식도 얻었으니, 이를 통해 인증서버를 직접 구축해보자. Frontend, Backend 부분으로 나누어 웹 페이지를 통해 소셜 로그인을 수행하고, 직접 구현한 인증서버에서 이를 처리하는 시스템 일체를 구축하는 것이 궁극적인 목표다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T22:12:25","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-2.md","content":"\r\n# 개요\r\n\r\nOAuth2.0 프로토콜에 대한 사전 지식도 얻었으니, 이를 통해 인증서버를 직접 구축해보자.\r\n\r\nFrontend, Backend 부분으로 나누어 웹 페이지를 통해 <span class=\"red-400\">소셜 로그인을 수행</span>하고, 직접 구현한 <span class=\"red-400\">인증서버에서 이를 처리하는 시스템 일체를 구축</span>하는 것이 궁극적인 목표다.\r\n\r\n인증 서버의 인증 방식은 <span class=\"primary\">인가 코드 승인 (Authorization Code Grant)</span>을 취한다.\r\n\r\n# 제원\r\n\r\n웹 페이지인 Frontend와 API 통신의 주체가 되는 인증서버인 Backend로 나뉜다.\r\n\r\n## Backend\r\n\r\n<b class=\"large green-600\">💬 Language</b>\r\n\r\n* [![Java](http://img.shields.io/badge/java-v16.0.2-007396?logo=java&logoWidth=25)](https://www.java.com/ko/)\r\n\r\n<b class=\"large green-600\">🧱 Framework</b>\r\n\r\n* [![Gradle](https://img.shields.io/badge/gradle-02303A?logo=gradle&logoWidth=25)](https://gradle.org/)\r\n* ![jakarta.servlet-api](https://img.shields.io/badge/jakarta.servlet--api-v5.0.0-blue)\r\n* ![lombok](https://img.shields.io/badge/lombok-v1.18.20-blue)\r\n* ![jjwt](https://img.shields.io/badge/jjwt-v0.9.1-blue)\r\n* ![scribejava-apis](https://img.shields.io/badge/scribejava--apis-v8.3.1-blue)\r\n* ![jersey-server](https://img.shields.io/badge/jersey--server-v3.0.3-blue)\r\n* ![jersey-container-servlet](https://img.shields.io/badge/jersey--container--servlet-v3.0.3-blue)\r\n* ![jersey-hk2](https://img.shields.io/badge/jersey--hk2-v3.0.3-blue)\r\n* ![jersey-media-json-jackson](https://img.shields.io/badge/jersey--media--json--jackson-v3.0.3-blue)\r\n\r\n<b class=\"large green-600\">📦 Publish</b>\r\n\r\n* [![Tomcat](http://img.shields.io/badge/Tomcat-v10.0.12-F8DC75?logo=apachetomcat&logoWidth=25&logoColor=FFF)](http://tomcat.apache.org/)\r\n* [![Raspberry Pi](http://img.shields.io/badge/RaspberryPi-F00?logo=raspberrypi&logoWidth=25&logoColor=FFF)](https://www.raspberrypi.org/)\r\n\r\nJersey는 RESTful API 프레임워크, scribeJAVA는 OAuth 프레임워크다.\r\n\r\nJersey 3는 Servlet 5.0 최신 스펙인 `jakarta.*`을 사용한다. 때문에 이를 구현한 Tomcat 10을 사용한다. Tomcat 10 미만 혹은 `jakarta.*`을 구현하지 않는 등 <b class=\"red-600\">최신 서블릿 스펙을 사용할 수 없는 WAS의 경우 이 프로젝트는 배포할 수 없다.</b>\r\n\r\n## Frontend\r\n\r\n<b class=\"large green-600\">💬 Language</b>\r\n\r\n* [![HTML5](http://img.shields.io/badge/HTML5-E34F26?logo=html5&logoWidth=25&logoColor=FFF)](https://developer.mozilla.org/ko/docs/Web/HTML)\r\n* [![JavaScript](http://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoWidth=25&logoColor=000)](https://developer.mozilla.org/ko/docs/Web/JavaScript)\r\n* [![CSS3](http://img.shields.io/badge/CSS3-1572B6?logo=css3&logoWidth=25)](https://developer.mozilla.org/ko/docs/Web/CSS)\r\n\r\n<b class=\"large green-600\">🧱 Framework</b>\r\n\r\n* [![eslint](https://img.shields.io/badge/eslint-^7.32.0-4B32C3?logo=eslint&logoWidth=25)](https://eslint.org/)\r\n\r\n<b class=\"large green-600\">📦 Publish</b>\r\n\r\n* [![GitHub](http://img.shields.io/badge/GitHub%20Pages-000?logo=github&logoWidth=25&logoColor=FFF)](https://pages.github.com/)\r\n\r\n원래는 Raspberry Pi로 배포하고 있었으나, 굳이 그럴 필요가 없어서 GutHub Pages로 배포한다.\r\n\r\nFrontend는 단순히 인증 서버와의 API 통신 및 정보 표출 정도만 수행하므로, React 같은 복잡한 기술은 최대한 지양하고 최대한 기본 기능으로만 구성했다.\r\n\r\n# 구성\r\n\r\n인증서버는 크게 세 부분으로 나눌 수 있다.\r\n\r\n* `controller` - 지정한 URL의 요청을 받아 process에게 위임한다.\r\n* `process` - API의 동작을 수행하고, 응답을 생성한다\r\n* `module` - API 동작 수행에 필요한 모듈\r\n\r\n이는 패키지로 구분한다.\r\n\r\n## controller\r\n\r\nJersey 프레임워크는 `controller` 영역에서 동작한다.\r\n\r\n기존의 Servlet은 RESTful API를 설계하기위해 직접 구현해야할 부분이 존재한다.\r\n\r\nRESTful API를 효과적으로 설계하기 위해 Jersey 프레임워크를 사용한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137264829-4e703edf-e682-4793-a2b1-675056cba087.png)\r\n\r\ncontroller는 <span class=\"primary\">정의된 process로 요청을 전달하고, process가 반환하는 응답을 요청자에게 다시 전달</span>한다.\r\n\r\n* `/login`\r\n  * GET `/:platform` - 플랫폼별 인증 URL 반환 API\r\n  * PUT `/put` - 정보 제공 동의 갱신 URL 반환 API\r\n  * POST `/:platform` - 플랫폼별 로그인 API\r\n  * POST `/auto` - 자동 로그인 API\r\n\r\n* `/logout`\r\n  * POST `/` - 로그아웃 API\r\n\r\n* `/revoke`\r\n  * POST `/` - 연동 해제 API\r\n\r\n* `/userinfo`\r\n  * POST `/` - 사용자 정보 API\r\n\r\n해당 프로젝트에선 위 `controller`들이 구현될 것이다.\r\n\r\n## process\r\n\r\n`process`에선 실제 로직이 구현되는 영역이다. 이 때 필요하다면 `module`을 호출하기도 한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137265824-a2652f3c-c32f-42cf-9b5e-8f523530895e.png)\r\n\r\n`process`는 <span class=\"primary\">수행 결과를 정해진 형식의 JSON을 기반으로 응답 객체</span>를 만들어 `controller`로 반환한다.\r\n\r\n``` json\r\n{\r\n    flag: true,\r\n    title: \"success\",\r\n    message: \"test api response success\",\r\n    body: {\r\n        key1: \"value1\",\r\n        key2: true,\r\n        key3: 4932,\r\n        key4: [\r\n            \"A\",\r\n            \"B\",\r\n            \"C\"\r\n        ],\r\n        key5: 93.203\r\n    }\r\n}\r\n```\r\n\r\n| 파라미터 | 필수 여부 |                   데이터 형식                    |      내용      |\r\n| :------: | :-------: | :----------------------------------------------: | :------------: |\r\n|   flag   |     Y     |                    `boolean`                     | 응답 정상 여부 |\r\n|  title   |     Y     |                     `String`                     |   응답 제목    |\r\n| message  |     Y     |                     `String`                     |  응답 메세지   |\r\n|   body   |     Y     | `String \\| Number \\| boolean \\| Array \\| Object` | 응답 정상 여부 |\r\n\r\n응답 명세는 위와 같다.\r\n\r\n`process`는 GET, POST 등 HTTP Method에 따라 나누어 관리한다.\r\n\r\n## module\r\n\r\nmodule은 여러 `process`에서 <span class=\"primary\">반복적으로 사용되는 로직의 모듈화를 구현한 객체</span>다.\r\n\r\n이 중 핵심 기능인 OAuth의 인증을 처리하는 모듈은 scribeJAVA 기반으로 작성된다.\r\n\r\n로그인, 사용자 정보 요청 등 인증과 관련된 로직을 수행하는 `process`들은 모두 위 모듈을 호출하여 사용함으로써 중복 코드를 줄이고 유지보수성을 높인다.\r\n\r\n# OAuth 모듈\r\n\r\n이 프로젝트의 Backend에 가장 중요한 역할을 담당하는 모듈로, OAuth 인증을 구현한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137314562-675ee988-0dad-4937-93a1-73753c2afee4.png)\r\n\r\n요즘은 어느정도 규모있는 플랫폼이라면 OAuth 서비스를 제공한다. 플랫폼은 달라도 OAuth를 준수한다면 모두 공통된 요청 받아 공통된 응답을 제공할 것이다. 공통 프로토콜을 사용하므로, 인증 모듈 하나를 만들어 모든 인증을 거기서 처리하면 될 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137314573-599b1317-0e46-4698-ac65-04fef57933e8.png)\r\n\r\n하지만 문제가 하나 있다. 아무리 공통 프로토콜을 사용한다지만, <span class=\"red-400\">플랫폼마다 추가적인 파라미터 혹은 헤더를 요구</span>하기도 한다. 조건문을 떡칠한다면 모를까, 고작 인증 모듈 하나에서 플랫폼별 요구사항을 하나하나 처리하기엔 문제가 많다. 조건문을 통한 분기 역시 유지보수적인 측면에서 그리 좋은 방식은 아니다.\r\n\r\n<br />\r\n<br />\r\n\r\nOAuth는 객체라기보단 일종의 개념에 더 가깝다. 이렇게 추상적인 개념의 형태는 JAVA의 인터페이스 내지는 추상 객체가 적합하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137314582-cf0c24f7-5ad3-42f8-a7d7-de19e59c8582.png)\r\n\r\n인증 모듈의 경우, 몇몇 플랫폼의 특이 사항으로 인해 문제가 발생하니, 기본적으로는 <span class=\"blue-600\">인증 모듈의 공통 로직을 사용하되, 추가적인 요구를 하는 플랫폼에 한해 로직을 변경하는 것이 효율적</span>일 것이다. 따라서 인증 모듈은 인터페이스보단 추상 객체가 더 어울릴 것이다.\r\n\r\n이렇게 인증 추상 모듈을 하나 생성하고, 각 소셜 플랫폼마다 인증 모듈을 상속받아 구현하게끔 설계하면 될 것이다.\r\n\r\n문제가 없는 플랫폼은 기 선언된 인증 모듈의 메서드를 그대로 사용하고, <span class=\"blue-600\">추가 요구사항이 있는 플랫폼은 해당 플랫폼의 인증 모듈에서 메서드를 오버라이딩</span>하여 요구사항에 맞게 재설계한다.\r\n\r\n## 인증 모듈 기능\r\n\r\n구현해야할 기능은 아래와 같다.\r\n\r\n* 플랫폼 로그인 URL 생성 로직\r\n* 정보 제공 동의 갱신 URL 생성 로직\r\n* 서비스 로그인 로직 (인가코드 -> Access Token)\r\n* 자동 로그인 로직\r\n* 로그아웃 로직\r\n* 사용자 정보 호출 로직\r\n* 연동 해제 로직\r\n\r\n최소한 위 기능이 구현되어야한다.\r\n\r\n사용자 정보 호출의 경우, 플랫폼마다 주는 응답이 천차만별로 다르다.\r\n\r\n사용자 정보는 OAuth로 전달받은 Access Token으로 Service Provider에 정보를 요청하여 받을 수 있다. OAuth는 어디까지나 인증을 받기 위한 표준 프로토콜로, <span class=\"red-400\">인증 토큰을 통해 수행하는 부가적인 활동에 대해서는 별다른 제약이 없으므로</span>, Access Token 발급 이후의 API 요청 및 응답은 플랫폼마다 천차만별로 다르다.\r\n\r\n때문에 사용자 정보 호출 로직의 경우, OAuth 표준 프로토콜에 구애받지 않는다. 이에 대응하기 위해 추상 메서드로 선언하여 각 모듈에서 응답을 정제하여 반환하도록 강제하자.\r\n\r\n# 구조도\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137319720-28a6d25b-6128-4873-bbb4-b0e0f5cce847.png)\r\n\r\nOAuth 모듈을 사용하는 API의 구조를 도식화하면 위와 같다.\r\n\r\nJersey가 URL을 캐치하여 정해진 process로 전달한다. process는 인증을 수행하기 위해 해당 플랫폼의 OAuth 구현체를 호출하여 로직을 수행할 것이다. 이후 결과가 반환되어 사용자에게 전달되는 구조다.\r\n\r\n# 정리\r\n\r\n지금까지 인증 서버에 대한 설계를 진행했다. 다음 장엔 위 설계를 토대로 인증 서버를 본격적으로 구축해본다. 그 중에서도 scribeJAVA와 OAuth 인증 모듈에 대해 다룰 예정이다.\r\n\r\n구축 순서는 module -> process -> controller 순이다.\r\n\r\n가장 안쪽에 위치한 프로세스가 module이므로, module에서부터 바깥쪽으로 순차적으로 구현할 예정이다.","url":["2021-10-14-oauth2-java-server-2","2021","10","14","oauth2-java-server-2"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 1. OAuth2.0이란?","excerpt":"사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다. 이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다. 이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T00:56:31","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-1.md","content":"\r\n# 개요\r\n\r\n사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137170074-d678c0e1-d30a-4d38-91e5-543344e18ec3.png)\r\n\r\n이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다.\r\n\r\n이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.\r\n\r\n# OAuth\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137171256-3ca820ec-1435-4103-bc34-9c922832886c.png)\r\n\r\nOAuth는 Open Authentication의 약자로, 인증을 위한 표준 프로토콜이다.\r\n\r\n이전의 인증 방식은 사이트 혹은 애플리케이션에 직접 회원가입을 수행하여 내 정보를 제공하고, 비밀번호를 통해 인증하는 비밀번호 인증 방식을 취한다. 물론 이 비밀번호 인증 방식은 인터넷의 초창기부터 지금까지 사용하는 기법이지만, 그렇다고 문제가 아주 없는 것은 아니였다.\r\n\r\n* 서비스마다 운영되는 중구난방적인 인증 시스템\r\n* 사이트의 신뢰성 문제\r\n* 인터넷을 사용할수록 과적되는 인증 정보\r\n\r\nOAuth 이전에는 이렇다할 인증 표준이 존재하지 않았다. 표준이 없다보니 인증 시스템은 서비스마다 개성이 넘처흘렀다. 사이트마다 요구하는 정보, 방식이 천차만별로 다르니 사용자 입장에서는 매우 혼란스러울 것이다.\r\n\r\n그래도 이 점은 나름 사이트를 구분할 수 있는 일종의 척도(?)가 되기도 한다만, 더 큰 문제는 해당 사이트를 신뢰할만한 지표가 전혀 없다는 것이다. 내 정보를 왜 가져가는지, 어떻게 보관하는지 알 길이 없는 사용자들은 울며 겨자먹기로 서비스에게 내 정보를 제공하게 된다.\r\n\r\n이런 사이트들을 조금만 돌아다니면서 상호작용을 하다보면, 나도 모르는 새에 계정정보가 쌓여있을 것이다. 인증의 주체가 되는 \"나\"는 하나인데, 인증 표준의 부재로 인해 각 서비스마다 나 자신을 인증하기 위한 여러 방법을 소유하게되는 것이다.\r\n\r\n<br />\r\n\r\n이러한 비효율성을 타파하기 위해 Twitter 주도하에 인증 표준이 설립되었고, 이 것이 OAuth의 시초다. OAuth 라는 표준 프로토콜이 정의됨에 따라 각 서비스는 공통된 인터페이스로 사용자에게 인증을 요구할 수 있고, 사용자 역시 익숙하고 신뢰성있는 대형 플랫폼에 인증 정보를 입력하기 때문에 보안적인 측면은 물론, 절차 또한 간소화되는 이점을 가지게 된다.\r\n\r\nOAuth는 1.0을 시작으로, 1.0에 세션 고정 공격이라는 보안 취약점이 발견됨에 따라 현재는 2.0을 사용하고 있다.\r\n\r\n> <b class=\"orange-400\">OAuth1.0의 몰락</b>  \r\n> OAuth1.0은 <span class=\"primary\">세션 고정 공격</span>이라는 보안 취약점을 가지고 있다. 이를 해결하기 위해 OAuth2.0에서는 이러한 문제들이 해결되었으며, OAuth2.0은 OAuth1.0을 완전히 대체한다.\r\n\r\nOAuth2.0은 그 방식에 따라 4가지 방식으로 구분한다.\r\n\r\n이를 설명하기 앞서 OAuth에서 사용하는 키워드에 대해 알아보자\r\n\r\n|      키워드      |                             의미                             |\r\n| :--------------: | :----------------------------------------------------------: |\r\n|       User       |                            사용자                            |\r\n|     Consumer     |               OAuth를 제공하는 서비스 (웹 등)                |\r\n| Service Provider |                OAuth 서비스 제공자 (NAVER 등)                |\r\n|   Access Token   | Consumer가 Service Provider의 자원에 접근하기 위한 인증 코드 |\r\n|  Refresh Token   |             Access Token을 재발급하기 위한 코드              |\r\n\r\n아마 대부분 User의 범주에 속해있을 것이다. 여기서 궁극적으로 구축할 서비스는 Consumer가 된다.\r\n\r\n간혹 Service Provider는 인증 서버와 자원 서버로 분리해서 다루기도 한다.\r\n\r\nNAVER, Google과 같은 플랫폼은 Service Provider가 되며, 인증 절차를 통해 Access Token과 Refresh Token을 전달받게 된다.\r\n\r\n# OAuth Workflow\r\n\r\nOAuth2.0은 구현 방식에 따라 4가지 방식으로 구분된다.\r\n\r\n## 인가 코드 승인 (Authorization Code Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179813-de61fd8a-bbe6-4824-afdf-3652cde164bc.png)\r\n\r\n* 사용자가 Service Provider에 직접 인증을 수행\r\n* 인증에 성공하면 Consumer Frontend는 인가 코드를 전달받음\r\n* Consumer는 인가 코드를 Service Provider에 전달하여 Access, Refresh Token을 반환받음\r\n* Token 반환 이전에 인가 코드를 받는 과정이 추가되어 높은 수준의 보안을 제공함\r\n* Consumer의 Backend에서 Token 교환이 일어나므로 중간에 이를 탈취하기 어려움\r\n* 웹에서 사용되는 가장 보편적인 인증 형태로, 이 프로젝트 또한 인가 코드 승인 형태가 적용됨\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=code\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                내용                 |\r\n| :-----------: | :----------------------------: | :---------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> |  응답 타입으로, 값은 `code`로 고정  |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL            |\r\n|     state     |               N                |      임의로 생성한 고유 상태값      |\r\n|     scope     |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\ncode=dfnY865gHjUbnknt57yGV\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n```\r\n\r\n| 구분  |            내용             |\r\n| :---: | :-------------------------: |\r\n| code  |          인가 코드          |\r\n| state | 요청에서 전달한 고유 상태값 |\r\n\r\n`state`는 Consumer Backend에서 임의로 생성한 상태값으로, 통상 UUID를 하나 생성하여 사용한다.\r\n\r\n`code`와 입력했던 `state`가 반환된다. `code`를 통해 Service Provider에 요청하여 Access Token으로 교환할 수 있다.\r\n\r\n## 암시적 승인 (Implicit Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179833-fe688388-0d29-47c0-b4db-c4a42b26dccd.png)\r\n\r\n* 인가 코드 승인과 달리, 인증 성공 시 Consumer는 Token을 직접 전달받음\r\n* 각 플랫폼에서 제공되는 JavaScript SDK를 사용하여 구현\r\n* 인가 코드 승인에 비해 서버가 필요하지 않아 구현이 간단함\r\n* Token이 GET 방식으로 URL 파라미터에 담겨 전달되므로 보안에 취약하다.\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=token\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                 내용                 |\r\n| :-----------: | :----------------------------: | :----------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `token`으로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY  |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL             |\r\n|     state     |               N                |      임의로 생성한 고유 상태값       |\r\n|     scope     |               N                |              요청 권한               |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\n#access_token=kr40FkgksmGS92lffkGls\r\n&token_type=Bearer\r\n&expires_in=3600\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    state     |      요청에서 전달한 고유 상태값       |\r\n\r\n인가 코드 승인과 달리, 요청에 Access Token이 포함되어 전달된다.\r\n\r\n> <b class=\"orange-400\">파라미터가 왜 </b>`#`<b class=\"orange-400\">으로 시작하지?</b>  \r\n> `#`은 URI Fragment라는 식별자다. 해당 식별자는 URL 접근 시 서버에 전달되지 않기 때문에 보안적인 측면에서 이점을 가져가기 위한 조치다.\r\n\r\n## 리소스 소유자 암호 자격 승인 (Resource Owner Password Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179866-29962644-c0a7-42f8-a397-7b3b1c361082.png)\r\n\r\n* Service Provider에 ID, PW를 전달하여 Token을 전달받음\r\n* 보안 구조가 비밀번호 기반의 인증 뿐이므로 이를 구현하는 Consumer는 신뢰성이 매우 높아야 함\r\n\r\n``` input\r\nPOST /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=password\r\n&client_id=asj2y93bdjen3\r\n&username=username123\r\n&password=password123\r\n&scope=email,profile\r\n```\r\n\r\n|    구분    |           필수 여부            |                내용                 |\r\n| :--------: | :----------------------------: | :---------------------------------: |\r\n| grant_type | <span class=\"red-400\">Y</span> |  승인 타입으로, `password`로 고정   |\r\n| client_id  | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n|  username  | <span class=\"red-400\">Y</span> |               아이디                |\r\n|  password  | <span class=\"red-400\">Y</span> |              비밀번호               |\r\n|   scope    |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n    \"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n## 클라이언트 자격 승인 (Client Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179894-94e8f974-27cd-44b1-9c36-5e1d3dc69377.png)\r\n\r\n* 사용자가 Access Token을 외부 저장소에서 받아 인증하는 형식\r\n* 클라이언트 자체가 인증 수단이므로 절차가 매우 간소함\r\n* 통상 자기 자신의 정보만을 호출함\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=client_credentials\r\n&client_id=asj2y93bdjen3\r\n&client_secret=https://oauth2.example.com/callback\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                      내용                       |\r\n| :-----------: | :----------------------------: | :---------------------------------------------: |\r\n|  grant_type   | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `client_credentials`로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> |       Service Provider에서 제공한 API KEY       |\r\n| client_secret | <span class=\"red-400\">Y</span> |   Service Provider에서 제공한 API Secret KEY    |\r\n|     scope     |               N                |                    요청 권한                    |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n\t\"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n# 정리\r\n\r\n* OAuth2.0은 인증을 위한 표준 프로토콜으로, OAuth 프로토콜을 준수하는 서비스는 기본적으로 공통된 API를 사용해서 인증을 수행할 수 있다.\r\n* OAuth 프로토콜을 통해 인증 절차는 간소화하고, 보안 수준은 강화할 수 있다.\r\n* OAuth의 방식은 4가지로 구분되며, 보편적으로 인가 코드 승인 방식을 사용한다.\r\n* 암시적 승인은 Serverless 서비스나 앱에서 주로 사용된다.\r\n* 나머지 방식은 특수한 환경에서 사용된다.\r\n\r\n다음 장에서는 구축할 시스템의 구성에 대해 다룬다.\r\n\r\n# 참고\r\n\r\n* [IT위키 - OAuth](https://itwiki.kr/w/OAuth)\r\n* [Microsoft OAuth](https://docs.microsoft.com/ko-kr/azure/active-directory/develop/active-directory-v2-protocols)\r\n* [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)","url":["2021-10-14-oauth2-java-server-1","2021","10","14","oauth2-java-server-1"]}],"data":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 9. Jersey로 RESTful API 서비스 제공하기","excerpt":"이 장에서는 Jersey를 활용하여 RESTful API 서비스를 제공하는 방법에 대해 다룬다. 이 프로젝트는 Jersey를 통해 요청을 받아 응답하므로, 컨트롤러를 구성하기 이전에 Jersey에 대해 잠깐 다루고 넘어간다. 통상 JAVA 서버를 구축하는데 Spring 프레임워크를 많이 사용할 것이다. 그럼에도 굳이 Jersey를 선택하는 이유는 일단 내가 Spring을 잘 모른다. 그것도 그거지만, Spring에 비해 규모가 작고 설정이 간단해서 온전히 RESTful 서버를 구축하는데 집중할 수 있다. Spring 설정의 악랄함은 고사하고, 이 프로젝트의 특성 상 복잡한 로직이나 다채로운 기능을 요구하지 않는다. Spring의 방대한 규모를 온전히 쓰지 못 하므로 배보다 배꼽이 더 크다는 뜻이다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-25T00:12:58","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","Jersey"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-25-oauth2-java-server-9.md","content":"<h1 id=\"개요\">개요 <a href=\"#개요\">🔗</a></h1><p>이 장에서는 Jersey를 활용하여 RESTful API 서비스를 제공하는 방법에 대해 다룬다. 이 프로젝트는 Jersey를 통해 요청을 받아 응답하므로, 컨트롤러를 구성하기 이전에 Jersey에 대해 잠깐 다루고 넘어간다.</p>\n<p>통상 JAVA 서버를 구축하는데 Spring 프레임워크를 많이 사용할 것이다. 그럼에도 굳이 Jersey를 선택하는 이유는 일단 내가 Spring을 잘 모른다. 그것도 그거지만, Spring에 비해 <span class=\"blue-600\">규모가 작고 설정이 간단해서 온전히 RESTful 서버를 구축하는데 집중</span>할 수 있다. Spring 설정의 악랄함은 고사하고, 이 프로젝트의 특성 상 복잡한 로직이나 다채로운 기능을 요구하지 않는다. Spring의 방대한 규모를 온전히 쓰지 못 하므로 배보다 배꼽이 더 크다는 뜻이다.</p>\n<br />\n\n<p><code class=\"inline-code\">Tomcat</code>은 반드시 <span class=\"red-600\">10 이상으로 사용할 것</span>. 이전 장에서도 누누히 얘기했지만, <code class=\"inline-code\">Jersey 3.x</code>는 Servlet 5.0인 <code class=\"inline-code\">jakarta.*</code>만을 사용한다. Servlet 4.x 밑으로는 지원을 안 하므로, 아무리 스펙 상 올바른 요청을 전송해도 404만 죽어라 뜬다. Tomcat은 이를 버전 10부터 제공하니 주의하자. 내가 이 문제 때문에 거진 수 시간을 날렸다.</p>\n<blockquote>\n<p><b class=\"orange-400\">Servlet 5.0?</b><br>Servlet 5.0부터는 <code class=\"inline-code\">jakarta.*</code>이라는 패키지를 사용한다. 우리가 지금까지 사용했던 Servlet 4.x 이하는 <code class=\"inline-code\">javax.*</code> 패키지를 사용한다. 패키지가 달라지는 것 외에 사용 방법은 완전히 동일하다. <code class=\"inline-code\">javax.*</code>을 <code class=\"inline-code\">jakarta.*</code>로 변경하기만 해도 마이그레이션이 완료된다.</p>\n</blockquote>\n<h1 id=\"Jersey-3 설정하기\">Jersey 3 설정하기 <a href=\"#Jersey-3 설정하기\">🔗</a></h1><p>프로젝트에 Jersey 3을 설정해보자.</p>\n<h2 id=\"의존성-모듈 설치\">의존성 모듈 설치 <a href=\"#의존성-모듈 설치\">🔗</a></h2><p><code class=\"inline-code\">Gradle</code>을 기준으로 설명한다. <code class=\"inline-code\">build.gradle</code>의 dependencies에 아래와 같이 지정한다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>TXT</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-txt\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0>dependencies {</td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1>    // https://mvnrepository.com/artifact/jakarta.servlet/jakarta.servlet-api</td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    compileOnly group: 'jakarta.servlet', name: 'jakarta.servlet-api', version: '5.0.0'</td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    </td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    // https://mvnrepository.com/artifact/org.glassfish.jersey.core/jersey-server</td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    implementation group: 'org.glassfish.jersey.core', name: 'jersey-server', version: '3.0.3'</td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>    </td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>    // https://mvnrepository.com/artifact/org.glassfish.jersey.containers/jersey-container-servlet</td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    implementation group: 'org.glassfish.jersey.containers', name: 'jersey-container-servlet', version: '3.0.3'</td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>    </td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>    // https://mvnrepository.com/artifact/org.glassfish.jersey.inject/jersey-hk2</td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11>    implementation group: 'org.glassfish.jersey.inject', name: 'jersey-hk2', version: '3.0.3'</td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12>    </td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13>    // https://mvnrepository.com/artifact/org.glassfish.jersey.media/jersey-media-json-jackson</td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14>    implementation group: 'org.glassfish.jersey.media', name: 'jersey-media-json-jackson', version: '3.0.3'</td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>    // 다른 라이브러리들...</td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>}</td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<ul>\n<li><code class=\"inline-code\">jakarta.servlet-api</code> - Servlet 5.0</li>\n<li><code class=\"inline-code\">jersey-server</code> - Jersey 서버 코어 구현체</li>\n<li><code class=\"inline-code\">jersey-container-servlet</code> - Jersey의 Servlet 구현체</li>\n<li><code class=\"inline-code\">jersey-hk2</code> - HK2 InjectionManager 구현체</li>\n<li><code class=\"inline-code\">jersey-media-json-jackson</code> - Jersey의 응답 객체에 JSON 제공자를 Jackson과 연동하는 모듈</li>\n</ul>\n<p>각 라이브러리의 의미는 위와 같다. 이 중 <code class=\"inline-code\">jersey-media-json-jackson</code>은 플러그인으로, <span class=\"red-400\">JSON 형태로 응답하기 위해선 반드시 이 제공자 플러그인이 필요</span>하다. 그 밖에도 여러 유용한 플러그인이 있지만, 이 프로젝트에선 위 4개 정도만 있으면 Jersey를 사용할 수 있다.</p>\n<h2 id=\"Jersey-요청 URL 지정하기\">Jersey 요청 URL 지정하기 <a href=\"#Jersey-요청 URL 지정하기\">🔗</a></h2><p>Jersey의 요청 URL을 지정한다. 무슨 뜻이냐면, <span class=\"primary\">Jersey가 담당할 최상위 URL을 지정</span>한다는 의미다.</p>\n<p>예를 들어, <code class=\"inline-code\">/api</code>로 지정했다면 <code class=\"inline-code\">https://example.com/api</code>로 시작하는 요청은 일반적인 Servlet이 아닌 Jersey가 위임받게 된다.</p>\n<p>전통적인 방식으로 <code class=\"inline-code\">web.xml</code>에 지정하는 방법이 있지만, 다소 번거로운데다가 권장하지도 않는다. 우리는 서버 단계에서 이를 구현할 것이다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token annotation punctuation\">@ApplicationPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/api\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Application</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token comment\" data-tag=\"new\">// api 접두사 요청을 jersey가 담당</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>위와 같이 지정하면 된다. 클래스 하나 생성해서 <code class=\"inline-code\">Application</code> 상속시키면 된다. 이후 <code class=\"inline-code\">@ApplicationPath</code>에 원하는 경로 접두어를 지정하면 된다.</p>\n<p>위 설정은 <code class=\"inline-code\">/api</code>로 시작하는 경로를 Jersey에게 위임한다.</p>\n<h2 id=\"RESTful-API 설정하기\">RESTful API 설정하기 <a href=\"#RESTful-API 설정하기\">🔗</a></h2><p>위 설정 정도만 하면 Jersey를 사용할 준비가 끝났다. 이제 RESTful API를 설계하여 응답을 받아보자.</p>\n<p>임의의 클래스 하나를 생성하고 아래와 같이 지정하자. 클래스 이름은 임의로 지정해도 무관하다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/userinfo\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestAPI</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token comment\" data-tag=\"new\">// /api/userinfo API</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p><code class=\"inline-code\">@Path</code>에 원하는 경로를 지정하다. 위 클래스는 <code class=\"inline-code\">/api/userinfo</code> 요청을 위임받아 수행하는 API 클래스가 된다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/userinfo\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestAPI</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token annotation punctuation\">@GET</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">testResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"It's Worked!\"</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>위 처럼 메소드를 하나 생성해보자. <code class=\"inline-code\">testResponse</code> 메소드에 의해 <code class=\"inline-code\">/api/userinfo</code> GET 요청은 It's Worked!를 반환하여 브라우저에 출력할 것이다. <code class=\"inline-code\">@GET</code> 이외에도 <code class=\"inline-code\">@POST</code>, <code class=\"inline-code\">@PUT</code> 등 다양한 HTTP 메서드를 지원하니, 원하는대로 설정하면 된다.</p>\n<p><code class=\"inline-code\">@Path</code>는 마찬가지로 요청을 받을 URL을 지정한다. 이 때 상위의 <code class=\"inline-code\">@Path</code>를 순서대로 URL 접두어에 붙이니 유의할 것. 이 패턴으로 다양한 RESTful API를 생성할 수 있다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/userinfo\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestAPI</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token annotation punctuation\">@GET</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">testResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"It's Worked!\"</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>    <span class=\"token annotation punctuation\">@GET</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/{id}\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">userinfoResponse</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"{ key1: \\\"value1\\\", key2: \\\"value2\\\", id: \\\"\"</span> <span class=\"token operator\">+</span> id <span class=\"token operator\">+</span> <span class=\"token string\">\"\\\" }\"</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>    <span class=\"token annotation punctuation\">@POST</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/{hash}\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=19><td class=\"line-number\" data-number=\"19\">19</td><td class=\"line-code\" data-number=19>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">useraddResponse</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hash\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> hash<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@FormParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> key<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=20><td class=\"line-number\" data-number=\"20\">20</td><td class=\"line-code\" data-number=20>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=21><td class=\"line-number\" data-number=\"21\">21</td><td class=\"line-code\" data-number=21>        <span class=\"token keyword\">return</span> hash <span class=\"token operator\">+</span> key<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=22><td class=\"line-number\" data-number=\"22\">22</td><td class=\"line-code\" data-number=22>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=23><td class=\"line-number\" data-number=\"23\">23</td><td class=\"line-code\" data-number=23></td></tr>\n<tr data-number=24><td class=\"line-number\" data-number=\"24\">24</td><td class=\"line-code\" data-number=24>    <span class=\"token annotation punctuation\">@GET</span></td></tr>\n<tr data-number=25><td class=\"line-number\" data-number=\"25\">25</td><td class=\"line-code\" data-number=25>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/check\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=26><td class=\"line-number\" data-number=\"26\">26</td><td class=\"line-code\" data-number=26>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">usercheckResponse</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@QueryParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@QueryParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> key<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=27><td class=\"line-number\" data-number=\"27\">27</td><td class=\"line-code\" data-number=27>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=28><td class=\"line-number\" data-number=\"28\">28</td><td class=\"line-code\" data-number=28>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=29><td class=\"line-number\" data-number=\"29\">29</td><td class=\"line-code\" data-number=29>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=30><td class=\"line-number\" data-number=\"30\">30</td><td class=\"line-code\" data-number=30></td></tr>\n<tr data-number=31><td class=\"line-number\" data-number=\"31\">31</td><td class=\"line-code\" data-number=31>    <span class=\"token annotation punctuation\">@DELETE</span></td></tr>\n<tr data-number=32><td class=\"line-number\" data-number=\"32\">32</td><td class=\"line-code\" data-number=32>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/remove\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=33><td class=\"line-number\" data-number=\"33\">33</td><td class=\"line-code\" data-number=33>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">userremoveResponse</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@CookieParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"auth\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> auth<span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=34><td class=\"line-number\" data-number=\"34\">34</td><td class=\"line-code\" data-number=34>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=35><td class=\"line-number\" data-number=\"35\">35</td><td class=\"line-code\" data-number=35>        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=36><td class=\"line-number\" data-number=\"36\">36</td><td class=\"line-code\" data-number=36>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=37><td class=\"line-number\" data-number=\"37\">37</td><td class=\"line-code\" data-number=37><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>위 처럼 다채롭게 RESTful API를 설계해보자. 다양한 반환값을 줄 수 있다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">애노테이션</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\"><code class=\"inline-code\">@PathParam</code></td>\n<td align=\"center\">지정한 URL의 값이 할당됨. <code class=\"inline-code\">@Path</code>에서 <code class=\"inline-code\">/{key}</code>와 같이 입력함</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">@QueryParam</code></td>\n<td align=\"center\">지정한 키를 가진 URL 파라미터가 할당됨</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">@FormParam</code></td>\n<td align=\"center\">지정한 Body의 파라미터가 할당됨</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">@CookieParam</code></td>\n<td align=\"center\">지정한 키를 가진 Cookie가 할당됨</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">@HeaderParam</code></td>\n<td align=\"center\">지정한 키를 가진 Header가 할당됨</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>위 애노테이션을 사용해서 원하는 요소를 쉽게 인수로 받아올 수 있다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">메서드</th>\n<th align=\"center\">HTTP</th>\n<th align=\"left\">대상 URL</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\"><code class=\"inline-code\">testResponse</code></td>\n<td align=\"center\">GET</td>\n<td align=\"left\"><code class=\"inline-code\">/api/userinfo</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">userinfoResponse</code></td>\n<td align=\"center\">GET</td>\n<td align=\"left\"><code class=\"inline-code\">/api/userinfo/{id}</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">useraddResponse</code></td>\n<td align=\"center\">POST</td>\n<td align=\"left\"><code class=\"inline-code\">/api/userinfo/{hash}</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">usercheckResponse</code></td>\n<td align=\"center\">GET</td>\n<td align=\"left\"><code class=\"inline-code\">/api/userinfo/check?id={id}&amp;key={key}</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"inline-code\">userremoveResponse</code></td>\n<td align=\"center\">DELETE</td>\n<td align=\"left\"><code class=\"inline-code\">/api/userinfo/remove</code></td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>각 메서드에 매칭되는 URL은 위 표와 같다.</p>\n<p>그 밖에도 <code class=\"inline-code\">@Producer</code>로 응답 타입이나 응답의 Header 등을 강제하는 기능도 있지만, 이 프로젝트에선 크게 중요하지 않으므로 넘어간다.</p>\n<p>자세한 내용은 <a href=\"https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest3x/index.html\" target=\"_blank\">Jersey 3 공식 문서</a>를 참고하자.</p>\n<h2 id=\"Jersey-Context 지정하기\">Jersey Context 지정하기 <a href=\"#Jersey-Context 지정하기\">🔗</a></h2><p>근데 쓰다보면 좀 이상하다. 우리가 Servlet에서 지겹게 사용하던 <code class=\"inline-code\">HttpServletRequest</code>, <code class=\"inline-code\">HttpServletResponse</code>는 어디로 갔을까?</p>\n<p>Jersey가 Servlet를 대신하여 요청을 위임받고 있다보니, Servlet 객체가 표면적으로 드러나지 않는다. 이 경우 <code class=\"inline-code\">@Context</code> 애노테이션을 통해 Servlet 객체들에게 접근할 수 있다.</p>\n<h3 id=\"상속으로-구현하기\">상속으로 구현하기 <a href=\"#상속으로-구현하기\">🔗</a></h3><p>필자는 각 추상 객체 하나를 만들어 필요한 Context를 몰아넣고, 모든 controller API에 상속하는 방식으로 구성하고 있다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> API</td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    <span class=\"token annotation punctuation\">@Context</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    </td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    <span class=\"token annotation punctuation\">@Context</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>    </td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token annotation punctuation\">@Context</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UriInfo</span> uriInfo<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>위와 같이 API라는 추상 객체 하나를 선언한다. 이후 <code class=\"inline-code\">HttpServletRequest</code>, <code class=\"inline-code\">HttpServletResponse</code>를 <code class=\"inline-code\">@Context</code> 애노테이션을 붙여 지정한다. <code class=\"inline-code\">UriInfo</code>는 나도 크게 써본적은 없어서, 굳이 없어도 무방하다.</p>\n<p>그 밖에 공통 API 객체에 넣고 싶은 메서드가 있다면 같이 포함해도 무방하다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/userinfo\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestAPI</span> <span class=\"token keyword\">extends</span> API</td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token annotation punctuation\">@GET</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">testResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">getContextPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p><code class=\"inline-code\">TestAPI</code> 객체에 <code class=\"inline-code\">API</code> 추상 객체를 상속시킨다. <code class=\"inline-code\">protected</code>로 선언되어 있으므로, <code class=\"inline-code\">API</code>를 상속받는 모든 객체에서 <code class=\"inline-code\">HttpServletRequest</code>를 비롯한 다른 Context에 접근할 수 있게 된다.</p>\n<h3 id=\"그냥-구현하기\">그냥 구현하기 <a href=\"#그냥-구현하기\">🔗</a></h3><p>어떠한 이유로든 상속으로 구현하기 싫다면, 아래와 같이 통짜로 그냥 집어넣으면 된다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/userinfo\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestAPI</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    <span class=\"token annotation punctuation\">@Context</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>    </td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>    <span class=\"token annotation punctuation\">@Context</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>    </td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>    <span class=\"token annotation punctuation\">@Context</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UriInfo</span> uriInfo<span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12>    <span class=\"token annotation punctuation\">@GET</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13>    <span class=\"token annotation punctuation\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">testResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15>    <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=16><td class=\"line-number\" data-number=\"16\">16</td><td class=\"line-code\" data-number=16>        <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">getContextPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></td></tr>\n<tr data-number=17><td class=\"line-number\" data-number=\"17\">17</td><td class=\"line-code\" data-number=17>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=18><td class=\"line-number\" data-number=\"18\">18</td><td class=\"line-code\" data-number=18><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>이렇게 해도 무방하다. 단, 각 controller API 마다 동일한 코드를 넣어줘야함은 잊지 말자.</p>\n<h1 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h1><p>Jersey를 사용함으로써 Servlet 보다 훨씬 강력한 요청, 응답을 수행할 수 있다. 다음 장에서는 이를 기반으로 컨트롤러를 직접 구성해보자.</p>\n","url":["2021-10-25-oauth2-java-server-9","2021","10","25","oauth2-java-server-9"],"toc":[{"text":"개요","tag":"개요","depth":1},{"text":"Jersey 3 설정하기","tag":"Jersey-3 설정하기","depth":1},{"text":"의존성 모듈 설치","tag":"의존성-모듈 설치","depth":2},{"text":"Jersey 요청 URL 지정하기","tag":"Jersey-요청 URL 지정하기","depth":2},{"text":"RESTful API 설정하기","tag":"RESTful-API 설정하기","depth":2},{"text":"Jersey Context 지정하기","tag":"Jersey-Context 지정하기","depth":2},{"text":"상속으로 구현하기","tag":"상속으로-구현하기","depth":3},{"text":"그냥 구현하기","tag":"그냥-구현하기","depth":3},{"text":"정리","tag":"정리","depth":1}]},"hash":"04cc14e4bf2"},"__N_SSG":true}