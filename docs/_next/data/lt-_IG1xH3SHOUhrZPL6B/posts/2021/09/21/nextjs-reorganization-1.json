{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[Ubuntu] Ubuntu 원격 프로토콜 보안 강화하기","excerpt":"SSH, SFTP와 같은 원격 프로토콜은 서버의 접근성을 향상시켜주지만, 서버의 보안성을 극도로 훼손한다. 공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다. 따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다. 외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/133300948-2ee9b77a-1589-4afc-8489-fb402a13520f.png","date":"2021-09-15T01:53:21","type":"posts","category":"Ubuntu","tag":["Ubuntu","SSH","SFTP"],"comment":true,"publish":true},"name":"2021-09-15-increase-ubuntu-remote-security.md","content":"\r\n# 개요\r\n\r\nSSH, SFTP와 같은 원격 프로토콜은 <span class=\"green-600\">서버의 접근성을 향상</span>시켜주지만, <span class=\"red-600\">서버의 보안성을 극도로 훼손</span>한다.\r\n\r\n공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다.\r\n\r\n따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다.\r\n\r\n외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.\r\n\r\n단순히 재미삼아 내가 접속한 도메인에 접속시도를 하는 어중이떠중이들도 있겠지만, 그 중 몇몇은 공격자로 취급할 수 있을 정도의 실력을 가지기도 하며, 그 중에서도 극소수의 몇몇은 내 서버의 보안을 우회할 수 있을 정도의 실력을 가지고 있을 수도 있다.\r\n\r\n서버의 특성 상 여러 내부 시스템 및 네트워크와 연결되어 있으므로, 서버가 뜷리는 것은 그 서버와 연관된 각종 정보들의 안전을 보장할 수 없음을 의미한다. 심지어 <span class=\"red-600\">항상 최상의 보안대책을 강구하는 기업에서조차 피해를 입기도 한다.</span> 우스갯소리로 이미 대다수의 자국민 주민등록번호는 인터넷에 나뒹굴고 있을거라고 얘기하기도 할 정도니.\r\n\r\n기업처럼 높은 수준의 보안과 수준에 맞는 지식을 가진 담당자가 있을 경우 피해 확인 및 보완이라도 할 수 있겠지만, 보안에 무감각하거나 관련 지식이 미흡한 <span class=\"orange-400\">소규모 사업장이나 개인의 경우 자신의 서버가 피해를 입었다는 사실조차 인지하지 못 하기도 한다.</span> 심할 경우 서버 관리조차 이루어지지 않아 공격자의 개인 서버로 사용되기까지 한다.\r\n\r\n그 어떤 보안대첵을 강구해도 보안은 언제나 부족하다. 하지만 간단한 조치만으로도 앞서 언급한 위협의 상당부분을 차단할 수 있다. 말했듯이 대부분은 공격자라고 부르기도 뭐한 장난섞인 시도이며, <span class=\"blue-400\">상대적으로 낮은 가치의 데이터가 대다수인 개인 서버가 일정 수준의 보안을 갖추고 있을 경우 이를 우회하는 것은 시간낭비</span>이기 때문이다.\r\n\r\n간단히 말해 여러분이 게임을 하는데 체력은 많고 패턴도 귀찮은데다, 보상은 잡몹 수준인 보스가 있다고 가정하자. 해당 구간에 도달할 때마다 한숨만 나올 것이며, 게임 커뮤니티엔 해당 보스를 삭제해달라는 요구가 빗발칠 것이다. 유튜브를 보다보면 인기 급상승 5위로 올라온 \"역대 최악의 게임 보스 TOP 10\" 영상에 당당히 이름이 올라가있다. 또한 DC의 해당 게임 갤러리나 인벤에선 그 보스의 이름을 비하의 의미로 사용하고 있을 것이며, 해당 보스를 스킵할 수 있는 각종 연구들이 활발하게 진행되고 있을 것이다.\r\n\r\n이 장에선 우리의 서버를 이런 \"<span class=\"pink-600\">보상은 없고 패턴은 귀찮은 체력돼지</span>\" 보스로 만들어 공격자들이 드러워서 피하도록 만들어 볼 것이다.\r\n\r\n# 서비스 포트 변경하기\r\n\r\n파일 시스템에 직접적으로 영향을 주는 통신은 <span class=\"primary\">SSH</span>, <span class=\"primary\">SFTP</span>가 존재한다. 각 프로토콜의 전신인 Telnet과 FTP는 SSL의 미적용으로 OS 설치 시 비활성화 되어있다. 굳이 해당 프로토콜을 쓸 이유조차 없으니, 여기서는 논외로 한다.\r\n\r\n각 서비스 포트는 동일하게 SSH 데몬에서 관리하므로 22다. 기본 프로토콜의 포트는 기본 포트가 고정적이므로, 대부분의 공격 시도는 이런 불변성을 악용하여 이루어진다. 반대로 말하자면, <span class=\"green-600\">서비스 포트를 변경하는 것만으로도 간단한 공격 시도를 손쉽게 차단</span>할 수 있다.\r\n\r\n기본으로 설정된 포트와 달리, 서버 담당자가 임의로 바꾼 포트는 추적할 방법이 없기 때문. 포트의 최대값은 65,535개이므로, 임의의 포트로 변경했다면 공격자는 모든 포트에 통신을 시도하여 SSH 포트를 찾아내야만 한다.\r\n\r\nSSH와 SFTP의 서비스 포트를 변경하거나, `iptables`이나 공유기 설정을 통해 포트포워딩을 시켜 임의의 외부 포트와 22번 포트를 매칭시켜줄 수도 있다.\r\n\r\n## 서비스 포트 변경을 통한 접근 제어\r\n\r\n``` bash\r\nsudo vi /etc/ssh/sshd_config\r\n```\r\n\r\n파일 내용을 보면 `#Port 22`로 주석처리된 구문을 확인할 수 있는데, 해당 주석을 제거하여 원하는 포트로 입력해준 뒤 저장하면 된다.\r\n\r\n``` bash\r\nsystemctl restart ssh\r\n```\r\n\r\nSSH 서비스를 재시작함을 잊지 말자.\r\n\r\n## 포트포워딩을 통한 접근 제어\r\n\r\nSSH의 포트 변경이 꺼려진다면, 포트포워딩을 통해 외부에서 접속하는 임의의 포트 하나와 매칭하자. `iptables`를 활용하여 구성할 수 있다.\r\n\r\n``` bash\r\n# 포트포워딩 추가\r\niptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port [PORT NUMBER]\r\n\r\n# 포트포워딩 삭제\r\niptables -t nat -D PREROUTING -p tcp --dport 22 -j REDIRECT --to-port [PORT NUMBER]\r\n\r\n# 포트포워딩 상태 확인\r\niptables -L\r\n```\r\n\r\n공유기를 사용하고 있다면 공유기에서 포트포워딩을 진행할 수도 있다.\r\n\r\n`iptables`를 활용하면 특정 IP만 해당 포트에 접근할 수 있도록 제한할 수도 있다. <span class=\"primary\">geoIP</span> 플러그인과 연동하면 국가별 IP 대역별로 관리할 수도 있으니, 관심이 있다면 찾아보길 바란다. 적용이 마냥 간단하지는 않으니 참고할 것.\r\n\r\n# RSA Key 파일로만 접근 허용하기\r\n\r\n공격자가 꽤나 근성이 있어서, 혹은 운이 좋아서 내가 임의로 변경한 SSH 서비스 포트를 알아내어 공격을 시도한다고 가정해보자.\r\n\r\n계정정보의 경우 보통 Brute Force 기법을 통해 가능한 모든 조합의 계정정보를 입력하여 로그인을 시도할 것이다. 이를 막기 위해 일정량의 <span class=\"blue-400\">로그인 실패가 감지되면 잠시 동안 접근을 제한</span>하거나, <span class=\"blue-400\">계정을 잠궈 관리자가 해제해야 다시 활성화</span>되게끔 시스템을 구성하기도 한다.\r\n\r\n위 방법도 충분히 좋은 방법이지만, 오로지 <span class=\"blue-600\">RSA Key로만 로그인할 수 있도록 서버 설정을 구성</span>하면 로그인의 보안을 대폭 강화할 수 있다.\r\n\r\n내가 사용자의 계정정보, 심지어 비밀번호까지 알고 있더라도 <span class=\"amber-600\">서버에 등록된 공개키와 매칭되는 개인키가 없을 경우 로그인을 시도할 수 없다.</span>\r\n\r\n<br />\r\n\r\n절차는 아래와 같다.\r\n\r\n1. RSA 키쌍 생성\r\n2. 서버에 공개키 등록\r\n3. SSH, SFTP 프로토콜 접속 시 개인키 파일을 제공하여 로그인 수행\r\n\r\nRSA 키 생성 시 키 파일에 암호를 설정할 수 있다. 이 경우, 로그인 시 해당 키 파일에 설정된 비밀번호를 요구한다. 키 파일의 비밀번호는 서버의 계정정보와 별개이므로, 키 파일이 유출되었다 하더라도 키 파일의 사용을 막아 실질적인 피해를 방지할 수 있다.\r\n\r\n## RSA 키쌍 생성하기\r\n\r\n``` bash\r\nssh-keygen -t rsa\r\n```\r\n\r\n위 명령어를 사용하여 <span class=\"indigo-400\">RSA 비대칭키를 생성</span>하자. 생성 과정에서 키 파일의 비밀번호를 요구하는데, 빈 칸인 채로 Enter를 누르면 비밀번호 없이 생성된다. 이 경우, 키 파일만 획득하면 키 파일을 사용할 수 있다. 반대로 비밀번호를 입력하면 해당 키 파일을 사용하기 위해 지정한 비밀번호를 입력하여 디코딩해야한다.\r\n\r\n* 개인키 `/home/username/.ssh/id_rsa`\r\n* 공개키 `/home/username/.ssh/id_rsa.pub`\r\n\r\n기본적으로 위 경로에 바로 생성된다.\r\n\r\n## RSA 키를 서버에 등록하기\r\n\r\n``` bash\r\nssh-copy-id username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n위 명령어를 입력하여 <span class=\"indigo-400\">키 파일을 서버에 등록</span>하자. `/home/username/.ssh/id_rsa.pub`를 자동으로 등록한다.\r\n\r\n## 키 파일로 SSH 접속하기\r\n\r\n``` bash\r\nssh -i [PRIVATE KEY] username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n위 명령어를 입력하여 SSH를 접속할 수 있다. `-i` 옵션으로 개인키 경로를 입력할 수 있다. 키 생성 시 비밀번호를 입력했다면 비밀번호 입력이 필요하며, 따로 생성하지 않았을 경우 즉시 로그인이 된다.\r\n\r\n### 저 Windows에서 쓰고있는데, 개인키 사용시 오류떠요!\r\n\r\n아마 대부분 Ubuntu에서 RSA 키를 생성하고, 생성한 개인키를 Windows로 전송하여 SSH 접근하는데 사용할 것이다.\r\n\r\n``` output\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\nPermissions for 'C:\\\\id_rsa' are too open.\r\nIt is required that your private key files are NOT accessible by others.\r\nThis private key will be ignored.\r\nLoad key \"C:\\\\id_rsa\": bad permissions\r\n```\r\n\r\n하지만 막상 Windows에서 키 파일 사용 시, 키 파일이 너무 많은 유저에게 허용되면 보안 상의 이유로 키 파일의 사용을 제한한다. 해결책은 하나다. 해당 키 파일을 사용할 유저에게만  권한을 부여해주면 된다.\r\n\r\n문제는 Windows의 편의성으로 인해, 파일 전송 완료 시 필요한 권한을 자동으로 부여해주기 때문에, 수동으로 제거해야한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/133301005-c4c5a2df-f878-4ff5-8dc0-63366e28b59b.png)\r\n\r\n키 파일의 [속성] - [보안] 탭에서 파일에 부여된 접근권한을 확인할 수 있다. 보다시피 현재는 너무 많은 사용자에게 접근이 허가되어 있으므로, 오직 나만 접근할 수 있도록 변경한다. 안타깝게도 파일에 상속이 적용되어있어서 그냥 삭제되지 않는다. 하단의 [고급] 탭을 누르자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/133299523-ec1af2cc-44e2-4b39-b5ae-d7e04425500f.png)\r\n\r\n하단의 [상속 사용 안 함] 버튼을 클릭하여 상속 관계를 제거한다. 메시지 하나가 뜰텐데, [명시적 사용 권한으로 변환]을 선택한다. 제거하면 사용자를 직접 지정해야해서 번거롭다.\r\n\r\n이후 내 계정을 제외한 모든 권한 항목은 제거한다. 이후 저장하고 다시 시도하면 정상적으로 로그인을 수행할 수 있다.\r\n\r\n\r\n# SSH 접근 시 키 파일 방식만 허용하기\r\n\r\n여기까지 왔다면 로그인은 잘 됐다는 뜻인데, 키 파일로 로그인할 수 있는 건 좋지만, <span class=\"red-400\">문제는 그냥 계정 정보를 입력해도 로그인이 된다.</span>\r\n\r\n이래서야 키 파일의 높은 보안성을 활용하기 어렵다. 로그인 시 반드시 <span class=\"blue-400\">키 파일 로그인만을 허용</span>하여, 내 서버의 개인키를 가진 인원만 접속할 수 있도록 제한해보자.\r\n\r\n<p class=\"red-600\">※ 무턱대고 설정했다간 본인조차 SSH에 접속하지 못하는 상황이 생기기도 하니 주의할 것</p>\r\n\r\n``` bash\r\nsudo vi /etc/ssh/sshd_config\r\n```\r\n\r\nSSH 설정 파일을 열어 아래의 값을 수정하자. <span class=\"green-400\">비밀번호 입력 로그인 방식을 사용하지 않도록 설정</span>하는 것이다.\r\n\r\n* `PasswordAuthentication yes` -> `PasswordAuthentication no`\r\n\r\n``` bash\r\nsystemctl restart ssh\r\n```\r\n\r\n재부팅 후 로그인을 수행해보자.\r\n\r\n``` bash\r\n# 일반 로그인 방식의 SSH\r\nssh username@xxx.xxx.xxx.xxx\r\n\r\n# 키 파일 방식의 SSH\r\nssh -i [PRIVATE KEY] username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n일반로그인은 계정 정보를 제대로 입력했다 하더라도 로그인에 실패할 것이다.\r\n\r\n# 정리\r\n\r\nSSH와 SFTP를 반드시 개인키로만 로그인할 수 있도록 구성을 변경했다.\r\n\r\n생각보다 간단한 수준의 보안 작업이라도, 실제로 이루어지는 공격의 대다수를 무력화시킬 수 있다.\r\n\r\n키를 통해 더욱 안전하게 서버의 보안을 지킬 수 있지만, 키 파일을 분실하지 않도록 주의하자.","url":["2021-09-15-increase-ubuntu-remote-security","2021","09","15","increase-ubuntu-remote-security"]},"next":{"header":{"title":"[NextJS] 블로그 개편기 - 2. Typescript 입히기","excerpt":"내가 JavaScript를 접하고 기본 개념 정도에 익숙해졌을 때, 개발 커뮤니티에서 전설처럼 들려오던 이야기를 듣게 되었다.","coverImage":"https://user-images.githubusercontent.com/50317129/134931033-89954c3d-5e00-4b3b-85aa-54a1dfa29e46.png","date":"2021-09-21T05:30:21","type":"posts","category":"NextJS","tag":["NextJS","React","TypeScript"],"group":"블로그 개편기","comment":true,"publish":true},"name":"2021-09-21-nextjs-reorganization-2.md","content":"\r\n# 개요\r\n\r\n내가 JavaScript를 접하고 기본 개념 정도에 익숙해졌을 때, 개발 커뮤니티에서 전설처럼 들려오던 이야기를 듣게 되었다.\r\n\r\n<br />\r\n<br />\r\n<br/ >\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>-----</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"태초의 개발자들은 웹에서 다양한 동작을 수행하기 위해 스크립트 언어를 사용했다고 하는데, 그 것이 오늘날 자바스크립트라고 불리우는 것이라 했다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"수 십년에 이르는 자바스크립트의 독재로, 개발자들은 스크립트를 사용하기 위해 반드시 자바스크립트를 거쳐야만 했다고 한다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"자바스크립트는 강력했으나 그 성격이 나태로워, 자신이 사용할 인수를 검사하지 않았으며, 인수에 대한 모든 책임은 전적으로 개발자가 지는 부당한 처우를 받았다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"하루는 자신이 받아야할 인수로 문자열이 아닌, 수상한 객체가 들어왔음에도 이를 제대로 확인하지 않아 누군가의 사이트에 큰 화를 입혔으며, 그 사이트의 담당자는 이틀을 귀가하지 못 하고 고통받았다고 한다.\"</i></p>\r\n\r\n<br />\r\n<br />\r\n<br/ >\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"어느날 스크립트 중 타입을 가진 이가 나타났다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"그 자는 특이하게 인수를 직접 검증할 수 있어, 잘 못 들어온 인수를 차단하고 오로지 올바른 인수만을 받는 일을 능히 하였다. 그의 권능으로 타입스크립트를 쓰는 IDE와 개발자는 그의 타입을 쉬이 유추하여 화를 막을 수 있었다고 전해진다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"그 자가 현신하는 날. ECMA에 새로운 혁명이 일어나 개발자들을 구원해주리라.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>-----</i></p>\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n나는 이 전설같은 이야기에 매료되었으나, 감히 타입스크립트가 이 곳에 현신할리는 없다 생각했다.\r\n\r\n그러던 어느 날, 내가 블로그 개편을 마음먹은 당일에 내 코드에 당도하시어 친히 자신의 권능을 보이셨다.\r\n\r\n이제 난 자바스크립트의 모호함과 허술함에서 구원될 수 있으리라 믿었다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n하지만 내가 그렇게 생각한 건 <span class=\"red-600\">^^ㅣfoot 경기도 오산이였다.</span>\r\n\r\n# 타입스크립트\"님\" 강림시키기\r\n\r\nNextJS에 타입스크립트\"님\"을 강림시키는 법은 생각보다 매우 간단했다.\r\n\r\n## 새 프로젝트\r\n\r\n``` bash\r\n# NPM 기반\r\nnpx create-next-app --ts\r\n\r\n# Yarn 기반\r\nyarn create-next-app --typescript\r\n```\r\n\r\n위 명령어를 입력하면 타입스크립트\"님\" 기반의 템플릿이 생성된다.\r\n\r\n## 기존 프로젝트\r\n\r\n``` bash\r\n# NPM 기반\r\nnpm install typescript @types/react @types/node --save-dev\r\n\r\n# Yarn 기반\r\nyarn add typescript @types/react @types/node --dev\r\n```\r\n\r\n위 명령어를 입력하여 타입스크립트\"님\" 관련 플러그인을 설치한다.\r\n\r\n그리고 루트 경로에 `tsconfig.json` 파일을 하나 생성하면 된다. 타입스크립트\"님\"이 정확히 어떤 식으로 권능을 행할지 자세하게 \"간청\"할 수 있다.\r\n\r\n``` json\r\n{\r\n\t\"compilerOptions\": {\r\n\t\t\"target\": \"ESNext\",\r\n\t\t\"lib\": [ \"dom\", \"dom.iterable\", \"esnext\", \"ES2021\" ],\r\n\t\t\"allowJs\": true,\r\n\t\t\"skipLibCheck\": true,\r\n\t\t\"strict\": true,\r\n\t\t\"forceConsistentCasingInFileNames\": true,\r\n\t\t\"noEmit\": true,\r\n\t\t\"esModuleInterop\": true,\r\n\t\t\"module\": \"esnext\",\r\n\t\t\"moduleResolution\": \"node\",\r\n\t\t\"resolveJsonModule\": true,\r\n\t\t\"isolatedModules\": true,\r\n\t\t\"jsx\": \"preserve\",\r\n\t\t\"baseUrl\": \".\",\r\n\t\t\"paths\": {\r\n\t\t\t\"@commons/*\": [ \"commons/*\" ],\r\n\t\t\t\"@components/*\": [ \"components/*\" ],\r\n\t\t\t\"@pages/*\": [ \"pages/*\" ],\r\n\t\t\t\"@styles/*\": [ \"styles/*\" ]\r\n\t\t}\r\n\t},\r\n\t\"include\": [ \"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\" ],\r\n\t\"exclude\": [ \"node_modules\" ]\r\n}\r\n```\r\n\r\n내가 간청한 기도는 위와 같으니, 참고해서 보도록 하자. [타입스크립트 성서](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)에 이와 관련된 기도문 예시가 잘 나와있다.\r\n\r\n\"새 프로젝트\"로 시작했다면 이미 주기도문이 기록되어있으니 참고할 것.\r\n\r\n# 타입스크립트\"님\"와 동행하기\r\n\r\n기존의 리액트 컴포넌트는 죄다 `.js`, `.jsx` 같은 불결한 확장자를 달고 있을 것이다. 이 낙인은 전부 제거해버리고, `.ts`, `.tsx`와 같이 교체하자. 이 얼마나 성스러운가! 앞으로 생성할 모든 컴포넌트에도 이 표식을 자랑스럽게 새기도록한다.\r\n\r\n자바스크립트와 달라진 점이라곤 타입 여부다. <span class=\"primary\">문법이나 사용 방식은 그대로</span>기 때문에, 기존 방식 그대로 대접해도 타입스크립트\"님\"은 전혀 신경쓰지 않으신다.\r\n\r\n## 행한 기적\r\n\r\n### 타입 명시\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>그가 한 번 손짓하시메, 모든 이가 타입을 가지게 되었노라.</i></p>\r\n\r\n타입스크립트\"님\"은 말 그대로 타입 유추를 가능케 하신다. 모든 인수, 반환에 타입을 지정해줌으로써, 개발자가 해당 인수와 반환이 어떤 타입을 반환하는지 알 수 있게 해주신다.\r\n\r\n``` javascript\r\n/**\r\n * 숫자 두 개 뺏기고 문자열 하나 받기\r\n * \r\n * @param {number} n: 소중한 숫자\r\n * @param {number} m: 귀중한 숫자\r\n * \r\n * @returns {string} 근본없는 문자열\r\n */\r\nfunction add(n, m)\r\n{\r\n\tconst temp = n + m;\r\n\r\n\treturn `${n} + ${m} = ${temp}`;\r\n}\r\n```\r\n\r\n``` typescript\r\n/**\r\n * 덧셈의 권능 목도하기\r\n * \r\n * @param {number} n: 미천한 숫자\r\n * @param {number} m: 가련한 숫자\r\n * \r\n * @returns {string} 광휘의 문자열\r\n */\r\nfunction add(n: number, m: number): string\r\n{\r\n\tconst temp: number = n + m;\r\n\r\n\treturn `${n} + ${m} = ${temp}`;\r\n}\r\n```\r\n\r\n보았는가, 이 차이를. 위 예시에서 볼 수 있듯이 자바스크립트와 타입스크립트\"님\"의 차이는 광야와 같이 크다. 무려 <span class=\"green-600\">모든 인수, 변수에 타입을 부여</span>해주신다.\r\n\r\n따라서 함수의 인수나 반환값으로 이단자들이 출입하는 것을 막아주신다.\r\n\r\n<br />\r\n<br />\r\n\r\n어째 안 해도 될 일을 구태여 하고 있는거 아니냐고? 어제도 당신과 같은 말을 한 이단자가 있<b class=\"red-400\">었</b>지.....\r\n\r\n### IDE 지원\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>그의 사도가 그가 말씀하신대로 코드에 키보드를 내리치니, 광야같던 개발기간이 반으로 갈라지더라.</i></p>\r\n\r\nVSCode를 사용해보면 알겠지만, 자바스크립트의 기본 API 외에 개발자가 직접 설계한 API의 경우 자동완성이 제대로 먹히질 않는다.\r\n\r\n이는 당연한 결과로, IDE는 무지하여 개발자가 직접 작성한 스크립트의 정확한 구조를 모르기 때문이다. JAVA나 C계열 언어처럼 정해진 구조로 명시되지도 않았으므로, IDE 입장에서는 무엇이 어떻게 되어있는 지 전혀 알 수 없다.\r\n\r\n하지만 타입스크립트\"님\"이라면 다르다. 작성한 코드의 모든 타입과 구조가 사전에 명시되기 때문에, <span class=\"primary\">IDE가 이를 파악하고 해당 요소의 하위 객체를 자동완성을 통해 보여준다.</span> 이러한 기능은 높은 개발 생산성으로 이어진다. 즉, 같은 자원으로도 더욱 많은 결과를 내는 오병이어의 기적을 몸소 행하시는 것이다.\r\n\r\n### 객체지향 개발의 용이성\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>수고하고 무거운 짐 진 자들아, 다 내게로 오라. 내가 너희를 쉬게 하리라.</i></p>\r\n\r\n위 같은 이유로 자바스크립트는 객체지향 패턴을 적용하기 난감한 언어였다.(불가능한 건 아니다)\r\n\r\n하지만 타입스크립트\"님\"이 모든 이에게 타입을 부여함으로써, <span class=\"primary\">객체지향 패턴을 적용하는 데 유용</span>하도록 만들어주었다.\r\n\r\n이로 인해 클래스, 인터페이스 등의 개념을 쉽게 적용할 수 있어, JAVA와 같은 객체지향 기반 언어에서 온 자들이 좀 더 편히 머무를 수 있도록 행하셨다.\r\n\r\n## 이단자의 기록\r\n\r\n구태여 이런 난잡스러운 자를 받아들여 없는 고생을 사서 함이, 참으로 통탄할 일이다.\r\n\r\n### 허례허식과 위선\r\n\r\n자바스크립트에선 전혀 신경쓰지 않아도 될 영역임에도 타입스크립트에선 그 잘난 \"타입\"으로 인해 강제되는 영역이 존재한다.\r\n\r\n예를 들어, 하위 컴포넌트가 프로퍼티를 받기 위해선 인터페이스로 타입을 미리 선언해주어야 한다.\r\n\r\n``` typescript\r\ninterface Props {\r\n\twidth: number,\r\n\theight: number,\r\n\tcolor?: string\r\n}\r\n\r\n/**\r\n * 컴포넌트 ReactElement 하사 받기\r\n * \r\n * @param {Props} param0: 프로퍼티\r\n * \r\n * @returns {ReactElement} ReactElement\r\n */\r\nexport default function Component({ width, height, color }: Props): ReactElement\r\n{\r\n\treturn <div style={{ width: width, height: height, color: color || 'white' }}>테스트</div>\r\n}\r\n```\r\n\r\n이 처럼 타입 하나를 선언해주기 위해 인터페이스를 설계하는 등, <span class=\"red-400\">같은 일을 함에 있어서 더 많은 작업을 요구</span>한다.\r\n\r\n이러한 허례허식주의는 코드에 겉치레를 추가함으로써, <span class=\"red-400\">코드의 가독성을 잔혹하게 해치는 결과</span>로 이어진다.\r\n\r\n또한 그 거창한 이름과 달리, 결국 속은 자바스크립트와 다를 것이 없다. 겉으로는 뭔가 대단한 \"척\", 있는 \"척\"을 해대도, 결국 권능을 수행하는 주체는 동일한 자바스크립트다. 이는 곧, <span class=\"red-400\">자바스크립트의 근본적인 문제점, 단점을 동일하게 공유</span>한다는 뜻이다. 이 것이 위선이 아니고 무엇인가.\r\n\r\n### 가혹한 율법\r\n\r\n타입에서 나오는 불편함이야 충분히 이해할 수 있었다. 타입이 주는 명확한 이점도 있으니.\r\n\r\n그럼에도 불구하고 타입스크립트를 차마 이해할 수 없는 점은, 가혹한 규칙에 있다.\r\n\r\n``` typescript\r\n/**\r\n * 테스트 \"목도\"하기\r\n * \r\n * @param {*} color: 색상\r\n * \r\n * @return {*} 요소\r\n */\r\nfunction test(color)\r\n{\r\n\tconst ref = useRef();\r\n\r\n\tuseEffect(() =>\r\n\t{\r\n\t\tref.current.style.backgroundColor = color;\r\n\t});\r\n\r\n\treturn <div ref={ref}>Color</div>;\r\n}\r\n```\r\n\r\n위 코드가 어때 보이는가? 보기엔 매우 평범해보인다. 겉모습 뿐만 아니라, 실제로 자바스크립트로 돌려봐도 문제가 없는 코드다. 그럼에도 불구하고 타입스크립트는 엄격한 규칙에 따라 이를 허용해주지 않는다.\r\n\r\n위 코드에는 아래와 같은 매우 \"중대한\" 오류가 존재한다.\r\n\r\n1. color의 타입이 명시되지 않음\r\n2. test 함수의 반환값이 명시되지 않음\r\n3. useRef()의 타겟이 명시되지 않음\r\n4. ref, ref.current가 존재하지 않을 수도 있음\r\n\r\n이와 같은 이유로 컴파일 단계서부터 거절당한다.\r\n\r\n심지어 4번은 골때리는데, 분명히 존재하는 요소임에도, 심지어 동적으로 렌더링하는 것이 아니라 태초부터 HTML에 기록된 요소마저 <span class=\"grey-400\">\"응? 그거 없을 수도 있는데? 진짜 확실해?? 진짜???\"</span>하며 동작을 거부한다. 착실한 신도조차 미치고 돌아버리다 못 해 그 회전각이 2160도로 돌아간다. 아마 여기서 조금만 더 돌아버리게 만들면 그 신도는 몇 초간 공중에 체공도 할 수 있을 것이라 자신한다.\r\n\r\n``` typescript\r\n/**\r\n * 테스트 \"목도\"하기\r\n * \r\n * @param {number} color: 색상\r\n * \r\n * @return {ReactElement} 요소\r\n */\r\nfunction test(color: string): ReactElement\r\n{\r\n\tconst ref = useRef<HTMLDivElement>(null);\r\n\r\n\tuseEffect((): void =>\r\n\t{\r\n\t\tif (ref && ref.current)\r\n\t\t{\r\n\t\t\tref.current.style.backgroundColor = color;\r\n\t\t}\r\n\t});\r\n\r\n\treturn <div ref={ref}>Color</div>;\r\n}\r\n```\r\n\r\n올바른 사용법은 위와 같다. 이 얼마나 쓸데없는가. 정확한 검증은 그렇다쳐도, 이건 의심병인지 모를 수준으로 모든 요소를 일단 \"없다\"고 가정한다. 나는 이미 있는 걸 증명하고자 갖가지 쓸데없는 허례허식을 통해 이미 존재가 증명된 존재를 직접 증명해야하고.\r\n\r\n# 정리\r\n\r\n그럼에도 불구하고, 타입스크립트\"님\"의 권능은 자바스크립트 개발의 새로운 방향성을 제시하기 충분했다.\r\n\r\n특히 JAVA나 C# 같은 타이트한 객체지향을 먼저 시작한 나로써는 자바스크립트의 그 모호함이 정말 싫었는데, 타입스크립트는 타입과 정형화를 통해 이런 불편함을 충분히 해소시켜줄만한 것이였다.\r\n\r\n하지만, 자바스크립트나 리액트가 아직 익숙하지 않다면 타입스크립트\"님\"의 영접은 시기상조일 수도 있다고도 생각한다. 위에 기술된 이단자의 기록처럼, 타입스크립트\"님\"의 권능은 기존에 없던 주변코드를 요구하게 되며, 이는 곧 코드의 진입장벽으로 이어지게 될 것이다.\r\n\r\n과유불급이다. 현세의 종교 역시 이를 맹신하며 본래의 일을 소홀히하면 필연적으로 문제를 일으키게 된다. 당신 역시 타입스크립트\"님\"의 권능을 맹목적으로 받기 위해 애쓰다 정작 중요한 일을 그르치지 말도록 하자.\r\n\r\n# 여담\r\n\r\n<span class=\"grey-600\">내가 뭘 쓴거야...</span>","url":["2021-09-21-nextjs-reorganization-2","2021","09","21","nextjs-reorganization-2"]}},"group":[{"header":{"title":"[NextJS] 블로그 개편기 - 3. SCSS 입히기","excerpt":"원래 내 블로그는 JS-in-CSS 스타일 방식을 사용하고 있었다. 그 이유는 Material-UI 때문. Material-UI의 공식 예제에서 대놓고 JS-in-CSS 방식으로 설명하기 때문에, React 기초 수준이였던 난 당연히 이렇게 해야하는 줄 알고 있었다. 하지만 개발을 거듭하며, 그 중 몇몇은 복잡한 스타일을 강요받기도 하며 점점 스타일 구문이 비대해지는 컴포넌트가 생겨나기 시작했다. 이에 따라 JS-in-CSS의 단점이 점점 대두되기 시작했다. 대표적인 문제점으로 FOCU(Flash Of Unstyled Content). 스타일 렌더링에 시간이 소요되어, 사용자가 렌더링 이전의 페이지를 보게 되는 현상이다. 내 페이지의 경우 약 1초가 조금 안 되게 FOUC가 발생했는데, 사용자 경험을 극도로 해치는 일이였다. 블로그 개편을 마음먹게 된 가장 큰 이유 역시 이 FOCU 현상 때문이였으며, 관련 정보 조사 결과 CSS-in-CSS의 성능이 월등히 뛰어나다는 점을 확인했다.","coverImage":"https://user-images.githubusercontent.com/50317129/134931033-89954c3d-5e00-4b3b-85aa-54a1dfa29e46.png","date":"2021-09-24T13:17:24","type":"posts","category":"NextJS","tag":["NextJS","React","SCSS","CSS"],"group":"블로그 개편기","comment":true,"publish":true},"name":"2021-09-24-nextjs-reorganization-3.md","content":"\r\n# 개요\r\n\r\n원래 내 블로그는 JS-in-CSS 스타일 방식을 사용하고 있었다. 그 이유는 Material-UI 때문. Material-UI의 공식 예제에서 대놓고 JS-in-CSS 방식으로 설명하기 때문에, React 기초 수준이였던 난 당연히 이렇게 해야하는 줄 알고 있었다.\r\n\r\n하지만 개발을 거듭하며, 그 중 몇몇은 복잡한 스타일을 강요받기도 하며 점점 스타일 구문이 비대해지는 컴포넌트가 생겨나기 시작했다. 이에 따라 JS-in-CSS의 단점이 점점 대두되기 시작했다. 대표적인 문제점으로 FOCU(Flash Of Unstyled Content). 스타일 렌더링에 시간이 소요되어, 사용자가 렌더링 이전의 페이지를 보게 되는 현상이다. 내 페이지의 경우 약 1초가 조금 안 되게 FOUC가 발생했는데, 사용자 경험을 극도로 해치는 일이였다.\r\n\r\n블로그 개편을 마음먹게 된 가장 큰 이유 역시 이 FOCU 현상 때문이였으며, 관련 정보 조사 결과 CSS-in-CSS의 성능이 월등히 뛰어나다는 점을 확인했다.\r\n\r\n``` javascript\r\n/**\r\n * 스타일 객체 반환 함수\r\n *\r\n * @returns {JSON} 스타일 객체\r\n */\r\nfunction getStyles()\r\n{\r\n\treturn makeStyles((theme) => ({\r\n\t\tfab_bright: {\r\n\t\t\tposition: \"fixed\",\r\n\t\t\tbottom: 50,\r\n\t\t\tright: 50,\r\n\t\t\tbackgroundColor: grey[800],\r\n\t\t\tcolor: grey[200],\r\n\t\t\t\"&:hover\": {\r\n\t\t\t\tbackgroundColor: grey[700]\r\n\t\t\t},\r\n\t\t\t\"& svg\": {\r\n\t\t\t\tcolor: orange[600]\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.up(\"md\")]: {\r\n\t\t\t\t\"& span\": {\r\n\t\t\t\t\tmarginLeft: theme.spacing(1)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.down(\"sm\")]: {\r\n\t\t\t\tbottom: 70,\r\n\t\t\t\tright: 20\r\n\t\t\t}\r\n\t\t},\r\n\t\tfab_dark: {\r\n\t\t\tposition: \"fixed\",\r\n\t\t\tbottom: 50,\r\n\t\t\tright: 50,\r\n\t\t\tbackgroundColor: grey[200],\r\n\t\t\tcolor: grey[900],\r\n\t\t\t\"&:hover\": {\r\n\t\t\t\tbackgroundColor: grey[300]\r\n\t\t\t},\r\n\t\t\t\"& svg\": {\r\n\t\t\t\tcolor: blue[600]\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.up(\"md\")]: {\r\n\t\t\t\t\"& span\": {\r\n\t\t\t\t\tmarginLeft: theme.spacing(1)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.down(\"sm\")]: {\r\n\t\t\t\tbottom: 70,\r\n\t\t\t\tright: 20\r\n\t\t\t}\r\n\t\t},\r\n\t\tdiv: {\r\n\t\t\theight: 24\r\n\t\t}\r\n\t}))();\r\n}\r\n```\r\n\r\n심지어 JS-in-CSS 시절의 스타일 구현 코드를 보면, 요소의 중첩이 적용되어있어 일반적인 CSS로는 그대로 옮기기 어려운 형태였다. 또한 CSS의 중첩을 접하게 되면서, 중첩이 주는 편의성에 익숙해진 터라 스타일만 CSS로 옳기면서 그 편의성만 그대로 유지하고 싶었다.\r\n\r\n결국 프로젝트에 CSS 전처리기를 적용하기로 결정했다.\r\n\r\n# CSS의 전처리기\r\n\r\nCSS의 전처리기는 여러 종류가 있다.\r\n\r\n* [SASS/SCSS](https://sass-lang.com)\r\n* [LESS](https://lesscss.org)\r\n* [Stylus](https://www.stylus.com)\r\n* [PostCSS](https://postcss.org)\r\n\r\nCSS 전처리기의 궁극적인 목표는 CSS의 확장성을 통해 개발에서의 여러 이점을 확보하는 것이다.\r\n\r\nCSS 전처리기를 사용하면 무려 파일에서 `@for`나 `@mixin`, 변수와 같은 동적 코딩이 가능해진다. 아쉽게도 전처리기 파일을 그대로 브라우저에서 사용할 순 없다. 역시나 이런 류의 다른 언어와 마찬가지로 컴파일이 필요하며, 컴파일의 결과물은 CSS 파일로 출력된다.\r\n\r\n즉, 컴파일 단계에서 CSS 전처리기 파일에 선언된 명령문이 동작하여 평범한 CSS로 출력되는 것이다.\r\n\r\n## 장점\r\n\r\n1. 반복적인 CSS 구문 축소\r\n2. 변수를 통한 일괄 관리\r\n3. 중첩을 통한 CSS 구문 가독성 확보\r\n4. 파일 분리를 통한 컴포넌트화 용이\r\n\r\n## 단점\r\n\r\n1. 전처리기별로 학습곡선 존재\r\n2. 별도의 개발환경 구축 필요\r\n\r\n# SCSS\r\n\r\n이 블로그에서 나는 SCSS를 차용했다. CSS 전처리기에 걸맞는 다양한 확장 구문을 사용할 수 있으면서도, 기존의 CSS 문법과 거의 차이가 없기 때문이다.\r\n\r\n원래 SCSS의 전신은 SASS로, Syntactically Awesome Style Sheets의 약자다. 한글로 직역하면 대충 문법적으로 개쩌는 스타일 시트 정도로 표현할 수 있다.\r\n\r\nSASS는 가장 처음으로 나온 전처리기로, Ruby 언어에 기반한 문법을 가지고 있어 CSS에서 바로 선회하기 어려운 부분이 많았다. 표현식이 달랐고, 문법에도 차이가 있었다.\r\n\r\n이후 SASS의 단점을 해소한 SCSS(Sassy CSS)나 나왔는데, CSS 전처리기의 확장성을 지니면서도 CSS의 문법과 매우 유사하다. 덕분에 전처리기 중에서도 러닝커브가 상당히 낮은 편이다.\r\n\r\n<br />\r\n<br />\r\n\r\nSCSS와 SASS의 차이는 아래의 예시에서 극명하게 드러난다.\r\n\r\n``` css\r\ndiv {\r\n\tcolor: grey;\r\n\r\n\twidth: 80px;\r\n\theight: 160px;\r\n}\r\n\r\ndiv h1 {\r\n\tcolor: dodgerblue;\r\n}\r\n```\r\n\r\n``` sass\r\n$length: 80px\r\n\r\ndiv\r\n\tcolor: grey\r\n\r\n\twidth: $length\r\n\theight: $length * 2\r\n\r\n\th1\r\n\t\tcolor: dodgerblue\r\n```\r\n\r\n``` scss\r\n$length: 80px;\r\n\r\ndiv {\r\n\tcolor: grey;\r\n\r\n\twidth: $length;\r\n\theight: $length * 2;\r\n\r\n\th1 {\r\n\t\tcolor: dodgerblue;\r\n\t}\r\n}\r\n```\r\n\r\n위 차이에서 알 수 있듯이, SASS는 CSS와 SCSS에 비해 표현식이 좀 다르다. 모티브로 삼은 언어가 서로 달라서 생긴 차이다.\r\n\r\n다행히도 후에 나온 SCSS는 SASS의 장점과 CSS의 문법을 그대로 흡수하여 흡사 CSS를 작성하는 것과 별반 차이가 없기에, 대부분 SCSS를 많이 차용하는 편이다. 실제로 SASS로 구현 가능한 건 SCSS로 전부 구현할 수 있으며, 심지어 공식 홈페이지에서도 SCSS를 권장하고 있다. 또한 SASS와 SCSS의 개발환경 역시 동일하다.\r\n\r\nSASS가 CSS 전처리기의 선두주자지만, 여러 이유로 후발주자인 SCSS가 더 많이 사용되고 있다. 하지만 이러한 상징성 및 이름의 유사성으로 인해 SASS와 SCSS를 구분없이 혼용하거나 그냥 둘 다 뭉뚱그려 SASS라고 표현하기도 한다.\r\n\r\n즉, `SASS = SCSS`라 봐도 무방하다.\r\n\r\n이렇게 다양한 장점들로 인해 SCSS를 차용하기로 결정했다.\r\n\r\n# 프로젝트에 SCSS 적용하기\r\n\r\nSCSS는 Typescript와 같이 별도의 템플릿은 없으므로, 직접 설정해야한다. 매우 쉬우니 겁먹지 않아도 된다.\r\n\r\n## SCSS Loader 설치하기\r\n\r\n``` bash\r\n# NPM 기반\r\nnpm install @zeit/next-sass --save-dev\r\n\r\n# Yarn 기반\r\nyarn add @zeit/next-sass --dev\r\n```\r\n\r\n위 명령어를 이용하여 SASS Loader를 설치한다. 내가 쓴 건 SCSS 아니냐고? 위에 언급했다시피 SASS와 SCSS의 개발환경이 동일하다. 컴파일러 역시 동일하므로, SASS Loader를 설치해도 아무 문제가 없다.\r\n\r\n## SCSS Loader 설정하기\r\n\r\n``` javascript\r\nconst withSass = require('@zeit/next-sass');\r\n\r\nmodule.exports = withSass();\r\n\r\n// 기존 next.config.js 내용 ...\r\n```\r\n\r\nNextJS의 설정파일인 `next.config.js`에 위 구문을 추가한다. `withSass()` 안엔 JSON 형태로 추가적인 옵션을 지정할 수 있다. 예를 들어, `@zeit/next-sass` 로더를 적용하면 CSS 파일들은 전부 SASS/SCSS로 변경하라는 문구와 함께 오류를 띄운다. 이 때, 아래와 같이 옵션을 주면 CSS도 병행해서 사용할 수 있다.\r\n\r\n``` javascript\r\nmodule.exports = withSass({\r\n\tcssModules: true\r\n});\r\n```\r\n\r\n[@zeit/next-sass NPM 저장소](https://www.npmjs.com/package/@zeit/next-sass)에서 자세한 옵션을 확인할 수 있다.\r\n\r\n이후 프로젝트에서의 사용은 CSS와 동일하다.\r\n\r\n# 예시\r\n\r\n``` scss\r\n@mixin oneline {\r\n\tdisplay: block;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\ttext-overflow: ellipsis;\r\n\ttransition: 0.5s;\r\n}\r\n\r\n.category {\r\n\t@include oneline;\r\n\r\n\twidth: 50%;\r\n\tfont-size: 20px !important;\r\n\tmargin-bottom: 0px !important;\r\n\r\n\ttransition: 0.5s;\r\n\r\n\tcolor: map-get($map: $amber, $key: \"700\");\r\n\r\n\t@media (max-width: 960px) {\r\n\t\tfont-size: 16px !important;\r\n\r\n\t\ttransition: 0.5s;\r\n\t}\r\n}\r\n```\r\n\r\n컨텐츠의 카테고리를 표시하는 SCSS의 일부다. `@mixin`, `@include` 구문을 통해 코드를 함수화하여 필요한 곳에서 호출하여 사용할 수 있었다.\r\n\r\n``` scss\r\n@mixin genColor($map, $str) {\r\n\t@each $key, $val in $map {\r\n\t\t.#{$str}-#{$key} {\r\n\t\t\tcolor: $val;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n@include genColor($red, red);\r\n@include genColor($pink, pink);\r\n@include genColor($purple, purple);\r\n@include genColor($deepPurple, deepPurple);\r\n@include genColor($indigo, indigo);\r\n@include genColor($blue, blue);\r\n@include genColor($lightBlue, lightBlue);\r\n@include genColor($cyan, cyan);\r\n@include genColor($teal, teal);\r\n@include genColor($green, green);\r\n@include genColor($lightGreen, lightGreen);\r\n@include genColor($lime, lime);\r\n@include genColor($yellow, yellow);\r\n@include genColor($amber, amber);\r\n@include genColor($orange, orange);\r\n@include genColor($deepOrange, deepOrange);\r\n@include genColor($brown, brown);\r\n@include genColor($grey, grey);\r\n@include genColor($blueGrey, blueGrey);\r\n```\r\n\r\n`@mixin`은 타 언어의 메소드와 개념이 매우 유사하여, 코드의 중복을 효과적으로 방지할 수 있는 매력적인 예약어다.\r\n\r\n``` scss\r\n@import \"./fonts/apple.module.scss\";\r\n@import \"./fonts/blacksword.module.scss\";\r\n\r\n@import \"./common/color.module.scss\";\r\n@import \"./common/icons.scss\";\r\n\r\n@import \"./components/global/markdown.scss\";\r\n```\r\n\r\n`@import`로 다른 SCSS 파일을 삽입할 수 있다. 이러한 패턴으로 SCSS을 컴포넌트별로 관리할 수 있었으며, 코드의 길이가 늘어남을 방지하여 더 나은 유지보수 용이성을 제공했다.\r\n\r\n# 정리\r\n\r\n큰 장점과 동반되는 여러 자잘한 단점들이 있었던 Typescript와 다르게, SCSS의 많은 장점에도 불구하고 그 단점은 거의 체감되지 않았다.\r\n\r\n앞으로의 모든 프로젝트에 SCSS를 적용시키고 싶을 정도로 개발 편의성이나 생산성을 향상시켜주지 않았나 싶다.\r\n\r\nSCSS의 개발환경 구축 필요성도, 어차피 내 블로그는 NextJS로 구성됐기 때문에 설정에서 몇 줄 추가하는 것 만으로 해결. 여러모로 만족스러운 경험이였다.","url":["2021-09-24-nextjs-reorganization-3","2021","09","24","nextjs-reorganization-3"]},{"header":{"title":"[NextJS] 블로그 개편기 - 2. Typescript 입히기","excerpt":"내가 JavaScript를 접하고 기본 개념 정도에 익숙해졌을 때, 개발 커뮤니티에서 전설처럼 들려오던 이야기를 듣게 되었다.","coverImage":"https://user-images.githubusercontent.com/50317129/134931033-89954c3d-5e00-4b3b-85aa-54a1dfa29e46.png","date":"2021-09-21T05:30:21","type":"posts","category":"NextJS","tag":["NextJS","React","TypeScript"],"group":"블로그 개편기","comment":true,"publish":true},"name":"2021-09-21-nextjs-reorganization-2.md","content":"\r\n# 개요\r\n\r\n내가 JavaScript를 접하고 기본 개념 정도에 익숙해졌을 때, 개발 커뮤니티에서 전설처럼 들려오던 이야기를 듣게 되었다.\r\n\r\n<br />\r\n<br />\r\n<br/ >\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>-----</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"태초의 개발자들은 웹에서 다양한 동작을 수행하기 위해 스크립트 언어를 사용했다고 하는데, 그 것이 오늘날 자바스크립트라고 불리우는 것이라 했다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"수 십년에 이르는 자바스크립트의 독재로, 개발자들은 스크립트를 사용하기 위해 반드시 자바스크립트를 거쳐야만 했다고 한다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"자바스크립트는 강력했으나 그 성격이 나태로워, 자신이 사용할 인수를 검사하지 않았으며, 인수에 대한 모든 책임은 전적으로 개발자가 지는 부당한 처우를 받았다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"하루는 자신이 받아야할 인수로 문자열이 아닌, 수상한 객체가 들어왔음에도 이를 제대로 확인하지 않아 누군가의 사이트에 큰 화를 입혔으며, 그 사이트의 담당자는 이틀을 귀가하지 못 하고 고통받았다고 한다.\"</i></p>\r\n\r\n<br />\r\n<br />\r\n<br/ >\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"어느날 스크립트 중 타입을 가진 이가 나타났다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"그 자는 특이하게 인수를 직접 검증할 수 있어, 잘 못 들어온 인수를 차단하고 오로지 올바른 인수만을 받는 일을 능히 하였다. 그의 권능으로 타입스크립트를 쓰는 IDE와 개발자는 그의 타입을 쉬이 유추하여 화를 막을 수 있었다고 전해진다.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>\"그 자가 현신하는 날. ECMA에 새로운 혁명이 일어나 개발자들을 구원해주리라.\"</i></p>\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>-----</i></p>\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n나는 이 전설같은 이야기에 매료되었으나, 감히 타입스크립트가 이 곳에 현신할리는 없다 생각했다.\r\n\r\n그러던 어느 날, 내가 블로그 개편을 마음먹은 당일에 내 코드에 당도하시어 친히 자신의 권능을 보이셨다.\r\n\r\n이제 난 자바스크립트의 모호함과 허술함에서 구원될 수 있으리라 믿었다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n하지만 내가 그렇게 생각한 건 <span class=\"red-600\">^^ㅣfoot 경기도 오산이였다.</span>\r\n\r\n# 타입스크립트\"님\" 강림시키기\r\n\r\nNextJS에 타입스크립트\"님\"을 강림시키는 법은 생각보다 매우 간단했다.\r\n\r\n## 새 프로젝트\r\n\r\n``` bash\r\n# NPM 기반\r\nnpx create-next-app --ts\r\n\r\n# Yarn 기반\r\nyarn create-next-app --typescript\r\n```\r\n\r\n위 명령어를 입력하면 타입스크립트\"님\" 기반의 템플릿이 생성된다.\r\n\r\n## 기존 프로젝트\r\n\r\n``` bash\r\n# NPM 기반\r\nnpm install typescript @types/react @types/node --save-dev\r\n\r\n# Yarn 기반\r\nyarn add typescript @types/react @types/node --dev\r\n```\r\n\r\n위 명령어를 입력하여 타입스크립트\"님\" 관련 플러그인을 설치한다.\r\n\r\n그리고 루트 경로에 `tsconfig.json` 파일을 하나 생성하면 된다. 타입스크립트\"님\"이 정확히 어떤 식으로 권능을 행할지 자세하게 \"간청\"할 수 있다.\r\n\r\n``` json\r\n{\r\n\t\"compilerOptions\": {\r\n\t\t\"target\": \"ESNext\",\r\n\t\t\"lib\": [ \"dom\", \"dom.iterable\", \"esnext\", \"ES2021\" ],\r\n\t\t\"allowJs\": true,\r\n\t\t\"skipLibCheck\": true,\r\n\t\t\"strict\": true,\r\n\t\t\"forceConsistentCasingInFileNames\": true,\r\n\t\t\"noEmit\": true,\r\n\t\t\"esModuleInterop\": true,\r\n\t\t\"module\": \"esnext\",\r\n\t\t\"moduleResolution\": \"node\",\r\n\t\t\"resolveJsonModule\": true,\r\n\t\t\"isolatedModules\": true,\r\n\t\t\"jsx\": \"preserve\",\r\n\t\t\"baseUrl\": \".\",\r\n\t\t\"paths\": {\r\n\t\t\t\"@commons/*\": [ \"commons/*\" ],\r\n\t\t\t\"@components/*\": [ \"components/*\" ],\r\n\t\t\t\"@pages/*\": [ \"pages/*\" ],\r\n\t\t\t\"@styles/*\": [ \"styles/*\" ]\r\n\t\t}\r\n\t},\r\n\t\"include\": [ \"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\" ],\r\n\t\"exclude\": [ \"node_modules\" ]\r\n}\r\n```\r\n\r\n내가 간청한 기도는 위와 같으니, 참고해서 보도록 하자. [타입스크립트 성서](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)에 이와 관련된 기도문 예시가 잘 나와있다.\r\n\r\n\"새 프로젝트\"로 시작했다면 이미 주기도문이 기록되어있으니 참고할 것.\r\n\r\n# 타입스크립트\"님\"와 동행하기\r\n\r\n기존의 리액트 컴포넌트는 죄다 `.js`, `.jsx` 같은 불결한 확장자를 달고 있을 것이다. 이 낙인은 전부 제거해버리고, `.ts`, `.tsx`와 같이 교체하자. 이 얼마나 성스러운가! 앞으로 생성할 모든 컴포넌트에도 이 표식을 자랑스럽게 새기도록한다.\r\n\r\n자바스크립트와 달라진 점이라곤 타입 여부다. <span class=\"primary\">문법이나 사용 방식은 그대로</span>기 때문에, 기존 방식 그대로 대접해도 타입스크립트\"님\"은 전혀 신경쓰지 않으신다.\r\n\r\n## 행한 기적\r\n\r\n### 타입 명시\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>그가 한 번 손짓하시메, 모든 이가 타입을 가지게 되었노라.</i></p>\r\n\r\n타입스크립트\"님\"은 말 그대로 타입 유추를 가능케 하신다. 모든 인수, 반환에 타입을 지정해줌으로써, 개발자가 해당 인수와 반환이 어떤 타입을 반환하는지 알 수 있게 해주신다.\r\n\r\n``` javascript\r\n/**\r\n * 숫자 두 개 뺏기고 문자열 하나 받기\r\n * \r\n * @param {number} n: 소중한 숫자\r\n * @param {number} m: 귀중한 숫자\r\n * \r\n * @returns {string} 근본없는 문자열\r\n */\r\nfunction add(n, m)\r\n{\r\n\tconst temp = n + m;\r\n\r\n\treturn `${n} + ${m} = ${temp}`;\r\n}\r\n```\r\n\r\n``` typescript\r\n/**\r\n * 덧셈의 권능 목도하기\r\n * \r\n * @param {number} n: 미천한 숫자\r\n * @param {number} m: 가련한 숫자\r\n * \r\n * @returns {string} 광휘의 문자열\r\n */\r\nfunction add(n: number, m: number): string\r\n{\r\n\tconst temp: number = n + m;\r\n\r\n\treturn `${n} + ${m} = ${temp}`;\r\n}\r\n```\r\n\r\n보았는가, 이 차이를. 위 예시에서 볼 수 있듯이 자바스크립트와 타입스크립트\"님\"의 차이는 광야와 같이 크다. 무려 <span class=\"green-600\">모든 인수, 변수에 타입을 부여</span>해주신다.\r\n\r\n따라서 함수의 인수나 반환값으로 이단자들이 출입하는 것을 막아주신다.\r\n\r\n<br />\r\n<br />\r\n\r\n어째 안 해도 될 일을 구태여 하고 있는거 아니냐고? 어제도 당신과 같은 말을 한 이단자가 있<b class=\"red-400\">었</b>지.....\r\n\r\n### IDE 지원\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>그의 사도가 그가 말씀하신대로 코드에 키보드를 내리치니, 광야같던 개발기간이 반으로 갈라지더라.</i></p>\r\n\r\nVSCode를 사용해보면 알겠지만, 자바스크립트의 기본 API 외에 개발자가 직접 설계한 API의 경우 자동완성이 제대로 먹히질 않는다.\r\n\r\n이는 당연한 결과로, IDE는 무지하여 개발자가 직접 작성한 스크립트의 정확한 구조를 모르기 때문이다. JAVA나 C계열 언어처럼 정해진 구조로 명시되지도 않았으므로, IDE 입장에서는 무엇이 어떻게 되어있는 지 전혀 알 수 없다.\r\n\r\n하지만 타입스크립트\"님\"이라면 다르다. 작성한 코드의 모든 타입과 구조가 사전에 명시되기 때문에, <span class=\"primary\">IDE가 이를 파악하고 해당 요소의 하위 객체를 자동완성을 통해 보여준다.</span> 이러한 기능은 높은 개발 생산성으로 이어진다. 즉, 같은 자원으로도 더욱 많은 결과를 내는 오병이어의 기적을 몸소 행하시는 것이다.\r\n\r\n### 객체지향 개발의 용이성\r\n\r\n<p class=\"grey-500\" align=\"center\"><i>수고하고 무거운 짐 진 자들아, 다 내게로 오라. 내가 너희를 쉬게 하리라.</i></p>\r\n\r\n위 같은 이유로 자바스크립트는 객체지향 패턴을 적용하기 난감한 언어였다.(불가능한 건 아니다)\r\n\r\n하지만 타입스크립트\"님\"이 모든 이에게 타입을 부여함으로써, <span class=\"primary\">객체지향 패턴을 적용하는 데 유용</span>하도록 만들어주었다.\r\n\r\n이로 인해 클래스, 인터페이스 등의 개념을 쉽게 적용할 수 있어, JAVA와 같은 객체지향 기반 언어에서 온 자들이 좀 더 편히 머무를 수 있도록 행하셨다.\r\n\r\n## 이단자의 기록\r\n\r\n구태여 이런 난잡스러운 자를 받아들여 없는 고생을 사서 함이, 참으로 통탄할 일이다.\r\n\r\n### 허례허식과 위선\r\n\r\n자바스크립트에선 전혀 신경쓰지 않아도 될 영역임에도 타입스크립트에선 그 잘난 \"타입\"으로 인해 강제되는 영역이 존재한다.\r\n\r\n예를 들어, 하위 컴포넌트가 프로퍼티를 받기 위해선 인터페이스로 타입을 미리 선언해주어야 한다.\r\n\r\n``` typescript\r\ninterface Props {\r\n\twidth: number,\r\n\theight: number,\r\n\tcolor?: string\r\n}\r\n\r\n/**\r\n * 컴포넌트 ReactElement 하사 받기\r\n * \r\n * @param {Props} param0: 프로퍼티\r\n * \r\n * @returns {ReactElement} ReactElement\r\n */\r\nexport default function Component({ width, height, color }: Props): ReactElement\r\n{\r\n\treturn <div style={{ width: width, height: height, color: color || 'white' }}>테스트</div>\r\n}\r\n```\r\n\r\n이 처럼 타입 하나를 선언해주기 위해 인터페이스를 설계하는 등, <span class=\"red-400\">같은 일을 함에 있어서 더 많은 작업을 요구</span>한다.\r\n\r\n이러한 허례허식주의는 코드에 겉치레를 추가함으로써, <span class=\"red-400\">코드의 가독성을 잔혹하게 해치는 결과</span>로 이어진다.\r\n\r\n또한 그 거창한 이름과 달리, 결국 속은 자바스크립트와 다를 것이 없다. 겉으로는 뭔가 대단한 \"척\", 있는 \"척\"을 해대도, 결국 권능을 수행하는 주체는 동일한 자바스크립트다. 이는 곧, <span class=\"red-400\">자바스크립트의 근본적인 문제점, 단점을 동일하게 공유</span>한다는 뜻이다. 이 것이 위선이 아니고 무엇인가.\r\n\r\n### 가혹한 율법\r\n\r\n타입에서 나오는 불편함이야 충분히 이해할 수 있었다. 타입이 주는 명확한 이점도 있으니.\r\n\r\n그럼에도 불구하고 타입스크립트를 차마 이해할 수 없는 점은, 가혹한 규칙에 있다.\r\n\r\n``` typescript\r\n/**\r\n * 테스트 \"목도\"하기\r\n * \r\n * @param {*} color: 색상\r\n * \r\n * @return {*} 요소\r\n */\r\nfunction test(color)\r\n{\r\n\tconst ref = useRef();\r\n\r\n\tuseEffect(() =>\r\n\t{\r\n\t\tref.current.style.backgroundColor = color;\r\n\t});\r\n\r\n\treturn <div ref={ref}>Color</div>;\r\n}\r\n```\r\n\r\n위 코드가 어때 보이는가? 보기엔 매우 평범해보인다. 겉모습 뿐만 아니라, 실제로 자바스크립트로 돌려봐도 문제가 없는 코드다. 그럼에도 불구하고 타입스크립트는 엄격한 규칙에 따라 이를 허용해주지 않는다.\r\n\r\n위 코드에는 아래와 같은 매우 \"중대한\" 오류가 존재한다.\r\n\r\n1. color의 타입이 명시되지 않음\r\n2. test 함수의 반환값이 명시되지 않음\r\n3. useRef()의 타겟이 명시되지 않음\r\n4. ref, ref.current가 존재하지 않을 수도 있음\r\n\r\n이와 같은 이유로 컴파일 단계서부터 거절당한다.\r\n\r\n심지어 4번은 골때리는데, 분명히 존재하는 요소임에도, 심지어 동적으로 렌더링하는 것이 아니라 태초부터 HTML에 기록된 요소마저 <span class=\"grey-400\">\"응? 그거 없을 수도 있는데? 진짜 확실해?? 진짜???\"</span>하며 동작을 거부한다. 착실한 신도조차 미치고 돌아버리다 못 해 그 회전각이 2160도로 돌아간다. 아마 여기서 조금만 더 돌아버리게 만들면 그 신도는 몇 초간 공중에 체공도 할 수 있을 것이라 자신한다.\r\n\r\n``` typescript\r\n/**\r\n * 테스트 \"목도\"하기\r\n * \r\n * @param {number} color: 색상\r\n * \r\n * @return {ReactElement} 요소\r\n */\r\nfunction test(color: string): ReactElement\r\n{\r\n\tconst ref = useRef<HTMLDivElement>(null);\r\n\r\n\tuseEffect((): void =>\r\n\t{\r\n\t\tif (ref && ref.current)\r\n\t\t{\r\n\t\t\tref.current.style.backgroundColor = color;\r\n\t\t}\r\n\t});\r\n\r\n\treturn <div ref={ref}>Color</div>;\r\n}\r\n```\r\n\r\n올바른 사용법은 위와 같다. 이 얼마나 쓸데없는가. 정확한 검증은 그렇다쳐도, 이건 의심병인지 모를 수준으로 모든 요소를 일단 \"없다\"고 가정한다. 나는 이미 있는 걸 증명하고자 갖가지 쓸데없는 허례허식을 통해 이미 존재가 증명된 존재를 직접 증명해야하고.\r\n\r\n# 정리\r\n\r\n그럼에도 불구하고, 타입스크립트\"님\"의 권능은 자바스크립트 개발의 새로운 방향성을 제시하기 충분했다.\r\n\r\n특히 JAVA나 C# 같은 타이트한 객체지향을 먼저 시작한 나로써는 자바스크립트의 그 모호함이 정말 싫었는데, 타입스크립트는 타입과 정형화를 통해 이런 불편함을 충분히 해소시켜줄만한 것이였다.\r\n\r\n하지만, 자바스크립트나 리액트가 아직 익숙하지 않다면 타입스크립트\"님\"의 영접은 시기상조일 수도 있다고도 생각한다. 위에 기술된 이단자의 기록처럼, 타입스크립트\"님\"의 권능은 기존에 없던 주변코드를 요구하게 되며, 이는 곧 코드의 진입장벽으로 이어지게 될 것이다.\r\n\r\n과유불급이다. 현세의 종교 역시 이를 맹신하며 본래의 일을 소홀히하면 필연적으로 문제를 일으키게 된다. 당신 역시 타입스크립트\"님\"의 권능을 맹목적으로 받기 위해 애쓰다 정작 중요한 일을 그르치지 말도록 하자.\r\n\r\n# 여담\r\n\r\n<span class=\"grey-600\">내가 뭘 쓴거야...</span>","url":["2021-09-21-nextjs-reorganization-2","2021","09","21","nextjs-reorganization-2"]}],"data":{"header":{"title":"[NextJS] 블로그 개편기 - 1. Record One","excerpt":"인터넷으로 알음알음 React를 배워, 뭣도 모르고 호기롭게 블로그를 개발한지가 5월이였다. 그 때만 해도 이 재밌는 걸 가지고 뭐라도 만들어보고 싶다는 강한 열망에 사로잡혔었는데, 그 때 눈에 보였던 게 개발 블로그였다. 그 때 내가 사용하던 블로그는 Jekyll 기반의 GitHub 블로그였는데, 재밌어보여서 시작했다가 며칠 안 가 관둔지가 1년이 넘었었다. 블로그에 흥미가 떨어진 이유 중 하나가 뭐 좀 할라치면 남이 작성한 코드를 일일히 분석한다는 스트레스였다. 개발 블로그를 보자마자 떠오른 내 머릿속의 흐름은 대충 저랬다.","coverImage":"https://user-images.githubusercontent.com/50317129/134931033-89954c3d-5e00-4b3b-85aa-54a1dfa29e46.png","date":"2021-09-21T03:22:35","type":"posts","category":"NextJS","tag":["NextJS","React"],"group":"블로그 개편기","comment":true,"publish":true},"name":"2021-09-21-nextjs-reorganization-1.md","content":"<h1 id=\"개요\">개요 <a href=\"#개요\">🔗</a></h1><p>인터넷으로 알음알음 <span class=\"lightBlue-600\">React</span>를 배워, 뭣도 모르고 호기롭게 블로그를 개발한지가 5월이였다. 그 때만 해도 이 재밌는 걸 가지고 뭐라도 만들어보고 싶다는 강한 열망에 사로잡혔었는데, 그 때 눈에 보였던 게 개발 블로그였다.</p>\n<p>그 때 내가 사용하던 블로그는 <span class=\"pink-600\">Jekyll</span> 기반의 GitHub 블로그였는데, 재밌어보여서 시작했다가 며칠 안 가 관둔지가 1년이 넘었었다. 블로그에 흥미가 떨어진 이유 중 하나가 뭐 좀 할라치면 남이 작성한 코드를 일일히 분석한다는 스트레스였다. 개발 블로그를 보자마자 떠오른 내 머릿속의 흐름은 대충 저랬다.</p>\n<ol>\n<li>나 빼고 다 하는 개발 블로그 나도 다시 해야하지 않나?</li>\n<li>저번에 테마 받아서 만들어둔거, 여기서기 수정해서 소스도 개판이라 다시 쳐다보기 싫은데....</li>\n<li>정적 블로그는 백엔드 롤도 없어서 간단하니 내 React 지식 정도로도 만들 수 있지 않을까?</li>\n<li>내 개발 블로그를 내가 직접 만들면 개발자로써의 보람도 있을 것 같은데..</li>\n<li>내가 만들었으니 꾸준히 관리할 수 있지 않을까? 어차피 다 내가 짠거잖아?</li>\n</ol>\n<p>거기까지 생각이 미친 난 블로그 개발을 시작했고, 퇴근 후 틈틈히 만들다보니 기간은 한 두달? 정도 걸리지 않았나 싶다.</p>\n<p>나름 머릿속에 구상한 디자인은 얼추 잘 나온 것 같았는데, 문제가 생겼다. <span class=\"red-600\">블로그가 느려도 너무 느렸다.</span> HTML 레이아웃이 뜨고 난 뒤, CSS가 입혀 렌더링되기까지 과정이 눈에 보일 정도였다. 더군다나 정적임에도 불구하고 라우팅엔 뭐가 그리 시간이 필요한지...</p>\n<p>참고 쓰다가, 이렇게 놔뒀다가는 <span class=\"blue-500\">\"내가 직접 개발했어요!\"</span>라는 말이 <span class=\"blue-500\">\"내가 이렇게 실력이 병x신 같습니다 엌ㅋㅋㅋㅋㅋ\"</span>이나 마찬가질거란 생각이 들었다. 더군다나 구글이나 네이버에 검색 등록도 해야하는데 이러면 전세계 사람들에게까지 광고하는 꼴이니 이대로는 안 됐다.</p>\n<p>그렇게 난 첫 배포 두 달만에 대대적인 개편을 시작했다. 개편 과정에서 처음 접해보는 언어나 여러 시행착오가 있었기에, 혹시 나와 비슷한 문제로 고통받는 영혼들이 조금이나마 쉴 수 있도록 개발기를 작성한다.</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<p><del class=\"grey-500\">사실 추석이라 심심하다.</del></p>\n","url":["2021-09-21-nextjs-reorganization-1","2021","09","21","nextjs-reorganization-1"],"toc":[{"text":"개요","tag":"개요","depth":1}]},"hash":"2c6cb9be1cb"},"__N_SSG":true}