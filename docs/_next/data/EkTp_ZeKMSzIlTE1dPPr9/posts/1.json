{"pageProps":{"posts":[{"header":{"title":"[라즈베리파이 4] Ubuntu에 톰캣 설치하기","excerpt":"OS가 준비되었으므로 본격적으로 웹 서버 환경을 구축해보자. 대표적인 WAS인 Tomcat을 활용하여 페이지를 호스팅한다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-09-02T23:07:19","type":"posts","category":"RaspberryPi","tag":["라즈베리파이","Ubuntu","Tomcat(톰캣)"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-09-02-ubuntu-in-tomcat.md","content":"\r\n# 개요\r\n\r\nOS가 준비되었으므로 본격적으로 웹 서버 환경을 구축해보자. 대표적인 WAS인 Tomcat을 활용하여 페이지를 호스팅한다.\r\n\r\n* Tomcat 9.0.50\r\n\r\n# 웹 서버 구축하기\r\n\r\n아래의 과정을 통해 Ubuntu 서버에 웹 서버를 구축하자.\r\n\r\n## 1. JAVA 설치\r\n\r\n우리가 사용할 WAS는 Tomcat으로, 구동 시 WAS를 필요로한다.\r\n\r\n``` bash\r\nsudo apt-get install openjdk-15-jdk\r\n```\r\n\r\n원하는 JAVA 버전을 설치한다. 본 문서에서는 최신 버전인 JAVA 15를 설치한다.\r\n\r\n``` bash\r\njava -version\r\n```\r\n\r\n``` output\r\nopenjdk version \"15.0.3\" 2021-04-20\r\nOpenJDK Runtime Environment (build 15.0.3+3-Ubuntu-1)\r\nOpenJDK 64-Bit Server VM (build 15.0.3+3-Ubuntu-1, mixed mode, sharing)\r\n```\r\n\r\n`java -version` 명령어를 수행하여 위와 같은 형식의 결과물이 출력되면 JAVA 설치가 완료된 것이다.\r\n\r\n## 2. 환경변수 설정\r\n\r\nJAVA 환경변수를 설정한다. 자바 컴파일러인 `javac` 명령어 입력 시 실제로 호출되는 파일의 경로를 확인하여 설치 경로를 찾는다.\r\n\r\n``` bash\r\nwhich javac\r\n```\r\n\r\n``` output\r\n/usr/lib/jvm/java-15-openjdk-arm64/bin/javac\r\n```\r\n\r\n`which` 명령어는 명령어의 위치를 찾아주는 명령어다. 이를 입력하여 위치를 확인하면 위와 같은 경로가 나온다. `java-{VERSION}-openjdk-arm64`과 같은 폴더에 설치되어있으며, 버전마다 폴더명이 조금씩 다르다.\r\n\r\n위 경로는 폴더가 아닌, 명령어 파일의 경로다. `JAVA_HOME`은 자바가 설치된 최상위 경로인 `/usr/lib/jvm/java-15-openjdk-arm64`가 된다.\r\n\r\n사용자 설정파일인 `.profile`에 환경변수를 지정한다.\r\n\r\n``` bash\r\nvi ~/.profile\r\n```\r\n\r\n``` input\r\nexport JAVA_HOME=/usr/lib/jvm/java-15-openjdk-arm64\r\nexport PATH=$JAVA_HOME/bin:$PATH\r\n```\r\n\r\n사용자 설정파일을 열어 위 내용을 입력한다. `a` 혹은 `i`를 눌러 작성할 수 있다. 작성 이후 `:wq`를 입력하여 저장하면 된다.\r\n\r\n``` bash\r\nsource ~/.profile\r\n```\r\n\r\n위 명령어를 입력하여 변경된 사용자 설정파일을 갱신한다. 이를 입력하지 않으면 해당 쉘에서는 변경된 환경변수가 반영되지 않는다.\r\n\r\n## 3. Tomcat 설치\r\n\r\n``` bash\r\nsudo apt-get install tomcat9\r\nsudo apt-get install libtcnative-1\r\n```\r\n\r\n`tomcat9`는 Tomcat 9버전이고, `libtcnative-1` 패키지를 설치하여 컴파일없이 Tomcat Native를 활성화할 수 있다.\r\n\r\nTomcat Native 찾다보면 `./configure`, `make` 같은 명령어가 나오기도 하는데, Tomcat Native 모듈을 직접 컴파일하는 방식이니 참고할 것.\r\n\r\n톰캣의 설치 경로는 `/var/lib/tomcat9`다.\r\n\r\n``` bash\r\n# 톰캣 기동\r\nsystemctl start tomcat9\r\n\r\n# 톰캣 정지\r\nsystemctl stop tomcat9\r\n\r\n# 톰캣 재기동\r\nsystemctl restart tomcat9\r\n```\r\n\r\n위 명령어를 통해 톰캣 서비스를 on/off할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131715233-e70c15ac-0e38-48f3-8618-96b63a87ee0e.png)\r\n\r\nTomcat Native 활성화 여부는 로그에서 확인할 수 있으며, 로그에 위와 같은 문구가 출력되면 Tomcat Native가 활성화된 것이다.\r\n\r\n``` bash\r\ncd /var/log/tomcat9\r\n```\r\n\r\nTomcat9 기준 로그는 위와 같으며, `catalina.yyyy-MM-dd.log` 형태의 파일을 열면 확인할 수 있다.\r\n\r\n## 4. 포트 개방\r\n\r\n통신에 사용할 포트를 개방한다.\r\n\r\nUbuntu는 <span class=\"primary\">ufw</span>로 방화벽 설정을 쉽게 관리할 수 있다.\r\n\r\n``` bash\r\nsudo apt-get install ufw\r\n```\r\n\r\n위 명령어를 입력하여 ufw를 설치할 수 있다.\r\n\r\n``` bash\r\n# ufw 활성화\r\nsudo ufw enable\r\n\r\n# ufw 비활성화\r\nsudo ufw disable\r\n\r\n# ufw 상태 확인\r\nsudo ufw status verbose\r\n```\r\n\r\nufw를 설치하면 기본적으로 비활성화되어있으므로, `sudo ufw enable` 명령어를 통해 활성화시킨다.\r\n\r\n``` bash\r\n# 22번(SSH) 포트 허용\r\nsudo ufw allow 22\r\n\r\n# 22번 포트 차단\r\nsudo ufw deny 22\r\n\r\n# 1.1.1.1 IP에게만 22번 포트 개방\r\nsudo ufw allow from 1.1.1.1 to any port 22\r\n\r\n# 1.1.1.1 ~ 10 IP 대역에게만 22번 포트 폐쇄\r\nsudo ufw deny from 1.1.1.1/10 to any port 22\r\n```\r\n\r\n위와 같은 방식으로 포트 정책을 구성할 수 있다.\r\n\r\nTomcat의 경우 `8080`을 기본 포트로 사용하므로 해당 포트를 개방한다.\r\n\r\n``` bash\r\nsudo ufw allow 8080\r\n```\r\n\r\n## 4. 페이지 호스팅 확인\r\n\r\n``` bash\r\nifconfig -a\r\n```\r\n\r\n위 명령어를 입력하면 연결된 IP를 알 수 있으나, 공유기를 사용할 경우 `192.168.0.x`와 같은 사설 IP가 표시된다. 이 경우 공유기 설정에서 들어오는 실제 IP를 확인하자.\r\n\r\n* `eth0` - 이더넷 정보\r\n* `wlan0` - 무선랜 정보\r\n\r\n인터넷 연결 방식에 따라 위와 같이 구분된다. 동일한 방식으로 여러개가 연결되어있다면 숫자가 1씩 늘어난다.\r\n\r\n라즈베리파이의 IP `xxx.xxx.xxx.xxx:8080`에 접속하여 톰캣 페이지가 정상적으로 출력되는지 확인하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131716513-505d0ed5-32ef-423e-b86d-d020253cede0.png)\r\n\r\n별다른 설정을 변경하지 않았을 경우 위와 같은 관리자 페이지가 표시될 것이다.\r\n\r\n만약 정상적으로 출력되지 않는다면 아래 항복을 확인해보자.\r\n\r\n* 인터넷 연결이 정상적인지\r\n* 라즈베리파이에 연결된 IP가 맞는지\r\n* Tomcat 서비스 포트가 개방되어있는지\r\n* Tomcat이 정상적으로 구동되었는지\r\n\r\n# 목표\r\n\r\n* <del class=\"grey-400\">라즈베리파이에 Ubuntu 서버를 구축한다.</del>\r\n* <del class=\"grey-400\">Tomcat을 구동하여 페이지를 호스팅한다.</del>\r\n* 도메인을 입힌다.\r\n* SSH, RDP 등의 원격 통신환경을 구축한다.\r\n* MariaDB를 설치하여 DB 통신을 수행한다.","url":["2021-09-02-ubuntu-in-tomcat","2021","09","02","ubuntu-in-tomcat"]},{"header":{"title":"[라즈베리파이 4] 라즈베리파이에 Unbuntu 설치하기","excerpt":"목요일을 기점으로 모든 준비물의 배송이 완료됐다. 클린 상태의 라즈베리파이는 OS가 별도로 깔려있지 않은 FreeDOS 상태이므로, 직접 OS를 설치해야한다. 컴퓨터도 주기적으로 포맷하고, 가상머신도 몇 개 돌려본 나로썬 크게 문제될 건 없지만, 이건 내가 지금까지 다루던 컴퓨터와는 좀 다르다는점이 흠. 한 번도 다뤄보지 않은 장비인데다, 일반적인 데스크탑에 비해 여러 차이점과 제약사항이 있어 그리 순탄하진 않았다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-08-31T01:51:39","type":"posts","category":"RaspberryPi","tag":["라즈베리파이","Ubuntu"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-08-31-ubuntu-in-raspberry.md","content":"\r\n# 개요\r\n\r\n목요일을 기점으로 모든 준비물의 배송이 완료됐다. 클린 상태의 라즈베리파이는 OS가 별도로 깔려있지 않은 FreeDOS 상태이므로, 직접 OS를 설치해야한다. 컴퓨터도 주기적으로 포맷하고, 가상머신도 몇 개 돌려본 나로썬 크게 문제될 건 없지만, 이건 내가 지금까지 다루던 컴퓨터와는 좀 다르다는점이 흠.\r\n\r\n한 번도 다뤄보지 않은 장비인데다, 일반적인 데스크탑에 비해 여러 차이점과 제약사항이 있어 그리 순탄하진 않았다.\r\n\r\n# Rasbian? Ubuntu?\r\n\r\n라즈베리파이는 전용 OS인 <span class=\"pink-600\">Raspbian</span>이 존재한다. Raspbian은 라즈베리파이에 가장 최적화된 OS이므로 라즈베리파이의 네이티브한 영역을 쉽게 다룰 수 있을 것이다.\r\n\r\n하지만 난 라즈베리파이를 다룬다기보단 라즈베리파이를 통해 서버를 구축할 예정이므로, Raspbian보단 훨씬 범용적인 OS가 알맞다. 이를테면 CentOS 같은 거 말이다.\r\n\r\n그 중에서 내가 선택한 OS는 Ubuntu. CentOS는 RHEL에서 인수한 뒤 CentOS의 가장 큰 장점인 RHEL과의 동일성을 아작내놨다. 굳이 쓸 필요가 없어진 셈.\r\n\r\n때문에 이전부터 써보고 싶기도 했고, 한국인에게 가장 친숙한 Linux인 Ubuntu를 설치하고자 한다.\r\n\r\n익숙하지 않은 라즈베리파이로의 설치는 물론 관련 정보들을 쉽게 얻을 수 있을 것이다.\r\n\r\n# 라즈베이파이에 Ubuntu 설치하기\r\n\r\n본격적으로 라즈베리파이에 Ubuntu를 설치해보자.\r\n\r\n## 준비물\r\n\r\n* Raspberry Pi 4 Model B\r\n* 전원 케이블 (5V 3A 이상)\r\n* MicroSD, 리더기 (구형 펌웨어일 경우)\r\n* Micro HDMI, 혹은 HDMI 케이블 (모니터 쓸 경우)\r\n\r\n준비물은 위와 같다.\r\n\r\n원래 기본적으로 라즈베리파이는 MicroSD 이외에는 인식하지 않는다. USB같은 외장 디스크를 인식하려면 펌웨어의 업데이트가 필요하다.\r\n\r\n<span class=\"red-600\">2020년 8월 이후 출시된 보드의 경우 펌웨어가 기본적으로 업데이트</span>된다고 한다. 난 중고로 샀는데, 8월 이전 출시된 보드인지 USB를 바로 인식하지 않았었다.\r\n\r\n펌웨어 업데이트는 OS설치 후 가능하므로, 만약 <span class=\"red-600\">구형 보드라면 얄쨜없이 MicroSD가 필요</span>하니 참고할 것.\r\n\r\n<br />\r\n\r\n라즈베리파이는 기본적으로 Micro HDMI라고 하는 작은 단자를 제공한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131310544-4fc47a26-b541-45e1-ac8c-4586bcbdc978.png)\r\n\r\n위 사진의 좌측 단자가 일반적으로 알고있는 HDMI, 우측의 작은 단자가 Micro HDMI다. Argon M2 케이스의 경우 Micro HDMI와 연결된 HDMI 단자를 제공해주므로 상관없었으나, 별도의 케이스나 커넥터 없이 모니터를 연결할 경우 위 사진과 같은 <span class=\"amber-500\">Micro HDMI to HDMI</span> 케이블이 필요하니 주의할 것.\r\n\r\n## Ubuntu 설치파일 다운로드\r\n\r\n디스크에 Ubuntu를 설치하기위해 아래 두 파일을 다운로드하자.\r\n\r\n* [이미지 레코더 BalenaEtcher 다운로드](https://www.balena.io/etcher/)\r\n* [Ubuntu ISO 다운로드](https://ubuntu.com/download/raspberry-pi)\r\n\r\n이미지 레코더는 부팅 디스크를 만들어준다. Windows 포맷 USB를 만드는 과정이라고 생각하면 된다.\r\n\r\nUbuntu는 Linux이므로, 위 경로에서 쉽게 다운로드 받을 수 있다.\r\n\r\n* <span class=\"orange-600\">Ubuntu Server</span> - CLI 기반 (GUI 없음)\r\n* <span class=\"orange-600\">Ubuntu Desktop</span> - GUI 기반 (설치 시 모니터 필요)\r\n\r\n페이지에 접속하면 두 버전을 다운로드 받을 수 있다. Desktop은 우리가 일반적으로 알고있는 GUI 기반의 OS다. Server는 DOS같은 명령어 기반의 CLI OS다. 어떤 걸 설치해도 상관없으나 Linux에 익숙하지 않다면 Desktop을 추천한다. 하지만 <span class=\"red-500\">GUI 기반이므로 설치 후 OS 셋팅 시 모니터가 필요함</span>에 유의하자.\r\n\r\n이 문서에서는 Ubuntu Desktop을 설치한다. Electron 같은 UI 프로그램이나 Ubuntu에서의 웹 페이지 테스트를 위해선 GUI 환경이 필요하다. CLI에선 브라우저를 띄우는 등의 행위가 불가능하기 때문. Ubuntu Server도 추후 관련 프로그램을 설치하여 GUI 환경으로 구동할 수 있다.\r\n\r\n## Ubuntu 부팅 디스크 만들기\r\n\r\n아래의 과정을 통해 부팅 디스크를 만든다. 본문에서는 MicroSD로 진행한다. 디스크 종류가 달라진다고 해서 과정이 달라지지 않으니 걱정하지 않아도 된다.\r\n\r\n### 1. BalenaEtcher 실행\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131342380-c9c0d006-e4cf-457a-9cbf-66ffcfbf8e4f.png)\r\n\r\nUSB를 꽂고 다운로드받은 <span class=\"green-400\">BalenaEtcher를 실행</span>한다.\r\n\r\n### 2. Ubuntu ISO 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131342500-b406e9e9-c72f-41f6-aedb-1e1d88f678f7.png)\r\n\r\n다운로드받은 <span class=\"green-400\">Ubuntu ISO를 선택</span>한다. 선택한 ISO가 디스크에 기록될 것이다.\r\n\r\nUbuntu Desktop ISO는 용량이 많음에 유의하자.\r\n\r\n### 3. 디스크 드라이브 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131343798-ae4caaa3-5b39-42cc-8d87-362bde5ad5eb.png)\r\n\r\nISO가 기록될 디스크 드라이브를 선택한다.\r\n\r\n<span class=\"blue-400\">[Show hidden]</span>을 클릭하면 USB 형태의 외장 드라이브 뿐만 아니라, M2 혹은 SATA와 연결된 D드라이브 등도 선택 가능하다. 물론 그럴일은 없겠지만, 시스템 드라이브는 선택 불가능하다.\r\n\r\n### 4. 디스크 기록\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131343897-2ab71120-ba0e-4a10-9e20-85b7f562f25c.png)\r\n\r\n모든 선택이 완료되면 <span class=\"blue-400\">[Flash!]</span> 버튼을 클릭하여 부팅 디스크를 만든다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131344037-dd53f8e7-4a66-4e3e-90d5-dd06bdf79904.png)\r\n\r\nSSD같이 Disk I/O가 빠르면 금방 끝나지만, 느리면 수 분의 시간이 걸린다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131344661-ef5737a7-e2b8-483b-88af-9f79318c6661.png)\r\n\r\n완료되면 위와 같은 화면이 뜬다.\r\n\r\n디스크를 뺐다 껴서 다시 인식시키면 아래 두 디스크가 인식된다.\r\n\r\n* `system-boot` 혹은 `boot` - 부팅 디스크\r\n* 메인 디스크\r\n\r\n이 부팅 디스크를 라즈베리파이에 연결하면 Ubuntu를 사용할 수 있다.\r\n\r\n## 라즈베리파이 연결\r\n\r\n부팅 디스크를 라즈베리파이에 연결하자. MicroSD라면 칩 아래쪽에, USB라면 USB 단자 등 맞는 방식으로 연결하면 된다.\r\n\r\n정상적으로 부팅되면 빨간불과 함께 녹색불이 점멸한다. <span class=\"red-500\">빨간불만 뜨면 부팅 중 문제가 있다는 뜻</span>이다. 이 경우 모니터를 연결해야 자세한 문제를 확인할 수 있다.\r\n\r\n이후 셋팅은 일반적인 Ubuntu 사용과 동일하다. 사용자 생성하고 설정값 지정하고 그런 것들.\r\n\r\n본인이 MicroSD가 아닌 USB로 부팅디스크를 만들었는데, 화면에서 <span class=\"red-500\">USB Stop</span>이라는 문구가 뜨며 반복적으로 Fail이 뜨면 USB를 인식할 수 없는 구형보드라는 뜻이다. \r\n\r\nMicroSD 정도로 만족하거나, 신형 보드라서 애초에 USB나 SSD를 부팅 디스크로 사용했다면 그냥 쓰면 된다. 하지만 본인의 라즈베리파이의 펌웨어가 구형이고, MicroSD로는 만족할 수 없다면 아래의 과정을 통해 펌웨어 업데이트를 진행해야한다.\r\n\r\n# 펌웨어 업데이트\r\n\r\n<p class=\"red-600\" align=\"center\">USB가 인식되는 신형 펌웨어는 수행할 필요 없음</p>\r\n\r\n라즈베리파이가 USB나 SSD를 부팅 디스크로 인식할 수 있도록 펌웨어를 업데이트한다.\r\n\r\n펌웨어 업데이트는 반드시 라즈베리파이에 OS가 설치된 후에 진행할 수 있다. 즉, 구형 보드에서 SSD로 부팅하려면 MicroSD로 부팅 한 번, 펌웨어 업데이트 후 SSD로 부팅 한 번으로 총 두 개의 부팅 디스크를 만들어야 한다.\r\n\r\n## 1. 패키지 최신화\r\n\r\n먼저, 터미널을 열어 아래 두 명령어를 입력한다.\r\n\r\n``` bash\r\nsudo apt-get update\r\nsudo apt-get upgrade\r\n```\r\n\r\n패키지 저장소 및 설치된 패키지를 최신화한다.\r\n\r\n## 2. 설정값 변경\r\n\r\n업데이트가 완료되면 아래의 명령어를 입력하여 해당 파일의 내용을 변경한다.\r\n\r\n``` bash\r\nsudo vim /etc/default/rpi-eeprom-update\r\n```\r\n\r\n`FIRMWARE_RELEASE_STATUS=\"critical\"` 설정값에서 `critical`을 `stable`로 변경한다.\r\n\r\n즉, `FIRMWARE_RELEASE_STATUS=\"stable\"`로 변경해주면 된다.\r\n\r\n## 3. 부트로더 업데이트\r\n\r\n이제 부트로더를 업데이트한다.\r\n\r\n``` bash\r\nsudo rpi-eeprom-update -d -f /lib/firmware/raspberrypi/bootloader/stable/pieeprom-2020-06-15.bin\r\n```\r\n\r\n해당 경로에 가보면 `2020-06-15` 버전 말고도 `2020-07-16`, `2020-12-11` 등 다양한 버전이 있는데, 대부분 위 버전을 추천하는 것 같다.\r\n\r\n필자는 최신버전을 좋아해서, 버전 중 가장 최신이였던 `2020-12-11`로 업데이트했으나 설정값이 이상하여 결국 상기한 `2020-06-15` 버전으로 다시 업데이트했다. 업데이트는 금방되니 부담가질 필요는 없다.\r\n\r\n## 4. 확인\r\n\r\n``` bash\r\nsudo reboot\r\n```\r\n\r\n부트로더 업데이트가 완료되면 기기를 재부팅한다.\r\n\r\n재부팅이 완료되면 아래의 명령어를 입력하여 USB를 인식할 수 있는지 확인하자.\r\n\r\n``` bash\r\nsudo vcgencmd bootloader_config\r\n```\r\n\r\n``` output\r\n[all]\r\nBOOT_UART=0\r\nWAKE_ON_GPIO=1\r\nPOWER_OFF_ON_HALT=0\r\nDHCP_TIMEOUT=45000\r\nDHCP_REQ_TIMEOUT=4000\r\nTFTP_FILE_TIMEOUT=30000\r\nENABLE_SELF_UPDATE=1\r\nDISABLE_HDMI=0\r\nBOOT_ORDER=0xf41\r\n```\r\n\r\n위 명령어를 입력하면 이와 같은 형식의 설정값이 출력된다. 다른건 상관없고, `BOOT_ORDER`의 값이 `0xf41`라면 정상적으로 업데이트가 완료된 것이다.\r\n\r\n이제 라즈베리파이가 USB를 부팅 디스크로 인식할 수 있다.\r\n\r\n디스크의 값이 아닌 라즈베리파이 기기 자체의 펌웨어가 업데이트된 것이므로, MicroSD에서 USB로 디스크가 바뀌어도 업데이트는 유지된다. 필자는 이걸 몰라서 쓸데없는 고민을 했었다.\r\n\r\n## 5. 부팅 디스크 재생성\r\n\r\n이제 MicroSD의 역할은 모두 끝났다. 나중을 대비해 MicroSD는 고이 모셔두자. 아주 간간히 쓸 일이 생기기도 하고 그런다.\r\n\r\nUSB, SSD 등 원하는 디스크에다 본문의 [부팅 디스크 만들기](#Ubuntu-부팅%20디스크%20만들기) 과정을 다시 수행한다.\r\n\r\n# 설정\r\n\r\nUbuntu 설치가 완료되면, 이후는 우리가 아는 일반적인 OS 셋팅이 진행된다.\r\n\r\nUbuntu Desktop의 경우, 언어, 계정 등의 설정이 추가로 진행된다.\r\n\r\nUbuntu Server의 경우, CLI 환경이므로 별도의 설정이 필요하지 않다. 기본 계정이 생성되며, 아이디와 비밀번호 모두 동일하게 ubuntu다. 로그인 후 바꿔주자. \r\n\r\n# 목표\r\n\r\n* <del class=\"grey-400\">라즈베리파이에 Ubuntu 서버를 구축한다.</del>\r\n* 도메인을 입힌다.\r\n* SSH, RDP 등의 원격 통신환경을 구축한다.\r\n* Tomcat을 구동하여 페이지를 호스팅한다\r\n* MariaDB를 설치하여 DB 통신을 수행한다.","url":["2021-08-31-ubuntu-in-raspberry","2021","08","31","ubuntu-in-raspberry"]},{"header":{"title":"[라즈베리파이 4] Hello Raspberry!","excerpt":"개발자의 적지않은 수가 클라우드든, 디바이스든 자신만의 서버를 구축하여 다양하게 활용하고 있다. 개발을 하다보면 필연적으로 24시간 언제나 가동되는 서버 비스무리한 것이 필요할 때가 있다. 일례로 GitHub Pages의 경우 정적 페이지만 호스팅해줄 뿐, 백엔드나 DB는 사용할 수가 없어 동적 페이지 호스팅은 불가능하다. 그러나 개인 API 혹은 DB 서버가 존재한다면, 해당 서버와의 통신을 통해 더욱 동적 페이지 호스팅이 가능하다. 웹에서 백엔드가 갖는 역할을 생각해본다면, 개인이 활용 가능한 서버가 있고 없고의 차이는 천지차이가 난다. 나 역시도 개발하는 입장에서 제약없이 사용할 수 있는 서버의 소요가 이전부터 있어왔고, 개인 서버를 구축하기 위한 방안을 모색했다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-08-29T13:41:41","type":"posts","category":"RaspberryPi","tag":["라즈베리파이"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-08-29-hello-raspberry.md","content":"\r\n# 서버가 필요해!\r\n\r\n개발자의 적지않은 수가 클라우드든, 디바이스든 자신만의 서버를 구축하여 다양하게 활용하고 있다.\r\n\r\n개발을 하다보면 필연적으로 24시간 언제나 가동되는 서버 비스무리한 것이 필요할 때가 있다. 일례로 GitHub Pages의 경우 정적 페이지만 호스팅해줄 뿐, 백엔드나 DB는 사용할 수가 없어 동적 페이지 호스팅은 불가능하다.\r\n\r\n그러나 개인 API 혹은 DB 서버가 존재한다면, 해당 서버와의 통신을 통해 더욱 동적 페이지 호스팅이 가능하다. 웹에서 백엔드가 갖는 역할을 생각해본다면, 개인이 활용 가능한 서버가 있고 없고의 차이는 천지차이가 난다.\r\n\r\n나 역시도 개발하는 입장에서 제약없이 사용할 수 있는 서버의 소요가 이전부터 있어왔고, 개인 서버를 구축하기 위한 방안을 모색했다.\r\n\r\n# Hello, Raspberry Pi\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png)\r\n\r\n많은 선택지가 있었지만, 내가 선택한 방안은 <span class=\"pink-700\">Raspberry Pi</span>를 통해 서버환경을 구축하는 것이였다.\r\n\r\n한창 트렌디한 <span class=\"orange-500\">Cloud</span> 플랫폼, 서버 호스팅 서비스도 있었지만, 여러 요인을 비교해본 결과 라즈베이 파이가 적절하다고 생각했다.\r\n\r\n# 왜 하필?\r\n\r\n근래 들어 AWS를 필두로 클라우드 시장이 크게 활성화됐다. 덕분에 국/내외를 막론하고 여러 양질의 클라우드 서비스 제공처가 생겼다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131238859-18b9cccd-4d6b-4e38-b279-c0faa66d4815.png)\r\n\r\n클라우드 서비스를 활용하면 개인 서버를 쉽게 구축할 수 있겠지만, 그럼에도 불구하고 난 라즈베리 파이를 선택했다.\r\n\r\n크게 비용적 측면, 학구적 측면에서 생각했다.\r\n\r\n## 비용적 측면\r\n\r\n라즈베리 파이를 선택한 가장 큰 이유.\r\n\r\n몇 번 테스트삼아 쓸 것도 아니고, WAS, DB 등 각종 개발 관련 툴을 구동하려는 나로써는 서버의 사양 또한 쉽사리 무시할 수 없는 요소 중 하나다.\r\n\r\n높은 사양은 당연하게도 높은 비용으로 직결된다. 하지만 난 돈이 없다. 그렇다고 마냥 아낄 건 아니다만, 최대한 합리적인 선택지를 취할 필요가 있었다.\r\n\r\n내가 원하는 조건은 아래와 같았다.\r\n\r\n* 하나 이상의 Tomcat을 구동하는데 무리가 없을 것.\r\n* 하나 이상의 DBMS를 구동하는데 무리가 없을 것.\r\n* 최소 100GB 이상의 데이터를 보관할 수 있을 것.\r\n* 최대한 적은 유지비를 요구할 것.\r\n\r\n위 조건을 충족하기 위해선 많은 RAM, 디스크 용량이 필요했다. SSD일 경우 가격은 가격은 더욱 상승할 것이고. 서버에서 컴파일같은 연산 작업의 소요는 거의 없을 것 같아 CPU는 크게 신경쓰지 않았다.\r\n\r\n<span class=\"orange-500\">AWS</span>와 <span class=\"pink-700\">Raspberry Pi</span>를 비교하면 아래와 같이 정리할 수 있다.\r\n\r\n|  구분   | <span class=\"orange-500\">AWS LightSail</span> | <span class=\"pink-700\">Raspberry Pi 4 Model B</span> |\r\n| :-----: | :-------------------------------------------: | :--------------------------------------------------: |\r\n|   CPU   |                     2Core                     |                        4Core                         |\r\n|   RAM   |                      8GB                      |                         8GB                          |\r\n|   VGA   |                       X                       |                    O (Support 4K)                    |\r\n|   SSD   |                     320GB                     |                     256GB (별도)                     |\r\n| Pricing |                40$ / per month                |                   160,000 (영구적)                   |\r\n\r\nCPU와 VGA는 위 조건의 영향을 적게 받으므로 제외하고 본다면 AWS가 우수해보인다. 하지만 AWS는 40$라는 적지않은 돈이 **매 달** 과금된다는 게 문제. 라즈베리 파이가 16만원에 영구적인 소장이 가능함을 감안하면 4개월 이후부터 AWS의 비용이 지속적으로 늘어난다. 환율을 천 원으로 감안했음에도 이 정도다.\r\n\r\nAWS에서 가성비로 호평받는 LightSail이 이정도면 EC2는 볼 필요도 없는 셈.\r\n\r\n장기적인 측면에서 볼 때 비용적으론 라즈베리 파이가 우수하다.\r\n\r\n## 학구적 측면\r\n\r\n서버를 다루고, 새로운 OS를 접한다는 것 자체도 개발자에겐 하나의 스펙으로 작용할 수 있다.\r\n\r\nAWS 역시 클라우드 업계의 대표로, 최근의 회사들은 AWS를 다루는 능력 또한 중요하게 보고있다.\r\n\r\n스펙적인 면을 감안하면 AWS가 훨씬 우세하지만, AWS나 라즈베리파이나 결국 서버의 범주에 들어가므로 서버를 학습하는덴 크게 무리는 없을 것이다.\r\n\r\n라즈베리파이는 처음부터 끝까지 사용자가 직접 구축해야하지만, 이 점이 오히려 학구적으로는 장점으로 작용할 것이다.\r\n\r\n# 장비 목록\r\n\r\n어떤 장비를 구입했는지 살펴보자. 가능한한 중고품을 적극적으로 활용했다.\r\n\r\n|  구분  |          이름          |                          가격                           |\r\n| :----: | :--------------------: | :-----------------------------------------------------: |\r\n| Device | Raspberry Pi 4 Model B | 60,000원 <span class=\"grey-600\">(정가 104,000원)</span> |\r\n|  SSD   | SAMSUNG 256GB M2 SATA  | 31,000원 <span class=\"grey-600\">(정가 57,900원)</span>  |\r\n|  Case  |      Argon ONE M2      |                        59,000원                         |\r\n| Power  |      5V 4A 어댑터      |                        10,200원                         |\r\n|  기타  |    MicroSD, 리더기     |                       총 6,400원                        |\r\n|  총합  |          6종           |                        237,500원                        |\r\n\r\n케이스, SSD 등의 별매품을 구매하는데 비용이 좀 소요됐다. 아마 정가로 샀다면 30만원 정도 되지 않았을까 싶다.\r\n\r\n기기를 6만원주고 샀는데 케이스가 6만원 가까이되는 이 아이러니함. 저 케이스는 중고품이 없어서 어쩔 수 없었다.\r\n\r\n# 실물\r\n\r\n케이스까지 조립해서 구동한 라즈베리파이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131309644-69d69416-12e9-4fd6-95fc-3f1909289387.png)\r\n\r\n# 목표\r\n\r\n라즈베리파이 서버의 최종 목표는 아래와 같다.\r\n\r\n* 라즈베리파이에 Ubuntu 서버를 구축한다.\r\n* 도메인을 입힌다.\r\n* SSH, RDP 등의 원격 통신환경을 구축한다.\r\n* Tomcat을 구동하여 페이지를 호스팅한다\r\n* MariaDB를 설치하여 DB 통신을 수행한다.","url":["2021-08-29-hello-raspberry","2021","08","29","hello-raspberry"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1021번 회전하는 큐","excerpt":"지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다. 지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-08-26T01:39:29","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","덱","SILVER","SILVER IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-08-26-a1021.md","content":"\r\n# 회전하는 큐\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/7.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1021번 문제](https://www.acmicpc.net/problem/1021)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 $N$개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.\r\n\r\n지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다.\r\n\r\n1. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 $a_1, \\dotsb, a_k$였던 것이 $a_2, \\dotsb, a_k$가 된다.\r\n2. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면 $a_1, \\dotsb, a_k$가 $a_2, \\dotsb, a_k, a_1$이 된다.\r\n3. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면 $a_1, \\dotsb, a_k$가 $a_k, a_1, \\dotsb, a_{k - 1}$이 된다.\r\n\r\n큐에 처음에 포함되어 있던 수 $N$이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 큐의 크기 $N$과 뽑아내려고 하는 수의 개수 $M$이 주어진다. $N$은 50보다 작거나 같은 자연수이고, $M$은 $N$보다 작거나 같은 자연수이다. 둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다. 위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 문제의 정답을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n``` input\r\n10 3\r\n1 2 3\r\n```\r\n\r\n``` output\r\n0\r\n```\r\n\r\n### 예제 2\r\n\r\n``` input\r\n10 3\r\n2 9 5\r\n```\r\n\r\n``` output\r\n8\r\n```\r\n\r\n### 예제 3\r\n\r\n``` input\r\n32 6\r\n27 16 30 11 6 23\r\n```\r\n\r\n``` output\r\n59\r\n```\r\n\r\n### 예제 4\r\n\r\n``` input\r\n10 10\r\n1 6 3 2 7 9 8 4 10 5\r\n```\r\n\r\n``` output\r\n14\r\n```\r\n\r\n# 풀이\r\n\r\n<span class=\"teal-600\">큐</span>의 특성을 알고 있다면 이해하기 쉬운 문제다.\r\n\r\n큐는 배열의 형태로, 한쪽 입구에서 요소의 삽입이 일어나며, 다른 한쪽에서 요소의 삭제가 일어나는 자료구조다. 컨테이너 벨트처럼 순차적으로 데이터를 처리하는 선입선출(FIFO) 방식을 차용하고 있어 순차적인 데이터를 처리하는데 유용하다.\r\n\r\n> 큐의 특성은 해당 블로그에 작성된 [게시글](/posts/2021/07/31/about-algorithm-chapter08#8-3.-%ED%81%90)에서 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130629741-6b9dc89d-86fa-4c84-a06e-05950c86a489.png)\r\n\r\n\r\n하지만 단순한 큐가 아니라, 아래의 특징을 갖는 자료구조를 설계해야한다.\r\n\r\n1. 첫 번째 원소를 뽑아내는 연산\r\n2. 데이터의 좌우 이동 연산 (각 끝의 요소는 반대편으로 이동하는 방식으로 순환)\r\n\r\n위 자료구조를 토대로 알고리즘이 원하는 동작을 구현하면 된다.\r\n\r\n문제에서 제시하는 데이터를 순서대로 뽑아내되, 최소한의 데이터 이동이 이루어져야한다.\r\n\r\n1번 연산을 수행하면, 단순히 첫 번째 칸의 원소만 지우는 게 아니라, 칸 자체를 제거한다.\r\n\r\n즉, <span class=\"red-500\">10개의 칸을 가진 큐에서 1번 연산을 수행하면 칸이 9개로 감소</span>한다.\r\n\r\n## 예제 풀이\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130823251-4d6f5300-4363-49b6-ad76-7168d484dff8.png)\r\n\r\n예제 2를 기준으로 풀이를 진행한다. 큐의 길이는 총 10으로, 위와 같을 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130823281-5ed5b772-66ce-494a-9189-2366cd7ad45c.png)\r\n\r\n뽑을 원소의 순서는 위와 같다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">1. 2의 위치 계산</b>\r\n\r\n첫 번째로 뽑을 원소인 2와 데이터의 삭제 연산이 일어나는 첫 번째 칸까지의 위치를 계산한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130824338-20a0e7da-d8c3-4e00-a691-0ea103fd3cce.png)\r\n\r\n* 오른쪽: 9칸\r\n* 왼쪽: 1칸\r\n\r\n왼쪽이 더 빠르므로, 방향을 왼쪽으로 정한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">2. 요소 왼쪽으로 이동</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130824549-67551e2a-3d14-4581-8161-743bb46469fc.png)\r\n\r\n* 누적 이동횟수: 1\r\n\r\n요소 2를 첫 번째 칸까지 왼쪽으로 1칸 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">3. 요소 삭제</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130824982-ae2575aa-dfff-4424-affe-15e9a92ddbb9.png)\r\n\r\n요소 2를 삭제한다. 아예 칸 자체가 사라짐에 유의하자.\r\n\r\n삭제는 이동횟수에 포함되지 않는다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">4. 9의 위치 계산</b>\r\n\r\n두 번째로 뽑을 원소인 9와 데이터의 삭제 연산이 일어나는 첫 번째 칸까지의 위치를 계산한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130825673-9af78509-8918-4638-84cc-0ffcfa30a95b.png)\r\n\r\n* 오른쪽: 3칸\r\n* 왼쪽: 6칸\r\n\r\n오른쪽이 더 빠르므로, 방향을 오른쪽으로 정한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">5. 요소 오른쪽으로 이동</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130826195-b7a12a3f-0fed-4e46-bcb0-46936bfd130f.png)\r\n\r\n* 누적 이동횟수: 4\r\n\r\n요소 9를 첫 번째 칸까지 오른쪽으로 3칸 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">6. 요소 삭제</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130826601-776f4bc8-944e-4d5f-a05d-73116334e229.png)\r\n\r\n요소 9를 삭제한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">7. 5의 위치 계산</b>\r\n\r\n마지막으로 뽑을 원소인 5와 데이터의 삭제 연산이 일어나는 첫 번째 칸까지의 위치를 계산한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130827731-deda3121-792f-4664-b851-8e21d2a0a1a9.png)\r\n\r\n* 오른쪽: 4칸\r\n* 왼쪽: 4칸\r\n\r\n거리가 서로 동등한 케이스다. 이 경우 알고리즘 역시 별도의 제약조건을 걸지 않았으므로, 아무 방향으로 이동해도 상관없다.\r\n\r\n본 문서에선 왼쪽을 기준으로 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">8. 요소 왼쪽으로 이동</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130828678-790bc1ee-7c7d-43d9-912f-ee7ecc41c1f8.png)\r\n\r\n* 누적 이동횟수: 8\r\n\r\n요소 9를 첫 번째 칸까지 오른쪽으로 4칸 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">9. 요소 삭제</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130828805-3a216247-5361-47be-8c13-c41081b594dd.png)\r\n\r\n요소 9를 삭제한다.\r\n\r\n<b class=\"large deepPurple-300\">10. 결과 도출</b>\r\n\r\n총 이동횟수는 8회이므로, 알고리즘의 결과는 8이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\n\r\n/**\r\n * 백준 전체 1021 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/14/A1021/\">1021 풀이</a>\r\n * @since 2021.07.14 12:57:01\r\n */\r\npublic class Main\r\n{\r\n\t// 뽑을 수의 갯수\r\n\tprivate static int M;\r\n\t\r\n\t// 큐\r\n\tprivate static final LinkedList<Integer> QUEUE = new LinkedList<>();\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// N과 M\r\n\t\tint[] meta = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 수의 위치\r\n\t\tint[] position = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 큐의 크기\r\n\t\tint N = meta[0];\r\n\t\t\r\n\t\tM = meta[1];\r\n\t\t\r\n\t\t// 큐의 크기만큼 큐 초기화\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tQUEUE.add(i + 1);\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(String.valueOf(solve(position)));\r\n\t\twriter.newLine();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 큐 연산 갯수 반환 함수\r\n\t *\r\n\t * @param position: [int[]] 수의 위치 배열\r\n\t *\r\n\t * @return [int] 연산 갯수\r\n\t */\r\n\tprivate static int solve(int[] position)\r\n\t{\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < M; i++)\r\n\t\t{\r\n\t\t\t// 뽑을 요소의 인덱스\r\n\t\t\tint target = QUEUE.indexOf(position[i]);\r\n\t\t\t\r\n\t\t\t// 구간 구분 기준\r\n\t\t\tint ref = QUEUE.size() / 2;\r\n\t\t\t\r\n\t\t\t// 오른쪽으로 이동하는 게 더 빠를 경우\r\n\t\t\tif (target > ref)\r\n\t\t\t{\r\n\t\t\t\twhile (position[i] != QUEUE.getFirst())\r\n\t\t\t\t{\r\n\t\t\t\t\t// 맨 끝 요소를 제거하고 맨 앞에 추가\r\n\t\t\t\t\tQUEUE.addFirst(QUEUE.removeLast());\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 왼쪽으로 이동하는 게 더 빠를 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\twhile (position[i] != QUEUE.getFirst())\r\n\t\t\t\t{\r\n\t\t\t\t\t// 맨 앞 요소를 제거하거 맨 끝에 추가\r\n\t\t\t\t\tQUEUE.addLast(QUEUE.removeFirst());\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tQUEUE.removeFirst();\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n회전하는 큐의 주요 동작은 양방향 이동, 삭제다. 해당 동작은 각각 `move()`, `pop()` 메소드로 구현된다.\r\n\r\n``` java\r\n/**\r\n * 이동 함수\r\n *\r\n * @param direction: [DIRECTION] 방향 Enum\r\n * @param distance: [int] 거리\r\n */\r\nprivate static void move(DIRECTION direction, int distance)\r\n{\r\n\t// 왼쪽으로 이동할 경우\r\n\tif (DIRECTION.LEFT == direction)\r\n\t{\r\n\t\tfor (int i = 0; i < distance; i++)\r\n\t\t{\r\n\t\t\tQUEUE.addLast(QUEUE.removeFirst());\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 오른쪽으로 이동할 경우\r\n\telse\r\n\t{\r\n\t\tfor (int i = 0; i < distance; i++)\r\n\t\t{\r\n\t\t\tQUEUE.addFirst(QUEUE.removeLast());\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n`move()` 수행 시 방향은 `enum` 객체인 `DIRECTION`으로 구분하며, 입력한 횟수만큼 이동한다.\r\n\r\n``` java\r\n/**\r\n * 삭제 함수\r\n */\r\nprivate static void pop()\r\n{\r\n\tQUEUE.removeFirst();\r\n}\r\n```\r\n\r\n`pop()` 수행 시 큐의 첫 번째 요소를 삭제한다.\r\n\r\n<br />\r\n\r\n핵심 알고리즘 함수는 아래와 같다.\r\n\r\n``` java\r\n/**\r\n * 큐 연산 갯수 반환 함수\r\n *\r\n * @param position: [int[]] 수의 위치 배열\r\n *\r\n * @return [int] 연산 갯수\r\n */\r\nprivate static int solve(int[] position)\r\n{\r\n\tint count = 0;\r\n\t\r\n\tfor (int i = 0; i < M; i++)\r\n\t{\r\n\t\t// 뽑을 요소의 인덱스\r\n\t\tint target = QUEUE.indexOf(position[i]);\r\n\t\t\r\n\t\t// 요소의 중간\r\n\t\tint mid = QUEUE.size() / 2;\r\n\t\t\r\n\t\t// 인덱스가 요소의 중간값을 넘을 경우 오른쪽이 더 빠름\r\n\t\tDIRECTION direction = target > mid ? DIRECTION.RIGHT : DIRECTION.LEFT;\r\n\t\t\r\n\t\t// 오른쪽으로 갈 경우 큐의 길이에서 인덱스를 빼서 역계산\r\n\t\tint distance = direction == DIRECTION.RIGHT ? QUEUE.size() - target : target;\r\n\t\t\r\n\t\tmove(direction, distance);\r\n\t\tpop();\r\n\t\t\r\n\t\t// 이동 길이 누적\r\n\t\tcount += distance;\r\n\t}\r\n\t\r\n\treturn count;\r\n}\r\n```\r\n\r\n`target`으로 뽑을 요소의 인덱스를 구한다.\r\n\r\n`mid` 큐의 중간값으로, `target`이 중간값보다 클 경우 오른쪽으로, 아닐 경우 왼쪽으로 이동하도록 `direction`을 지정한다.\r\n\r\n`distance`는 거리로, 오른쪽으로 이동할 경우 큐의 사이즈에서 거리를 빼고, 왼쪽으로 이동할 경우 거리를 그대로 사용한다.\r\n\r\n이후 계산한 방향, 거리만큼 이동하고 데이터를 삭제한다. 이동거리는 `count`에 누적된다.\r\n\r\n## 분류\r\n\r\n* 자료구조\r\n* 덱","url":["2021-08-26-a1021","2021","08","26","a1021"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1020번 디지털 카운터","excerpt":"지민이는 매 초마다 수가 증가하는 N자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. 10^N-1에 이르면 다시 0부터 시작한다. 각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다. 모든 인접한 두 개의 선분은 +로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다. 현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오. 1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 N자리를 채워야 하므로, N자리보다 작을 때는 앞에 0이 있을 수도 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-08-24T01:17:46","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","PLATINUM","PLATINUM II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-08-24-a1020.md","content":"\r\n# 디지털 카운터\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/19.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1020번 문제](https://www.acmicpc.net/problem/1020)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 매 초마다 수가 증가하는 $N$자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. $10^{N - 1}$에 이르면 다시 0부터 시작한다.\r\n\r\n각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다.\r\n\r\n``` input\r\n    +   +---+   +---+   +   +   +---+\r\n    |       |       |   |   |   |\r\n    +   +---+   +---+   +---+   +---+\r\n    |   |           |       |       |\r\n    +   +---+   +---+       +   +---+\r\n\r\n+---+   +---+   +---+   +---+   +---+\r\n|           |   |   |   |   |   |   |\r\n+---+       +   +---+   +---+   +   +\r\n|   |       |   |   |       |   |   |\r\n+---+       +   +---+       +   +---+\r\n```\r\n\r\n모든 인접한 두 개의 선분은 $+$로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다.\r\n\r\n현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오.\r\n\r\n1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 $N$자리를 채워야 하므로, $N$자리보다 작을 때는 앞에 0이 있을 수도 있다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 현재 카운터에 나와있는 수가 주어진다. $N$은 그 수의 길이와 같다. (수가 0으로 시작할 수도 있음) 그리고, $N$은 15보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 최소 몇 초가 지나야 현재 카운터에 나와 있는 수와 선분의 개수가 같아지는지 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n``` input\r\n007\r\n```\r\n\r\n``` output\r\n11\r\n```\r\n\r\n# 풀이\r\n\r\n## 문제 이해하기\r\n\r\n문제 이해도는 그리 높지 않다. <span class=\"green-A400\">디지털 계산기</span>를 생각해보자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/124596989-df266800-de9d-11eb-963c-2dea1d25f9b3.png)\r\n\r\n숫자를 표현하는데 여러 개의 선분이 필요하며, 문제의 기호보다 위 그림을 보면 쉽게 이해할 수 있을 것이다. 각 숫자를 표현하는데 필요한 숫자를 표로 정리하면 아래와 같다.\r\n\r\n|   숫자    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 선분 갯수 |   6   |   2   |   5   |   5   |   4   |   5   |   6   |   3   |   7   |   5   |\r\n\r\n### 특징 1\r\n\r\n임의의 숫자 02를 표현하는데 필요한 선분의 갯수는 각각 6개와 5개로, 11개의 선분이 필요하다.\r\n\r\n숫자는 1초마다 바뀌며, 선분의 합이 11개가 되는 숫자가 몇 초 뒤에 나오는지를 계산하면 된다. 선분의 합이 11개인 가장 가까운 수는 03으로, 1초가 걸린다.\r\n\r\n만약 정해진 자릿수의 최대를 넘어가면 0부터 다시 돌아와 카운팅한다. 즉, 02의 경우 두 자리이므로, 99를 넘어서면 다시 00으로 되돌아간다.\r\n\r\n### 특징 2\r\n\r\n이번엔 임의의 숫자 98의 케이스를 생각해보자. 주어진 숫자가 두 자리이므로, $N = 2$임을 알 수 있다. 98을 표현하는데 필요한 선분의 갯수는 각각 7과 5로, 12개의 선분이 필요하다.\r\n\r\n99 역시 총 10개의 선분으로 이루어지므로 답이 되지 못하며, 두 자리 수의 최대값은 99이므로 00으로 넘어가서 값을 찾는다. <span class=\"primary\">오버플로우(Overflow)</span>의 개념과 동일하다.\r\n\r\n0은 6개의 선분으로 이루어져 있으므로, 00을 표현하는데 필요한 선분의 갯수는 12개다. 즉, 답은 2초가 된다.\r\n\r\n이렇게 정해진 자릿수를 초과할 경우 또한 계산해야한다.\r\n\r\n## 다이나믹 프로그래밍 적용하기\r\n\r\n문제의 요구사항도 직관적이고, 특징 또한 그리 복잡하지 않다. 순수히 문제에서 요구하는 로직 자체가 어렵다.\r\n\r\n숫자의 자릿수가 최대 15자리(100조)에 육박하므로, 이렇게 많은 양의 데이터를 빠르게 처리하는데는 <span class=\"primary\">다이나믹 프로그래밍</span>이 적절할 것이다.\r\n\r\n또한 `int`는 약 21억까지만 다룰 수 있으므로, `long` 데이터를 써야함을 짐작할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n그 어떤 고려사항 없이 무식하게 접근한다면 그리 어렵지 않을 것이다. 숫자를 하나하나 분리해서 선분의 갯수를 구하여 합한 다음, 현재 숫자부터 1씩 증가시키며 위 계산을 반복하면 될 것이다. 물론 그렇게 쉬웠다면 내가 일주일 넘게 고민하지도 않았겠지만.\r\n\r\n<span class=\"primary\">다이나믹 프로그래밍</span>은 이분 매칭과 같은 특정한 패턴이 있는게 아닌 개념에 가까워서, 이를 적절히 적용할 수 있는 접근 방식<span class=\"grey-400\">(점화식 등)</span>을 도출해야한다.\r\n\r\n### 원리 이해하기\r\n\r\n이 알고리즘의 핵심은 <span class=\"red-A400\">선분의 합</span>이다. <span class=\"orange-400\">하나의 숫자를 표시하는데 필요한 선분의 수는 2 ~ 7 사이의 값</span>을 가진다. 동일한 선분의 갯수를 가지는 숫자가 있으므로 일부 겹친다.\r\n\r\n만약 하나의 숫자를 통해 만들 수 있는 선분의 합을 나열하고, 이 합을 가질 수 있는 숫자들 중 가장 작은 수를 표시하면 아래와 같다.\r\n\r\n| 선분 갯수 |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n예를 들어, 선분의 갯수가 5인 숫자는 [ 2, 3, 5, 9 ]로 4개가 존재한다. 그 중 가장 작은 수는 4이므로 위 표의 5에는 2가 매칭된다.\r\n\r\n위 표는 한 자릿수에서 나올 수 있는 경우의 수다. 만약 두 자릿수를 기준으로 표를 도식하면 아래와 같다. 한 자릿수에서의 최소값이 2, 최대값이 7이므로, 두 자릿수에서는 4 ~ 14의 범위를 가짐을 유추할 수 있다.\r\n\r\n| 선분 갯수 |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |\r\n\r\n위처럼 나타낼 수 있다. 두 자릿수에서 선분의 합이 11인 수는 02가 가장 작음을 바로 찾을 수 있다.\r\n\r\n이러한 원리를 통해 자릿수를 하나하나 넓혀가며 동일한 선분을 가지는 값을 빠르게 찾을 수 있다.\r\n\r\n예를 들어, **0598**와 동일한 선분의 수를 갖는 가장 가까운 수를 찾아보자. **0598**의 선분합은 6 + 5 + 5 + 7 = <p class=\"amber-600\">23</p>이다. 즉, 0598과 가장 가까우면서 선분의 합이 23인 숫자를 찾으면 된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"amber-600 large\">1. 1의 자리 비교하기</p>\r\n\r\n1의 자리를 비우면 **059_**와 같이 표기할 수 있다. 8의 선분값은 7이므로 **_**에 0부터 9까지 순차적으로 대입하여 선분값이 <span class=\"lightBlue-600\">7</span>이 되는 수를 찾는다. 단, 원래의 값인 8은 탐색 대상에서 제외한다.\r\n\r\n선분의 합이 7이 되는 한 자릿수는 8 이외엔 없으므로, 1의 자리에선 동일한 선분합을 갖는 숫자가 자신 이외에 없다.\r\n\r\n따라서 1의 자리 조합으로는 만족하는 수를 찾을 수 없다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"amber-600 large\">2. 10의 자리 비교하기</p>\r\n\r\n10의 자리를 비우면 **05_X**와 같이 표기할 수 있다. **_**는 0부터 9까지 대입할 자리이며, **X**은 해당 자리에서 나올 수 있는 선분의 합을 가지는 가장 작은 수가 대입된다.\r\n\r\n| 선분 갯수 |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n즉, **X**는 위 표에 해당하는 0, 1, 2, 4, 7, 8만 올 수 있다.\r\n\r\n* `_` 0 ~ 9\r\n* `X` 0, 1, 2, 4, 7, 8\r\n\r\n**_**와 **X**의 합이 8, 9의 선분합과 동일하면 된다. 따라서 선분의 합이 <span class=\"lightBlue-600\">12</span>가 되는 조합을 찾는다.\r\n\r\n| 구분  |                    0                    |   1    |                    2                    |                    3                    |    4    |                    5                    |                    6                    |    7    |                    8                    |                    9                    |\r\n| :---: | :-------------------------------------: | :----: | :-------------------------------------: | :-------------------------------------: | :-----: | :-------------------------------------: | :-------------------------------------: | :-----: | :-------------------------------------: | :-------------------------------------: |\r\n|   1   |                 01 (8)                  | 11 (4) |                 21 (7)                  |                 31 (7)                  | 41 (6)  |                 51 (7)                  |                 61 (8)                  | 71 (5)  |                 81 (9)                  |                 91 (7)                  |\r\n|   7   |                 07 (9)                  | 17 (5) |                 27 (8)                  |                 37 (8)                  | 47 (7)  |                 57 (8)                  |                 67 (9)                  | 77 (6)  |                 87 (10)                 |                 97 (8)                  |\r\n|   4   |                 04 (10)                 | 14 (6) |                 24 (9)                  |                 34 (9)                  | 44 (8)  |                 54 (9)                  |                 64 (10)                 | 74 (7)  |                 84 (11)                 |                 94 (9)                  |\r\n|   2   |                 02 (11)                 | 12 (7) |                 22 (10)                 |                 32 (10)                 | 42 (9)  |                 52 (10)                 |                 62 (11)                 | 72 (8)  | <span class=\"yellow-600\">82 (12)</span> |                 92 (10)                 |\r\n|   0   | <span class=\"yellow-600\">00 (12)</span> | 10 (8) |                 20 (11)                 |                 30 (11)                 | 40 (10) |                 50 (11)                 | <span class=\"yellow-600\">60 (12)</span> | 70 (9)  |                 80 (13)                 |                 90 (11)                 |\r\n|   8   |                 08 (13)                 | 18 (9) | <span class=\"yellow-600\">28 (12)</span> | <span class=\"yellow-600\">38 (12)</span> | 48 (11) | <span class=\"yellow-600\">58 (12)</span> |                 68 (13)                 | 78 (10) |                 88 (14)                 | <span class=\"yellow-600\">98 (12)</span> |\r\n\r\n0500, 0528, 0538, 0558, 0560, 0582, 0598이 후보군이다.\r\n\r\n하지만 0598은 자기 자신으로 제외되며, 나머지 숫자 모두 조건은 맞지만, 0598보다 작다. 한 사이클을 돌아야 나오는 수이므로, 아직 속단하긴 이르다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"amber-600 large\">3. 100의 자리 비교하기</p>\r\n\r\n100의 자리를 비우면 **0_XX**와 같이 표기할 수 있다.\r\n\r\n| 선분 갯수 |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |\r\n\r\n즉, **XX**는 위 표에 해당하는 00, 01, 02, 04, 07, 08, 11, 12, 14, 17, 88만 올 수 있다.\r\n\r\n* `_` 0 ~ 9\r\n* `X` 00, 01, 02, 04, 07, 08, 11, 12, 14, 17, 88\r\n\r\n**_**와 **XX**에 값을 각각 대입해봄으로써 5, 8, 9의 선분합인 17을 가지는 수를 찾는다.\r\n\r\n| 구분  |                    0                     |    1     |                    2                     |                    3                     |                    4                     |                    5                     |                    6                     |                    7                     |                    8                     |                    9                     |\r\n| :---: | :--------------------------------------: | :------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: |\r\n|  11   |                 011 (10)                 | 111 (6)  |                 211 (9)                  |                 311 (9)                  |                 411 (8)                  |                 511 (9)                  |                 611 (10)                 |                 711 (7)                  |                 811 (11)                 |                 911 (9)                  |\r\n|  17   |                 017 (11)                 | 117 (7)  |                 217 (10)                 |                 317 (10)                 |                 417 (9)                  |                 517 (10)                 |                 617 (11)                 |                 717 (8)                  |                 817 (12)                 |                 917 (10)                 |\r\n|  14   |                 014 (12)                 | 114 (8)  |                 214 (11)                 |                 314 (11)                 |                 414 (10)                 |                 514 (11)                 |                 614 (12)                 |                 714 (9)                  |                 814 (13)                 |                 914 (11)                 |\r\n|  12   |                 012 (13)                 | 112 (9)  |                 212 (12)                 |                 312 (12)                 |                 412 (11)                 |                 512 (12)                 |                 612 (13)                 |                 712 (10)                 |                 812 (14)                 |                 912 (12)                 |\r\n|  01   |                 001 (14)                 | 101 (10) |                 201 (13)                 |                 301 (13)                 |                 401 (12)                 |                 501 (13)                 |                 601 (14)                 |                 701 (11)                 |                 801 (15)                 |                 901 (13)                 |\r\n|  07   |                 007 (15)                 | 107 (11) |                 207 (14)                 |                 307 (14)                 |                 407 (13)                 |                 507 (14)                 |                 607 (15)                 |                 707 (12)                 |                 807 (16)                 |                 907 (14)                 |\r\n|  04   |                 004 (16)                 | 104 (12) |                 204 (15)                 |                 304 (15)                 |                 404 (14)                 |                 504 (15)                 |                 604 (16)                 |                 704 (13)                 | <span class=\"yellow-600\">804 (17)</span> |                 904 (15)                 |\r\n|  02   | <span class=\"yellow-600\">002 (17)</span> | 102 (13) |                 202 (16)                 |                 302 (16)                 |                 402 (15)                 |                 502 (16)                 | <span class=\"yellow-600\">602 (17)</span> |                 702 (14)                 |                 802 (18)                 |                 902 (16)                 |\r\n|  00   |                 000 (18)                 | 100 (14) | <span class=\"yellow-600\">200 (17)</span> | <span class=\"yellow-600\">300 (17)</span> |                 400 (16)                 | <span class=\"yellow-600\">500 (17)</span> |                 600 (18)                 |                 700 (15)                 |                 800 (19)                 | <span class=\"yellow-600\">900 (17)</span> |\r\n|  08   |                 008 (19)                 | 108 (15) |                 208 (18)                 |                 308 (18)                 | <span class=\"yellow-600\">408 (17)</span> |                 508 (18)                 |                 608 (19)                 |                 708 (16)                 |                 808 (20)                 |                 908 (18)                 |\r\n|  88   |                 088 (20)                 | 188 (16) |                 288 (19)                 |                 388 (19)                 |                 488 (18)                 |                 588 (19)                 |                 688 (20)                 | <span class=\"yellow-600\">788 (17)</span> |                 888 (21)                 |                 988 (19)                 |\r\n\r\n0002, 0200, 0300, 0408, 0500, 0602, 0788, 0804, 0900이 후보군이다.\r\n\r\n이 중 0602는 입력값인 0598과 <span class=\"lightBlue-600\">4</span>만큼 차이가 나므로 선분의 갯수가 동일한 가장 가까운 수다.\r\n\r\n얼고리즘이 요구하는 답은 <span class=\"green-500\">선분의 갯수가 동일한 가장 가까운 수가 나오는데 걸리는 시간</span>이다. 각 숫자는 1초마다 바뀌므로, 0598에서 0602가 되는데 걸리는 시간 <span class=\"lightBlue-600\">4</span>가 답이 된다.\r\n\r\n### DP배열 만들기\r\n\r\n위 예제의 경우 <span class=\"amber-600\">0598</span>의 선분합을 구하고, 0599부터 하나하나 계산하면서 나아가면 쉽게 풀 수 있을 것이다. 하지만 이 방식은 매우 비효율적이기 때문에 알고리즘의 취지와는 맞지 않다.\r\n\r\n한 자릿수, 두 자릿수에서 나올 수 있는 선분합의 최소값을 가지는 수를 정리하면 아래와 같다.\r\n\r\n* 한 자릿수\r\n\r\n| 선분 갯수 |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n* 두 자릿수\r\n\r\n| 선분 갯수 |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |\r\n\r\n위 표의 값들을 계산하여 하나의 표로 만들면 <span class=\"primary\">메모이제이션</span>을 적용할 수 있을 것이다.\r\n\r\n메모이제이션을 적용할 배열 `dp[i][j]`가 있다고 가정하자. 각 인덱스의 의미는 아래와 같다.\r\n\r\n* $i$: 자릿수 $(i = 1, 2, \\, \\, \\, \\dotsm \\, \\, \\, , 14, 15)$\r\n* $j$: 선분의 합\r\n\r\n<p class=\"red-400 small\">※ i와 j엔 0이 오지 않는다. 이유는 후술</p>\r\n\r\n* $dp[1][6]$: 선분의 합이 6인 한자리 수 중 가장 작은 수\r\n* $dp[2][12]$: 선분의 합이 12인 두자리 수 중 가장 작은 수\r\n* $dp[n][m]$: 선분의 합이 m인 n자리 수 중 가장 작은 수\r\n\r\n만약 $dp[3][6]$을 구할 경우, 세 자릿수의 선분 합이 6인 숫자의 최소값이므로 111(2 + 2 + 2)가 된다. 이렇게 적절한 값이 나올 수 있도록 배열 `dp`의 표현식을 도출해야한다.\r\n\r\n### DP배열 예시\r\n\r\nDP배열의 예시는 아래와 같다.\r\n\r\n| $i$, $j$ |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |  15   |  16   |  17   |  18   |  19   |  20   |  21   |\r\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|    0     |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|    1     |   -   |   -   |   1   |   7   |   4   |   2   |   0   |   8   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|    2     |   -   |   -   |   -   |   -   |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|    3     |   -   |   -   |   -   |   -   |   -   |   -   |  111  |  117  |  114  |  112  |  011  |  017  |  014  |  012  |  001  |  007  |  004  |  002  |  000  |  008  |  088  |  888  |\r\n\r\n세 자리 숫자를 기준으로 계산한 DP배열은 위와 같다. 자릿수를 기준으로 $i$값이 비례해서 늘어난다. 하지만 배열의 값은 고정적으로, 숫자가 변한다고 해서 DP배열의 값이 이에 따라 변하지 않는다.\r\n\r\n쉽게 말하면 0598과 135 숫자를 입력값으로 했을 때, `dp[2][7]`은 둘 다 12로 동일하다.\r\n\r\n### DP배열 크기 선언하기\r\n\r\n알고리즘에서의 자릿수는 $N$이므로, `dp`의 크기를 식으로 표현하면 아래와 같다.\r\n\r\n``` java\r\nlong[] dp = new long[N + 1][(N * 7) + 1];\r\n\r\nArrays.fill(arr, Long.MAX_VALUE);\r\n```\r\n\r\n요소의 값이 크므로 `long` 배열로 선언한다. 배열 `dp`는 가급적 적절한 큰 값으로 초기화를 진행해준다.\r\n\r\n본 문서에서는 `long`의 최대값인 `Long.MAX_VALUE`로 배열 전체를 초기화한다.\r\n\r\n<br />\r\n\r\n``` java\r\nprivate static final int[] FLAG = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 5 };\r\n```\r\n\r\n숫자 선분의 갯수 또한 코드화한다. `FLAG`는 각 해당 인덱스 숫자가 가지는 선분의 합을 반환한다.\r\n\r\n`FLAG[2]`는 숫자 2의 선분합으로, 5를 반환한다.\r\n\r\n<br />\r\n\r\n$N = 3$일 경우, 세 자릿수를 가지며, 선분 합의 최대값은 21이다. 이를 배열로 초기선언하면 `new long[3][21]`로 표현할 수 있겠지만, 컴퓨터 언어의 특성으로 혼란이 생긴다.\r\n\r\n대부분의 컴퓨터 언어는 배열의 시작을 `0`으로 본다. 위와 같이 선언한 매열에서 두 자릿수를 가지며, 선분 합이 10인 값을 호출하려면 `dp[2][10]`이 아니라 `dp[1][9]`를 호출해야한다.\r\n\r\n특히 이렇게 복잡한 문제의 경우 변수를 사용하는 과정에서 많은 혼란을 야기할 수 있기 때문에, 가급적 서로 맞춰주는 것이 중요하다. 이를 위해 첫 인덱스인 0을 사용하지 않고 각 선언 크기에 1을 더하여 범위를 증가시킨다음, 시작 인덱스를 1로 사용한다.\r\n\r\n즉, 해당 문제에서 $i$와 $j$가 0인 배열은 사용하지 않으며, 어떤 의미도 가지지 않는다.\r\n\r\n### DP배열 초기값 지정하기\r\n\r\n<span class=\"primary\">다이나믹 프로그래밍</span>은 원래라면 처음부터 다시 계산해야하는 복잡한 과정을 생략하고, 이전에 계산된 내용을 토대로 추가적인 계산을 수행한다.\r\n\r\n초기엔 로직에 따른 정석적인 계산을 하지만, 이후 계산값을 누적하고 이를 활용하여 다음 값을 계산한다. 특히 데이터의 양이 많으면 많을 수록 속도에서의 우위를 가져갈 수 있다.\r\n\r\n따라서 <span class=\"primary\">다이나믹 프로그래밍</span>은 초기값 설정도 매우 중요하다. 여기서의 초기값은 <span class=\"teal-A400\">한 자리수에서 나올 수 있는 선분합의 조합</span>으로 정의할 수 있다.\r\n\r\n<br />\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   -   |   -   |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n위 표를 배열 `dp`에 입력하면 된다. 한 자리 숫자이므로 $i = 1$로 고정이며, $j$는 선분합이다. 값은 그 숫자다.\r\n\r\n``` java\r\ndp[1][2] = 1\r\ndp[1][3] = 7\r\ndp[1][4] = 4\r\ndp[1][5] = 2\r\ndp[1][6] = 0\r\ndp[1][7] = 8\r\n```\r\n\r\n위처럼 선언해주면 된다.\r\n\r\n<br />\r\n\r\n하드코딩이 마음에 안 든다면, 아래처럼 사용하는 방법도 있다.\r\n\r\n``` java\r\nfor (int i = 0; i < FLAG.length; i++)\r\n{\r\n\tdp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i);\r\n}\r\n```\r\n\r\n0부터 FLAG의 배열을 순차적으로 돌면서 해당 선분값을 가지는 가장 작은 값을 초기값으로 할당하게 된다.\r\n\r\n### DP배열 전개하기\r\n\r\n지정한 초기값을 토대로 배열 `dp`의 값을 전개한다. 한 자릿수는 <span class=\"teal-500\">2 ~ 7 사이의 값</span>을 가진다.\r\n\r\n그렇다면, 두 자릿수는 한 자릿수의 조합이므로, <span class=\"teal-500\">4 ~ 14 사이의 값</span>을 가질 것이다.\r\n\r\n즉, 자릿수별로 유효한 DP배열의 범위는 아래와 같다.\r\n\r\n$$\r\nn \\text{의 자리 범위} = (n - 1) * 2 \\,\\,\\, \\sim \\,\\,\\, (n - 1) * 7\r\n$$\r\n\r\n각 자릿수 별로 위 범위만큼만 신경쓰면 된다.\r\n\r\n<br />\r\n\r\n한 자릿수에서 할당된 숫자는 0, 1, 2, 4, 7, 8로 여섯 가지가 존재한다. 두 자릿수 또한 이 숫자들의 조합으로만 이루어진다.\r\n\r\n따라서 00, 01, 02, ~ 84, 87, 88을 조합하여 선분의 합을 가지는 가장 작은 수를 `dp`에 할당한다.\r\n\r\n<br />\r\n\r\n예를 들어, `dp[2][8]`의 경우 01, 10, 44 등의 숫자 조합이 올 수 있다. 그 중 가장 작은 수는 01이므로, `dp[2][8] = 1`이 될 것이다.\r\n\r\n``` java\r\nfor (int n = 2; n < dp.length; n++)\r\n{\r\n\tfor (int i = 2; i < 8; i++)\r\n\t{\r\n\t\tint start = (n - 1) * 2;\r\n\t\tint end = (n - 1) * 7 + 1;\r\n\t\t\r\n\t\tfor (int j = start; j < end; j++)\r\n\t\t{\r\n\t\t\tdp[n][i + j] = Math.min(dp[n][i + j], (long) Math.pow(10, n - 1) * dp[1][i] + dp[n - 1][j]);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n따라서 이를 식으로 표현하면 위와 같다.\r\n\r\n* $n$: 자릿수\r\n* $i$: $n$의 자리에 할당될 수의 선분합\r\n* $j$: 남은 자리에 할당될 수의 선분합\r\n\r\n$n$은 자릿수로써, 일의 자리는 일전에 이미 계산했으므로 2부터 시작한다.\r\n\r\n`start`, `end`는 $n$의 자리 범위를 코드로 나타낸 것이다.\r\n\r\n$i$와 $j$는 각각의 선분합으로, 위의 예시에서 설명한  **0_XX**에서 $i$는 `_`, $j$는 `XX`의 선분합이라 생각하면 된다.\r\n\r\n`dp[n][i + j]`와 `Math.pow(10, n - 1) * dp[1][i] + dp[n - 1][j]` 중 더 작은 값을 `dp` 배열에 할당한다.\r\n\r\n이를 배열이 끝날 때까지 반복하면 DP배열이 완성된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1020 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/08/24/a1020\">1020 풀이</a>\r\n * @since 2021.07.06 11:36:34\r\n */\r\npublic class Main\r\n{\r\n\t// 숫자 선분 갯수\r\n\tprivate static final int[] FLAG = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 5 };\r\n\t\r\n\t// 메모이제이션 배열\r\n\tprivate static long[][] dp;\r\n\t\r\n\t// 입력 숫자\r\n\tprivate static long number;\r\n\t\r\n\t// 자리별로 분리된 숫자 배열\r\n\tprivate static int[] numbers;\r\n\t\r\n\t// 숫자 자릿수\r\n\tprivate static int N;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 입력값\r\n\t\tString input = reader.readLine();\r\n\t\t\r\n\t\tnumber = Long.parseLong(input);\r\n\t\t\r\n\t\tnumbers = Arrays.stream(input.split(\"\")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tN = numbers.length;\r\n\t\t\r\n\t\tputDP();\r\n\t\t\r\n\t\tlong result = solve();\r\n\t\t\r\n\t\twriter.write(String.valueOf(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * DP 채우기 함수\r\n\t */\r\n\tprivate static void putDP()\r\n\t{\r\n\t\tdp = new long[N + 1][(N * 7) + 1];\r\n\t\t\r\n\t\t// 전체 배열을 long의 최대값으로 초기화\r\n\t\tfor (long[] arr : dp)\r\n\t\t{\r\n\t\t\tArrays.fill(arr, Long.MAX_VALUE);\r\n\t\t}\r\n\t\t\r\n\t\t// 초기값 설정\r\n\t\tfor (int i = 0; i < FLAG.length; i++)\r\n\t\t{\r\n\t\t\tdp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i);\r\n\t\t}\r\n\t\t\r\n\t\t// 배열 채우기\r\n\t\tfor (int n = 2; n < dp.length; n++)\r\n\t\t{\r\n\t\t\tfor (int i = 2; i < 8; i++)\r\n\t\t\t{\r\n\t\t\t\tint start = (n - 1) * 2;\r\n\t\t\t\tint end = (n - 1) * 7 + 1;\r\n\t\t\t\t\r\n\t\t\t\tfor (int j = start; j < end; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tdp[n][i + j] = Math.min(dp[n][i + j], dp[n - 1][j] + (long) Math.pow(10, n - 1) * dp[1][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 동작 함수\r\n\t *\r\n\t * @return [long] 동일한 선분의 갯수를 가지는 숫자가 나오기까지 걸리는 시간\r\n\t */\r\n\tprivate static long solve()\r\n\t{\r\n\t\t// 결과\r\n\t\tlong result = (long) Math.pow(10, N);\r\n\t\t\r\n\t\t// 1의 자리 숫자만 비교\r\n\t\tfor (int num = 0; num < 10; num++)\r\n\t\t{\r\n\t\t\t// 입력된 숫자의 1의 자리값\r\n\t\t\tint units = numbers[N - 1];\r\n\t\t\t\r\n\t\t\t// 1의 자리 숫자와 다른 숫자이면서 선분의 갯수는 동일할 경우\r\n\t\t\tif (FLAG[units] == FLAG[num] && units != num)\r\n\t\t\t{\r\n\t\t\t\t// num이 1의 자리 숫자보다 클 경우\r\n\t\t\t\tif (num > units)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = Math.min(result, num - units);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// num이 1의 자리 숫자보다 작을 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = Math.min(result, (long) Math.pow(10, N) + num - units);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 비교할 선분의 갯수 (1의 자리를 위에서 이미 비교했으므로 1의 자리에 해당하는 선분값을 초기값으로 지정)\r\n\t\tint count = FLAG[numbers[N - 1]];\r\n\t\t\r\n\t\t// (10^i)의 자리 숫자부터 하나씩 비교\r\n\t\tfor (int i = 2; i < N + 1; i++)\r\n\t\t{\r\n\t\t\t// (10^i-1)의 자리까지만 표기한 수\r\n\t\t\tlong digit = number % (long) Math.pow(10, i);\r\n\t\t\t\r\n\t\t\t// (10^i)의 자릿수 선분 갯수 누적\r\n\t\t\tcount += FLAG[numbers[N - i]];\r\n\t\t\t\r\n\t\t\t// (10^i)의 자릿수에 0 ~ 9를 대입하여 비교\r\n\t\t\tfor (int num = 0; num < 10; num++)\r\n\t\t\t{\r\n\t\t\t\t// 비교할 선분의 갯수와 현재 숫자의 선분의 갯수차가 양수일 경우\r\n\t\t\t\tif (count - FLAG[num] >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// (10^i-1)의 자릿수에 현재 숫자를 곱한 수\r\n\t\t\t\t\tlong pows = (long) Math.pow(10, i - 1) * num;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// i-1 자리에서 선분의 합이 (count - FLAG[num])이 되는 가장 작은 수\r\n\t\t\t\t\tlong target = dp[i - 1][count - FLAG[num]];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// pows와 target의 합이 digit과 다르며, 유효한 값을 가지는 메모이제이션 배열일 경우\r\n\t\t\t\t\tif (digit != pows + target && target != Long.MAX_VALUE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlong val = pows + target - digit;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// 계산한 값이 음수일 경우\r\n\t\t\t\t\t\tif (val <= 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// 10^N 자리를 넘어가므로 한 주기를 돌아 다시 카운팅해야한다.\r\n\t\t\t\t\t\t\tval += (long) Math.pow(10, N);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tresult = Math.min(result, val);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다. `putDP()` 메소드는 DP배열을 전개하며, `solve()` 메소드는 알고리즘을 수행한다.\r\n\r\n``` java\r\nprivate static void putDP()\r\n{\r\n\tdp = new long[N + 1][(N * 7) + 1];\r\n\t\r\n\t// 전체 배열을 long의 최대값으로 초기화\r\n\tfor (long[] arr : dp)\r\n\t{\r\n\t\tArrays.fill(arr, Long.MAX_VALUE);\r\n\t}\r\n\t\r\n\t// 초기값 설정\r\n\tfor (int i = 0; i < FLAG.length; i++)\r\n\t{\r\n\t\tdp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i);\r\n\t}\r\n\t\r\n\t// 배열 채우기\r\n\tfor (int n = 2; n < dp.length; n++)\r\n\t{\r\n\t\tfor (int i = 2; i < 8; i++)\r\n\t\t{\r\n\t\t\tint start = (n - 1) * 2;\r\n\t\t\tint end = (n - 1) * 7 + 1;\r\n\t\t\t\r\n\t\t\tfor (int j = start; j < end; j++)\r\n\t\t\t{\r\n\t\t\t\tdp[n][i + j] = Math.min(dp[n][i + j], dp[n - 1][j] + (long) Math.pow(10, n - 1) * dp[1][i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nDP배열은 위 코드와 같이 전개하며, `Arrays.fill(arr, Long.MAX_VALUE)`를 통해 `long`의 최대값으로 배열을 초기화한다.\r\n\r\n이후 `dp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i)` 구문을 통해 한 자릿수에서 해당 선분값을 가지는 가장 작은 값을 할당한다.\r\n\r\n<br />\r\n\r\n모든 숫자의 조합은 0, 1, 2, 4, 7, 8로 이루어지므로, 각 숫자를 조합하여 나올 수 있는 모든 경우의 수를 비교하여 선분합의 최소값을 DP배열에 기록한다.\r\n\r\n**0_XXX**에서 `_`은 한 자릿수에서 나올 수 있는 수의 조합이며, `XXX`는 세 자릿수에서 나올 수 있는 수의 조합이다.\r\n\r\n즉, $i$는 `_`, $j$는 `XXX`를 표현한 것이다.\r\n\r\n예시로, $N = 3$일 경우 $2 \\leq i \\leq 7$, $4 \\leq j \\leq 14$가 된다.\r\n\r\n``` java\r\nprivate static long solve()\r\n{\r\n\t// 결과\r\n\tlong result = (long) Math.pow(10, N);\r\n\t\r\n\t// 1의 자리 숫자만 비교\r\n\tfor (int num = 0; num < 10; num++)\r\n\t{\r\n\t\t// 입력된 숫자의 1의 자리값\r\n\t\tint units = numbers[N - 1];\r\n\t\t\r\n\t\t// 1의 자리 숫자와 다른 숫자이면서 선분의 갯수는 동일할 경우\r\n\t\tif (FLAG[units] == FLAG[num] && units != num)\r\n\t\t{\r\n\t\t\t// num이 1의 자리 숫자보다 클 경우\r\n\t\t\tif (num > units)\r\n\t\t\t{\r\n\t\t\t\tresult = Math.min(result, num - units);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// num이 1의 자리 숫자보다 작을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult = Math.min(result, (long) Math.pow(10, N) + num - units);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 비교할 선분의 갯수 (1의 자리를 위에서 이미 비교했으므로 1의 자리에 해당하는 선분값을 초기값으로 지정)\r\n\tint count = FLAG[numbers[N - 1]];\r\n\t\r\n\t// (10^n)의 자리 숫자부터 하나씩 비교\r\n\tfor (int n = 2; n < N + 1; n++)\r\n\t{\r\n\t\t// (10^n-1)의 자리까지만 표기한 수\r\n\t\tlong digit = number % (long) Math.pow(10, n);\r\n\t\t\r\n\t\t// (10^n)의 자릿수 선분 갯수 누적\r\n\t\tcount += FLAG[numbers[N - n]];\r\n\t\t\r\n\t\t// (10^n)의 자릿수에 0 ~ 9를 대입하여 비교\r\n\t\tfor (int num = 0; num < 10; num++)\r\n\t\t{\r\n\t\t\t// 비교할 선분의 갯수와 현재 숫자의 선분의 갯수차가 양수일 경우\r\n\t\t\tif (count - FLAG[num] >= (n - 1) * 2)\r\n\t\t\t{\r\n\t\t\t\t// (10^n-1)의 자릿수에 현재 숫자를 곱한 수\r\n\t\t\t\tlong pows = (long) Math.pow(10, n - 1) * num;\r\n\t\t\t\t\r\n\t\t\t\t// n-1 자리에서 선분의 합이 (count - FLAG[num])이 되는 가장 작은 수\r\n\t\t\t\tlong target = dp[n - 1][count - FLAG[num]];\r\n\t\t\t\t\r\n\t\t\t\t// pows와 target의 합이 digit과 다르며, 유효한 값을 가지는 메모이제이션 배열일 경우\r\n\t\t\t\tif (digit != pows + target && target != Long.MAX_VALUE)\r\n\t\t\t\t{\r\n\t\t\t\t\tlong val = pows + target - digit;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 계산한 값이 음수일 경우\r\n\t\t\t\t\tif (val <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 10^N 자리를 넘어가므로 한 주기를 돌아 다시 카운팅해야한다.\r\n\t\t\t\t\t\tval += (long) Math.pow(10, N);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n```\r\n\r\n실제 알고리즘을 수행하는 소스는 위와 같다.\r\n\r\n`long result = (long) Math.pow(10, N)`은 알고리즘의 최대값으로 초기화하는 작업이다. 예를 들어, <span class=\"teal-500\">384</span>와 동일한 선분합을 가지는 수가 나올 시간을 찾는다고 해보자.\r\n\r\n운 나쁘게 동일한 선분합을 가지는 수가 없다면 <span class=\"teal-500\">384</span>부터 1씩 증가하여 한 사이클을 돌아 다시 <span class=\"teal-500\">384</span>로 돌아올 것이다.\r\n\r\n즉, 한 사이클 $c$의 값은 $c = 10^{N + 1}$으로 표현할 수 있다. 알고리즘의 결과는 이 값을 넘지 않는다.\r\n\r\n<br />\r\n\r\n``` java\r\n// 1의 자리 숫자만 비교\r\nfor (int num = 0; num < 10; num++)\r\n{\r\n\t// 입력된 숫자의 1의 자리값\r\n\tint units = numbers[N - 1];\r\n\t\r\n\t// 1의 자리 숫자와 다른 숫자이면서 선분의 갯수는 동일할 경우\r\n\tif (FLAG[units] == FLAG[num] && units != num)\r\n\t{\r\n\t\t// num이 1의 자리 숫자보다 클 경우\r\n\t\tif (num > units)\r\n\t\t{\r\n\t\t\tresult = Math.min(result, num - units);\r\n\t\t}\r\n\t\t\r\n\t\t// num이 1의 자리 숫자보다 작을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tresult = Math.min(result, (long) Math.pow(10, N) + num - units);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n초기값을 지정하기 위해 1의 자리 숫자를 비교하는 작업이다. 위 예제에서의 **059_** 과정에 해당한다.\r\n\r\n<br />\r\n\r\n* 1의 자리보다 클 경우\r\n\r\n\t비교하는 숫자가 나오기까지의 시간을 구하여 `result`와 비교한다. 더 작은 값이 `result`가 된다.\r\n\r\n* 1의 자리보다 작을 경우\r\n\r\n\t한 사이클을 돌고 난 뒤에 도달하는 수이므로, 최대 사이클 $c$에서 비교하는 숫자가 나오는데 걸리는 시간을 뺀다. 이를 `result`와 비교하여, 더 작은 값이 `result`가 된다.\r\n\r\n<br />\r\n\r\n비교할 선분합 `count`를 누적한다. **0598**이라는 수가 있을 때, **059_**에서 `_`는 8의 선분합인 7과 동일해야한다.\r\n\r\n만약 **05_X**에서 `_`와 `X`는 9와 8의 선분합인 12와 동일해야할 것이다. 이러한 선분합을 저장하는 변수가 `count`다.\r\n\r\n초기값으로 1의 자릿수가 가진 선분합인 `FLAG[numbers[N - 1]]`를 할당한다.\r\n\r\n<br />\r\n\r\n``` java\r\n// (10^n)의 자리 숫자부터 하나씩 비교\r\nfor (int n = 2; n < N + 1; n++)\r\n{\r\n\t// (10^n-1)의 자리까지만 표기한 수\r\n\tlong digit = number % (long) Math.pow(10, n);\r\n\t\r\n\t// (10^n)의 자릿수 선분 갯수 누적\r\n\tcount += FLAG[numbers[N - n]];\r\n\t\r\n\t// (10^n)의 자릿수에 0 ~ 9를 대입하여 비교\r\n\tfor (int num = 0; num < 10; num++)\r\n\t{\r\n\t\t// 비교할 선분의 갯수와 현재 숫자의 선분의 갯수차가 양수일 경우\r\n\t\tif (count - FLAG[num] >= (n - 1) * 2)\r\n\t\t{\r\n\t\t\t// (10^n-1)의 자릿수에 현재 숫자를 곱한 수\r\n\t\t\tlong pows = (long) Math.pow(10, n - 1) * num;\r\n\t\t\t\r\n\t\t\t// n-1 자리에서 선분의 합이 (count - FLAG[num])이 되는 가장 작은 수\r\n\t\t\tlong target = dp[n - 1][count - FLAG[num]];\r\n\t\t\t\r\n\t\t\t// pows와 target의 합이 digit과 다르며, 유효한 값을 가지는 메모이제이션 배열일 경우\r\n\t\t\tif (digit != pows + target && target != Long.MAX_VALUE)\r\n\t\t\t{\r\n\t\t\t\tlong val = pows + target - digit;\r\n\t\t\t\t\r\n\t\t\t\t// 계산한 값이 음수일 경우\r\n\t\t\t\tif (val <= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 10^N 자리를 넘어가므로 한 주기를 돌아 다시 카운팅해야한다.\r\n\t\t\t\t\tval += (long) Math.pow(10, N);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tresult = Math.min(result, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n10의 자리 이상부터는 위 소스에 의해 구분된다.\r\n\r\n`digit`는 $10^{N - 1}$의 자리에 해당하는 수가 할당된다. **05_X**에서 `X` 부분이다.\r\n\r\n`count`에 $10^N$의 선분의 합을 누적한다. `count`는 **05_X**에서 **_X**에 대한 선분 총합을 가지게 된다.\r\n\r\n<br />\r\n\r\n`_`에 0 ~ 9까지 대입되는 값을 `num`이라 한다. `X`에 대입되는 값은 DP배열에 이미 최적값을 계산해뒀으므로 그냥 꺼내서 쓰기만 하면 된다. 두 값이 `count`와 일치하면 된다.\r\n\r\n여기에선 `count`에서 `num`을 뺀다. 그럼 나머지 숫자가 있을텐데, 이를 현재 자릿수에 해당하는 DP배열에서 꺼내 사용한다.\r\n\r\n**05_X**에서 **_X**의 선분합은 12다. `_`에 3을 할당했을 경우 `X`는 `dp[1][7]`에 해당하는 숫자가 된다. 즉, **0598**과 **0538**의 선분합은 같다.\r\n\r\n<br />\r\n\r\n조건문 `if (count - FLAG[num] >= (n - 1) * 2)`을 통해 `X`가 가져야할 선분합을 계산한다.\r\n\r\n`(n - 1) * 2`인 이유는 $n = 1$일 경우 선분합의 범위는 $2 ~ 7$이기 때문, $n$에 비례하며, 일반식은 $(n - 1) * 2$와 같다. 이 최소값보다 커야 의미가 있다.\r\n\r\n* `pows` $10^{N - 1}$에 해당하는 수\r\n* `target` $10^{N - 1}$의 자리에서 `count - FLAG[num]`의 선분합을 갖는 DP배열값\r\n\r\n<br />\r\n\r\n원본값인 `digit`과 `pows + target`이 일치하지 않는 서로 다른 수이며, `target`이 DP배열의 초기값이 아닌 유효한 값을 가질 경우 이를 비교한다.\r\n\r\n`val`은 `pows + target`과 `digit` 사이의 시간차다. 이 값이 음수일 경우는 한 사이클이 돌아가므로 사이클 값인 $c$를 더해 보정한다.\r\n\r\n이후 마지막으로 계산된 `result`와 `val`을 비교하여 더 작은 값이 `result`가 된다.\r\n\r\n# 여담\r\n\r\n푼 건 7월 초에 풀었는데, 글 쓰는 와중 블로그 개편 작업을 시작하는 바람에 한 동안 못 하다가 이제서야 적는 풀이다.\r\n\r\n한달 넘게 지나서 가물가물한데, 이 문제도 이해하는 데 일주일 정도 들었던 것 같다.\r\n\r\n블로그 개편도 어느정도 마무리하고 안정화됐겠다, 다시 백준 알고리즘 풀이를 찬찬히 진행할 생각이다.\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍","url":["2021-08-24-a1020","2021","08","24","a1020"]},{"header":{"title":"블로그 텍스트 색상 예시","excerpt":"색상 테스트","coverImage":"https://user-images.githubusercontent.com/50317129/130466968-83b176c7-2175-4740-85de-12914252d160.png","date":"2021-08-20T15:43:00","type":"posts","category":"잡담","tag":["개발 블로그"],"comment":true,"publish":true},"name":"2021-08-20-color-test.md","content":"\r\n# 빨간색\r\n\r\n<p class=\"red-50\">색상 테스트</p>\r\n<p class=\"red-100\">색상 테스트</p>\r\n<p class=\"red-200\">색상 테스트</p>\r\n<p class=\"red-300\">색상 테스트</p>\r\n<p class=\"red-400\">색상 테스트</p>\r\n<p class=\"red-500\">색상 테스트</p>\r\n<p class=\"red-600\">색상 테스트</p>\r\n<p class=\"red-700\">색상 테스트</p>\r\n<p class=\"red-800\">색상 테스트</p>\r\n<p class=\"red-900\">색상 테스트</p>\r\n<p class=\"red-A100\">색상 테스트</p>\r\n<p class=\"red-A200\">색상 테스트</p>\r\n<p class=\"red-A400\">색상 테스트</p>\r\n<p class=\"red-A700\">색상 테스트</p>\r\n\r\n# 분홍색\r\n\r\n<p class=\"pink-50\">색상 테스트</p>\r\n<p class=\"pink-100\">색상 테스트</p>\r\n<p class=\"pink-200\">색상 테스트</p>\r\n<p class=\"pink-300\">색상 테스트</p>\r\n<p class=\"pink-400\">색상 테스트</p>\r\n<p class=\"pink-500\">색상 테스트</p>\r\n<p class=\"pink-600\">색상 테스트</p>\r\n<p class=\"pink-700\">색상 테스트</p>\r\n<p class=\"pink-800\">색상 테스트</p>\r\n<p class=\"pink-900\">색상 테스트</p>\r\n<p class=\"pink-A100\">색상 테스트</p>\r\n<p class=\"pink-A200\">색상 테스트</p>\r\n<p class=\"pink-A400\">색상 테스트</p>\r\n<p class=\"pink-A700\">색상 테스트</p>\r\n\r\n# 보라색\r\n\r\n<p class=\"purple-50\">색상 테스트</p>\r\n<p class=\"purple-100\">색상 테스트</p>\r\n<p class=\"purple-200\">색상 테스트</p>\r\n<p class=\"purple-300\">색상 테스트</p>\r\n<p class=\"purple-400\">색상 테스트</p>\r\n<p class=\"purple-500\">색상 테스트</p>\r\n<p class=\"purple-600\">색상 테스트</p>\r\n<p class=\"purple-700\">색상 테스트</p>\r\n<p class=\"purple-800\">색상 테스트</p>\r\n<p class=\"purple-900\">색상 테스트</p>\r\n<p class=\"purple-A100\">색상 테스트</p>\r\n<p class=\"purple-A200\">색상 테스트</p>\r\n<p class=\"purple-A400\">색상 테스트</p>\r\n<p class=\"purple-A700\">색상 테스트</p>\r\n\r\n# 진한 보라색\r\n\r\n<p class=\"deepPurple-50\">색상 테스트</p>\r\n<p class=\"deepPurple-100\">색상 테스트</p>\r\n<p class=\"deepPurple-200\">색상 테스트</p>\r\n<p class=\"deepPurple-300\">색상 테스트</p>\r\n<p class=\"deepPurple-400\">색상 테스트</p>\r\n<p class=\"deepPurple-500\">색상 테스트</p>\r\n<p class=\"deepPurple-600\">색상 테스트</p>\r\n<p class=\"deepPurple-700\">색상 테스트</p>\r\n<p class=\"deepPurple-800\">색상 테스트</p>\r\n<p class=\"deepPurple-900\">색상 테스트</p>\r\n<p class=\"deepPurple-A100\">색상 테스트</p>\r\n<p class=\"deepPurple-A200\">색상 테스트</p>\r\n<p class=\"deepPurple-A400\">색상 테스트</p>\r\n<p class=\"deepPurple-A700\">색상 테스트</p>\r\n\r\n# 남색\r\n\r\n<p class=\"indigo-50\">색상 테스트</p>\r\n<p class=\"indigo-100\">색상 테스트</p>\r\n<p class=\"indigo-200\">색상 테스트</p>\r\n<p class=\"indigo-300\">색상 테스트</p>\r\n<p class=\"indigo-400\">색상 테스트</p>\r\n<p class=\"indigo-500\">색상 테스트</p>\r\n<p class=\"indigo-600\">색상 테스트</p>\r\n<p class=\"indigo-700\">색상 테스트</p>\r\n<p class=\"indigo-800\">색상 테스트</p>\r\n<p class=\"indigo-900\">색상 테스트</p>\r\n<p class=\"indigo-\">색상 테스트</p>\r\n<p class=\"indigo-\">색상 테스트</p>\r\n<p class=\"indigo-\">색상 테스트</p>\r\n<p class=\"indigo-\">색상 테스트</p>\r\n\r\n# 파란색\r\n\r\n<p class=\"blue-50\">색상 테스트</p>\r\n<p class=\"blue-100\">색상 테스트</p>\r\n<p class=\"blue-200\">색상 테스트</p>\r\n<p class=\"blue-300\">색상 테스트</p>\r\n<p class=\"blue-400\">색상 테스트</p>\r\n<p class=\"blue-500\">색상 테스트</p>\r\n<p class=\"blue-600\">색상 테스트</p>\r\n<p class=\"blue-700\">색상 테스트</p>\r\n<p class=\"blue-800\">색상 테스트</p>\r\n<p class=\"blue-900\">색상 테스트</p>\r\n<p class=\"blue-A100\">색상 테스트</p>\r\n<p class=\"blue-A200\">색상 테스트</p>\r\n<p class=\"blue-A400\">색상 테스트</p>\r\n<p class=\"blue-A700\">색상 테스트</p>\r\n\r\n# 밝은 파랑색\r\n\r\n<p class=\"lightBlue-50\">색상 테스트</p>\r\n<p class=\"lightBlue-100\">색상 테스트</p>\r\n<p class=\"lightBlue-200\">색상 테스트</p>\r\n<p class=\"lightBlue-300\">색상 테스트</p>\r\n<p class=\"lightBlue-400\">색상 테스트</p>\r\n<p class=\"lightBlue-500\">색상 테스트</p>\r\n<p class=\"lightBlue-600\">색상 테스트</p>\r\n<p class=\"lightBlue-700\">색상 테스트</p>\r\n<p class=\"lightBlue-800\">색상 테스트</p>\r\n<p class=\"lightBlue-900\">색상 테스트</p>\r\n<p class=\"lightBlue-A100\">색상 테스트</p>\r\n<p class=\"lightBlue-A200\">색상 테스트</p>\r\n<p class=\"lightBlue-A400\">색상 테스트</p>\r\n<p class=\"lightBlue-A700\">색상 테스트</p>\r\n\r\n# 청록색\r\n\r\n<p class=\"cyan-50\">색상 테스트</p>\r\n<p class=\"cyan-100\">색상 테스트</p>\r\n<p class=\"cyan-200\">색상 테스트</p>\r\n<p class=\"cyan-300\">색상 테스트</p>\r\n<p class=\"cyan-400\">색상 테스트</p>\r\n<p class=\"cyan-500\">색상 테스트</p>\r\n<p class=\"cyan-600\">색상 테스트</p>\r\n<p class=\"cyan-700\">색상 테스트</p>\r\n<p class=\"cyan-800\">색상 테스트</p>\r\n<p class=\"cyan-900\">색상 테스트</p>\r\n<p class=\"cyan-A100\">색상 테스트</p>\r\n<p class=\"cyan-A200\">색상 테스트</p>\r\n<p class=\"cyan-A400\">색상 테스트</p>\r\n<p class=\"cyan-A700\">색상 테스트</p>\r\n\r\n# 암청색\r\n\r\n<p class=\"teal-50\">색상 테스트</p>\r\n<p class=\"teal-100\">색상 테스트</p>\r\n<p class=\"teal-200\">색상 테스트</p>\r\n<p class=\"teal-300\">색상 테스트</p>\r\n<p class=\"teal-400\">색상 테스트</p>\r\n<p class=\"teal-500\">색상 테스트</p>\r\n<p class=\"teal-600\">색상 테스트</p>\r\n<p class=\"teal-700\">색상 테스트</p>\r\n<p class=\"teal-800\">색상 테스트</p>\r\n<p class=\"teal-900\">색상 테스트</p>\r\n<p class=\"teal-A100\">색상 테스트</p>\r\n<p class=\"teal-A200\">색상 테스트</p>\r\n<p class=\"teal-A400\">색상 테스트</p>\r\n<p class=\"teal-A700\">색상 테스트</p>\r\n\r\n# 초록색\r\n\r\n<p class=\"green-50\">색상 테스트</p>\r\n<p class=\"green-100\">색상 테스트</p>\r\n<p class=\"green-200\">색상 테스트</p>\r\n<p class=\"green-300\">색상 테스트</p>\r\n<p class=\"green-400\">색상 테스트</p>\r\n<p class=\"green-500\">색상 테스트</p>\r\n<p class=\"green-600\">색상 테스트</p>\r\n<p class=\"green-700\">색상 테스트</p>\r\n<p class=\"green-800\">색상 테스트</p>\r\n<p class=\"green-900\">색상 테스트</p>\r\n<p class=\"green-A100\">색상 테스트</p>\r\n<p class=\"green-A200\">색상 테스트</p>\r\n<p class=\"green-A400\">색상 테스트</p>\r\n<p class=\"green-A700\">색상 테스트</p>\r\n\r\n# 연두색\r\n\r\n<p class=\"lightGreen-50\">색상 테스트</p>\r\n<p class=\"lightGreen-100\">색상 테스트</p>\r\n<p class=\"lightGreen-200\">색상 테스트</p>\r\n<p class=\"lightGreen-300\">색상 테스트</p>\r\n<p class=\"lightGreen-400\">색상 테스트</p>\r\n<p class=\"lightGreen-500\">색상 테스트</p>\r\n<p class=\"lightGreen-600\">색상 테스트</p>\r\n<p class=\"lightGreen-700\">색상 테스트</p>\r\n<p class=\"lightGreen-800\">색상 테스트</p>\r\n<p class=\"lightGreen-900\">색상 테스트</p>\r\n<p class=\"lightGreen-A100\">색상 테스트</p>\r\n<p class=\"lightGreen-A200\">색상 테스트</p>\r\n<p class=\"lightGreen-A400\">색상 테스트</p>\r\n<p class=\"lightGreen-A700\">색상 테스트</p>\r\n\r\n# 라임색\r\n\r\n<p class=\"lime-50\">색상 테스트</p>\r\n<p class=\"lime-100\">색상 테스트</p>\r\n<p class=\"lime-200\">색상 테스트</p>\r\n<p class=\"lime-300\">색상 테스트</p>\r\n<p class=\"lime-400\">색상 테스트</p>\r\n<p class=\"lime-500\">색상 테스트</p>\r\n<p class=\"lime-600\">색상 테스트</p>\r\n<p class=\"lime-700\">색상 테스트</p>\r\n<p class=\"lime-800\">색상 테스트</p>\r\n<p class=\"lime-900\">색상 테스트</p>\r\n<p class=\"lime-A100\">색상 테스트</p>\r\n<p class=\"lime-A200\">색상 테스트</p>\r\n<p class=\"lime-A400\">색상 테스트</p>\r\n<p class=\"lime-A700\">색상 테스트</p>\r\n\r\n# 노랑색\r\n\r\n<p class=\"yellow-50\">색상 테스트</p>\r\n<p class=\"yellow-100\">색상 테스트</p>\r\n<p class=\"yellow-200\">색상 테스트</p>\r\n<p class=\"yellow-300\">색상 테스트</p>\r\n<p class=\"yellow-400\">색상 테스트</p>\r\n<p class=\"yellow-500\">색상 테스트</p>\r\n<p class=\"yellow-600\">색상 테스트</p>\r\n<p class=\"yellow-700\">색상 테스트</p>\r\n<p class=\"yellow-800\">색상 테스트</p>\r\n<p class=\"yellow-900\">색상 테스트</p>\r\n<p class=\"yellow-A100\">색상 테스트</p>\r\n<p class=\"yellow-A200\">색상 테스트</p>\r\n<p class=\"yellow-A400\">색상 테스트</p>\r\n<p class=\"yellow-A700\">색상 테스트</p>\r\n\r\n# 등색\r\n\r\n<p class=\"amber-50\">색상 테스트</p>\r\n<p class=\"amber-100\">색상 테스트</p>\r\n<p class=\"amber-200\">색상 테스트</p>\r\n<p class=\"amber-300\">색상 테스트</p>\r\n<p class=\"amber-400\">색상 테스트</p>\r\n<p class=\"amber-500\">색상 테스트</p>\r\n<p class=\"amber-600\">색상 테스트</p>\r\n<p class=\"amber-700\">색상 테스트</p>\r\n<p class=\"amber-800\">색상 테스트</p>\r\n<p class=\"amber-900\">색상 테스트</p>\r\n<p class=\"amber-A100\">색상 테스트</p>\r\n<p class=\"amber-A200\">색상 테스트</p>\r\n<p class=\"amber-A400\">색상 테스트</p>\r\n<p class=\"amber-A700\">색상 테스트</p>\r\n\r\n# 주황색\r\n\r\n<p class=\"orange-50\">색상 테스트</p>\r\n<p class=\"orange-100\">색상 테스트</p>\r\n<p class=\"orange-200\">색상 테스트</p>\r\n<p class=\"orange-300\">색상 테스트</p>\r\n<p class=\"orange-400\">색상 테스트</p>\r\n<p class=\"orange-500\">색상 테스트</p>\r\n<p class=\"orange-600\">색상 테스트</p>\r\n<p class=\"orange-700\">색상 테스트</p>\r\n<p class=\"orange-800\">색상 테스트</p>\r\n<p class=\"orange-900\">색상 테스트</p>\r\n<p class=\"orange-A100\">색상 테스트</p>\r\n<p class=\"orange-A200\">색상 테스트</p>\r\n<p class=\"orange-A400\">색상 테스트</p>\r\n<p class=\"orange-A700\">색상 테스트</p>\r\n\r\n# 진한 주황색\r\n\r\n<p class=\"deepOrange-50\">색상 테스트</p>\r\n<p class=\"deepOrange-100\">색상 테스트</p>\r\n<p class=\"deepOrange-200\">색상 테스트</p>\r\n<p class=\"deepOrange-300\">색상 테스트</p>\r\n<p class=\"deepOrange-400\">색상 테스트</p>\r\n<p class=\"deepOrange-500\">색상 테스트</p>\r\n<p class=\"deepOrange-600\">색상 테스트</p>\r\n<p class=\"deepOrange-700\">색상 테스트</p>\r\n<p class=\"deepOrange-800\">색상 테스트</p>\r\n<p class=\"deepOrange-900\">색상 테스트</p>\r\n<p class=\"deepOrange-A100\">색상 테스트</p>\r\n<p class=\"deepOrange-A200\">색상 테스트</p>\r\n<p class=\"deepOrange-A400\">색상 테스트</p>\r\n<p class=\"deepOrange-A700\">색상 테스트</p>\r\n\r\n# 갈색\r\n\r\n<p class=\"brown-50\">색상 테스트</p>\r\n<p class=\"brown-100\">색상 테스트</p>\r\n<p class=\"brown-200\">색상 테스트</p>\r\n<p class=\"brown-300\">색상 테스트</p>\r\n<p class=\"brown-400\">색상 테스트</p>\r\n<p class=\"brown-500\">색상 테스트</p>\r\n<p class=\"brown-600\">색상 테스트</p>\r\n<p class=\"brown-700\">색상 테스트</p>\r\n<p class=\"brown-800\">색상 테스트</p>\r\n<p class=\"brown-900\">색상 테스트</p>\r\n\r\n# 회색\r\n\r\n<p class=\"grey-50\">색상 테스트</p>\r\n<p class=\"grey-100\">색상 테스트</p>\r\n<p class=\"grey-200\">색상 테스트</p>\r\n<p class=\"grey-300\">색상 테스트</p>\r\n<p class=\"grey-400\">색상 테스트</p>\r\n<p class=\"grey-500\">색상 테스트</p>\r\n<p class=\"grey-600\">색상 테스트</p>\r\n<p class=\"grey-700\">색상 테스트</p>\r\n<p class=\"grey-800\">색상 테스트</p>\r\n<p class=\"grey-900\">색상 테스트</p>\r\n\r\n# 푸른 회색\r\n\r\n<p class=\"blueGrey-50\">색상 테스트</p>\r\n<p class=\"blueGrey-100\">색상 테스트</p>\r\n<p class=\"blueGrey-200\">색상 테스트</p>\r\n<p class=\"blueGrey-300\">색상 테스트</p>\r\n<p class=\"blueGrey-400\">색상 테스트</p>\r\n<p class=\"blueGrey-500\">색상 테스트</p>\r\n<p class=\"blueGrey-600\">색상 테스트</p>\r\n<p class=\"blueGrey-700\">색상 테스트</p>\r\n<p class=\"blueGrey-800\">색상 테스트</p>\r\n<p class=\"blueGrey-900\">색상 테스트</p>","url":["2021-08-20-color-test","2021","08","20","color-test"]},{"header":{"title":"[SSL] Tomcat에 SSL 적용하기","excerpt":"SSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다. 이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-20T00:35:21","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","Tomcat(톰캣)"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-20-apply-ssl.md","content":"\r\n# 개요\r\n\r\nSSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다.\r\n\r\n이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.\r\n\r\n# Tomcat에 인증서 적용하기\r\n\r\nTomcat에 인증서를 적용한다. Tomcat Native가 설치되어있는지, 없는지에 따라 방법이 다르다.\r\n\r\n> <b class=\"orange-400\">Tomcat Native</b>  \r\n> Tomcat의 성능 향상을 위해 C, JAVA 같은 네이티브 모듈이 추가된다. Windows의 경우 dll 파일 하나만 옮기면 된다.\r\n\r\nTomcat Native가 적용되어 있다면 `pem` 파일을 바로 적용할 수 있으며, 아니라면 `pem`을 `jks`와 같은 호환 가능한 확장자로 적절히 변경해야한다.\r\n\r\n# Tomcat Native 설치방법\r\n\r\nOS에 따라 Tomcat Native를 설치하는 방법이 다르다. Tomcat Native를 설치하지 않고도 SSL을 적용할 수 있으니, 관심이 없다면 이 단계를 패스해도 무방하다.\r\n\r\n## Windows 10\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 Tomcat Native 라이브러리를 다운로드 받는다. 중간에 [Native 1.2.30 Windows Binaries.zip]을 다운로드 받으면 된다.\r\n\r\n압축 풀면 [bin] 폴더에 `tcnative-1.dll` 파일이 있을텐데, 해당 DLL을 `TOMCAT_HOME_HOME/bin`에 옮기는 것으로 설치가 끝난다.\r\n\r\n## Linux(CentOS 7 이상)\r\n\r\n``` bash\r\nyum -y install tomcat-native\r\n```\r\n\r\nCentOS 7을 기준으로 위 명령어를 입력하면 된다. 만약 위와 같은 명령어를 사용할 수 없다면 직접 [이 링크](https://tomcat.apache.org/download-native.cgi)에서 컴파일해서 적용해야한다.\r\n\r\n## Linux(컴파일)\r\n\r\n직접 소스를 컴파일해서 사용한다. <span class=\"pink-400\">CentOS</span>를 기준으로 설명한다.\r\n\r\n``` bash\r\nyum install apr-devel openssl-devel\r\n```\r\n\r\n혹은 <span class=\"pink-400\">Devian</span> 계열일 경우\r\n\r\n``` bash\r\napt-get install libapr1.0-dev libssl-dev\r\n```\r\n\r\n컴파일 이전에 위 도구들이 설치되어있어야 한다.\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 [Native 1.2.30 Source Release tar.gz]를 다운로드 받아 압축을 푼다.\r\n\r\n``` bash\r\ntar -zxvf Native 1.2.30 Source Release tar.gz\r\n```\r\n\r\n압축은 위 명령어로 해제하면 되며, OS에 따라 명령어가 다를 수 있다.\r\n\r\n``` bash\r\ncd ${압축 해제 경로}\r\n./configure --with-apr=/usr --prefix=${현재경로} --with-java-home=${JAVA_HOME}\r\nmake\r\nmake install\r\n```\r\n\r\n위 명령어를 순차적으로 입력해주면 된다.\r\n\r\n# SSL 인증서 적용하기\r\n\r\nSSL 인증서를 적용하자. <span class=\"orange-400\">Tomcat Native</span> 적용 여부에 따라 방법이 다르다.\r\n\r\n## Tomcat Native로 PEM 파일 적용하기\r\n\r\n`TOMCAT_HOME/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tSSLCertificateFile=\"example.com-crt.pem\"\r\n\tSSLCertificateKeyFile=\"example.com-key.pem\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n위와 같이 수정해주면 된다. `SSLCertificateFile`에 `crt.pem` 파일을, `SSLCertificateKeyFile`에 `key.pem` 파일 경로를 지정한다.\r\n\r\n## 일반 Tomcat에 PEM to JKS로 변환하여 적용하기\r\n\r\n어떠한 이유로든 Tomcat Native를 설치하지 못 할 경우, <span class=\"red-400\">일반 Tomcat은 PEM 파일을 인식할 수가 없다.</span> 따라서 Tomcat이 지원하는 포맷으로 변환하여 사용해야한다. 이 문서에선 `.jks` 파일으로 변환하여 적용한다.\r\n\r\n준비물은 아래와 같다.\r\n\r\n* OpenSSL\r\n* keytool (JAVA 깔면 있음)\r\n\r\n[OpenSSL](https://www.openssl.org/source/)은 직접 설치해야하고, <span class=\"orange-400\">keytool</span>은 `JAVA_HOME/bin`에 있으므로 JAVA가 있다면 따로 설치하지 않아도 된다.\r\n\r\n``` batch\r\n# pem to p12\r\nopenssl pkcs12 -export -out {name}.p12 -in {crt}.pem -inkey {key}.pem\r\n\r\n# p12 to jks\r\nkeytool -importkeystore -srckeystore {name}.p12 -srcstoretype pkcs12 -destkeystore {name}.jks -deststoretype jks\r\n```\r\n\r\n위 명령어를 순서대로 입력하면 된다. <span class=\"red-400\">변환 과정에서 인증서에 저장할 비밀번호를 요구한다. 추후 웹서버에 해당 비밀번호를 제공</span>해야하니, 잘 기억해두자.\r\n\r\n4개였던 `.pem`파일과 달리 `.jks`는 심플하게 하나만 생성된다. 생성이 완료되면 `TOMCAT_HOME/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tkeystoreFile=\"example.com.jks\"\r\n\tkeystorePass=\"비밀번호\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n`keystoreFile`에 생성한 `.jks` 파일을, `keystorePass`에 변환 과정에서 입력한 비밀번호를 입력한다.\r\n\r\n# 확인\r\n\r\n본 문서에선 SSL 포트를 `443`으로 설정했다. SSL의 기본 포트는 443이므로, 별도의 포트 표시를 하지 않아도 자동으로 연결될 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130097706-8a3cc174-e35d-46db-9f60-caa585a59d98.png)\r\n\r\n이제 톰캣을 기동하여, 도메인에 접속해보자. 인증서 정보가 확인되면 성공이다.\r\n\r\n참고로, 인증서는 도메인을 기준으로 동작한다. 만약 `localhost` 내지는 `127.0.0.1`, IP를 입력하여 들어오면 인증서 오류가 뜨니 참고할 것.\r\n\r\n# 정리\r\n\r\n이로써 SSL 적용이 완료됐다. 처음엔 뭔가 복잡해보여도, 한 번 해두면 크게 어려운 부분은 없다.\r\n\r\nLet's Encrypt는 DV 인증서를 무료로 받을 수 있는 가장 쉽고 빠른 방법이므로, SSL이 필요하다면 적극적으로 활용해보자.","url":["2021-08-20-apply-ssl","2021","08","20","apply-ssl"]},{"header":{"title":"[SSL] Windows 10에서 Let's Encrypt로 SSL 인증서 무료 발급받기","excerpt":"도메인도 있겠다. 이제 이 도메인을 가지고 SSL 인증서를 발급받아보자. 물론 SSL 인증서 또한 발급받는데 비용이 든다. 대부분의 운영 중인 도메인 업체는 SSL 발급도 병행한다. 테스트 목적이라면 도메인과 마찬가지로 SSL 발급도 부담스러울 것이다. SSL 역시 무료로 발급받을 수 있는 방법이 있으며, 도메인보다 그 방법이 훨씬 많다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-19T23:37:21","type":"posts","category":"WEB","tag":["CS","객체지향","SSL"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-19-lets-encrypt.md","content":"\r\n# 개요\r\n\r\n도메인도 있겠다. 이제 이 도메인을 가지고 SSL 인증서를 발급받아보자. 물론 SSL 인증서 또한 발급받는데 비용이 든다. 대부분의 운영 중인 도메인 업체는 SSL 발급도 병행한다.\r\n\r\n테스트 목적이라면 도메인과 마찬가지로 SSL 발급도 부담스러울 것이다. SSL 역시 무료로 발급받을 수 있는 방법이 있으며, 도메인보다 그 방법이 훨씬 많다.\r\n\r\n하지만 무료 답게 제약사항이 존재하기도 한다. 유효기간이 매우 짧다던가, 등록할 수 있는 도메인에 한계가 있다던가, 하지만 <span class=\"green-600\">Let's Encrypt</span>를 활용하면 별다른 제약 없이 SSL을 발급받을 수 있다. 이전에 설명했던 <span class=\"lightBlue-600\">Freenom</span>과 달리, 이쪽은 실서버에 적용해도 아무런 문제없이 사용할 수 있다. 덕분에 소규모 사이트의 인증서를 잘 살펴보면 심심치않게 발급기관이 <span class=\"green-600\">Let's Encrypt</span>임을 확인할 수 있다.\r\n\r\n# Let's Encrypt!\r\n\r\n<span class=\"green-600\">Let's Encrypt</span>를 통해 SSL을 발급받아보자. 환경은 아래와 같다. <span class=\"blue-600\">Windows 10</span>을 기준으로 진행한다.\r\n\r\n사실 Let's Encrypt는 SSL을 발급해주는 기관으로, Let's Encrypt에서 회원가입하고 뭐 제출하고 이런 방식이 아니다. Let's Encrypt와 통신하여 SSL을 발급해주는 프로그램들이 많이 있으니 이걸 다운로드 받으면 된다.\r\n\r\n[지원하는 프로그램 목록](https://letsencrypt.org/ko/docs/client-options/)을 확인해보자. 그 중 우리는 Windows 10용으로 빌드된 <span class=\"primary\">win-acme</span>를 사용한다.\r\n\r\n필요한 준비물은 아래와 같다.\r\n\r\n* Windows 10\r\n* 자신의 아이피와 연결된 도메인\r\n* 80포트가 접속 가능한 네트워크 환경\r\n  * 불가능하다면 DNS 설정이 가능함\r\n* WAS (여기선 Tomcat을 사용)\r\n\r\n위 준비물이 없으면 SSL 발급을 진행하기 어렵다.\r\n\r\n## 1. win-acme 다운로드\r\n\r\n아래의 사이트에서 win-acme를 다운로드 받는다.\r\n\r\n<br />\r\n\r\n<p align=\"center\"><a href=\"https://www.win-acme.com/\" target=\"_blank\">다운로드</a></p>\r\n\r\n<br />\r\n\r\n압축을 해제한다. `wacs.exe`를 실행하면 아래와 같은 창이 뜰 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130079131-3eb9c5de-c1bc-4919-a921-e4c7c7f28a3d.png)\r\n\r\n## 2. 발급 방법 선택\r\n\r\n명령어를 입력하여 발급을 진행할 것이다.\r\n\r\n* <span class=\"green-300\">Create certificate (default settings)</span>: 기본 옵션으로 SSL 발급 (N)\r\n* <span class=\"green-600\">Create certificate (full settings)</span>: 직접 옵션을 선택하여 SSL 발급 (M)\r\n* <span class=\"green-300\">Run renewals</span>: 갱신 (R)\r\n* <span class=\"green-300\">Manage renewals</span>: 갱신 관리 (A)\r\n* <span class=\"green-300\">More options...</span>: 더 많은 옵션 (O)\r\n* <span class=\"green-300\">Quit</span>: 종료 (Q)\r\n\r\n[M]을 입력하여 직접 옵션을 선택하여 SSL을 발급한다. 대소문자는 따로 구분하지 않으니 그냥 입력해도 된다.\r\n\r\n## 3. 도메인 입력 방법 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130080688-2bbbc350-399a-4bc3-b619-732d4b25ae58.png)\r\n\r\n* <span class=\"grey-600\">Read site bindings from IIS</span>: IIS에서 바인딩 (1)\r\n* <span class=\"green-600\">Manual input</span>: 직접 입력 (2)\r\n* <span class=\"green-300\">CSR created by another program</span>: 다른 프로그램에서 만든 CSR (3)\r\n* <span class=\"green-300\">Abort</span>: 중단 (C)\r\n\r\n우리는 [2]를 입력하여 직접 도메인을 입력한다.\r\n\r\n## 4. 도메인 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130080746-f57c8f5f-6243-4c9d-b5ca-a6859fcb30ec.png)\r\n\r\n인증받을 도메인을 입력한다. 다수의 도메인을 하나의 인증서로 만들 수도 있으며, 이 경우 쉼표(,)로 구분하면 된다.\r\n\r\n``` batch\r\nexample.com\r\n```\r\n\r\n하나의 도메인을 인증받는다면 위와 같이 입력한다.\r\n\r\n``` batch\r\nexample.com,www.example.com,admin.example.com\r\n```\r\n\r\n여러 도메인을 인증받는다면 위와 같이 쉼표로 구분하여 입력한다.\r\n\r\n입력한 모든 도메인이 인증되어야하니 참고할 것. 도메인을 입력하면 도메인에 대한 별칭을 입력하라고 하는데, 그냥 아무것도 입력하지 말고 [Enter] 눌러서 다음으로 넘어가자.\r\n\r\n## 5. 인증 방법 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130081483-11eef349-d3e7-4e81-9498-67355eb2632f.png)\r\n\r\n* <span class=\"green-600\">Save verification files on (network) path</span>: 네트워크 경로에 인증 파일 저장 (1)\r\n* <span class=\"grey-600\">Serve verification files from memory</span>: 메모리에 인증 파일 저장 (2)\r\n* <span class=\"green-300\">Upload verification files via FTP(S)</span>: FTP를 통한 인증 파일 업로드 (3)\r\n* <span class=\"green-300\">Upload verification files via SSH-FTP</span>: SSH-FTP를 통한 인증 파일 업로드 (4)\r\n* <span class=\"green-300\">Upload verification files via WebDav</span>: WebDav를 통한 인증 파일 업로드 (5)\r\n* <span class=\"green-300\">Create verification records manually (auto-renew not possible)</span>: 수동으로 인증 레코드 생성 (자동 갱신 불가능) (6)\r\n* <span class=\"green-300\">Create verification records acme-dns</span>: acme-dns를 통한 인증 레코드 생성 (7)\r\n* <span class=\"green-300\">Create verification records with your own script</span>: 본인 소유의 스크립트를 통해 인증 레코드 생성 (8)\r\n* <span class=\"grey-600\">Answer TLS verification request from win-acme</span>: win-acme의 TLS 인증요청 응답 (9)\r\n\r\n1번은 이후 입력할 웹루트 경로에 인증파일을 생성해주고, 3 ~ 5번은 제공해주는 파일을 직접 업로드한다. 6 ~ 8번은 DNS 레코드 설정이 필요하다.\r\n\r\n통상 1번이 가장 쉬우니, 본 문서에는 1번으로 진행한다.\r\n\r\n## 6. 웹루트 경로 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130083363-c4e34aeb-6041-4895-9e4c-71085514f51f.png)\r\n\r\n웹루트 경로를 입력한다. 예를 들어, `https://example.com` 도메인이 있다면, 이 도메인의 파일들이 위치한 경로를 입력해야한다.\r\n\r\n만약 순정 <span class=\"amber-400\">Tomcat</span>이라면 `$TOMCAT_HOME/webapps/ROOT`가 될 것이다.\r\n\r\n환경마다 다르니, 적절히 입력해주면 된다. 이 때 반드시 <span class=\"red-600\">80포트로 접속이 가능해야함에 주의</span>한다.\r\n\r\n만약 80포트 사용이 불가능하다면 DNS 설정으로 인증하는 6 ~ 8번을 시도하자. 이메일 인증은 지원하지 않는다.\r\n\r\n웹 설정을 복사할거냐고 물어보는데, 하지말자.\r\n\r\n## 7. CSR 유형 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130084201-636a0f36-ac1a-4aaa-b17d-948248b2600c.png)\r\n\r\n* <span class=\"green-300\">Elliptic Curve key</span>: 타원곡선 암호화 (1)\r\n* <span class=\"green-600\">RSA Key</span>: 비대칭 암호화 (2)\r\n\r\n[2]를 선택한다.\r\n\r\n## 8. 인증서 저장 방식 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130084595-c96c3c33-ddde-4b95-b395-5e073d6b4eba.png)\r\n\r\n* <span class=\"green-300\">IIS Central Certificate Store</span>: IIS용 인증서 (.pfx) (1)\r\n* <span class=\"green-600\">PEM encoded files</span>: 아파치 계열용 인증서 (.pem) (2)\r\n* <span class=\"green-300\">PFX archive</span>: .pfx 파일 (3)\r\n* <span class=\"grey-600\">Windows Certificate Store</span>: 윈도우 인증서 저장소 (4)\r\n* <span class=\"green-300\">No (additional) store steps</span>: (추가적인) 인증서 미저장 (2)\r\n\r\n본 문서에선 Tomcat을 기준으로 설명하므로 [2]를 선택한다.\r\n\r\n## 9. 저장경로 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130085226-7f89895e-ad04-4851-9b6f-5922eb749f36.png)\r\n\r\n원하는 저장경로를 입력한다. 편한 경로로 입력하자.\r\n\r\n## 10. 키파일 암호 입력 방식\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130085398-cc5e9c1e-6b1c-4b20-ba3d-d62caf3b02e3.png)\r\n\r\n* <span class=\"green-300\">None</span>: 안 함 (1)\r\n* <span class=\"green-600\">Type/paste in console</span>: 콘솔에서 입력/붙여넣기 (2)\r\n* <span class=\"green-300\">Search in vault</span>: vault에서 검색 (3)\r\n\r\n[2]를 선택한다.\r\n\r\n원하는 비밀번호를 입력한다. 입력하면 해당 비밀번호를 추후 사용하도록 valut에 저장할 것이냐고 묻는다. 원하는대로 하자.\r\n\r\n저장하게 되면 아마 [3]을 통해 이전의 암호를 사용할 수 있을 것 같다.\r\n\r\n## 11. 추가 인증서 저장 방식 선택\r\n\r\n8번과 같은 과정. 추가로 다른 확장자의 인증서가 필요하면 더 하면 된다.\r\n\r\n이 문서에선 필요 없으므로, [5]를 눌러 더 생성하지 않고 넘어간다.\r\n\r\n## 12. 추가 옵션\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130086251-6744a758-1f4a-44b3-9bc1-ed260fac4d67.png)\r\n\r\n* <span class=\"grey-300\">Create or update https bindings in IIS</span>: IIS에 HTTPS 바인딩 생성 혹은 갱신 (1)\r\n* <span class=\"grey-300\">Create or update ftps bindings in IIS</span>: IIS에 FTPS(보안 FTP) 바인딩 생성 혹은 갱신 (2)\r\n* <span class=\"green-300\">Start external scripts or program</span>: 외부 스크립트 실행 (3)\r\n* <span class=\"green-600\"></span>: 추가적인 설치 과정 없음 (4)\r\n\r\n[4] 별도로 할게 없으므로 넘어가자.\r\n\r\n## 13. 도메인 인증\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130086813-01c8e143-e2dd-4b3b-ad41-d89292d07607.png)\r\n\r\n아까 입력했던 도메인에 대한 인증을 수행한다. 도메인의 유효성만 검증하므로 DV 인증서라고 할 수 있다.\r\n\r\n아까 입력했던 웹루트에 `.well-known` 폴더가 생성됐을 것이다.\r\n\r\n`http://www.kapoo.ga/.well-known/{hash}/{file}`로 접근해서 실제 자신이 랜덤으로 생성한 파일의 정보와 일치한지 확인한다. 맞다면 해당 도메인이 유효하다고 판단한다.\r\n\r\n나중에 특정 작업 수행할 거냐고 물어보는 대답엔 아니라고 하자.\r\n\r\n## 14. 인증서 확인\r\n\r\n9번 과정에서 입력한 저장 경로로 가보면 `pem` 파일이 생성되었을 것이다.\r\n\r\n* example.com-chain.pem: 서명과 CA 중간 인증서를 통합한 인증서\r\n* example.com-chain-only.pem: CA의 중간 인증서\r\n* example.com-crt.pem: 서명된 인증서\r\n* example.com-key.pem: 인증서 개인키\r\n\r\n위 네 파일이 생성되면 정상적으로 SSL을 발급받은 것이다. 이를 웹서버, WAS 등에 적용하면 된다.\r\n\r\n# 정리\r\n\r\nLet's Encrypt를 통해 SSL을 무료로 발급받았다. 무료지만 무려 1년의 유효기간을 가지며, 발급 시 자동갱신 스크립트도 자동으로 추가된다.\r\n\r\n무료임에도 불구하고 환경만 잘 구축해두면, SSL은 거의 신경쓰지 않아도 된다. 이러한 편의성 때문에 무료임에도 많은 곳에서 Let's Encrypt를 사용한다.\r\n\r\n다음 장에서는 이 인증서를 직접 Tomcat에 적용해본다.","url":["2021-08-19-lets-encrypt","2021","08","19","lets-encrypt"]},{"header":{"title":"[SSL] Freenom을 활용한 무료 도메인 발급하기","excerpt":"이전 글들에서 SSL이 뭔지, 어떤식으로 동작하는지를 다뤘다. 사이트에 SSL을 적용하기 위해선 SSL 인증서를 발급받아야한다. SSL 인증서를 발급받기 위해선 인증받기 위한 도메인이 필요하다. 국내에서 서비스 중인 도메인 업체에서 쉽게 발급받을 수 있다. 위 업체는 도메인 외에도 호스팅 등 다양한 서비스를 제공한다. 이 외에도 여러 업체들이 있으며, 국내 뿐만 아니라 해외에서 서비스 중인 업체들도 있다. 업체마다 가격 및 정책이 다르니 발품팔다보면 좋은 금액으로 구매할 수도 있다. TLD(Top Level Domain)에 따라 가격이 달라지며, 저렴한 건 연간 몇 천원에서부터 비싸면 수십만원대에 이르기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T23:44:43","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","도메인"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-freenom-domain.md","content":"\r\n# 개요\r\n\r\n이전 글들에서 SSL이 뭔지, 어떤식으로 동작하는지를 다뤘다. 사이트에 SSL을 적용하기 위해선 SSL 인증서를 발급받아야한다.\r\n\r\nSSL 인증서를 발급받기 위해선 인증받기 위한 도메인이 필요하다. 국내에서 서비스 중인 도메인 업체에서 쉽게 발급받을 수 있다.\r\n\r\n* [가비아](https://www.gabia.com/)\r\n* [후이즈](https://whois.co.kr/)\r\n* [카페24](https://www.cafe24.com/)\r\n\r\n위 업체는 도메인 외에도 호스팅 등 다양한 서비스를 제공한다.\r\n\r\n이 외에도 여러 업체들이 있으며, 국내 뿐만 아니라 해외에서 서비스 중인 업체들도 있다. 업체마다 가격 및 정책이 다르니 발품팔다보면 좋은 금액으로 구매할 수도 있다.\r\n\r\nTLD(Top Level Domain)에 따라 가격이 달라지며, 저렴한 건 연간 몇 천원에서부터 비싸면 수십만원대에 이르기도 한다.\r\n\r\n> **TLD?**  \r\n> com, net과 같이 URL 마지막에 오는 최상위도메인을 뜻한다. TLD에 대한 내용은 이전에 작성한 게시글 <a href=\"/2021/05/29/uri-url-urn#TLD(Top-Level Domain, 최상위 도메인)\">URI? URL? URN? 리소스 식별자 구분하기</a>에서 확인 가능하다.\r\n\r\n# Freenom으로 무료 도메인 받기\r\n\r\n물론 위 방법으로 도메인을 발급받아도 좋지만, 여기엔 돈이 든다. 만약 본인이 실제 웹을 배포할 생각이라면 당연히 도메인을 구입하는 게 맞다.\r\n\r\n하지만 도메인 연결, SSL 적용 등 단순 테스트 목적이라면 적은 비용이라도 좀 아깝다는 생각이 들게 된다.\r\n\r\n다행히 [Freenom](https://www.freenom.com/)에서 무료 도메인을 발급해주니, 단순 테스트 목적으로 부담없이 사용할 수 있다.\r\n\r\n## 주의사항\r\n\r\nFrenom을 사용하는 데 몇 가지 주의사항이 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">1. 사용 가능한 TLD가 제한적임</p>\r\n\r\n주로 사용하는 TLD는 `com`, `net` 등이 있지만, Freenom은 `ga`, `ml` 등 특정한 ccTLD만 지원한다.\r\n\r\n* `tk (Tokelau)`: 뉴질랜드령 토켈라우제도\r\n* `ml (Mali)`: 말리\r\n* `ga (Gabon)`: 가봉\r\n* `gq (Equatorial Guinea)`: 적도 기니\r\n* `cf (Central African Republic)`: 중앙아프리카 공화국\r\n\r\n대중적인 TLD를 선택할 순 없지만, 무료이니 감안하자. 어차피 후술할 이유로 실제 서비스에 적용하기엔 무리가 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">2. 연장 시기를 놓치면 유료화</p>\r\n\r\n발급받은 도메인은 최대 1년 단위로 연장해야한다. 연장은 만료일로부터 2주 안에 신청이 가능하다.\r\n\r\n연장하는데 비용은 들지 않으나, 문제는 연장 시기를 놓쳐 만료될 경우다. 이렇게 만료된 도메인은 새로 발급받아야하는데, <span class=\"purple-600\">Special Domain</span>으로 분류되어 약 9$ 정도의 비용을 요구한다.\r\n\r\n9$이면 괜찮은 TLD의 도메인을 발급받을 수 있을 정도의 금액이므로 여기서 구매할 이유도 딱히 없다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large red-600\">3. 인기 도메인 강제 하이재킹</p>\r\n\r\nFreenom 도메인을 <span class=\"red-400\">실제 서비스에 사용하면 안되는 결정적인 이유.</span>\r\n\r\n만약, 당신의 서비스에 Freenom 도메인을 적용했는데, 운 좋게 서비스의 인기가 많아졌다고 가정하자. 인가가 많아지면 덩달아 접속량도 많아지는 건 당연지사.\r\n\r\n문제는 Freenom에서 이를 모니터링한다는 점이다. 단순 모니터링해서 접속자 통계를 제공해주면 좋겠지만, 무료인데 그런 서비스를 제공할리가 없다.\r\n\r\n실상은 도메인이 일정 트래픽 이상을 발생시키면 <span class=\"purple-600\">Special Domain</span> 어쩌고 하면서 <span class=\"red-400\">유료로 전환</span>시켜버린다.\r\n\r\n2번이야 연장하지 않은 귀책사유라도 있지, 이건 그냥 도메인 강탈이라서 답도 없다. 트래픽이 많으면 다음 갱신이 불가능하다 이런 것도 아니고, 그냥 <span class=\"red-400\">트래픽이 많은 도메인은 언제든 뺏길 수 있다.</span>\r\n\r\n도메인이야 다시 발급받으면 된다지만, 이미 사용하던 사람들에게 도메인의 변경으로 혼란을 주고, 서비스의 신뢰성을 훼손하게 되므로 서비스 운영에 지대한 악영향을 미친다.\r\n\r\n# 도메인 발급 방법\r\n\r\n아래의 절차에 따라 도메인을 발급받자. 외국 소재 사이트다보니, 사이트 속도가 좀 느릴 수도 있으니 참고할 것.\r\n\r\n## 1. 회원가입\r\n\r\n[Freenom](https://www.freenom.com/)에 접속하여 회원가입을 진행한다. Google 소셜 로그인을 지원하니, 이쪽을 시도해도 좋다.\r\n\r\n## 2. 사용 가능한 도메인 검색\r\n\r\n검색창에서 원하는 도메인명을 검색한다. [Services] -> [Register a New Domain]을 메뉴를 선택하면 검색 페이지가 뜬다. \r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129911927-51d23984-87d3-47e9-88bf-e13abf2dff8a.png)\r\n\r\n<span class=\"blue-400\">rwb0104</span>의 경우 5개의 무료 도메인 중 5개 전부 적용이 가능하다.\r\n\r\n## 3. 무료 TLD 선택\r\n\r\n앞서 언급했듯이, 무료 도메인은 총 5개가 있다.\r\n\r\n이 중 원하는 TLD를 선택하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129912910-869d2ce9-d312-4cf6-85bf-4aa534ea87d8.png)\r\n\r\n여기에선 `tk` TLD를 선택한다. 위의 [<span class=\"green-A400\">Checkout</span>] 버튼을 클릭하여 다음으로 넘어간다.\r\n\r\n## 4. 옵션 선택\r\n\r\n도메인 옵션을 선택한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129913319-c648e9cd-f097-4761-bede-685b5732039f.png)\r\n\r\n보다시피 별건 없고, 반드시 우측 콤보박스에서 [Period]를 12개월로 맞추자. 최대 12개월까지 무료로 사용 가능하며, 만료일자 기준으로 2주 안에 갱신이 가능하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129913740-d8f36236-2136-477f-8375-e20e435156a1.png)\r\n\r\n[<span class=\"green-A400\">Use DNS</span>]를 선택하여 자신의 IP를 입력하자.\r\n\r\n자신의 실제 IP는 [여기](https://www.findip.kr/)에서 확인할 수 있다. 192.168.0.x과 같은 사설 IP는 입력하면 안 된다.\r\n\r\n위 사진은 `rwb0104.tk`와 `www.rwb0104.tk`에 매칭되는 아이피를 연결하는 설정이다. 앞의 `www`와 같은 서브도메인은 필요에 따라 DNS 설정을 통해 추가할 수도, 삭제할 수도 있으니 크게 신경쓰지 않아도 된다.\r\n\r\n모든 설정을 완료했다면 [<span class=\"lightBlue-A400\">Continue</span>]를 클릭하여 진행한다.\r\n\r\n## 5. 구매\r\n\r\n100원이든 0원이든 일단 \"구매\"는 하는 셈이니, 절차상 구매 약관에 따라 구매한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129914504-abad20fc-e84d-4040-a003-1b82e6ba8080.png)\r\n\r\n$0.00 달러임을 확인하자. 문제가 없다면 약관에 동의하고 [<span class=\"lightBlue-A400\">Complete Order</span>]를 클릭한다.\r\n\r\n구매 확인서가 나오는데, 어차피 무료로 구매했으므로 신경쓰지 말고 넘어가자.\r\n\r\n## 6. 발급받은 도메인 확인\r\n\r\n[Services] -> [My Domains]에서 발급받은 도메인 목록을 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129914950-4ecd1040-82eb-4a35-b402-4914ea1013c1.png)\r\n\r\n[Manage Domain] 버튼을 클릭하면 도메인 설정을 변경하거나 삭제할 수 있다.\r\n\r\n# 도메인을 활용해 접속하기\r\n\r\n이제 도메인을 사용해 내 서버에 접속하자.\r\n\r\n아무런 설정을 건드리지 않은 Tomcat을 기동한다. 통상 `xxx.xxx.xxx.xxx:8080` 혹은 `localhost:8080`으로 접속했겠지만, 이제 IP `xxx.xxx.xxx.xxx`가 도메인과 연결되어 있으므로, 해당 도메인으로 접속해보자.\r\n\r\n`rwb0104.tk:8080` 이렇게 접속해서 문제없이 접속되면 도메인이 정상적으로 IP와 연동된 것이다.\r\n\r\n## 연결이 되지 않아요!\r\n\r\n* `xxx.xxx.xxx.xxx:8080`으로 접속되는지 확인할 것\r\n  * 접속이 될 경우 외부에서 문제없이 접속되므로, 도메인에 연결한 IP가 올바른지 확인\r\n  * 접속되지 않을 경우 애초에 외부에서 접속되지 않는 것이므로 방화벽이나 포트 통신에 문제가 없는지 확인\r\n\r\n# 정리\r\n\r\nFreenom은 실제로 쓰긴 굉장히 난감한 단점을 가진다. 그럼에도 불구하고 도메인 관련 테스트나 공부할 땐 또 이만한 사이트가 없는 것 같다.\r\n\r\n이제 도메인까지 발급받았으니, SSL 인증서를 발급받는 방법에 대해 다뤄보자.","url":["2021-08-18-freenom-domain","2021","08","18","freenom-domain"]},{"header":{"title":"[SSL] SSL 인증서","excerpt":"이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다. SSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다. 그렇다면, 해당 도메인에 SSL이 적용되어 https를 사용할 수 있는 이유는 무엇일까?","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T10:55:24","type":"posts","category":"WEB","tag":["CS","객체지향","SSL"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl-license.md","content":"\r\n# 개요\r\n\r\n이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다.\r\n\r\nSSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다.\r\n\r\n그렇다면, 해당 도메인에 SSL이 적용되어 `https`를 사용할 수 있는 이유는 무엇일까?\r\n\r\n# SSL 인증서\r\n\r\n이는 바로 인증서의 존재 덕분이다. 해당 사이트에 SSL이 적용되었는지 여부는 HandShake의 과정 중 ServerHello에서 받은 인증서 정보를 통해 확인할 수 있다.\r\n\r\nSSL 인증서엔 도메인명, 회사 정보, 서버 공개키가 포함되어있으며, 이 정보를 통해 도메인의 사이트의 유효성 확인, 암호화 통신이 가능하다.\r\n\r\n# SSL 인증서 종류\r\n\r\nSSL 인증서는 인증서 심사의 수준에 따라 DV, OV, EV 세 가지로 구분할 수 있다.\r\n\r\n## DV(Domain Validation)\r\n\r\n<span class=\"pink-600\">DV</span>는 오로지 <span class=\"pink-400\">도메인의 소유만을 검증하여 발급하는 인증서</span>다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820828-2bcf1d36-c954-471d-a7ce-e5facfa27859.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명 (*일 경우 와일드 카드)\r\n\r\n인증서 정보의 주체를 보면 도메인 정보인 CN외에 다른 정보는 확인할 수 없다.\r\n\r\nDV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n도메인 외의 소유자 등에 대한 다른 요인은 전혀 심사에 반영되지 않으므로, <span class=\"green-400\">발급 절차가 간단하고 금방 발급</span>된다. 또한 <span class=\"green-400\">금액 역시 대체적으로 저렴</span>한 편. 하지만 <span class=\"red-400\">신뢰성은 다른 인증서에 비해 떨어진다.</span>\r\n\r\n이 도메인이 실제함은 보증하지만, 그 이상의 요인은 보증하지 않기 때문이다. 혹여 누군가가 불법적인 일을 위해 페이퍼 컴퍼니를 만들고, 사이트를 그럴듯하게 꾸며놓아도 DV 인증서는 SSL을 발급해준다. 심사 기준이 오로지 도메인이기 때문에 발생하는 문제.\r\n\r\n물론 이는 어디까지나 단순한 \"믿음\"의 영역으로, <span class=\"green-400\">DV 인증서의 암호화 알고리즘이 다른 인증서에 비해 취약한 것도 아니기 때문에 보안 자체엔 전혀 문제가 없다.</span>\r\n\r\n신뢰에 기반하는 쇼핑몰, 금융업 등의 서비스에선 가급적 지양해야할 인증서.\r\n\r\n반대로 신뢰성을 그렇게 크게 요구하지 않는 <span class=\"lightBlue-400\">개인 프로젝트</span>, <span class=\"lightBlue-400\">소규모 사이트</span> 등엔 시간적으로나 경제적으로나 DV가 적합하다. DV 인증서를 직접 보고 싶다면, 소규모 개인 사이트나 블로그에 들어가면 된다. 블로그의 경우 GitHub나 NAVER 같은 플랫폼 연계가 아닌, 실제 본인이 서버를 임대해서 플랫폼 없이 직접 배포하는 그런 블로그에 들어가야 한다.\r\n\r\n### E-Mail\r\n\r\n<span class=\"orange-400\">도메인 소유주의 이메일에 인증 메일을 발송하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\n이 이메일은 아무거나 지정할 수 없고, 도메인을 발급받은 DNS 사이트에 등록된 이메일만 가능하다.\r\n\r\n타 인증방식과 다르게 <span class=\"green-400\">HTTP 80포트를 사용하지 못 해도 인증이 가능한 방식</span>이다. 만약 어떠한 이유로든 외부에서 자신의 사이트에 80포트로 접속할 수 없는 경우, 이 방법 외에 다른 인증은 불가능하다.\r\n\r\n### DNS 레코드\r\n\r\n<span class=\"orange-400\">DNS 설정을 추가하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\nDNS 설정의 A 레코드에 CA에서 임의로 생성한 URL을 추가한다. 해당 URL로 접근했을 때, HTTP 응답 코드가 200일 경우 인증된다.\r\n\r\nDNS 설정은 도메인 소유주만 관리할 수 있으므로, CNAME이 추가되면 도메인 소유주라 간주할 수 있다.\r\n\r\n반드시 <span class=\"red-400\">80포트로 웹 페이지에 접속할 수 있어야한다.</span> 만약 본인의 네트워크 환경 특수성으로 인해 80포트가 외부로 개방되지 않을 수도 있다. 이 경우 포트포워딩을 사용해서 외부의 80포트를 내부의 다른 포트로 라우팅해주면 된다. 최악의 경우 80포트 자체의 연결이 막혔거나, 본인이 포트포워딩을 마음대로 설정할 수 없는 경우는 이 방법으로 인증할 수 없다.\r\n\r\n### HTTP 요청\r\n\r\n웹 ROOT 경로에 `.well-known` 폴더를 생성하여 내부에 임시 파일을 생성한다. 임시 파일은 랜덤한 해쉬값이다. 이를 웹 서버에 배포하면 브라우저 상에서 해당 경로를 통해 파일에 접근할 수 있을 것이다.\r\n\r\n<span class=\"orange-400\">HTTP 요청은 이러한 방식으로 소유주에게 특정 파일을 서버에 업로드할 것을 요구하여, 해당 파일 접근 가능 여부를 통해 소유주임을 인증</span>한다.\r\n\r\n마찬가지로, <span class=\"red-400\">80포트 접근이 가능해야만 할 수 있는 인증</span>방법.\r\n\r\n## OV(Organization Validation)\r\n\r\n<span class=\"pink-600\">OV</span>는 <span class=\"pink-400\">도메인 뿐만 아니라, 해당 도메인을 소유한 회사, 기업에 대해 검증하여 발급</span>하는 인증서다.\r\n\r\n내가 제출한 도메인이 유효한지와는 별개로 <span class=\"orange-400\">도메인을 소유한 단체, 회사에 대한 검증까지 진행</span>한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820836-ac84d888-46cc-4877-a060-bea4df121e7c.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명\r\n* <span class=\"orange-400\">O(Organization)</span>: 기관명\r\n* <span class=\"orange-400\">L(Locality)</span>: 지역(시군구)\r\n* <span class=\"orange-400\">S(StateOrProvinceName)</span>: 주(시도)\r\n* <span class=\"orange-400\">C(CountryName)</span>: 국가\r\n\r\n인증서의 주체를 보면 도메인 정보 외에도 이를 소유한 회사/기관의 이름, 지역, 국가 등의 정보를 확인할 수 있다.\r\n\r\nOV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.2</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n자신의 단체/회사가 실존하는지를 입증하기 위해 사업자 등록증 같은 서류를 추가로 제출해야한다.\r\n\r\n소유주에 대한 검증 및 서류가 오가게 되므로, <span class=\"red-400\">발급이 즉시 이루어지진 못한다. 비용도 더 비싸며 족히 1 ~ 3일 정도는 소요</span>되는 편. 하지만 소유주에 대한 인증 덕분에 <span class=\"green-400\">보편적인 신뢰성을 제공</span>한다.\r\n\r\n대부분의 사기업 페이지에 적합한 인증서. OV 인증서는 <span class=\"lightBlue-400\">대부분의 사이트에 적용</span>되어 있으므로, 대충 번듯한 사이트 하나 들어가서 보면 된다. 지금 이 블로그도 GitHub가 주체라 OV 인증서를 확인할 수 있으니 참고할 것.\r\n\r\n## EV(Extended Validation)\r\n\r\n<span class=\"pink-400\">DV, OV인증과 더불어 법인 운영 담당자의 재직 증명, 법인 운영 기간 등 디테일한 요인을 검증</span>하여 발급하는 인증서다.\r\n\r\nOV의 경우 회사가 실재하는지를 검증한다면, <span class=\"pink-400\">EV</span>는 회사가 정상적으로 운영되는지를 검증한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820838-a87a8221-7785-49be-a3c2-26d0041b3295.png)\r\n\r\n인증서의 주체를 보면 도메인 정보, 회사 정보 외에도 다양한 정보가 추가되었음을 알 수 있다.\r\n\r\nEV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820842-41c97a59-f306-48d7-abfc-e6a06fd8ccf4.png)\r\n\r\n또한 EV 인증서는 다른 인증서와 달리 인증서 자체에 회사 서명을 표시해준다. 위 사진을 기준으로 좌측이 EV, 우측이 OV 혹은 DV. Microsoft Chromium Edge 기준으로 위와 같이 표시해준다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820843-1c77482f-bf84-47c4-a46b-ecfdf8149398.png)\r\n\r\n그 뿐만 아니라, IE로 접속했을 경우 주소창에 <span class=\"green-600\">Green Bar</span>를 적용하여 해당 도메인에 EV가 적용되었음을 시각적으로 알려준다. Chromium 기반 브라우저의 경우 시각적으로 표현해주진 않으니 참고할 것.\r\n\r\n인증서의 까다로운 심사절차로 인해 <span class=\"green-400\">발급하는데 걸리는 시간은 2주가 넘어가기도 하며, 비용 또한 매우 비싸다.</span> 하지만 <span class=\"red-400\">매우 강도 높은 신뢰성을 제공</span>한다.\r\n\r\n위와 같은 신뢰성 때문에, 이러한 신뢰성 보증이 필요한 공공기관, 금융권, 쇼핑몰과 같은 페이지에 사용된다. EV 인증서를 직접 보고싶다면, 아무 은행 홈페이지나 들어가보자.\r\n\r\n# 정리\r\n\r\nSSL이 적용되었는지 여부는 해당 사이트에 SSL 인증서가 있는지 여부를 통해 확인할 수 있다. 겉보기엔 SSL 인증서가 거기거 거기같지만 사실 그 종류만 해도 여러가지가 있으며, 인증서의 주체, 정책을 통해 현재 접속 중인 사이트의 SSL 종류를 확인할 수 있다.\r\n\r\nSSL을 적용하는 사이트의 성향에 따라 적합한 SSL 인증서를 발급받도록 하자.\r\n\r\n다음 장에서는 SSL 인증을 받기 위한 사전작업인 도메인 발급을 받아본다.","url":["2021-08-18-about-ssl-license","2021","08","18","about-ssl-license"]},{"header":{"title":"[SSL] SSL이란?","excerpt":"웹을 배포해본 적이 있다면 SSL에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 https://로 시작하며, http://와 달리 보안(Secure)을 의미하는 s가 붙는다. 지금 이 사이트의 주소도 https://blog.itcode.dev로 SSL이 적용된 걸 확인할 수 있다. NAVER나 Google도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T00:26:08","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","TLS"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl.md","content":"\r\n# 개요\r\n\r\n웹을 배포해본 적이 있다면 <span class=\"pink-600\">SSL</span>에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 `https://`로 시작하며, `http://`와 달리 <span class=\"blue-400\">보안(Secure)</span>을 의미하는 `s`가 붙는다. 지금 이 사이트의 주소도 [https://blog.itcode.dev](https://blog.itcode.dev)로 SSL이 적용된 걸 확인할 수 있다. [NAVER](https://naver.com)나 [Google](https://google.com)도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.\r\n\r\n# SSL(Secure Socket Layer)\r\n\r\n그렇다면 이 <span class=\"pink-600\">SSL</span>이란 놈은 뭘까? SSL은 Secure Socket Layer의 약자로, 직역하면 암호화 소켓층이다. 1994년 Netscape사에서 처음 개발되어 3.0 버전까지 존재한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129691442-090810ed-30c5-4245-aa9d-9dd785f621a6.png)\r\n\r\nSSL이란, <span class=\"amber-400\">웹 서버와 클라이언트의 통신 암호화 프로토콜</span>이다.\r\n\r\nSSL이 적용되지 않은 통신의 경우, 위 그림과 같이 평문(Plain Text)가 그대로 전송된다. 만약 제 3자가 어떠한 방식으로든 통신 패킷을 탈취할 경우, 그 내용을 쉽게 확인할 수 있다.\r\n\r\n통신 내용에 시덥잖은 것만 있다면 다행이겠지만, 사용자의 개인 정보나, 결제 정보와 같은 민감한 정보의 통신이라면 얘기가 달라진다.\r\n\r\nSSL을 적용한다면 이러한 문제를 기술적으로 해결할 수 있다. 요청을 암호화해서 보내므로 통신 패킷이 탈취되도 복호화 키가 없으면 원래 내용을 알 수 없기 때문이다.\r\n\r\n## TLS(Transport Layer Security)\r\n\r\nSSL을 접하다보면 <span class=\"pink-600\">TLS</span>라는 개념도 접하게 된다. 찾다보면 SSL이랑 TLS랑 혼재되어있기도 하고.\r\n\r\nSSL은 1996년에 3.0 버전이 출시되었으며, 보안취약점으로 인해 현재는 퇴출된 상태다.\r\n\r\nTLS는 국제 인터넷 표준화 기구(IETF)에서 개발한 것으로, SSL 3.0의 보안취약점을 보완한 통신 보안 프로토콜이다. 현재 TLS는 2018년 1.3 버전이 출시됏다.\r\n\r\nSSL을 보완한 것이 TLS지만, 인터넷에 적용되는 통신 보안 프로토콜을 전부 통틀어서 SSL이라 부른다.\r\n\r\n실상은 2015년에 SSL의 마지막 버전인 3.0 마저 금지됐다. 현재 사용 중인 프로토콜은 모두 TLS다.\r\n\r\n# SSL의 특징\r\n\r\n1. URL 프로토콜은 `https`이며, 기본 포트는 `443`이다.\r\n2. 통신 데이터가 암호화되어, 패킷이 탈취되는 사고가 발생해도 데이터를 지킬 수 있다.\r\n3. SSL 인증서를 통해 도메인의 신뢰성을 검증할 수 있다.\r\n4. 데이터 송/수신 과정에서 암/복호화가 발생하므로 속도가 느리다.\r\n\r\n# SSL의 원리\r\n\r\nSSL의 통신하는 원리는 아래와 같으며, 이러한 일련의 과정을 HandShake라 한다. 클라이언트와 서버 간의 요청/응답을 반복하며 통신에 필요한 사전 작업을 하는게 마치 악수 같아 붙여졌다고 한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129752108-1423e7cf-3c4c-4e4c-a77a-7a76d208d7f8.png)\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">1. ClientHello 요청</p>\r\n\r\n클라이언트가 특정 주소에 접근하면, 해당하는 서버에 요청을 보낸다. [NAVER](https://naver.com)에 접근하면 네이버 서버에 요청을 보내게 된다.\r\n\r\n* 난수 데이터\r\n* 암호화 프로토콜 정보 (프로토콜, 버전 등)\r\n* 클라이언트가 사용 가능한 암호화 기법\r\n* 세션 아이디\r\n* 기타 확장 정보\r\n\r\n이 요청에는 위와 같은 정보들이 포함되어있다. 클라이언트의 주요 정보를 서버에 전송하여, 해당 클라이언트를 식별하고, 어떤 암호화를 사용할 수 있는 지 등의 정보를 서버가 인지하도록 한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">2. ServerHello 응답</p>\r\n\r\n서버가 ClientHello 요청을 받으면, 위의 정보를 담아 클라이언트에게 일종의 화답을 보낸다.\r\n\r\n* 난수 데이터 (ClientHello의 데이터와 다름)\r\n* 서버가 사용할 암호화 기법\r\n* 인증서\r\n  * CA\r\n  * 도메인\r\n  * 공개키\r\n\r\n난수 데이터는 ClientHello에서 보낸 데이터과 아무런 상관관계가 없는 별개의 데이터다.\r\n\r\n클라이언트가 사용 가능하다고 통보한 암호화 기법 중 서버에서 활용할 암호화 기법을 전달하여 동일한 암호화 기법으로 송수신할 수 있도록 선언한다.\r\n\r\n인증서 정보와 함께, 서버와의 암호화 통신을 위한 서버 공개키가 전달된다. 서버의 공개키로 데이터를 암호화하면 서버는 이를 받아 개인키로 복호화하여 요청을 분석할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">3. 인증서 검토</p>\r\n\r\n서버가 전달한 인증서가, 실제 해당 서버의 인증서인지, 신뢰할 수 있는 CA에서 발급된 것인지, 실제 해당 CA에서 발급받았는지 등 인증서를 검토한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129752361-4831de06-e99b-4f0c-9862-fe1f8ab5642a.png)\r\n\r\n인증서에 이상이 없다면 주소창에 위와 같이 표시된다. (Microsoft Chromium Edge 기준)\r\n\r\n만약 문제가 있다면 아래와 같은 창을 보게 될 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129752602-f9967221-3b82-487f-91c4-7fefc1cf3e94.png)\r\n\r\n이는 브라우저가 사용자에게 보내는 경고문으로, 해당 사이트의 인증서가 올바르지 않으므로 신뢰할 수 없다고 경고하는 것이다.\r\n\r\n물론 사이트 관리자의 실수로 인증서가 만료됐거나, 잘못된 인증서를 교체해서 발생한 사소한 이유일 수도 있다. 하지만 낮선 사이트를 접속하는데 이와 같은 경고가 뜬다면, 정상적인 방법으로 인증서를 발급받을 수 없는 사이트일 가능성이 있으므로 접근을 자제하자.\r\n\r\n악의가 없는 사이트일지라도, 사용자의 데이터는 보호해주지 못 하니 주의할 것.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">4. Premaster Secret 송수신</p>\r\n\r\nClientHello, ServerHello에서 송수신한 난수 데이터를 조합하여 Premaster Secret을 생성한다.\r\n\r\n이를 ServerHello에서 전달받았던 공개키로 암호화한다. 이 데이터는 서버가 가진 개인키로만 복호화가 가능하다. 즉, 이 데이터는 탈취된다 하더라도 그 내용이 보호된다.\r\n\r\n서버는 수신된 데이터를 복호화하여 클라이언트와 동일한 Premaster Secret을 저장할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">5. 통신 키 생성</p>\r\n\r\n보유한 Premaster Secret을 토대로 Master Secret, Session Key를 생성한다. 이를 통해 클라이언트와 서버가 동일한 키를 보유하게 되므로 자신들끼리의 암호화 통신이 가능하다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">6. 데이터 송수신</p>\r\n\r\n필요한 데이터는 저장된 Session Key를 통한 대칭키 암호화 방식으로 암/복호화하여 통신한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">7. 세션 종료</p>\r\n\r\n클라이언트와의 연결이 끊겼을 경우 사용했던 Session Key는 폐기한다.\r\n\r\n# 정리\r\n\r\nSSL은 통신 패킷을 암호화하여 패킷 탈취, 정보 누출 등을 방지하기 위한 보안 프로토콜이다.\r\n\r\n현재는 모두 TLS로 교체되었지만, SSL 자체가 고유명사되어 넓은 의미의 통신 보안 프로토콜을 명칭하는 의미로 쓰인다.\r\n\r\n현대에 이르러서는 웹 배포에 있어서 필수적인 사항이므로, 내용을 잘 이해하자.\r\n\r\n다음 장에서는 SSL 인증서에 대해 다룬다.","url":["2021-08-18-about-ssl","2021","08","18","about-ssl"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 의존성 역전 원칙 (Dependency Inversion Principle)","excerpt":"의존성 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다. 말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가? 고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, 객체는 객체보다 인터페이스에 의존해야한다로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-17T03:06:35","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-17-dependency-inversion-principle.md","content":"\r\n# 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n<span class=\"orange-400\">의존성 역전 원칙</span>이란 <span class=\"red-600\">객체는 저수준 모듈보다 고수준 모듈에 의존해야한다</span>는 원칙이다.\r\n\r\n말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가?\r\n\r\n* <span class=\"primary\">고수준 모듈</span>: 인터페이스와 같은 객체의 형태나 추상적 개념\r\n* <span class=\"primary\">저수준 모듈</span>: 구현된 객체\r\n\r\n고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, <span class=\"red-600\">객체는 객체보다 인터페이스에 의존해야한다</span>로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.\r\n\r\n# 코드로 보는 의존성 역전 원칙\r\n\r\n예시를 통해 의존성 역전 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 의존성 역전 원칙을 준수하지 않은 코드\r\n\r\n어렸을 적 누구나 한 번씩 단풍에 대한 이야기를 다룬 게임을 해본적이 있을 것이다. 비록 이젠 죽어버렸지만 필자도 매우 좋아했었고, 성인이 된 후에도 방학시즌 이벤트만 되면 으레 복귀해서 게임을 즐기곤 했었다.\r\n\r\n그 게임은 RPG 장르로, RPG가 그렇듯 다양한 직업군과 그에 맞는 스킬/무기 시스템이 갖춰져있다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n수 많은 무기 가운데 하나인 한손검을 구현한 `OneHandSword` 객체가 있다. 캐릭터는 위와 같은 무기를 장비할 수 있을 것이다. 인스턴스 생성 시 무기의 이름과 데미지를 입력하여 생성한다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate OneHandSword weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic Character(String name, int health, OneHandSword weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic void chageWeapon(OneHandSword weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터를 구현한 `Character` 객체다. 게임 캐릭터가 취할 수 있는 기본적인 행동 일부가 구현되어있으며, 인스턴스 생성 시 캐릭터 이름, 체력, 무기를 입력하여 생성한다.\r\n\r\n하지만 다들 알다시피, 무기엔 한손검만 있는 게 아니다. 근접계열 무기만 하더라도 두손검, 단검, 창, 도끼, 둔기 등 다양한 종류가 존재할 수 있다. 그러나 이 `Character` 객체. 애초에 한손검 외엔 쓸 수가 없는 구조다. `Character`의 인스턴스 생성 시 `OneHandSword`에 의존성을 가지기 때문. \t공격 동작을 담당하는 `attack()` 메소드 역시 `OneHandSword`에 의존성을 가진다.\r\n\r\n이 상황에서 한손검을 제외한 다른 무기를 사용하려면 `Character`의 코드를 바꿔야한다. 즉, 이전에 다뤘던 [개방-폐쇄 원칙](/posts/2021/08/14/open-closed-principle)을 위배한다. 더 큰 문제는 무기가 바뀔 때마다 이 짓을 해줘야한다. \r\n\r\n## 의존성 역전 원칙을 준수한 코드\r\n\r\n만약 위 코드가 의존성 역전 원칙을 잘 지켰다면 고민할 필요가 없는 문제다. 위 코드의 <span class=\"red-400\">가장 큰 문제는 이미 완전하게 구현된 저수준 모듈을 의존하고 있다는 점</span>이다. 즉, 추상적인 고수준 모듈을 의존하도록 리팩토링해야한다.\r\n\r\n``` java\r\n/**\r\n * 공격 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 02:07:19\r\n */\r\npublic interface Attackable\r\n{\r\n\t/**\r\n\t * 공격 추상 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tint attack();\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 추상 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tString toString();\r\n}\r\n```\r\n\r\n우선 고수준 모듈인 `Weapon` 인터페이스를 생성한다. 공격 데미지를 반환하는 추상 함수 `attack()`과 무기 이름을 반환하는 추상 함수 `toString()`가 선언되어있다. 앞으로 모든 공격 가능한 무기 객체는 이 인터페이스를 상속받게 될 것이다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword implements Attackable\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\t@Override\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n`Attackable`를 상속받은 한손검 객체 `OneHandSword` 객체다. 상속받은 점 외에 크게 달라진 점은 없다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate Attackable weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic Character(String name, int health, Attackable weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic void chageWeapon(Attackable weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터 `Character` 객체다. 기존의 `OneHandSword`를 파라미터에서 좀 더 고수준 모듈인 `Attackable`을 파라미터로 받는 걸 확인할 수 있다. 그 밖의 무기와 관련된 메소드 전부가 그렇다.\r\n\r\n하나의 객체였던 저수준 모듈에서 고수준 모듈로 의존성이 바뀌게 되니, `Attackable`을 상속하는 모든 객체를 다룰 수 있다. 게임 시스템 내부적으로 모든 공격 가능한 무기는 `Attackable`을 상속받기로 가정했으므로, 공격 가능한 모든 무기를 사용할 수 있는 셈이다.\r\n\r\n이러한 변경으로 무기의 변경에 따라 `Character`의 <span class=\"green-600\">코드를 변경할 필요가 없으므로, 개방-폐쇄 원칙 또한 준수</span>할 수 있다.\r\n\r\n# 정리\r\n\r\n의존성 역전 원칙은 코드의 확장성 및 재사용성을 추구하기 위한 원칙이다. 경직된 객체보다 구현되지 않아 유연한 인터페이스가 더욱 확장 가능성이 높을 것이다.\r\n\r\n다른 원칙에 비해 <span class=\"orange-400\">의존성 역전 원칙은 중요도가 좀 떨어지는데, 그 이유는 타 원칙의 하위호환 격이기 때문</span>이다. 당장 위에서도 언급했듯이, 의존성 역전 원칙은 개방-폐쇄 원칙을 준수할 경우 자연스레 준수하기이다. 뿐만 아니라 1객체 = 1책임인 단일 책임 원칙, 기능별 인터페이스화를 추구하는 인터페이스 분리 원칙을 준수할 경우 역시 마찬가지다.\r\n\r\n객체 생성 시 객체로 구현해야할 것과 인터페이스로 구현해야할 것을 적절히 구분하여 올바른 의존 관계를 가지도록 구현하자. 이왕이면 방금 언급한 원칙들을 준수하여 두 마리 토끼를 잡는 것도 매우 좋은 방법일 것이다.\r\n\r\n# 마치며\r\n\r\n이 장을 끝으로 객체지향에 대한 글을 마무리한다. 지금껏 JAVA라는 객체지향 언어를 사용하고 있었음에도, 정작 객체지향에 대해 너무 몰랐다는 것을 새삼 느낀다. 내가 얼마나 비객체지향적으로 코딩했는지도....\r\n\r\n객체지향에서의 가장 큰 특징이라면 바로 <span class=\"primary\">상속</span>일 것이다. 객체지향의 5원칙 중 대부분이 상속과 직/간접적으로 연관된 것만 봐도, 객체지향의 아이덴티티는 상속이라고 할 수 있을 것이다. 그 만큼 객체지향에서 상속은 중요하면서 동시에 이해하기 어려운 개념이다. 잘 쓰기는 더더욱 어렵다.\r\n\r\n물론 객체지향의 의의를 온전히 구현하고, 수립된 원칙들을 전부 지키는 것은 시니어급 개발자라도 매우 어려운 일일 것이다. 당장 나 같아도 \"이 많은 걸 다 지켜가며 설계하라고?\"라는 생각이 들고, 대부분의 개발은 구현 과정보단 동작 결과에 치중하기 때문이다.\r\n\r\n탄탄한 기획과 이에 동반되는 고민은 견고한 설계가 가능하지만, 언제까지나 시간을 낭비할 수 없는 노릇이다. 아무리 탄탄하게 설계 중인 프로젝트라도 개발 기간을 준수하지 못 하면 결과물은 물론, 이 결과물을 내기까지 했던 모든 고민들이 시간낭비로 치부되는 것을 뻔하다.\r\n\r\n이러한 원칙을 정해진 시간 내에 구현해야 하므로, 객체지향을 잘 다루기 위해선 많은 노력이 필요할 것이다.","url":["2021-08-17-dependency-inversion-principle","2021","08","17","dependency-inversion-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"인터페이스 분리 원칙이란 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙이다. 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다. 위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다. 왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, Method1을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다. 하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-16T19:24:57","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-16-interface-segregation-principle.md","content":"\r\n# 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n\r\n<span class=\"orange-400\">인터페이스 분리 원칙</span>이란 <span class=\"red-600\">객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다</span>는 원칙이다.\r\n\r\n구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128585790-a761f795-b4da-4a52-865d-d2dd4b858f20.png)\r\n\r\n위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다.\r\n\r\n왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, `Method1`을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다.\r\n\r\n하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.\r\n\r\n# 코드로 보는 인터페이스 분리 원칙\r\n\r\n예시를 통해 인터페이스 분리 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 인터페이스 분리 원칙을 준수하지 않은 코드\r\n\r\n예를 들어, 스마트폰이라는 객체가 있다고 가정하자. 이 스마트폰 객체는 비교적 최신에 나온 덕분에 일반적인 스마트폰 기능 외에도 무선 충전, AR 뷰어, 생체인식 등의 다채로운 기능을 포함하고 있다.\r\n\r\n이를 가지고 S20을 구현하면 스마트폰 객체의 동작 모두가 필요하므로 ISP를 만족한다. 그러나 S2를 구현할 경우, 무선 충전, 생체인식과 같은 기능을 제공하지 않는다. 그럼에도 불구하고 부모 객체인 스마트폰에 이러한 인터페이스가 포함되어 있으므로, S2 입장에서는 필요하지도 않은 기능을 구현해야하는 낭비가 발생한다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\nabstract public class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선 충전\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tabstract public void biometrics();\r\n}\r\n```\r\n\r\n위와 같이 구현된 `SmartPhone` 객체가 있다. 생체인식을 담당하는 `biometrics()` 메소드의 경우, 기기에 등록된 생체정보를 활용해야 하므로 추상 메소드로 선언되어있다. 이 객체를 상속하여 `S20`과 `S2`를 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"S20 생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20`은 모든 기능이 필요하기 때문에, `SmartPhone`의 모든 메소드를 사용해야하므로, 불필요한 메소드가 없는 상태다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 무선충전, AR, 생체인식이 지원되지 않는 기기다. 그럼에도 불구하고 `SmartPhone`의 상속으로 인해 해당 기능의 메소드를 강제로 상속받게 된다. 더군다나 `biometrics()`의 경우 추상 메소드이므로 필요하지도 않은 기능을 구현까지 해야한다. 이러한 상속의 특징은 부모 객체의 규모가 매우 클 경우, 개발 편의성의 극심한 저하로 이뤄진다. 필요하지도 않은 수십개의 메소드를 일일히 오버라이딩하여 적절한 처리를 해준다고 생각해보자.\r\n\r\n## 인터페이스 분리 원칙을 준수한 코드\r\n\r\n객체의 특성을 확장을 통해 다른 객체를 편하게 구현하기 위한 것이 상속인데, 위와 같은 상황은 전혀 편하지 않다. 이는 부모 객체의 설계가 잘 못 됐을 수도 있고, 취지에 맞지 않는 객체를 상속했을 수도 있다. 이유야 어찌됐든 해결해야한다는 사실엔 변함이 없다.\r\n\r\n그렇다면 이 현상은 어떻게 해결할 수 있을까? 객체의 메소드를 각각 인터페이스로 만들면 된다. 각 객체는 필요한 인스턴스만 상속하면 되므로 필요한 동작만을 상속/구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\npublic class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n}\r\n```\r\n\r\n`SmartPhone` 객체는 모든 스마트폰에 적용되는 보편적인 동작만을 가지도록 변경했다.\r\n\r\n``` java\r\n/**\r\n * 무선충전 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:23:33\r\n */\r\npublic interface WirelessChargable\r\n{\r\n\t/**\r\n\t * 무선충전 추상 함수\r\n\t */\r\n\tvoid wirelessCharge();\r\n}\r\n\r\n/**\r\n * AR 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:24:29\r\n */\r\npublic interface ARable\r\n{\r\n\t/**\r\n\t * AR 추상 함수\r\n\t */\r\n\tvoid ar();\r\n}\r\n\r\n/**\r\n * 생체인식 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:25:08\r\n */\r\npublic interface Biometricsable\r\n{\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tvoid biometrics();\r\n}\r\n```\r\n\r\n각 기능의 인터페이스는 위와 같다. 원래 `SmartPhone`의 객체의 메소드였던 각 기능은 인터페이스 단위로 나뉘어졌음에 주목하자.\r\n\r\n이를 통해 `S20`과 `S2` 모두 필요한 객체만을 상속받아 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone implements WirelessChargable, ARable, Biometricsable\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선충전 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20` 객체의 코드다. `SmartPhone`을 상속받았으며, 인터페이스로 `WirelessChargable`, `ARable`, `Biometricsable`을 모두 상속받아 구현하고 있다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\t@Override\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(\"In S2\");\r\n\t\t\r\n\t\tsuper.message(number, text);\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 특수 기능이 구현되어있지 않으므로, 기본적인 `SmartPhone` 객체만을 상속받아 구현된다.\r\n\r\n인터페이스는 다중 상속을 지원하므로, 필요한 기능을 인터페이스로 나누면 해당 기능만을 상속받을 수 있다. 그 밖에 추후 업데이트 등을 통해 추가적인 기능이 탑재된다면, 같은 원리로 인터페이스를 설계해서 사용하면 필요한 객체에 필요한 기능을 쉽게 추가할 수 있다.\r\n\r\n# 정리\r\n\r\n인터페이스 분리 원칙은 객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙이다. 불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제가한다. 큰 규모의 객체는 필요에 따라 인터페이스로 잘게 나누어 확장성을 향상시킨다.\r\n\r\n객체를 상속할 땐 해당 객체가 상속 받는 객체에 적합한 객체인지, 의존적인 기능이 없는 지 판단하여 올바른 객체를 구현, 상속하도록 하자.","url":["2021-08-16-interface-segregation-principle","2021","08","16","interface-segregation-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"리스코프 치환 원칙은 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다. 객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다. 리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-15T13:42:11","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-15-liskov-subsitution-principle.md","content":"\r\n# 리스코프 치환 원칙 (Liskov Subsitution Principle)\r\n\r\n<span class=\"orange-400\">리스코프 치환 원칙</span>은 부모 객체와 이를 상속한 자식 객체가 있을 때 <span class=\"red-600\">부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다</span>는 원칙이다.\r\n\r\n객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다.\r\n\r\n리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.\r\n\r\n# 코드로 보는 리스코프 치환 원칙\r\n\r\n리스코프 치환 원칙을 설명할 때 많이 사용하는 예제로 직사각형과 정사각형의 관계가 있다.\r\n\r\n## 리스코프 치환 원칙을 위배한 코드\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\npublic class Rectangle\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n`Rectangle`은 직사각형을 구현한 객체다. 너비와 높이를 지정, 반환할 수 있으며, 지정된 값을 통해 자신의 넓이를 계산할 수 있다.\r\n\r\n정사각형 역시 넓게 보면 직사각형의 한 종류이니, <span class=\"red-400\">직사각형을 상속하여 정사각형 객체를 빠르게 만들 수 있을 것이라 생각했다.</span>\r\n\r\n``` java\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\npublic class Square extends Rectangle\r\n{\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\t@Override\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tsuper.setWidth(width);\r\n\t\tsuper.setHeight(getWidth());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\t@Override\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tsuper.setHeight(height);\r\n\t\tsuper.setWidth(getHeight());\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 정사각형 객체 `Square`를 `Rectangle`의 상속을 통해 쉽게 구현할 수 있었다.\r\n\r\n정사각형의 경우 직사각형과 달리 너비와 높이가 같으니, 너비나 높이를 지정하면 그에 맞게 너비와 높이를 모두 일치시켜주도록 오버라이딩을 수행했다.\r\n\r\n구현한 `Rectangle`의 넓이를 구해보자.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Rectangle();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n```\r\n\r\n`Rectangle`의 넓이를 구하는 소스는 이와 같다. 너비가 10, 높이가 5로 할당됐으므로 넓이 50이 정상적으로 반환된다.\r\n\r\n리스코프 치환 원칙에 의하면, 자식 객체는 부모 객체를 완전히 대체할 수 있다고 했으므로, `Rectangle`을 상속받은 `Square`로 대체하여 넓이를 구해보자.\r\n\r\n`Square`가 `Rectangle`을 완전히 대체했다면 동일한 결과인 50이 반환되어야 한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Square();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n25\r\n```\r\n\r\n어째서인지 넓이는 50이 아닌 25로 반환됐다. 자세히 살펴보니, 마지막에 수행된 `setHeight(5)`가 객체의 너비/높이를 모두 5로 할당했다. 그러니 넓이도 당연히 25가 출력될 수밖에 없었던 걸로 보인다. 즉, 이 객체는 리스코프 치환 원칙에 위배되는 코드다.\r\n\r\n곰곰히 생각해보면, 직사각형과 정사각형은 상속관계가 전혀 될 수 없다. 사각형의 특징을 서로 갖고있긴 하지만, 두 사각형 모두 사각형의 한 종류일 뿐으로, 하나가 다른 하나를 완전히 포함하지 못 하는 구조다.\r\n\r\n이렇게 잘못된 객체를 상속하거나, 올바르게 확장하지 못 할 경우 겉으로 보기엔 정상적이지만 올바른 객체는 아니다.\r\n\r\n## 리스코프 치환 원칙을 준수한 코드\r\n\r\n그렇다면 이 코드를 어떻게 리스코프 치환 원칙에 부합하게끔 구성할 수 있을까?\r\n\r\n답은 올바른 상속과 구현에 있다. 앞서 설명했다시피, 직사각형과 정사각형은 상속의 관계가 성립되기 어렵다. 따라서 이보다 더 상위 개념인 사각형 객체를 구현하고 정사각형, 직사각형이 이를 상속받으면 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 사각형 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:39:02\r\n */\r\npublic class Shape\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n위와 같이 `Shape`라는 사각형 객체를 구현한다.\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\nclass Rectangle extends Shape\r\n{\r\n\t/**\r\n\t * Rectangle 생성자 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic Rectangle(int width, int height)\r\n\t{\r\n\t\tsetWidth(width);\r\n\t\tsetHeight(height);\r\n\t}\r\n}\r\n\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\nclass Square extends Shape\r\n{\r\n\t/**\r\n\t * Square 생성자 함수\r\n\t *\r\n\t * @param length: [int] 길이\r\n\t */\r\n\tpublic Square(int length)\r\n\t{\r\n\t\tsetWidth(length);\r\n\t\tsetHeight(length);\r\n\t}\r\n}\r\n```\r\n\r\n`Shape`를 상속받는 두 사각형 `Rectangle`과 `Square` 객체는 위와 같다. `Rectangle`은 인스턴스 생성 시 `width`와 `height`를 파라미터로 받으며, `Square`는 각 변의 길이가 모두 동일하므로 `length` 하나만을 파라미터로 받는다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tShape rectangle = new Rectangle(10, 5);\r\n\t\tShape square = new Square(5);\r\n\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t\tSystem.out.println(square.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n25\r\n```\r\n\r\n이제 더 이상 `Rectangle`과 `Square`가 상속 관계가 아니므로, 리스코프 치환 원칙의 영향에서 벗어났다.\r\n\r\n# 정리\r\n\r\n리스코프 치환 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체해도 아무런 문제가 없도록 권고한다. 위의 직사각형과 정사각형의 케이스처럼 올바르지 못한 상속관계는 제거하고, 부모 객체의 동작을 완벽하게 대체할 수 있는 관계만 상속하도록 코드를 설계해야한다.\r\n\r\n리스코프 치환 원칙을 지키기 위해선 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요하다.\r\n\r\n부모 객체의 오버라이딩은 주로 동일한 메소드를 자식 객체만의 동작을 추가하기 위해 한다는 걸 감안하면 매우 준수하기 까다로운 원칙.\r\n","url":["2021-08-15-liskov-subsitution-principle","2021","08","15","liskov-subsitution-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 개방-폐쇄 원칙 (Open-Closed Principle)","excerpt":"개방 폐쇄 원칙이란 객체를 다룸에 있어서 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미. 좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다. 만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다. 이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-14T04:04:40","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-14-open-closed-principle.md","content":"\r\n# 개방-폐쇄 원칙 (Open-Closed Principle)\r\n\r\n<span class=\"orange-400\">개방 폐쇄 원칙</span>이란 객체를 다룸에 있어서 <span class=\"red-600\">객체의 확장은 개방적으로, 객체의 수정은 폐쇄적</span>으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미.\r\n\r\n좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다.\r\n\r\n만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다.\r\n\r\n이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.\r\n\r\n# 코드로 보는 개방-폐쇄 원칙\r\n\r\n<br />\r\n<p class=\"large grey-600\" align=\"center\"><i>If...</i></p>\r\n<br />\r\n\r\n저명한 IT업체에서 일하는 당신. 어느덧 정년을 바라보고 있다. 노후 대비를 위해 작은 편의점의 점주로 새로운 시작을 하는 당신. 예전부터 봐뒀던 곳에 적지 않은 비용을 지불하기까지 했다.\r\n\r\n다행히 안목이 틀리지 않았는지, 아침은 아침대로, 새벽은 새벽대로 끊임없는 유동인구 덕분에 생각했던 것 이상으로 수입이 들어오고 있다. 좀 더 일찍 시작했어도 됐으려나...\r\n\r\n여기저기 신경쓰다보니 초기 비용이 여의치 않아, POS기기는 저렴한 걸 선택했다. 영업사원이 사용 카드가 어쩌네 넌지시 얘기한 거 같은데, 그래봐야 POS가 거기서 거기겠지 뭐.\r\n\r\n<br />\r\n\r\n요즘 들어 매체에 신생 카드 업체에 대한 주제가 끊이질 않는다. 공격적인 혜택과 이전 카드에선 찾아볼 수 없었던 아기자기한 디자인이 그렇게 인기랜다. 이름이 초콜릿뱅크였나..? 혜택은 좋은데, 카드에 저런 디자인이 무슨 소용이람.\r\n\r\n<br />\r\n\r\n요즘들어 그 초코 뭐시긴가 하는 카드를 쓰는 사람이 많아졌다. 문제는 저 놈의 POS기가 새로운 카드는 전혀 인식을 못 한다. 이 문제 때문에 이번 주에만 반 이상이 넘는 고객을 돌려보냈다. 매출도 문제지만, 손님한테 아쉬운 소리하면서 사과하는 게 더 고역이다.\r\n\r\nPOS 업체에 전화해봤는데, 구조 상 그런거라며 계약 이전에 다 설명하고 서명받은 내용이란다. 난 그런 기억이 없는데....? 어쨌든 내게 남은 선택지라곤 지금 유지비용의 두 배 가까이 되는 신규 POS로 교체하던가, 위약금을 물고 새로운 POS 업체로 갈아타는 것 뿐이다. 이 문제 때문에 잠을 통 잘 수가 없다.\r\n\r\n<br />\r\n\r\n그래도 명색이 개발자인 당신. 어쩌면 내가 해결할 수도 있지 않을까? 수 십년 간의 경험을 토대로 기억을 되짚어가며 기기를 분석해보기 시작했다.\r\n\r\n``` java\r\n/**\r\n * 포스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:10:12\r\n */\r\npublic class Pos\r\n{\r\n\t/**\r\n\t * 결제 및 결과 반환 함수\r\n\t *\r\n\t * @param card : [Object] 카드 객체\r\n\t * @param name : [String] 카드사명\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 결제 결과\r\n\t */\r\n\tpublic boolean purchase(Object card, String name, int price)\r\n\t{\r\n\t\tboolean result;\r\n\t\t\r\n\t\tswitch (card.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\t\t\r\n\t\t\tdefault -> {\r\n\t\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n다행히 아직 감이 죽진 않았는지, 어렵지 않게 관련 모듈을 특정할 수 있었다. 카드 리더기에서 카드 인식 시 카드 정보가 담긴 객체를 `Object`로 캐스팅하여 전송한다. 정보 구분을 위해 카드사명까지 같이 전송하는 모양이다.\r\n\r\n딱 봐도 난감하기 그지없는 구조다. 실제로 초콜릿뱅크의 카드 정보는 리더기에서 잘 전달되고 있으나, `purchase` 메소드에서 초콜릿뱅크 카드를 구분하는 로직이 없어서 결제가 되지 않는다.\r\n\r\n``` java\r\npublic boolean purchase(String card, int price)\r\n{\r\n\tboolean result;\r\n\t\r\n\tswitch (card.toUpperCase())\r\n\t{\r\n\t\t// 신생 업체가 생길 때마다 해당 업체를 구분하는 로직을 추가한다.\r\n\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\tcase \"D\" -> result = ((CardD) card).send(price);\r\n\t\tcase \"E\" -> result = ((CardE) card).send(price);\r\n\t\tcase \"F\" -> result = ((CardF) card).send(price);\r\n\t\t\r\n\t\tdefault -> {\r\n\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\tresult = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n```\r\n그렇다면 `case` 구문에서 초콜릿뱅크를 구분하여 결제 정보를 전송하면 해결되지 않을까? 이 방식을 쓴다면 급한 불은 끌 수 있겠지만, 후에 또 다른 신생업체가 생기면 같은 문제가 반복될 게 뻔하다.\r\n\r\n이 방법은 매우 비효율적이다. 동작의 범위만 넓혔을 뿐, 근본적인 문제는 전혀 해결되지 않는다.\r\n\r\n당신은 이 코드를 좀 더 객체지향의 관점으로 접근하여 리팩토링을 실시한다.\r\n\r\n``` java\r\n/**\r\n * 결제 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:28:22\r\n */\r\npublic interface Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\tboolean send(int price);\r\n}\r\n```\r\n\r\n공통된 형태로 로직을 수행하기 위해 `Purchasable` 인터페이스를 구현했다. 또한 리더기에서 전송하는 모든 카드 객체는 `Purchasable`를 상속받도록 강제했다.\r\n\r\n``` java\r\n/**\r\n * A 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:36:11\r\n */\r\nclass CardA implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * B 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:38:00\r\n */\r\nclass CardB implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * C 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:39:51\r\n */\r\nclass CardC implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n이제 리더기에서 전달하는 모든 카드 객체는 `Purchasable` 인터페이스를 상속받는다. 카드 객체를 부모 객체인 `Purchasable`로 다룰 수 있을 것이다. 각 카드 객체의 동작에 전송이 각각 구현되어있어, 타 객체의 코드에 의존하지 않는다.\r\n\r\n``` java\r\n/**\r\n * 포스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:10:12\r\n */\r\npublic class Pos\r\n{\r\n\t/**\r\n\t * 결제 및 결과 반환 함수\r\n\t *\r\n\t * @param purchasable : [Purchasable] Purchasable 인터페이스\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 결제 결과\r\n\t */\r\n\tpublic boolean purchase(Purchasable purchasable, int price)\r\n\t{\r\n\t\treturn purchasable.send(price);\r\n\t}\r\n}\r\n```\r\n\r\n이제 결제 함수를 리팩토링 해보자. `CardA`, `CarB`, `CardC` 등 각각 개별적인 객체지만, 이제 `Purchasable`이라는 부모 객체가 있으므로 이를 묶을 수 있다. 우리는 리더기에서 주는 인터페이스 객체만 받아서 해당 객체의 `send`를 호출하면 된다.\r\n\r\n성공적으로 리팩토링을 마친 당신. 이제 어떤 카드든 결제가 가능하고 리더기가 정상적으로 인식만 한다면 결제를 진행할 수 있게됐다.\r\n\r\n당신이 한 각고의 노력과 빠른 대처로 인해 얼마 안 가 다시금 매출을 정상화시킬 수 있었다.\r\n\r\n# 정리\r\n\r\n리팩토링 전과 후를 비교해보자.\r\n\r\n``` java\r\npublic boolean purchase(Object card, String name, int price)\r\n{\r\n\tboolean result;\r\n\t\r\n\tswitch (card.toUpperCase())\r\n\t{\r\n\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\t\r\n\t\tdefault -> {\r\n\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\tresult = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n\r\npublic boolean purchase(Purchasable purchasable, int price)\r\n{\r\n\treturn purchasable.send(price);\r\n}\r\n```\r\n\r\n위는 이전 코드, 아래는 리팩토링한 코드다. <span class=\"amber-600\">기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다</span>는 의미를 여기에서 찾을 수 있다.\r\n\r\n리팩토링 이전 코드의 경우, 새로운 카드 인식. 즉, 기능 추가를 위해선 코드의 추가가 요구됐다. 다시 말해, <span class=\"red-600\">기능을 확장하기 위해선 코드의 수정이 필요</span>하다는 의미다.\r\n\r\n반대로 리팩토링 후의 코드를 보자. `Purchasable`라는 통합된 인터페이스를 사용하기 때문에 카드 추가에 따라 코드 단계에서 대응할 필요가 없다. 즉, <span class=\"red-600\">코드의 변경 없이 기능이 확장</span>된다.\r\n\r\n단일 책임 원칙과 마찬가지로, 비슷한 형태의 분기가 반복될 경우 개방-폐쇄 원칙을 준수하지 않았을 가능성이 높다. 이는 곧 높은 리팩토링 비용으로 직결되니, 이를 잘 준수하여 독립적인 모듈을 설계하자.","url":["2021-08-14-open-closed-principle","2021","08","14","open-closed-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 단일 책임 원칙 (Single Responsibility Principle)","excerpt":"올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 객체지향 5원칙(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다. 이 다섯가지 원칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-13T01:37:48","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-13-single-responsibility-principle.md","content":"\r\n# 객체지향 5원칙\r\n\r\n올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 <span class=\"amber-600\">객체지향 5원칙</span>(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다.\r\n\r\n이 다섯가지 원칙은 아래와 같다.\r\n\r\n1. 단일 책임 원칙 (Single Responsibility Principle)\r\n2. 개방-폐쇄 원칙 (Open-Closed Principle)\r\n3. 리스코프 치환 원칙 (Liskov Substitution Principle)\r\n4. 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n5. 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n각 원칙의 영어 앞글자를 따 <span class=\"primary\">SOLID</span>원칙이라고도 한다.\r\n\r\n# 단일 책임 원칙 (Single Responsibility Principle)\r\n\r\n<span class=\"orange-400\">단일 책임 원칙</span>이란 <span class=\"orange-400\">하나의 객체는 반드시 하나의 동작만의 책임을 갖는다</span>는 원칙이다.\r\n\r\n모듈화가 강해질수록 다른 객체와의 의존/연관성이 줄어든다. 반대로 이야기하면 모듈화가 약해질수록 다른 객체와의 의존/연관성은 크게 늘어나며, 최악의 경우 어떠한 은닉화 정책도 존재하지 않아 모듈의 메소드에 무분별하게 접근할 수도 있게된다.\r\n\r\n객체가 담당하는 동작. 즉, 책임이 많아질 수록 해당 객체의 변경에 따른 영향도의 양과 범위가 매우 커진다. 단일 책임 원칙은 특정 객체의 책임 의존성 과중을 최대한 지양하기 위한 원칙이다.\r\n\r\n# 코드로 보는 단일 책임 원칙\r\n\r\n자동차는 휠의 구동 특성에 따라 전륜(FWD), 후륜(RWD), 사륜(AWD)로 나뉘며, 그 특성은 아래와 같다.\r\n\r\n* 전륜 구동인 경우 앞의 두 바퀴에만 동력을 전달한다.\r\n* 후륜 구동인 경우 뒤의 두 바퀴에만 동력을 전달한다.\r\n* 사륜 구동인 경우 전체 바퀴에 동력을 전달한다.\r\n\r\n이를 객체로 구현해보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\npublic class Car\r\n{\r\n\tprivate final String WD;\r\n\t\r\n\tprivate final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tswitch (WD.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"FWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"RWD\" -> {\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"AWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n여기 `Car` 객체가 있다. `Car`는 생성 시 파라미터로 <span class=\"orange-400\">휠 구동 방식</span>을 받는다.\r\n\r\n`Car`에는 주행 동작을 구현하는 `run()`메소드가 있으며, 이 메소드는 파라미터로 <span class=\"orange-400\">동력</span>을 받는다. 이후 휠 구동 방식에 따라 올바른 휠에 동력을 할당하고 휠의 상태를 출력한다.\r\n\r\n휠의 구동 방식 별 동작이 하나의 책임으로 본다면 이 객체가 짊어지는 책임은 무려 세 가지나 된다. 이렇게 하나의 객체에 너무 많은 책임이 몰려있을 경우, 프로젝트에서 해당 객체의 의존성이 높아지게된다. 이러한 현상은 객체지향의 주요 특징 중 하나인 캡슐화를 정면으로 부정한다. 그 뿐만 아니라, 각자의 코드가 서로 의존될 경우, 코드 수정에 따른 영향도 역시 높아지고, 범위 또한 넓어진다.\r\n\r\n위의 예시는 단일 책임 원칙을 설명하기 위한 단순한 예시로, 만약 코드의 규모가 크거나 복잡성이 심하다면 코드 수정 시 마다 오만가지 오류가 발생할 것이다. 그 뿐만 아니라 코드가 변경되는 과정에서 이미 정해진 코드의 리팩토링도 필요할 수 있다. 리팩토링이 리팩토링을 부르는 참사가 일어날 수도 있다. 여기서부터 코드가 지저분해지기 쉽다.\r\n\r\n단일 책임 원칙은 바로 이와 같은 상황을 방지하고자 수립된 원칙으로, <span class=\"red-400\">1객체 = 1책임</span>으로 최대한 객체를 간결하고 명확하게 설계할 것을 요구한다. 위 코드의 책임을 줄여 단일 책임 원칙을 지키려면 어떻게 해야할까?\r\n\r\n``` java\r\n/**\r\n * 자동차 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\nabstract public class Car\r\n{\r\n\tprotected final String WD;\r\n\t\r\n\tprotected final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tabstract public void run(int power);\r\n}\r\n```\r\n\r\n우선 공통된 인터페이스 내지는 상위 객체를 구현할 필요가 있다. 이 객체의 경우 생성자가 필요하므로 인터페이스 보단 상위 객체가 적합하다.\r\n\r\n> **네? 인터페이스 차별이요??**  \r\n> 인터페이스는 일반적인 객체 혹은 추상 객체와 달리 생성자를 강제할 수 없습니다.\r\n\r\n객체 `Car`를 상위 객체에 적용될 수 있게끔 구현한다. `run()` 메소드는 훨 구동 타입에 따라 동작이 달라지므로, `abstract` 지시자를 통해 추상 메소드로 선언한다. 해당 객체의 인스턴스를 생성하거나, 상속받는 객체가 직접 구현하게 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 전륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:03:13\r\n */\r\nclass FrontWheelCar extends Car\r\n{\r\n\t/**\r\n\t * FrontWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic FrontWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 후륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\nclass RearWheelCar extends Car\r\n{\r\n\t/**\r\n\t * RearWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic RearWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 사륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\npublic class AllWheelCar extends Car\r\n{\r\n\t/**\r\n\t * AllWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic AllWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n전륜, 후륜, 사륜에 해당하는 객체를 생성한다. 이 세 객체는 모두 `Car`에 포함되므로 `Car`를 상속받아 구현한다. 각 객체의 `run()` 메소드에 동작을 구현함으로써, 각각의 객체가 하나의 책임을 가지게 된다.\r\n\r\n이렇게 객체별로 책임을 나누면, 코드 변경 시에도 해당하는 객체만 수정하면 되므로, 의존성이 낮아져 올바른 모듈화를 구현할 수 있다. 그 뿐만 아니라 코드가 간결해져 유지보수가 쉬워질 뿐만 아니라 수정에 따른 영향도도 매우 작아진다.\r\n\r\n# 정리\r\n\r\n코드를 설계하다보면 하나의 객체가 너무 많은 동작을 담당하는 경우가 자주 발생한다. 필자 또한 무의식적으로 하나의 객체/메소드에 너무 많은 책임을 할당하는 일이 비일비재했다. 단일 책임 원칙은 이러한 개발 방향을 올바르게 잡아준다.\r\n\r\n가급적 단일 책임 원칙을 고수하여 올바른 객체를 구현할 수 있도록 해보자.","url":["2021-08-13-single-responsibility-principle","2021","08","13","single-responsibility-principle"]},{"header":{"title":"[OOP] 객체지향의 특징 - 다형성(Polymorphism)","excerpt":"객체지향 언어는 동일한 이름을 가진 메소드를 허용하지 않는다. 예를 들어, \"먹는다\"는 동작이 구현된 메소드가 있다고 가정하자. 먹는다는 동일한 동작이 구태여 두 개나 구현될 필요는 없다. 이러한 관점에서 본다면 메소드의 고유 아이덴티티라고도 불릴 수 있는 메소드명의 유니크화는 어쩌면 당연하다. 하지만 조금 생각해보면 좀 이상하다. JAVA는 타입에 죽고 타입에 산다. JavaScript와 달리 파라미터에 아무 타입이나 넣을 수 없기 때문에, 정해진 타입 이외의 무언가를 넣으면 컴파일 단계에서 가차없이 컷한다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-12T00:32:42","type":"posts","category":"CS","tag":["CS","객체지향","다형성"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-12-polymorphism.md","content":"\r\n# 다형성 (Polymorphism)\r\n\r\n객체지향 언어는 동일한 이름을 가진 메소드를 허용하지 않는다. 예를 들어, \"먹는다\"는 동작이 구현된 메소드가 있다고 가정하자. 먹는다는 동일한 동작이 구태여 두 개나 구현될 필요는 없다. 이러한 관점에서 본다면 메소드의 고유 아이덴티티라고도 불릴 수 있는 메소드명의 유니크화는 어쩌면 당연하다.\r\n\r\n하지만 조금 생각해보면 좀 이상하다. JAVA는 타입에 죽고 타입에 산다. JavaScript와 달리 파라미터에 아무 타입이나 넣을 수 없기 때문에, 정해진 타입 이외의 무언가를 넣으면 컴파일 단계에서 가차없이 컷한다.\r\n\r\n> **One for One!**  \r\n> 하나의 파라미터는 반드시 하나의 타입만을 가진다. `public void run(String param)`은 반드시 문자열 타입만을 파라미터로 받는다.\r\n\r\n그말인즉슨, 동일한 메소드는 존재할 수 없으니, 해당 메소드에 입력할 수 있는 각각의 파라미터 타입도 하나로 고정된다. 하지만 `System.out.println()` 메소드를 보자. CLI 콘솔에 데이터를 출력하는 메소드로, JAVA를 다룬다면 안 써본 사람은 없는 메소드다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tSystem.out.println(\"문자열 데이터\");\r\n\t\tSystem.out.println(123456);\r\n\t\tSystem.out.println(true);\r\n\t}\r\n}\r\n```\r\n\r\n``` out\r\n문자열 데이터\r\n123456\r\ntrue\r\n```\r\n\r\n<br />\r\n<p class=\"grey-600\" align=\"center\"><i>아니 아깐 동일한 메소드는 존재할 수 없다매요;;</i></p>\r\n<br />\r\n\r\n분명히 아까 <span class=\"pink-400\">동일한 이름을 가진 메소드는 동일한 객체에서 존재할 수 없다</span>고 했었다. 그럼에도 불구하고 `System.out.println()`의 경우, 메소드명은 동일한데 여러 타입을 보란듯이 받아서 처리하고 있다. 어떻게 된걸까? 유명한 메소드는 예외사항이라도 적용되는걸까?\r\n\r\n`System.out.println()`이 여러 타입을 처리할 수 있는 이유는 해당 메소드에 <span class=\"teal-400\">다형성</span>이 적용되어있기 때문이다. 다형성이란, 하나의 객체 혹은 메소드가 여러 타입을 참조할 수 있음을 의미한다. 다형성은 크게 <span class=\"amber-400\">객체의 다형성</span>과, <span class=\"amber-400\">메소드의 다형성</span>으로 구분된다.\r\n\r\n## 다형성의 예제\r\n\r\n코드를 통해 다형성을 알아보자.\r\n\r\n### 객체의 다형성\r\n\r\n먼저, 객체에 적용되는 다형성이다. 객체의 경우 상속된 객체의 인스턴스 생성 시, 다형성을 적용할 수 있다.\r\n\r\n객체의 다형성은 <span class=\"red-400\">객체가 상속된 부모 객체의 인스턴스로 할당</span>될 수 있음을 의미한다.\r\n\r\n``` java\r\nclass TV\r\n{\r\n\t// 메소드\r\n}\r\n\r\nclass SmartTV extends TV\r\n{\r\n\t// 메소드\r\n}\r\n```\r\n\r\n위와 같은 두 객체가 있다고 가정하자. `SmartTV`는 `TV`를 상속받아 구현된 객체다. 이 경우 `SmartTV`는 다형성을 적용할 수 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\t// 객체와 인스턴스 타입 일치\r\n\t\tTV tv = new TV();\r\n\r\n\t\t// 객체와 인스턴스 타입 일치\r\n\t\tSmartTV smart = new SmartTV();\r\n\r\n\t\t// SmartTV는 TV의 자식 객체이므로 다형성이 적용되어 허용\r\n\t\tTV tv2 = new SmartTV();\r\n\r\n\t\t// 불가능\r\n\t\tSmartTV smart2 = new TV();\r\n\t}\r\n}\r\n```\r\n\r\n다른건 명확하므로 필요없고, 12번째 줄을 자세히 보자. `TV`와 `SmartTV`는 엄연히 다른 객체임에도 불구하고 인스턴스가 정상적으로 생성된다.\r\n\r\n이는 객체의 다형성이 적용된 결과로, `SmartTV`는 `TV`를 상속받아 만들어진 객체다. 즉 `SmartTV`는 `TV`를 온전히 포함하고 있으므로 `TV`의 인스턴스로 생성이 가능하다. 이러한 객체의 다형성은 객체를 상속했을 때 뿐만 아니라, 인터페이스를 상속할때도 가능하다.\r\n\r\n#### 다형성이 적용된 인스턴스\r\n\r\n객체의 다형성을 다룰 때 주의할 점이 한 가지 있다. 우리는 위에서 `SmartTV` 객체를 `TV`로 생성했다. 뭐 다형성 어쩌고로 인해 인스턴스가 정상적으로 생성됨은 알겠는데, 이 `TV`인듯 `SmartTV`인듯한 인스턴스는 어떻게 동작할까?\r\n\r\n이렇게 생성된 인스턴스 `tv2`는 `SmartTV`에 선언된 메소드들 중 `TV`에 선언된 메소드와 일치하는 메소드만 사용 가능하다.\r\n\r\n``` java\r\ninterface Movable\r\n{\r\n\tvoid move(boolean direction);\r\n}\r\n\r\nclass Unit implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n\r\n\tpublic void work(String act)\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n}\r\n```\r\n\r\n이번엔 인터페이스를 예시로 들어보자. 움직임에 대한 동작이 기술되어있는 인터페이스 `Movable`과 이를 상속받은 `Unit` 객체가 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tMovable movable = new Unit();\r\n\r\n\t\t// Movable에 존재하는 메소드이므로 호출 가능\r\n\t\tmovable.move(true);\r\n\r\n\t\t// Movable엔 없는 Unit만의 고유 메소드이므로 호출 불가능\r\n\t\tmovable.work(\"run\");\r\n\t}\r\n}\r\n```\r\n\r\n객체의 다형성으로 인해 `Unit` 객체를 `Movable`로 생성할 수 있음은 잘 알 것이다. `movable`이라는 인스턴스를 만들고 `move()`, `work()` 메소드를 각각 호출해보자.\r\n\r\n`move()`의 경우 `Movable` 인터페이스에서 상속받아 구현한 메소드고, `work()`는 `Unit`에서 직접 생성한 메소드다. 이 경우 `Unit`의 메소드를 호출할 수 있지만, `Movable`에 선언된 메소드만 호출 가능하다. 즉, `Unit`과 `Movable` 객체 간에 겹치는 메소드만 사용이 호출이 가능하다. 이 때 메소드의 동작은 `Unit`의 메소드로 동작한다.\r\n\r\n객체의 다형성을 사용하면 동일한 객체를 상속받은 여러 객체들을 다루기 매우 편리하다.\r\n\r\n``` java\r\nclass UnitA implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\twork(\"run\");\r\n\t}\r\n\r\n\tprivate void work(String act)\r\n\t{\r\n\t\tSystem.out.println(\"work: \" + act);\r\n\t}\r\n}\r\n\r\nclass UnitB implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\tdoing(3);\r\n\t}\r\n\r\n\tprivate void doing(int num)\r\n\t{\r\n\t\tSystem.out.println(\"doing: \" + num);\r\n\t}\r\n}\r\n\r\nclass UnitC implements Movable\r\n{\r\n\t@Override\r\n\tpublic void move(boolean direction)\r\n\t{\r\n\t\tactive(true);\r\n\t}\r\n\r\n\tprivate void active(boolean flag)\r\n\t{\r\n\t\tSystem.out.println(\"active: \" + flag);\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 동일한 인터페이스 `Movable`을 상속받은 여러 객체가 있다고 가정하자. 이 객체들은 각각 개별적인 객체지만, `Movable`을 상속받았으므로, 세 객체 모두 다형성을 통해 `Movable` 인스턴스로 할당할 수 있다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tMovable movable = switch (new Random().nextInt(3))\r\n\t\t{\r\n\t\t\tcase 0 -> new UnitA();\r\n\t\t\tcase 1 -> new UnitB();\r\n\t\t\tcase 2 -> new UnitC();\r\n\t\t\tdefault -> null;\r\n\t\t};\r\n\t\t\r\n\t\tmovable.move(true);\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n# 실행 시마다 달라짐\r\nwork: run\r\n```\r\n\r\n실행 시마다 `UnitA`, `UnitB`, `UnitC` 중 무작위로 선택된 객체의 인스턴스를 `Movable`에 할당한다. 서로 같은 객체임에도 `Movable`이라는 부모 객체로 인스턴스를 할당하여 공통된 메소드를 호출할 수 있다. 호출된 공통 메소드인 `move()` 내부에는 `Unit` 고유의 메소드가 포함되어도 상관없다.\r\n\r\n이처럼 메소드의 입력으로 여러 타입의 파라미터가 와야할 경우, 이 파라미터들이 동일한 객체를 상속하고 있다면 다형성을 적용하여 공통된 타입으로 다룰 수 있다.\r\n\r\n### 메소드의 다형성\r\n\r\n메소드 역시 다형성을 적용할 수 있다. 객체의 다형성은 객체 자신의 타입과 연관되지만, 메소드의 다형성은 메소드가 사용하는 파라미터의 타입과 연관된다.\r\n\r\n메소드의 다형성은 <span class=\"red-400\">메소드가 서로 동일한 이름을 가지더라도, 입력받는 파라미터가 다르면 각각 개별적인 메소드로 취급</span>함을 의미한다.\r\n\r\n``` java\r\n/**\r\n * 컨버터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 23:46:44\r\n */\r\npublic class Converter\r\n{\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param num: [int] 숫자\r\n\t */\r\n\tpublic void convert(int num)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"int: \").append(num));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param text: [String] 문자열\r\n\t */\r\n\tpublic void convert(String text)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"String: \").append(text));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param flag: [boolean] T/F\r\n\t */\r\n\tpublic void convert(boolean flag)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"boolean: \").append(flag));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 변환 함수\r\n\t *\r\n\t * @param c: [char] 문자\r\n\t */\r\n\tpublic void convert(char c)\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(\"char: \").append(c));\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 `Converter` 클래스로, 메소드의 이름이 모두 `convert`로 동일함을 알 수 있다. 하지만 각각의 메소드 모두 매개변수가 다르다. 이 경우 다형성에 의해 각각의 메소드가 독립적인 메소드로 인정받게된다.\r\n\r\n다형성의 존재로 인해 코드의 일관성을 유지할 수 있다. 대표적으로 우리가 콘솔에 출력할 때 사용하는 `System.out.println()` 메소드가 이에 해당한다.\r\n\r\n``` java\r\npublic void println(float x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(double x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 `System.out.println()`의 내부 소스다. 보다시피 이름이 동일하고, 동작까지도 콘솔에 출력하는 것으로 동일하지만 다형성으로 인해 각각의 메소드가 온전한 하나로 인정된다.\r\n\r\n만약 다형성이라는 개념이 없다면 어떨까? 동일한 동작을 함에도 매개변수가 달라진다는 이유만으로 비슷한 이름을 가진 메소드를 만들어야하고, 개발자는 각 매개변수에 맞게 메소드를 사용해야한다.\r\n\r\n``` java\r\npublic void printlnFloat(float x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnDouble(double x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnChar(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void printlnString(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n즉, 위와 같은 설계가 강요된다. 코드를 설계하다보면 동일한 동작에 다양한 종류의 객체가 와야할 수도 있다. JAVA는 <span class=\"green-400\">하나의 매개변수 = 하나의 타입</span>이라는 원칙을 고수하므로, JavaScript와 같이 다양한 종류의 타입이 매개변수로 올 수 없다.\r\n\r\n다형성을 활용하면 이러한 문제를 효과적으로 타개할 수 있다. 동일한 이름으로 다양한 매개변수를 받는 메소드를 작성하면, 개발자는 이를 사용 시 별다른 타입 구분 없이 마치 동일한 메소드를 사용한다는 개발 경험을 제공한다.\r\n\r\n``` java\r\n// println(String x)\r\nSystem.out.println(\"text\");\r\n\r\n// println(double x)\r\nSystem.out.println(1.5D);\r\n```\r\n\r\n위와 같이 개발자가 별도로 타입을 구분하지 않고 사용해도, 컴파일 시 해당 매개변수를 받는 메소드가 자동으로 호출된다.\r\n\r\n#### 반환값이 다른 메소드의 다형성?\r\n\r\n호기심이 많다면 이런 케이스를 생각해볼 수 있다. 매개변수에 대한 다형성이 있으면, 메소드의 반환값에 대한 다형성도 있지 않을까? 좋은 발상이지만, 아쉽게도 다형성은 반드시 매개변수로만 구분한다. <span class=\"red-400\">반환값의 경우 다형성이 적용되지 않는다.</span>\r\n\r\n``` java\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic void println(String x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(String.valueOf(x));\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 경우, 매개변수가 `char[]`, `String`으로 각각 다르므로 다형성이 적용된다.\r\n\r\n``` java\r\npublic void println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic boolean println(char[] x) {\r\n\tif (getClass() == PrintStream.class) {\r\n\t\twriteln(x);\r\n\t} else {\r\n\t\tsynchronized (this) {\r\n\t\t\tprint(x);\r\n\t\t\tnewLine();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n```\r\n\r\n반대로 위 경우는 메소드명과 매개변수는 동일하지만, 반환값이 다르다. 매개변수와 달리 <span class=\"red-400\">반환값은 다형성이 적용되지 않으므로, 중복된 메소드로 취급</span>된다. 따라서 위 소소는 컴파일 오류를 일으킨다.\r\n\r\n# 마무리\r\n\r\n객체의 다형성은 생산성에 초점이 맞춰져있다. 동일한 메소드로 여러 타입의 데이터를 처리하거나, 공통 상속된 객체를 처리함으로써 중복된 코드 소요를 제거하고 개발 편의성을 높여준다. 다형성을 적극적으로 활용하여 중복된 코드는 줄이고, 데이터 처리의 범위는 넓혀보자.","url":["2021-08-12-polymorphism","2021","08","12","polymorphism"]},{"header":{"title":"[OOP] 객체지향의 특징 - 상속(Inheritance)","excerpt":"나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다. 나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 상속이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-11T20:32:33","type":"posts","category":"CS","tag":["CS","객체지향","상속","추상"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-11-inheritance.md","content":"\r\n# 상속 (Inheritance)\r\n\r\n나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다.\r\n\r\n나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 **상속**이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.\r\n\r\n<p align=\"center\"><i><del>평범하게 살던 내가 콤퓨타 이세카이에선 상속자???!!?!?!</del></i></p>\r\n\r\n하지만 객체지향 언어에서는 누구나 필요에 의해 쉽게 상속받을 수 있다!\r\n\r\n객체지향 역시 동일한 개념이 존재한다. 객체지향에서의 <span class=\"teal-400\">상속</span>이란 <span class=\"blue-400\">객체가 다른 객체를 상속받아 상속받은 객체의 요소를 사용</span>하는 것을 의미한다.\r\n\r\n이 때 객체를 상속받은 객체는 <span class=\"teal-400\">자식</span>, 상속된 객체는 <span class=\"teal-400\">부모</span>라 칭한다.\r\n\r\n자식 객체는 상속된 부모 객체의 은닉화 구성에 따라 정해진 변수, 메소드에 접근할 수 있다. 또한 부모 객체가 <span class=\"teal-400\">추상 객체</span>일 경우 <span class=\"teal-400\">추상 메소드</span>와 <span class=\"teal-400\">오버라이딩</span>(Overriding)을 통해 부모 객체의 메소드를 구현하거나 다룰 수 있다.\r\n\r\n## 추상 객체\r\n\r\n<span class=\"teal-400\">추상 객체</span>는 하나 이상의 추상 메소드를 포함하는 객체다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\t// 메소드\r\n}\r\n```\r\n\r\nJAVA로 표현한 추상 클래스는 위와 같으며, 클래스의 맨 앞에 `abstract` 키워드를 적어 해당 객체가 추상 객체임을 표현할 수 있다.\r\n\r\n## 추상 메소드\r\n\r\n<span class=\"teal-400\">추상 메소드</span>는 자식 객체에서 구현해야하는 메소드다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\tpublic void normalMethod()\r\n\t{\r\n\t\tSystem.out.println(\"일반 메소드\");\r\n\t}\r\n\r\n\tabstract public void abstractMethod();\r\n}\r\n```\r\n\r\n위는 JAVA로 표현한 추상 객체다. `normalMethod()`은 일반적인 메소드고, `abstractMethod()`는 추상 메소드다. 추상 메소드는 일반적인 메소드와 큰 차이가 있는데, 메소드의 동작이 기술되어있지 않다.\r\n\r\n추상 메소드의 구현은 자식 객체가 담당하며, 아래 단계에서 이루어진다.\r\n\r\n* 추상 객체의 인스턴스 생성 시\r\n* 추상 객체를 상속받을 시\r\n\r\n일반적인 메소드는 자신의 객체에서 선언되어있다. 하지만 추상 메소드의 경우, 추상 객체를 할당받으려는 객체에서 선언이 이루어진다. 이 경우 어떤 메리트가 있을까?\r\n\r\n예를 들어, 부모 객체 `Main`과 이를 상속받은 자식 객체 `Sub`가 있다고 가정하자. 만약 동작 구조 상 `abstractMethod()`에서 자식 객체의 변수나 메소드를 사용해야만 한다면?\r\n\r\n`normalMethod()` 처럼 동작이 이미 부모 객체에 선언되는 경우 자식 객체의 요소를 반영하기가 매우 어렵다. 인스턴스를 생성하는 방법도 있겠지만 어떤 객체를 상속받을 지 알 수 없는 경우, 예상되는 객체의 인스턴스를 전부 할당받아놓는 게 아니라면 불가능에 가깝다. 그리고 이 방법의 경우 메모리 낭비가 너무 심해진다.\r\n\r\n반면 `abstractMethod()` 같은 추상 메소드의 경우 자식 객체에서 구현되기 때문에 자식 객체의 변수나 메소드에 직접적으로 접근할 수 있다. 때문에 자식 객체의 요소를 활용해서 동작을 구현해야 할 경우, 해당 메소드를 추상으로 정의하면 자식 객체의 특성에 맞게 구현하기 용이하다.\r\n\r\n### 추상 메소드 구현 - 인스턴스 생성 시\r\n\r\nJAVA를 통해 `Main`의 인스턴스를 `Sub`에서 생성해보자.\r\n\r\n``` java\r\npublic class Sub\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tMain main = new Main()\r\n\t\t{\r\n\t\t\t@Override\r\n\t\t\tpublic void abstractMethod()\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(text());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"Sub 객체의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n원래대로라면 `abstractMethod()` 메소드는 `Sub` 객체의 `text()`에 접근할 수 없다. `text()`는 `private` 접근제어자를 가지기 때문이다.\r\n\r\n하지만 추상 메소드의 경우 구현이 `Sub`에서 이루어지기 때문에 `Sub`의 모든 요소에 직접적으로 접근할 수 있다. 즉, `private` 같은 내부 메소드까지 전부 접근 가능하다.\r\n\r\n### 추상 메소드 구현 - 상속 시\r\n\r\nJAVA를 통해 `Main`을 `Sub`에 상속시켜보자.\r\n\r\n``` java\r\npublic class Sub extends Main\r\n{\r\n\t@Override\r\n\tpublic void abstractMethod()\r\n\t{\r\n\t\tSystem.out.println(text());\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"자식 객체 Sub의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n부모 객체에 추상 메소드가 있을 경우, 자식 객체는 이를 반드시 오버라이딩해야한다. 그러지 않을 경우 컴파일 오류를 일으킨다.\r\n\r\n마찬가지로 메소드의 구현이 자식 객체에서 이루어지므로, 자식 객체의 모든 요소에 접근할 수 있다.\r\n\r\n추상 메소드는 이처럼 구현의 주체를 자식 객체에게 전가함으로써, 자식 객체의 요소에 제한없이 접근할 수 있다. 원래라면 `public` 등으로 열어줬어야 함에도 자식 객체 내부에서 구현이 이루어지기 때문에 접근제어자를 변경할 필요가 없다.\r\n\r\n# 상속의 예제\r\n\r\nJAVA를 통해 객체의 상속이 어떤식으로 이루어지고, 어떤식으로 사용되는지 알아보자.\r\n\r\n``` java\r\nimport java.util.Date;\r\n\r\n/**\r\n * 컴퓨터 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:19:19\r\n */\r\nabstract public class Computer\r\n{\r\n\tprivate final String OS;\r\n\t\r\n\t/**\r\n\t * Computer 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Computer(String os)\r\n\t{\r\n\t\tthis.OS = os;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\tpublic void startup()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - started at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - shutdown at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 추상 함수\r\n\t */\r\n\tabstract public void run();\r\n}\r\n```\r\n\r\n여기 `Computer`라는 추상 객체가 존재한다. 이 객체는 `OS`라는 상태와 `startup`, `shutdown`, `run`이라는 동작을 가진다.\r\n\r\n이 중 `run`은 좀 특별한데, 동작은 적혀있으나, 어떤식으로 동작하는지에 대한 명세는 정해져있지 않다.\r\n\r\n이는 <span class=\"teal-400\">추상 객체</span>의 특징 중 하나로, 추상 객체는 하나 이상의 <span class=\"teal-400\">추상 메서드</span>를 포함할 수 있다. 추상 메서드는 구현되지 않은 메서드로, **동작의 개념** 정도로만 이해하면 된다. <span class=\"red-400\">추상 메서드의 구현은 해당 객체를 상속받은 자식 객체에서 이루어진다.</span> 즉, `run` 추상 메소드는 자식마다 제각각으로 구현된 동작을 수행한다.\r\n\r\n아래의 두 클래스 `Asus`와 `Dell`은 `Computer` 추상 클래스를 상속받은 자식 클래스다.\r\n\r\n``` java\r\n/**\r\n * ASUS 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:24:50\r\n */\r\npublic class Asus extends Computer\r\n{\r\n\t/**\r\n\t * Asus 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Asus(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"ASUS 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n``` java\r\n/**\r\n * DELL 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:26:46\r\n */\r\npublic class Dell extends Computer\r\n{\r\n\t/**\r\n\t * Dell 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Dell(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void startup()\r\n\t{\r\n\t\tsuper.startup();\r\n\t\t\r\n\t\tSystem.out.println(\"시스템 안정화 수행\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\t@Override\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(\"시스템 프로세스 정리 수행\");\r\n\t\t\r\n\t\tsuper.shutdown();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"DELL 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n`Asus`와 `Dell` 모두 `Computer`를 상속받았음을 확인할 수 있다. 또한 모두 `run` 함수가 제각각 구현된 것 역시 확인할 수 있다.\r\n\r\n그런데 `Asus`와 달리 `Dell`은 부팅 시와 종료 시 각각 시스템의 안정성을 위한 사전/후 작업이 추가됐다.\r\n\r\n이러한 사전/후 작업을 구현하기 위해 `startup`, `shutdown`을 오버라이딩한다. 이 과정을 통해 시작과 종료 함수에 각각 원하는 동작을 추가한다.\r\n\r\n> **super?**  \r\n> 자식 클래스에서 부모 클래스를 호출할 때 `super` 키워드를 이용해 호출한다. `Dell`의 오버라이딩 메소드 동작에서 활용됨을 알 수 있다. `super.shutdown()`은 부모 클래스 `Computer`의 메소드인 `shutdown()`을 호출한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tDell dell = new Dell(\"Windows 10 Pro\");\r\n\t\tAsus asus = new Asus(\"Ubuntu 21.04\");\r\n\t\t\r\n\t\tdell.startup();\r\n\t\tdell.run();\r\n\t\tdell.shutdown();\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tasus.startup();\r\n\t\tasus.run();\r\n\t\tasus.shutdown();\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\nWindows 10 Pro - started at Fri Aug 06 22:54:39 KST 2021\r\n시스템 안정화 수행\r\nDELL 작업 수행\r\n시스템 프로세스 정리 수행\r\nWindows 10 Pro - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n\r\nUbuntu 21.04 - started at Fri Aug 06 22:54:39 KST 2021\r\nASUS 작업 수행\r\nUbuntu 21.04 - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n```\r\n\r\n`Asus`와 `Dell`의 메소드를 순서대로 수행하면 위와 같은 결과가 나온다. `Dell`의 시작, 종료 간 시스템 동작이 수행됨을 확인할 수 있다.\r\n\r\n# 정리\r\n\r\n객체지향은 모든 객체의 모듈화를 추구한다. 좋은 모듈화는 <span class=\"amber-400\">캡슐화</span>, <span class=\"amber-400\">은닉화</span>가 적절히 구현되고 유지되는 것을 지향한다.\r\n\r\n하지만 포장이 견고하면 뜯기 어렵듯이, 탄탄한 모듈화는 모듈이 경직된다. 재사용의 범위가 제한되는 것 뿐만 아니라, 이를 이용한 확장 또한 어려울 것이다. 만약 객체지향에 이 두 개념만 있었다면 개발자는 재사용성과 모듈화를 적절히 타협하며 객체를 구현했을 것이다.\r\n\r\n하지만 상속이라는 개념의 존재로 인해 객체에 지정된 모듈화를 전혀 해치지 않으면서 재사용성, 확장성을 보장받을 수 있다. 객체지향의 모듈화로 인한 딜레마를 상쇄하는 키치한 개념이 아닐 수 없다. 개인적으로는 객체지향의 특징 중 가장 중요한 특징이라고 생각한다. 물론 객체지향 중에서도 매우 어려운 개념이지만, 이를 잘 이해하면 조금 더 객체지향다운 코드를 짤 수 있을 것이다.","url":["2021-08-11-inheritance","2021","08","11","inheritance"]},{"header":{"title":"[OOP] 객체지향의 특징 - 캡슐화(Encapsulation)와 정보 은닉","excerpt":"객체. 즉, 클래스의 내부 변수와 메소드를 하나로 패키징하는 특징이다. 객체에 선언된 변수나 메소드가 구분없이 중구난방으로 접근할 수 있다면 정상적인 객체로 보기 어렵다. 캡슐화와 비슷한 개념으로 정보 은닉이라는 개념이 있다. 정보 은닉은 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도한다. 이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-08T11:05:05","type":"posts","category":"CS","tag":["CS","객체지향","캡슐화","정보 은닉","접근제어자"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-08-encapulation.md","content":"\r\n# 캡슐화 (Encapsulation)\r\n\r\n객체. 즉, <span class=\"blue-400\">클래스의 내부 변수와 메소드를 하나로 패키징</span>하는 특징이다.\r\n\r\n객체에 선언된 변수나 메소드가 구분없이 중구난방으로 접근할 수 있다면 정상적인 객체로 보기 어렵다.\r\n\r\n<span class=\"primary\">캡슐화</span>와 비슷한 개념으로 <span class=\"primary\">정보 은닉</span>이라는 개념이 있다.\r\n\r\n정보 은닉은 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도한다.\r\n\r\n이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다.\r\n\r\n# 캡슐화의 예제\r\n\r\nJAVA의 경우 <span class=\"orange-700\">접근제어자</span>를 통해 객체의 캡슐화, 은닉화를 구현한다.\r\n\r\n* `public`: 다른 객체에서 해당 객체의 인스턴스를 생성하여 접근할 수 있다.\r\n* `protected`: 해당 객체를 상속받은 객체 내부에서 접근할 수 있다. 단순 인스턴스에선 접근할 수 없다.\r\n* `default`: 동일한 패키지 내의 객체에서 인스턴스를 생성하여 접근할 수 있다.\r\n* `private`: 선언된 객체 내부에서만 사용 가능하며, 외부에선 어떠한 방법으로든 해당 지시자를 가진 변수 혹은 메소드를 사용할 수 없다.\r\n\r\n대표적인 접근제어자는 위와 같으며, 이를 통해 <span class=\"red-400\">객체 내부의 상태와 동작의 접근 방법을 강제</span>할 수 있다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\t// 동작\r\n\t}\r\n}\r\n```\r\n\r\n``` java\r\npublic class B\r\n{\r\n\tprivate void publicMethod()\r\n\t{\r\n\t\tSystem.out.println(\"public 메소드 접근\");\r\n\t}\r\n\r\n\tdefault void defaultMethod()\r\n\t{\r\n\t\tSystem.out.println(\"default 메소드 접근\");\r\n\t}\r\n\r\n\tprotected void protectedMethod()\r\n\t{\r\n\t\tSystem.out.println(\"protected 메소드 접근\");\r\n\t}\r\n\r\n\tprivate void privateMethod()\r\n\t{\r\n\t\tSystem.out.println(\"private 메소드 접근\");\r\n\t}\r\n}\r\n```\r\n\r\n## public 요소의 접근 방법\r\n\r\n`public`은 접근제어자 중 <span class=\"orange-400\">가장 개방적인 접근제어자</span>다. 이름부터가 공공(public)이니 말 다했다.\r\n\r\n별다른 조건 없이 객체 `A`에서 객체 `B`의 새로운 인스턴스를 생성하면 `A`에서 `B`의 `public` 요소에 접근할 수 있는 권한이 생긴다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tB b = new B();\r\n\t\tb.publicMethod();\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 `publicMethod()`에 정상적으로 접근 가능하다. 반드시 외부의 접근이 필요한 멤버 변수나 메소드에만 사용해야한다. 해당 접근제어자를 <span class=\"red-400\">남용할 경우 불필요한 요소를 개방</span>하게 되어 정보 은닉이 이루어지지 않는다.\r\n\r\n## protected 요소의 접근 방법\r\n\r\n`protected`는 상속과 연관된 접근제어자다. 이 제어자를 가진 요소는 <span class=\"orange-400\">해당 객체를 상속받은 객체만 접근</span>할 수 있다.\r\n\r\n객체 `A`에서 객체 `B`를 상속받는다. 이 때 자식 객체는 `A`, 부모 객체는 `B`가 된다. 상속을 받게 되면 `A`에서 `B`의 `protectedMethod` 요소에 접근할 수 있는 권한이 생긴다.\r\n\r\n``` java\r\npublic class A extends B\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tprotectedMethod();\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 `protectedMethod()`에 정상적으로 접근 가능하다. `public`과 달리 별도의 인스턴스는 받지 않아도 된다. 이는 `A`가 `B`를 상속받기 때문에, `B`의 <span class=\"lightBlue-400\">멤버 변수와 메소드의 접근 권한을 일부 승계</span>하기 때문\r\n\r\n## default 요소의 접근 방법\r\n\r\n`default`는 제한적인 `public` 접근제어자라 할 수 있다. 이 제어자를 가진 요소는 <span class=\"orange-400\">동일한 패키지 내에서만 접근</span>할 수 있다.\r\n\r\n객체 `A`와 `B`가 동일한 패키지에 위치할 때, `A`에서 `B`의 새로운 인스턴스를 할당받으면 `defaultMethod()`에 접근할 수 있다.\r\n\r\n``` java\r\npublic class A\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tB b = new B();\r\n\t\tb.publicMethod();\r\n\t}\r\n}\r\n```\r\n\r\n패키지가 같을 경우 `public`을, 패키지가 다를 경우 `private`과 같은 동작을 한다. 동일한 패키지 여부에 따라 개방/폐쇄가 갈린다. 만약 변수나 메소드에 <span class=\"lightBlue-400\">별다른 접근제어자를 지정하지 않았다면 이 제어자가 기본으로 적용</span>된다.\r\n\r\n``` java\r\npublic class Main\r\n{\r\n\tvoid defaultMethod()\r\n\t{\r\n\t\t// 접근제어자를 지정하지 않으면 default로 자동 지정\r\n\t}\r\n}\r\n```\r\n\r\n## private 요소의 접근 방법\r\n\r\n`private`는 반드시 <span class=\"orange-400\">선언된 객체 내부에서만 접근</span>할 수 있다. 즉, `B`가 아닌 어떤 클래스에서도 `privateMethod()`에 접근할 수 없다. 메소드 뿐만 아니라 멤버 변수도 마찬가지다. 은닉화를 위한 접근제어자로, <span class=\"red-400\">해당 접근제어자의 사용을 통해 내부 변수나 메소드를 은닉</span>할 수 있다.\r\n\r\n객체는 기본적으로 은닉화가 이루어져야한다. 객체를 구현할 때 개방/폐쇄의 명세를 디테일하게 명세하지 않았다면 일단은 `private`로 만드는 것이 좋다. 이후 설계 과정에서 적절한 개방이 필요할 경우 해당 메소드나 변수를 개방한다. 이와 같은 방식은 필요 시에 요소를 적절히 개방함으로써, 차후 프로젝트나 객체의 규모가 커짐에 따라 놓칠 수 있는 불필요한 개방을 미연에 방지할 수 있다. 즉, 올바른 캡슐화/은닉화를 구현하는데 용이한 방식이다.\r\n\r\n# 정리\r\n\r\n별다른 생각 없이 모든 메소드를 개방시킨 객체는 모듈이라 보기 어렵다. 반대로 모든 메소드를 은폐시킨 객체 역시 모듈로써의 의미가 전혀 없다. 즉, 객체가 모듈의 의미를 갖기 위해선 적절히 설계된 개방/폐쇄가 필요하다는 뜻이다.\r\n\r\n캡슐화와 정보 은닉을 메소드가 모듈로써의 의미를 갖게 헤주는 중요한 요소이다. 사용하는 언어의 접근제어자에 대한 이해를 통해 올바른 캡슐화, 정보 은닉을 지키는 객체를 구현하자.","url":["2021-08-08-encapulation","2021","08","08","encapulation"]},{"header":{"title":"[OOP] 객체지향 프로그래밍(Object Oriented Programming)이란?","excerpt":"IT 업계에 종사하게 된다면 십중팔구 JAVA, C++, C# 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 객체지향언어라는 점이다. 물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, C의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-07T12:06:45","type":"posts","category":"CS","tag":["CS","객체지향"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-07-what-is-oop.md","content":"\r\n# OOP\r\n\r\nIT 업계에 종사하게 된다면 십중팔구 <span class=\"amber-400\">JAVA</span>, <span class=\"amber-400\">C++</span>, <span class=\"amber-400\">C#</span> 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 <span class=\"primary\">객체지향</span>언어라는 점이다.\r\n\r\n물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, <span class=\"amber-400\">C</span>의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.\r\n\r\n# 객체지향에 대해 설명해보세요.\r\n\r\n제목 그대로 위와 같은 질문을 받았다고 가정해보자. 난 이 질문의 명확한 답을 주지 못 한다. 자바 경험이 없지 않음에도 불구하고, 이론에는 크게 관심이 없기도 했고, 비전공자인 난 구태여 찾아보지 않는 이상 이와 같은 내용을 실무에서 습득하긴 어려웠다.\r\n\r\n내가 쓰는 언어가 어떤 방식으로 동작하는지 모른다면 그건 제대로 쓴다고 보긴 어렵다. 이 주제를 통해 객체지향의 개념에 대해 정리해보고자 한다.\r\n\r\n## 객체\r\n\r\n**객체**지향. 말 그대로 <span class=\"teal-400\">객체</span>를 지향하는 언어다. 객체지향에 대해 이해하기 위해선, 일단 이 방법론이 궁극적으로 지향하는 **객체**란 개념에 대해 이해할 필요가 있다.\r\n\r\n객체지향이 말하는 <span class=\"teal-400\">객체</span>란 프로그램 동작의 주체가 되는 요소를 의미한다. 이 객체는 유/무형을 가리지 않는다. 실체가 명확한 것일 수도 있고, 무형의 개념일 수도 있다.\r\n\r\n모든 객체는 상태와 동작을 가진다. 예를 들어, **TV**를 구매한다고 생각해보자. 대부분의 사람들은 TV의 디자인, 성능, 가격 등을 적절히 고려하여 TV를 구매할 것이다.\r\n\r\nTV의 색, 인치, 가격 등은 TV가 가진 상태라고 볼 수 있다. TV 채널 이동, 다시 보기, 넷플릭스 연결 등은 TV의 기능이라고 볼 수 있다.\r\n\r\n이렇게 모든 객체에는 <span class=\"green-400\">상태</span>와 <span class=\"green-400\">동작</span>이 존재한다.\r\n\r\n국내 객체지향 언어의 대표격인 <span class=\"amber-400\">JAVA</span>는 이러한 개념을 아래와 같이 접근한다.\r\n\r\n| 객체지향 |     JAVA      |\r\n| :------: | :-----------: |\r\n|   객체   |    클래스     |\r\n|   상태   |   멤버 변수   |\r\n|   동작   | 메소드 (함수) |\r\n\r\n여기 **자동차**라는 현실의 객체를 JAVA가 어떻게 클래스로 다루는지 예제를 통해 알아보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.05 22:06:24\r\n */\r\npublic class Car\r\n{\r\n\t// 시동 여부\r\n\tprivate final boolean IS_STARTED = false;\r\n\t\r\n\t// 최대 속력\r\n\tprivate final int MAX_SPEED;\r\n\t\r\n\t// 현재 속력\r\n\tprivate int speed;\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param maxSpeed: [int] 최대 속도\r\n\t */\r\n\tpublic Car(int maxSpeed)\r\n\t{\r\n\t\tMAX_SPEED = maxSpeed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 결과\r\n\t */\r\n\tpublic boolean startUp()\r\n\t{\r\n\t\treturn !IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 종료 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 종료 결과\r\n\t */\r\n\tpublic boolean shutdown()\r\n\t{\r\n\t\treturn IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 현재 속도 반환 함수\r\n\t *\r\n\t * @return [int] 현재 속도\r\n\t */\r\n\tpublic int getSpeed()\r\n\t{\r\n\t\treturn speed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void upSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 가속된 값이 최대 속도를 넘지 않을 경우\r\n\t\t\tif (MAX_SPEED >= speed + amount)\r\n\t\t\t{\r\n\t\t\t\tspeed += amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가속된 값이 최대 속도를 넘을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = MAX_SPEED;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 감속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void downSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 감속된 값이 0보다 클 경우\r\n\t\t\tif (0 <= speed - amount)\r\n\t\t\t{\r\n\t\t\t\tspeed -= amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 감속된 값이 0보다 작을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위의 코드 Car 클래스는 자동차라는 현실의 객체를 매우 간단한 형태로 구현한 클래스다.\r\n\r\n<br />\r\n\r\n* **멤버 변수** (상태)\r\n  * `IS_STARTED` 자동차 시동 여부\r\n  * `MAX_SPEED`: 최대 속도\r\n  * `speed`: 현재 속도\r\n\r\n<br />\r\n\r\n* **메소드** (동작)\r\n  * `startUp`: 엔진 시동\r\n  * `shutdown`: 엔진 정지\r\n  * `getSpeed`: 현재 속도 표시\r\n  * `upSpeed`: 가속\r\n  * `downSpeed`: 감속\r\n\r\n<br />\r\n\r\nCar 클래스의 요소는 위와 같이 구분된다. JAVA에서 이 객체를 사용하려면 메모리에 할당해야하고, 이렇게 할당된 객체를 <span class=\"teal-400\">인스턴스</span>(Instance)라 칭한다.\r\n\r\nCar 클래스를 메모리에 할당하여 새로운 인스턴스를 만드는 것은 현실에서 자동차 하나를 뽑는 것과 동일한 개념이다.\r\n\r\n## 객체지향\r\n\r\n객체**지향**이므로, 앞서 언급했듯이 이를 이해하기 위해선 객체를 이해해야한다. 이미 이전 문단에서 객체에 대해 장황하게 설명했으므로, <span class=\"teal-400\">객체지향</span>은 이러한 객체를 통해 코드를 구성하는 방법론이라 정의할 수 있다.\r\n\r\n모든 객체는 각 객체의 특성에 부합하는 상태와 동작을 가지며, 이를 통해 객체 간의 상호작용을 코드로 나타낼 수 있다. 객체지향은 이러한 객체의 상호작용을 코드로 나타낸다.\r\n\r\n일례로 JAVA는 `String`, `HashMap` 등, 모든 요소를 객체(Object)로 다룬다. 우리는 JAVA로 필요한 객체를 메모리에 할당하고, 객체가 가진 변수나 메소드를 사용하여 코딩한다. 이러한 JAVA의 프로그래밍 방식은 지금껏 설명한 객체지향의 그 것과 동일함을 알 수 있다.\r\n\r\n# 그래서 이걸 왜 쓰는데?\r\n\r\n객체지향을 차용한 언어는 매우 많다. 대표격인 JAVA 이외에도 C++, C#, Visual Basic, Swift, Python 등이 있다. 또한 이 언어들은 우리에게 매우 익숙한 이름일 뿐만 아니라, 프로그래밍 언어에서 다들 한 자리씩은 차지하는 매우 비중있는 언어들이다.\r\n\r\n그렇다면 객체지향 언어가 개발자들에게 그토록 널리 쓰이며, 사랑받을 수 있었던 이유는 무엇일까?\r\n\r\n객체지향은 절차지향의 후발주자다. 보통 이런 경우의 후발주자는 선발의 단점 혹은 니즈들을 개선하여 출시하므로 기능 혹은 편의성에서 많은 이점을 가진다. 객체지향은 특히 생산성과 유지보수 용이성을 높이는 데 포커스를 두었으며, 덕분에 객체지향 언어를 구사하는 개발자는 개발을 비교적 쉽고 빠르게 수행할 수 있다.\r\n\r\n## 장점\r\n\r\n* <span class=\"green-400\">코드 재사용성</span>  \r\n모듈화된 객체를 기반으로 코드가 작성되기 때문에, 해당 객체의 특징을 비슷한 다른 로직에도 적용해서 사용하거나, 다른 개발자가 구현한 객체를 가져와 쓰기에도 용이하다.\r\n\r\n* <span class=\"green-400\">간편한 유지보수</span>  \r\n객체를 수정할 경우, 해당 객체를 사용하는 모든 로직에 일괄적으로 적용되니, 중복 코드에 대한 관리가 간단해진다. 혹은 객체나 동작이 변경될 경우, 해당 객체나 동작과 연관된 객체만을 찾아 수정하면 된다.\r\n\r\n* <span class=\"green-400\">큰 규모의 프로그래밍에 유리</span>  \r\n객체, 모듈 단위로 구분되는 특징으로 인해 업무 분장이 쉽고, 각 모듈의 연관성을 도식하기 용이하다.\r\n\r\n## 단점\r\n\r\n* <span class=\"red-400\">비교적 느린 속도</span>  \r\n절차지향과 달리 객체지향은 각 객체의 의존 관계로 인해 대체적으로 속도가 느리다.\r\n\r\n* <span class=\"red-400\">높은 설계역량 요구</span>  \r\n모듈 단위의 상호작용으로 이루어진 방식은, 모듈의 정확한 명세와 상호 간의 연관성이 얼마나 짜임새있게 설계되었는지 중요하다. 잘 못 설계된 객체나 연관성은 라쟈나 코드로 변하기 쉽다.\r\n\r\n* <span class=\"red-400\">코드의 잠재적인 복잡성</span>  \r\n높은 수준의 설계역량 요구와 더불어 추상 객체, 상속, 인터페이스 등의 복잡한 개념과 그 활용은 코드의 구조를 파악하기 어렵게 만든다.\r\n\r\n# 객체지향을 사용하는 언어들\r\n\r\n* JAVA\r\n* C++\r\n* C#\r\n* Python\r\n* Simula 67\r\n* Delphi\r\n* Swift\r\n* Ruby\r\n* Perl\r\n\r\n<del class=\"grey-600\">대부분 아는 얼굴들이구만</del>\r\n\r\n# 정리\r\n\r\n기존의 C언어의 기반인 절차지향도 나름의 장점이 있었다. 컴퓨터의 처리 흐름과 코드의 흐름이 매우 유사하기 때문에 전처리가 적어 실행 속도가 비교적 빨랐다. 또한 코드의 흐름이 일정했으므로, 이를 분석하기도 수월했을 것이다.\r\n\r\n하지만 시대가 지남에 따라 시대가 발전했고, 개발자의 평균 역량 또한 높아졌다. 컴퓨터의 처리 속도는 언급할 필요조차 없었고. 이러한 환경의 발전으로 인해 절차지향의 장점이 주는 메리트가 적어지면서, 반대로 단점이 주는 디메리트가 더더욱 크게 다가왔을 것이다.\r\n\r\n객체지향은 유지보수의 용이성과 개발 편의성을 중요시 여기는 개발 방법론이다. 객체지향이 가지는 장점 덕분에 <span class=\"pink-400\">개발자 간의 코드 공유</span>가 쉬워졌으며, <span class=\"pink-400\">서비스의 규모는 더욱 증가</span>하고, <span class=\"pink-400\">견고한 프로그램</span>을 만들기 쉬워졌다.\r\n\r\n절차지향이 컴퓨터에게 친화적이라면, 객체지향은 개발자에게 친화적이라 할 수 있겠다. 컴퓨터의 성능이 미친듯이 높아짐에 따라, 프로그램의 성능은 자연스레 개발자의 역량에 갈리게 됐다. 이러한 흐름으로 인해 객체지향은 많은 언어, 개발자에게 사랑받을 수 있었을 것이다.\r\n\r\n요즘 AI 기술이 발달함에 따라 [Copilot](https://copilot.github.com/) 등 AI가 코딩을 보조해주는 기술이 연구되고, 등장하고 있는 것 같다.\r\n\r\n나중에 시간이 지나 개발자의 역량이 더 이상 중요하지 않게 되면 새로운 방법론이 대세가 되지 않을까?","url":["2021-08-07-what-is-oop","2021","08","07","what-is-oop"]},{"header":{"title":"재귀를 사용한 재귀적 반복","excerpt":"컴퓨터 언어에서의 재귀란 자기 자신을 호출함을 의미한다. 알고리즘에서의 재귀는 매우 중요한 개념 중 하나로써, 그 특성 상 복잡한 연산 및 연산에 걸리는 소요 시간을 효과적으로 개선할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-08-04T00:26:26","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","재귀"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-08-04-about-algorithm-chapter09.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 9장 재귀를 사용한 재귀적 반복\r\n\r\n컴퓨터 언어에서의 <span class=\"primary\">재귀</span>란 자기 자신을 호출함을 의미한다. 알고리즘에서의 재귀는 매우 중요한 개념 중 하나로써, 그 특성 상 복잡한 연산 및 연산에 걸리는 소요 시간을 효과적으로 개선할 수 있다.\r\n\r\n``` javascript\r\n/**\r\n * 재귀 함수\r\n */\r\nfunction recursive()\r\n{\r\n\tconsole.log('recursive');\r\n\r\n\trecursive();\r\n}\r\n```\r\n\r\n``` output\r\nrecursive\r\nrecursive\r\nrecursive\r\nrecursive\r\nrecursive\r\nrecursive\r\n...\r\n```\r\n\r\n위 소스는 재귀의 특성을 간단하게 구현한 예제다. 위 함수를 호출하면 <span class=\"teal-400\">\"recursive\"</span>라는 단어가 끝없이 출력된다.\r\n\r\n`recursive` 함수 내에서 자기 자신을 끝없이 호출하기 때문에 이러한 현상이 일어난다. 겉보기엔 쓸데없는 장난처럼 보이기도 하지만, 재귀의 특징을 잘 활용하면 매우 강력한 도구가 된다.\r\n\r\n## 9-1. 루프 대신 재귀\r\n\r\n지금껏 코드에서 어떤 동작을 반복하기 위해 우리는 루프를 사용한다. `for`, `while` 등과 같은 반복문을 통해 원하는 만큼 동작을 반복한다.\r\n\r\n10부터 0까지 카운트다운을 하는 소스를 설계해보면 아래와 같다.\r\n\r\n``` javascript\r\n/**\r\n * 루프를 활용한 카운트다운 함수\r\n * \r\n * @param {number} start: 시작 숫자\r\n */\r\nfunction countdown(start)\r\n{\r\n\tfor (let i = start; i >= 0; i--)\r\n\t{\r\n\t\tconsole.log(i);\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n10\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n0\r\n```\r\n\r\n위 소스는 javascript로 루프를 사용해 작성한 카운트다운 소스다. 하지만, 루프 대신 재귀를 사용하면 아래처럼 구성할 수도 있다.\r\n\r\n``` javascript\r\n/**\r\n * 재귀를 활용한 카운트다운 함수\r\n * \r\n * @param {number} start: 시작 숫자\r\n */\r\nfunction countdown(start)\r\n{\r\n\tconsole.log(start);\r\n\r\n\tcountdown(start - 1);\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n10\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n0\r\n-1\r\n-2\r\n...\r\n```\r\n\r\n반대로 위 소스는 루프 대신 재귀를 활용하여 카운트다운을 수행한다. `start`를 출력하고 1을 뺀 값을 다시 자기 자신인 `countdown`에 전달한다.\r\n\r\n대부분의 루프는 재귀로 대체할 수 있다. 단순히 대체되는 것 이상으로 재귀는 루프와 달리 유의미한 성능 향상도 기대할 수 있다.\r\n\r\n그 이전에, 위 소스의 출력을 살펴보자. 통상 카운트다운은 정해진 숫자부터 1 혹은 0까지를 센다. 그런데 위 소스, 0을 넘어서 -1, -2... 한 없이 내려간다. 왜 이러는 걸까?\r\n\r\n## 9-2. 기저 조건\r\n\r\n이전 문단에서 기술한 재귀 함수는 카운트다운이라고 볼 수 없다. 그냥 입력한 숫자부터 끊임없이 숫자를 나열하는 것이나 다름없다. 이런 현상이 발생하는 이유는, 이 재귀 함수에 일종의 브레이크라고 할만한 것이 없기 때문이다.\r\n\r\n우리가 원하는 것은 0까지의 카운트다운이므로, `start`의 값이 0일 경우 더 이상 자기 자신을 호출하지 않도록 바꿔줄 필요가 있다.\r\n\r\n``` javascript\r\n/**\r\n * 재귀를 활용한 완전한 카운트다운 함수\r\n * \r\n * @param {number} start: 시작 숫자\r\n */\r\nfunction countdown(start)\r\n{\r\n\tconsole.log(start);\r\n\r\n\t// 값이 0보다 클 경우\r\n\tif (start > 0)\r\n\t{\r\n\t\tcountdown(start - 1);\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n10\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n0\r\n...\r\n```\r\n\r\n위 소스는 이러한 문제를 개선한 소스다. `start`가 0보다 클 경우에만 자기 자신을 다시 호출한다. 0보다 작거나 같을 경우, 재귀가 더 이상 일어나지 않아 동작이 종료된다. 동작에 브레이크가 걸리는 것이다.\r\n\r\n우리가 `for`나 `while`에 특정 조건을 삽입해서 원하는 만큼만 반복문을 수행하는 것처럼 재귀도 이러한 조건을 달아서 원하는 만큼만 반복하게끔 구성해야한다.\r\n\r\n물론 위의 두 반복문은 조건을 어디에 어떤 식으로 입력해야하는지 명확하게 기술되어있다면, 재귀는 코드 내에서 조건을 구성하므로 그 방식이 명확하지 않다. 때문에 재귀를 처음 접하거나, 경험이 없을 경우 이런 방식의 조건 설정이 익숙하지 않아 무한히 동작하는 재귀 함수를 만들기도 한다.\r\n\r\n이렇게 재귀를 멈추는 조건을 <span class=\"primary\">기저 조건</span>이라 한다. 앞서 설명한 예제 `countdown`의 기저 조건은 `start > 0`이라 할 수 있다.\r\n\r\n## 9-3. 재귀 코드 읽기\r\n\r\n앞서 말했듯이, 재귀는 그 조건이 명확하게 보이지 않다. 때문에 경우에 따라선 재귀 코드를 읽는 것초자 어렵기도 하다. 간단한 예제를 통해서 재귀 코드를 읽어보자.\r\n\r\n고등학교 수학에서 배운 내용 중 팩토리얼(Factorial) 연산이 있다. 팩토리얼은 $5!$과 같이 표기하며, 연산 결과는 $5 \\times 4 \\times 3 \\times 2 \\times 1 = 120$이 된다. 즉, 일반식으로 표기하면 아래와 같다.\r\n\r\n$$\r\nn! = n \\times (n - 1) \\times (n - 2) \\times \\dotsb \\times 2 \\times 1\r\n$$\r\n\r\n팩토리얼 연산을 단축하면 $n! = n \\times (n - 1)!$와 같이 표기할 수 있다. 이러한 패턴은 재귀를 적용시키기 매우 용이한 패턴이다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 팩토리얼 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/31/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.02 Mon 22:57:53\r\n */\r\npublic class Factorial\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tint index = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\twriter.write(String.valueOf(factorial(index)));\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 팩토리열 연산 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t *\r\n\t * @return [int] 팩토리얼 연산 결과\r\n\t */\r\n\tprivate static int factorial(int index)\r\n\t{\r\n\t\t// 인덱스가 1일 경우\r\n\t\tif (index == 1)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t\r\n\t\t// 인덱스가 1이 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn index * factorial(index - 1);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n3628800\r\n```\r\n\r\n책에서 설명하는 재귀 코드를 읽는 방법은 아래와 같다.\r\n\r\n1. 기저 조건이 무엇인지 찾는다.\r\n2. 기저 조건을 다룬다는 가정하에 함수를 살펴본다.\r\n3. 기저 조건 바로 **전** 조건을 다룬다는 가정하에 함수를 살펴본다.\r\n4. 한 번에 한 조건씩 올라가면서 계속 분석한다.\r\n\r\n``` java\r\n// 인덱스가 1일 경우\r\nif (index == 1)\r\n{\r\n\treturn 1;\r\n}\r\n\r\n// 인덱스가 1이 아닐 경우\r\nelse\r\n{\r\n\treturn index * factorial(index - 1);\r\n}\r\n```\r\n\r\n위 소스의 구조는 매우 간단하므로, 어렵지 않게 분기를 찾을 수 있다. `index == 1`인 경우와 아닌 경우가 분기다.\r\n\r\n``` java\r\n// 인덱스가 1이 아닐 경우\r\nelse\r\n{\r\n\treturn index * factorial(index - 1);\r\n}\r\n```\r\n\r\n재귀는 자기 자신을 호출하는 것이므로, 분기의 `else` 부분이 재귀가 일어나는 영역이라 추측할 수 있다. 따라서 재귀가 일어나지 않는 영역이 <span class=\"teal-400\">기저 조건</span>이라 할 수 있다.\r\n\r\n``` java\r\n// 인덱스가 1일 경우\r\nif (index == 1)\r\n{\r\n\treturn 1;\r\n}\r\n```\r\n\r\n즉, 위 재귀 함수의 기저 조건은 `index == 1`이다. `factorial(1)`은 1을 반환한다. 이 기저 조건을 토대로 `factorial(4)`의 동작을 전개하면 아래와 같다.\r\n\r\n1. $\\text{factorial(4)} = 4 \\times \\text{factorial(3)}$\r\n2. $\\text{factorial(4)} = 4 \\times 3 \\times \\text{factorial(2)}$\r\n3. $\\text{factorial(4)} = 4 \\times 3 \\times 2 \\times \\text{factorial(1)}$\r\n4. $\\text{factorial(4)} = 4 \\times 3 \\times 2 \\times 1 = 12$\r\n\r\n이와 같이 순차적으로 자기 자신을 호출하여 연산을 수행한다. 재귀 함수의 <span class=\"green-400\">기저 조건은 재귀를 멈추는 요인</span>이므로, 기저 조건을 바탕으로 전개하면 비교적 쉽게 연산을 이해할 수 있다.\r\n\r\n## 9-4. 컴퓨터의 눈으로 바라본 재귀\r\n\r\n우리가 재귀함수를 이해하는 것도 중요하지만, 결국 코드의 실행 주체는 어찌됐든 컴퓨터가 담당하게 된다. 즉, 우리가 이를 이해하는 것 만큼 컴퓨터가 이를 어떻게 이해하는지 아는 것 또한 매우 중요하다.\r\n\r\n이전 장에서, 우리는 <span class=\"amber-400\">스택</span>에 대해 다뤘었다. 컴퓨터가 재귀를 다룰 때 스택을 활용하여 관리한다. `factorial(4)`를 컴퓨터가 스택으로 어떻게 관리하는 지 알아보자.\r\n\r\n1. `factorial(4)`를 호출한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024009-1ee1fc5d-ecce-4711-b729-36a70b8592d1.png\" width=\"200px\" />\r\n\r\n`factorial(4)` 내부에서 `factorial(3)`을 호출하므로, `factorial(4)`를 스택에 삽입하고 `factorial(3)`을 수행한다. 이 때 `factorial(4)`는 종료된 것이 아니라, 재귀 호출로 인해 연산이 중단된 상태다.\r\n\r\n<br />\r\n<br />\r\n\r\n2. `factorial(3)`을 호출한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024019-b76d21a2-24f6-47f6-bf2f-f46350da31e1.png\" width=\"200px\" />\r\n\r\n마찬가지로 재귀로 인해 연산 과정에서 `factorial(2)`를 호출하므로, 마찬가지로 연산을 중단하고 스택에 삽입한다.\r\n\r\n<br />\r\n<br />\r\n\r\n3. `factorial(2)`를 호출한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024025-f96e2b60-943b-4abc-8200-043ffbb63821.png\" width=\"200px\" />\r\n\r\n위와 동일하다.\r\n\r\n<br />\r\n<br />\r\n\r\n4. `factorial(1)`를 호출한다.\r\n\r\n`factorial(1)`는 기저 조건이므로 재귀가 호출되지 않는다. 1을 반환하고 연산을 종료한다. 하지만 스택에 데이터가 남아있으므로, 전체 연산이 종료되지 않았음을 알 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n5. `factorial(2)`를 종료한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024038-575615fd-5018-4c32-b205-a0fe3b0a34f2.png\" width=\"200px\" />\r\n\r\n`factorial(2)`의 연산 결과는 `factorial(1)`의 결과와 연관된다. `factorial(1)` 결과가 계산되었으므로, `factorial(2)`를 종료할 수 있다. 연산을 종료하고 스택에서 제거한다.\r\n\r\n<br />\r\n<br />\r\n\r\n6. `factorial(3)`을 종료한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024048-93fcb67e-c73e-4423-ab3f-415f2fa817d4.png\" width=\"200px\" />\r\n\r\n`factorial(3)`의 연산을 종료하고 스택에서 제거한다.\r\n\r\n<br />\r\n<br />\r\n\r\n7. `factorial(4)`을 종료한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024224-c83b0f90-388c-4264-8543-194c56cea310.png\" width=\"200px\" />\r\n\r\n`factorial(4)`의 연산을 종료하고 스택에서 제거한다. 스택에 데이터가 남아있지 않으므로 모든 연산이 종료된다.\r\n\r\n<br />\r\n<br />\r\n\r\n위와 같이 재귀는 스택을 활용하여 연산한다. 만약 기저 조건의 설정을 잘 못 해서 재귀 연산이 끝없이 일어날 수도 있다. 이 경우 스택 역시 끝없이 쌓이게 되서 메모리가 더 이상 감당할 수 없을 때 스택 오버플로우가 발생한다.\r\n\r\n## 9-5. 재귀 다뤄보기\r\n\r\n지금까지 다룬 팩토리얼 연산의 경우 사실 루프를 사용해도 그리 어렵지 않게 풀 수 있으며, 제시된 코드 역시 재귀를 사용했을 때 크게 이점이 있는 것도 아니였다.\r\n\r\n이번엔 좀 더 재귀를 사용했을 때 이점이 있을 법한 주제로 코드를 설계해보자. 재귀는 구조 상 알고리즘 내에서 자기 자신을 호출하는 알고리즘에 가장 적합하다. 즉, 재귀의 사용 여부는 루프의 보다 <span class=\"red-400\">나 자신을 다시 호출해야 하는지 여부</span>에 따라 갈린다.\r\n\r\n코드로 파일 리스트를 불러온 적이 있다면 익숙할 것이다. 우리가 생각하는 것처럼 특정 폴더 내의 파일 리스트 전체를 불러오는 것은 생각보다 까다롭다. 단순히 폴더 바로 밑의 파일 리스트만을 가져온다면 쉽겠지만, 그 하위, 하위의 하위 파일까지 가져오려면 그리 간단하지 않기 때문이다.\r\n\r\n현재 폴더 및 하위 폴더의 모든 폴더 리스트를 출력하는 코드를 작성해보자. 우선은 가장 간단하게, 하위 폴더는 신경쓰지 말고 현재 폴더에 존재하는 폴더 리스트만을 가져와보자.\r\n\r\n폴더 루트 경로는 `D:\\root`와 같으며, 구조는 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128032026-9ad5c07e-c274-45b2-8865-0164ddd8f618.png)\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.Objects;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 폴더 리스트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/08/04/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.03 Tue 22:55:59\r\n */\r\npublic class DirectoryList\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"폴더 리스트를 출력할 경로를 입력하세요 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString path = reader.readLine();\r\n\t\t\r\n\t\tString[] list = getList(path);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(list));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 폴더 리스트 반환 함수\r\n\t *\r\n\t * @param path: [String] 경로\r\n\t *\r\n\t * @return [String[]] 폴더 리스트\r\n\t */\r\n\tprivate static String[] getList(String path)\r\n\t{\r\n\t\treturn Arrays.stream(Objects.requireNonNull(new File(path).listFiles(File::isDirectory))).map(File::getName).toArray(String[]::new);\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nD:\\root\r\n```\r\n\r\n``` output\r\n[a, b, c]\r\n```\r\n\r\n현재 폴더의 직전 하위 폴더 리스트만을 출력한다. 한단계 하위 폴더 리스트를 출력하기 위해 코드를 개선해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 폴더 리스트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/08/04/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.03 Tue 23:32:46\r\n */\r\npublic class MoreDirectoryList\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"폴더 리스트를 출력할 경로를 입력하세요 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString path = reader.readLine();\r\n\t\t\r\n\t\tArrayList<String> list = getList(path);\r\n\t\t\r\n\t\twriter.write(String.valueOf(list));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 폴더 리스트 반환 함수\r\n\t *\r\n\t * @param path: [String] 경로\r\n\t *\r\n\t * @return [ArrayList<String>] 폴더 리스트\r\n\t */\r\n\tprivate static ArrayList<String> getList(String path)\r\n\t{\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\t\r\n\t\tFile[] files = new File(path).listFiles(File::isDirectory);\r\n\t\t\r\n\t\t// 파일 배열이 유효할 경우\r\n\t\tif (files != null)\r\n\t\t{\r\n\t\t\tfor (File file : files)\r\n\t\t\t{\r\n\t\t\t\tlist.add(file.getName());\r\n\t\t\t\t\r\n\t\t\t\tFile[] files1 = file.listFiles(File::isDirectory);\r\n\t\t\t\t\r\n\t\t\t\t// 파일 배열이 유효할 경우\r\n\t\t\t\tif (files1 != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (File file1 : files1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlist.add(file1.getName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list;\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nD:\\root\r\n```\r\n\r\n``` output\r\n[a, a1, a2, b, b1, b2, c, c1, c2]\r\n```\r\n\r\n각 폴더의 하위 폴더의 리스트까지 출력해준다. 소스를 봐도 폴더일 경우 동일한 소스가 한 번 더 동작된다. 하지만 이는 매우 제한적이다. 폴더의 깊이가 정해져있다면 이런 식으로 계속 동일한 소스를 반복하면 되겠지만, 이러한 케이스는 거의 존재하지 않아 무의미하다.\r\n\r\n이 경우 재귀를 사용하면 매우 손쉽게 모든 폴더의 하위 리스트를 출력할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 재귀 폴더 리스트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/08/04/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.03 Tue 23:36:43\r\n */\r\npublic class RecursiveDirectoryList\r\n{\r\n\tprivate static final ArrayList<String> LIST = new ArrayList<>();\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"폴더 리스트를 출력할 경로를 입력하세요 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString path = reader.readLine();\r\n\t\t\r\n\t\tgetList(path);\r\n\t\t\r\n\t\twriter.write(String.valueOf(LIST));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 폴더 리스트 산출 함수\r\n\t *\r\n\t * @param path: [String] 경로\r\n\t */\r\n\tprivate static void getList(String path)\r\n\t{\r\n\t\tFile[] files = new File(path).listFiles(File::isDirectory);\r\n\t\t\r\n\t\t// 파일 배열이 유효할 경우\r\n\t\tif (files != null)\r\n\t\t{\r\n\t\t\tfor (File file : files)\r\n\t\t\t{\r\n\t\t\t\tLIST.add(file.getName());\r\n\t\t\t\t\r\n\t\t\t\tgetList(file.getPath());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nD:\\root\r\n```\r\n\r\n``` output\r\n[a, a1, a2, b, b1, b11, b2, c, c1, c11, c12, c2]\r\n```\r\n\r\n재귀를 이용하여 하위 폴더의 전체 폴더명을 출력할 수 있다. 동일한 소스를 구태여 반복할 필요도 없고, 하위 깊이가 얼마나 되는지 알 필요 없이 폴더명 전체 리스트를 출력할 수 있다.\r\n\r\n탐색 순서는 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128036750-4094185e-3e77-4f24-94c7-dd8ccc9428ef.png)\r\n\r\n# 마무리\r\n\r\n이 장의 핵심 내용은 아래와 같다.\r\n\r\n* 재귀는 자기 자신을 호출하는 구조다.\r\n* 대부분의 루프는 재귀로 대체할 수 있다.\r\n* 알고리즘 구조 상 자기 자신을 호출해야할 때 가장 적합하다.\r\n\r\n백준 알고리즘을 풀었을 때도, 재귀를 사용해야하는 문제가 적지 않았을 정도로 재귀는 알고리즘에서 그 쓰임새가 매우 높다. 이번 장을 통해 재귀의 특성을 정리함으로써, 앞으로 알고리즘을 푸는데 많은 도움이 될 것 같다.","url":["2021-08-04-about-algorithm-chapter09","2021","08","04","about-algorithm-chapter09"]},{"header":{"title":"스택과 큐로 간결한 코드 생성","excerpt":"이 장에서는 스택과 큐에 대해 알아본다. 사실 이 두 자료구조는 배열에 특정한 제약을 건 자료구조다. 제약이라는 개념 때문에 특수한 상황에서만 쓰이지 않을까 싶지만, 오히려 이러한 제약이 주는 규칙으로 인해 굉장히 많은 곳에서 쓰인다. 스택과 큐의 가장 큰 특징은 데이터 처리에 순서가 있다는 점이다. 스택과 큐는 그 제약에 따라 반드시 정해진 순서로 데이터를 처리한다. 이러한 특징 덕에 순서가 필요한 작업들에 유용하게 사용된다. 대표적으로 스케쥴러, 대기 등이 있으며 OS의 인터럽트(Interrupt) 작업에서 스택이 쓰인다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-31T11:58:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","큐","스택"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-31-about-algorithm-chapter08.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 8장 스택과 큐로 간결한 코드 생성\r\n\r\n이 장에서는 <span class=\"amber-400\">스택</span>과 <span class=\"amber-400\">큐</span>에 대해 알아본다. 사실 이 두 자료구조는 배열에 특정한 제약을 건 자료구조다. <span class=\"red-400\">제약</span>이라는 개념 때문에 특수한 상황에서만 쓰이지 않을까 싶지만, 오히려 이러한 제약이 주는 규칙으로 인해 굉장히 많은 곳에서 쓰인다.\r\n\r\n스택과 큐의 가장 큰 특징은 <span class=\"green-400\">데이터 처리에 순서</span>가 있다는 점이다. 스택과 큐는 그 제약에 따라 반드시 정해진 순서로 데이터를 처리한다. 이러한 특징 덕에 순서가 필요한 작업들에 유용하게 사용된다. 대표적으로 스케쥴러, 대기 등이 있으며 OS의 인터럽트(Interrupt) 작업에서 스택이 쓰인다.\r\n\r\n## 8-1. 스택\r\n\r\n<span class=\"amber-400\">스택</span>이 데이터를 관리하는 방식은 배열의 그것과 매우 유사하다. 아까도 말했듯이, 스택과 큐엔 특정한 제약이 걸려있으며 그 중 스택의 제약은 아래와 같다.\r\n\r\n* 데이터는 반드시 스택의 입구에서만 삽입할 수 있다.\r\n* 스택의 가장 끝에 위치한 데이터만 읽을 수 있다.\r\n* 스택의 가장 끝에 위치한 데이터만 삭제할 수 있다.\r\n\r\n스택의 입구는 하나 뿐이며, 이 <span class=\"red-400\">입구에서 모든 연산</span>이 일어난다. 길쭉한 프링글스 통을 연상하면 이해하기 쉽다. 프링글스 칩을 꺼내먹기 위해선 반드시 정해진 입구에서만 꺼내서 먹을 수 있으며, 맨 위의 칩만 꺼낼 수 있다. 스택의 데이터와 연산을 이에 대입하면 매우 유사하다.\r\n\r\n스택의 입구. 즉, 끝을 위(top)이라 하며, 스택의 가장 밑을 아래(bottom)라 한다. 스택의 연산은 두 가지로 나뉜다.\r\n\r\n| 구분  |     내용      |\r\n| :---: | :-----------: |\r\n| PUSH  | 데이터를 삽입 |\r\n|  POP  | 데이터를 삭제 |\r\n\r\n스택의 푸시 연산을 도식화하면 아래와 같다.\r\n\r\n1. 스택에 2를 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523633-6a838ba9-339f-4443-bfd7-bea18c4d6558.png\" width=\"200px\" />\r\n\r\n2. 스택에 6을 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523640-caec6583-e44a-43f8-95d0-678f1aac1523.png\" width=\"200px\" />\r\n\r\n3. 스택에 9를 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523649-7046261f-d896-4c24-bd68-648a795c8b58.png\" width=\"200px\" />\r\n\r\n푸시는 항상 스택의 위에서 이루어진다는 점을 기억하자.\r\n\r\n스택의 팝 연산은 아래와 같다.\r\n\r\n1. 스택에 9를 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523655-40e026a8-5631-41c8-a300-03d0ce237242.png\" width=\"200px\" />\r\n\r\n2. 스택에 6을 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523665-e28389b1-27d0-4fb9-b29a-aa4c5278c253.png\" width=\"200px\" />\r\n\r\n이 과정 후엔 스택에 5만 남게된다. 스택은 항상 위에만 데이터를 삽입할 수 있으므로, 스택의 중간에 데이터를 삽입하려면 해당 위치까지 모든 데이터를 팝한 뒤 푸시해야한다.\r\n\r\n이렇게 먼저 들어온 게 가장 늦게 나가고. 반대로 가장 늦게 들어온 게 가장 빨리 나가는 걸 <span class=\"primary\">LIFO</span>(Last In, First Out)이라 한다.\r\n\r\n월요일의 출근길을 생각해보자. 최대한 늦게 들어가고 최대한 빨리 나오고 싶지 않은가?\r\n\r\n## 8-2. 스택 다뤄보기\r\n\r\n필자는 코드 규칙에 굉장히 민감한 편이다. 쓸데없이 예민해서, 내 방식대로 포맷팅이 되어있지 않은 소스는 리딩만으로도 스트레스를 받는다. 굳이 내 방식이 아니더라도 일관성있는 규칙이라면 그나마 나은데, 일관성도 없이 막 짠 코드를 보는 건 정말이지.... 가뜩이나 코드 리딩도 제대로 못 하는데 코드가 난잡하기까지 하면 당연히 답이 없을 것 같다.\r\n\r\n그래서 나는 ESLint를 굉장히 선호한다. TypeScript, HTML 등의 코드를 내가 정의한 규칙에 부합한지 알려주고, 틀리다면 수정까지 해준다. 나같이 코드 규칙에 예민한 사람에겐 필수품이나 다름없다.\r\n\r\n이렇게 코드를 정렬해주는 Lint는 언어별로 다른 규칙을 일일히 이해하고 틀린 부분을 잘 찾아야 하므로 딱 봐도 구현하기 매우 어려워 보인다. 이 문단에서는 스택을 활용하여 간단한 코드 Lint를 만들어본다.\r\n\r\n예를 들어, 아래와 같은 코드가 있다고 가정하자.\r\n\r\n``` javascript\r\n// 정상\r\nconst list1 = [ 1, 2, 3 ]\r\n\r\n// 오류1. 닫는 대괄호 없음\r\nconst list2 = [ 1, 2, 3\r\n\r\n// 오류2. 여는 대괄호 없음\r\nconst list3 = 1, 2, 3]\r\n\r\n// 오류3. 괄호 쌍이 맞지 않음\r\nconst list4 = (1, 2, 3]\r\n```\r\n\r\n모든 언어에서, 괄호는 항상 한 쌍으로 이루어진다. 따라서 `list1`을 제외한 나머지 코드에는 오류가 표시된다. 스택을 사용한다 해서 린트 구현이 쉬워지는 건 아니다. 온전한 동작을 하는 하나의 린트를 설계하는 것은 매우 어려우므로, 여기서는 <span class=\"green-400\">괄호</span>에 대해서만 생각한다.\r\n\r\n책에서 정의한 괄호 린트의 규칙은 아래와 같다.\r\n\r\n1. 괄호가 아닌 문자는 모두 무시한다.\r\n2. 여는 괄호가 나오면 스택에 푸시한다. 스택에 넣는다는 것은 해당 괄호가 닫히기를 기다린다는 의미이다.\r\n3. 닫는 괄호가 나오면 스택 위의 원소를 확인하고, 아래와 같이 분석한다.\r\n   * 스택에 원소가 없으면 이전에 여는 괄호가 나오지 않은 것으로, <span class=\"red-400\">오류 2</span>와 같다.\r\n   * 스택에 데이터가 있지만, 닫는 괄호가 스택 위에 있는 원소와 종류가 일치하지 않을 경우, <span class=\"red-400\">오류 3</span>과 같다.\r\n   * 닫는 괄호가 스택 위에 있는 원소와 괄호 종류가 같을 경우, 괄호가 성공적으로 닫혔으므로 정상적인 케이스다. 해당 괄호는 더 이상 기록할 필요가 없으므로 스택 위 원소를 POP한다.\r\n4. 줄 끝에 도달했는데, 스택에 여전히 원소가 남아있을 경우, 닫는 괄호가 없는 <span class=\"red-400\">오류 1</span>과 같다.\r\n\r\n정의한 규칙을 토대로 예제를 기술하면 아래와 같다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666476-c4e4a04d-bfc7-4a64-9861-554fab1c41d7.png\" width=\"400px\" />\r\n\r\n예제는 위 구문을 토대로 서술하며, 스택 역시 그림과 같다.\r\n\r\n1. 여는 소괄호를 스택에 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666490-27aa0e68-7d97-4285-9ab5-564b4ae3fa34.png\" width=\"400px\" />\r\n\r\n만약 닫는 괄호였다면 오류였을 것이다.\r\n\r\n2. 다음 괄호가 나올 때까지 포인터를 이동한다.\r\n\r\n`var`, `x` 등 괄호가 아닌 구문은 모두 무시한다. 이후부터는 2번 과정의 기술은 생략한다.\r\n\r\n3. 여는 중괄호를 스택에 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666497-84783779-d69a-49a2-941e-1c45fa3daafe.png\" width=\"400px\" />\r\n\r\n비록 스택 밑의 괄호와 종류는 다르지만, 둘 다 여는 괄호이므로 제대로 닫히기만 하면 오류는 아니다.\r\n\r\n4. 여는 대괄호를 스택에 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666504-41da2695-b18f-494c-bbc9-e63bd9199866.png\" width=\"400px\" />\r\n\r\n마찬가지로 스택에 푸시한다.\r\n\r\n5. 닫는 대괄호가 감지되었으므로, 스택의 맨 위 원소와 비교하여 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666509-840346c4-7b4a-4b33-ab01-cd0fc558b536.png\" width=\"400px\" />\r\n\r\n아래와 같을 경우 팝 연산이 가능하다.\r\n\r\n* 스택의 맨 위 괄호와 현재 포인터의 괄호 종류가 같다.\r\n* 스택의 맨 위 괄호는 반드시 여는 괄호다.\r\n\r\n이 경우 위 두 조건을 충족하므로, 여는 대괄호를 스택에서 팝하여 제거한다.\r\n\r\n6. 닫는 중괄호가 감지되었으므로, 스택의 맨 위 원소와 비교하여 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666517-95b68f96-48c9-4883-a1c5-765658a85bd2.png\" width=\"400px\" />\r\n\r\n여는 대괄호가 팝 연산으로 인해 스택에서 삭제되었으므로, 현재 스택의 가장 맨 위 요소는 여는 중괄호다. 조건을 충족하므로 마찬가지로 스택에서 팝하여 제거한다.\r\n\r\n7. 닫는 소괄호가 감지되었으므로, 스택의 맨 위 원소와 비교하여 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666523-8a33d330-933a-47fe-b3bc-e4bcbfde07d5.png\" width=\"400px\" />\r\n\r\n마찬가지로 조건을 충족하므로 요소를 팝한다.\r\n\r\n8. 코드 끝에 도달했으므로, 스택의 상태를 확인하여 오류 여부를 판단한다.\r\n\r\n코드의 모든 요소들을 확인했다. 만약 스택에 원소가 하나라도 남아있다면 해당 구문은 오류가 발생한 것이다.\r\n\r\n이 경우 스택에 원소가 하나도 없으므로 정상적인 구문으로 판단할 수 있다. 즉 위 구문에서 우리가 설계한 린트는 오류를 표시하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Stack;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 괄호 린트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/31/about-algorithm-chapter08/\">스택과 큐로 간결한 코드 생성</a>\r\n * @since 2021.07.30 Fri 23:30:56\r\n */\r\npublic class Linter\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString code = reader.readLine();\r\n\t\t\r\n\t\tchar c = lint(code);\r\n\t\t\r\n\t\t// 린트 결과가 정상일 경우\r\n\t\tif (c == '0')\r\n\t\t{\r\n\t\t\twriter.write(\"오류 없음\");\r\n\t\t}\r\n\t\t\r\n\t\t// 여는 괄호가 없을 경우\r\n\t\telse if (c == 'x')\r\n\t\t{\r\n\t\t\twriter.write(\"여는 괄호 존재하지 않음\");\r\n\t\t}\r\n\t\t\r\n\t\t// 닫는 괄호가 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(c);\r\n\t\t\twriter.write(\" 닫는 괄호 존재하지 않음\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 린트 결과 반환 함수\r\n\t *\r\n\t * @param text: [String] 구문\r\n\t *\r\n\t * @return [char] 린트 결과\r\n\t */\r\n\tprivate static char lint(String text)\r\n\t{\r\n\t\tStack<Character> stack = new Stack<>();\r\n\t\t\r\n\t\tfor (int i = 0; i < text.length(); i++)\r\n\t\t{\r\n\t\t\tchar c = text.charAt(i);\r\n\t\t\t\r\n\t\t\t// 여는 괄호일 경우\r\n\t\t\tif (isOpenBrace(c))\r\n\t\t\t{\r\n\t\t\t\tstack.push(c);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 닫는 괄호일 경우\r\n\t\t\telse if (isCloseBrace(c))\r\n\t\t\t{\r\n\t\t\t\t// 스택이 비어있을 경우\r\n\t\t\t\tif (stack.isEmpty())\r\n\t\t\t\t{\r\n\t\t\t\t\treturn 'x';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 스택이 비어있지 않을 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tchar co = stack.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 괄호가 서로 매칭되지 않을 경우\r\n\t\t\t\t\tif (!isMatched(co, c))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn co;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 스택이 비어이쓸 경우\r\n\t\tif (stack.isEmpty())\r\n\t\t{\r\n\t\t\treturn '0';\r\n\t\t}\r\n\t\t\r\n\t\t// 스택이 비어있지 않을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn stack.pop();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 여는 괄호 여부 반환 함수\r\n\t *\r\n\t * @param c: [char] 문자\r\n\t *\r\n\t * @return [boolean] 여는 괄호 여부\r\n\t */\r\n\tprivate static boolean isOpenBrace(char c)\r\n\t{\r\n\t\treturn c == '(' || c == '{' || c == '[';\r\n\t}\r\n\t\r\n\t/**\r\n\t * 닫는 괄호 여부 반환 함수\r\n\t *\r\n\t * @param c: [char] 문자\r\n\t *\r\n\t * @return [boolean] 여는 괄호 여부\r\n\t */\r\n\tprivate static boolean isCloseBrace(char c)\r\n\t{\r\n\t\treturn c == ')' || c == '}' || c == ']';\r\n\t}\r\n\t\r\n\t/**\r\n\t * 괄호 매칭 여부 반환 함수\r\n\t *\r\n\t * @param open: [char] 여는 괄호\r\n\t * @param close: [char] 닫는 괄호\r\n\t *\r\n\t * @return [boolean] 괄호 매칭 여부\r\n\t */\r\n\tprivate static boolean isMatched(char open, char close)\r\n\t{\r\n\t\t// 소괄호가 서로 매칭될 경우\r\n\t\tif (open == '(' && close == ')')\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 중괄호가 서로 매칭될 경우\r\n\t\telse if (open == '{' && close == '}')\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn open == '[' && close == ']';\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nconst a = (1 + 2 * 3;\r\n```\r\n\r\n``` output\r\n( 닫는 괄호 존재하지 않음\r\n```\r\n\r\n소스와 입출력은 위와 같다. 문자열을 하나하나 분석하여 여는 괄호가 있을 때까지 분석하여, 여는 괄호가 감지되면 스택에 푸시한다.\r\n\r\n분석 중에 닫는 괄호가 나오면, 스택을 팝하여 닫는 괄호와 종류가 일치하는지 비교한다. 만약 일치할 경우 계속 진행하며, 일치하지 않다면 관련 오류를 표시한다.\r\n\r\n``` java\r\nfor (int i = 0; i < text.length(); i++)\r\n{\r\n\tchar c = text.charAt(i);\r\n\t\r\n\t// 여는 괄호일 경우\r\n\tif (isOpenBrace(c))\r\n\t{\r\n\t\tstack.push(c);\r\n\t}\r\n\t\r\n\t// 닫는 괄호일 경우\r\n\telse if (isCloseBrace(c))\r\n\t{\r\n\t\t// 스택이 비어있을 경우\r\n\t\tif (stack.isEmpty())\r\n\t\t{\r\n\t\t\treturn 'x';\r\n\t\t}\r\n\t\t\r\n\t\t// 스택이 비어있지 않을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tchar co = stack.pop();\r\n\t\t\t\r\n\t\t\t// 괄호가 서로 매칭되지 않을 경우\r\n\t\t\tif (!isMatched(co, c))\r\n\t\t\t{\r\n\t\t\t\treturn co;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n해당 동작은 위 소스에서 제어한다. 또한 모든 동작 이후에도 스택에 원소가 남아있을 경우, 정상적으로 닫히지 않은 괄호가 있는 것이므로 역시 오류를 표시한다.\r\n\r\n``` java\r\n// 스택이 비어있을 경우\r\nif (stack.isEmpty())\r\n{\r\n\treturn '0';\r\n}\r\n\r\n// 스택이 비어있지 않을 경우\r\nelse\r\n{\r\n\treturn stack.pop();\r\n}\r\n```\r\n\r\n해당 동작은 모든 감지가 끝난 뒤, 위 소스에서 제어한다.\r\n\r\n이와 같이 스택은 가장 나중에 들어온 데이터를 먼저 처리해야할 경우에 굉장히 유용하다. 방금과 같은 린트나, 우리의 실수를 막아주는 `Ctrl + z` 등에 사용된다.\r\n\r\n## 8-3. 큐\r\n\r\n큐 역시 스택과 비슷하게 배열에 특정 규칙이 적용된 자료구조다. 큐의 제약사항은 아래와 같다.\r\n\r\n* 데이터는 큐의 끝에만 삽입할 수 있다. (스택과 동일)\r\n* 데이터는 큐의 앞에서만 읽을 수 있다. (스택과 반대)\r\n* 데이터는 큐의 앞에서만 삭제할 수 있다. (스택과 반대)\r\n\r\n스택과 골자는 비슷하나, 연산을 보면 살짝 다르다. 스택이 출입구가 하나로 통일된 형태라면, 큐는 출입구가 서로 나뉜 형태다. 스택은 프링글스 통을, 큐는 일반적인 파이프를 연상하면 쉽다. 단, 이 파이프는 한 쪽 방향으로만 흘러간다.\r\n\r\n스택과 달리 큐는 PUSH 같은 연산명이 따로 있진 않다. 큐의 연산을 도식화하면 아래와 같다.\r\n\r\n1. 큐에 8을 삽입한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694394-a849f2e6-591e-46f3-aef5-e94332f61df6.png\" width=\"400px\" />\r\n\r\n2. 큐에 93을 삽입한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694400-dfc6ccda-f609-4dcc-b9b0-4365fb21abf3.png\" width=\"400px\" />\r\n\r\n3. 큐에 51을 삽입한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694406-70a9119d-e29f-4ad9-9fa1-f3259c3b537f.png\" width=\"400px\" />\r\n\r\n여기까지는 스택의 PUSH 연산과 크게 다른 점이 없다.\r\n\r\n4. 큐의 8을 삭제한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694414-d59f5897-2f8c-481c-bd5f-e66c77875907.png\" width=\"400px\" />\r\n\r\n스택과 달리 큐는 데이터 입구의 반대편에서 데이터를 삭제할 수 있다.\r\n\r\n5. 큐의 93을 삭제한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694425-97870074-8a27-412f-945f-50c458f991d7.png\" width=\"400px\" />\r\n\r\n6. 큐의 51을 삭제한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694428-f3bb5a80-ec75-446a-b8f0-6d12b0d74abd.png\" width=\"400px\" />\r\n\r\n컨테이너 벨트처럼 순차적으로 처리하는 특징을 확인할 수 있다.\r\n\r\n## 8-4. 큐 다뤄보기\r\n\r\n스택과는 다른 방식으로 데이터를 순차적으로 처리하는 큐의 특성 덕분에 여러 곳에서 유용하게 쓰인다. 대기열이나 작업 예약 등 먼저 들어온 요소가 먼저 나가는 <span class=\"primary\">FIFO</span>(First In, First Out)으로 동작한다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.LinkedList;\r\nimport java.util.Objects;\r\nimport java.util.Queue;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 큐 프린터 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/31/about-algorithm-chapter08/\">스택과 큐로 간결한 코드 생성</a>\r\n * @since 2021.07.31 Sat 03:21:35\r\n */\r\npublic class Printer\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tQueue<String> queue = new LinkedList<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"출력할 문자열 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString work = reader.readLine();\r\n\t\t\t\r\n\t\t\t// 입력을 종료할 경우\r\n\t\t\tif (work.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 작업할 입력이 들어올 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tqueue.offer(work);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\twriter.write(\"[INFO] \");\r\n\t\t\twriter.write(Objects.requireNonNull(queue.poll()));\r\n\t\t\twriter.newLine();\r\n\t\t\twriter.flush();\r\n\t\t}\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nFirst Document\r\nSecond Document\r\nThird Document\r\nFourth Document\r\nFifth Document\r\nx\r\n```\r\n\r\n``` output\r\n[INFO] First Document\r\n[INFO] Second Document\r\n[INFO] Third Document\r\n[INFO] Fourth Document\r\n[INFO] Fifth Document\r\n```\r\n\r\n얼핏 보면 그냥 입력받은 순서대로 바로 콘솔에 뿌려주는 것 처럼 보이지만, 이는 소스가 간단하기 때문에 일어나는 착각이다.\r\n\r\n실제로 복잡한 작업을 하다보면, 조건에 따라 작업을 저장했다가 후에 순차적으로 후처리를 해야하는 등의 작업이 필요하다. 이런 경우에 큐의 특징은 매우 유용하다. \r\n\r\n우리가 흔히 아는 배열에 담아도 되지 않냐 반문할 수 있지만, 수시로 작업이 추가/삭제될 경우 배열은 그 인덱스를 신경써주어야한다. 반면 큐의 경우 작업의 IO에 있어서 정해진 규약이 있기 때문에 인덱스에 구애받지 않고 추가하고 삭제하면 된다.\r\n\r\n# 마무리\r\n\r\n이 장의 핵심은 아래와 같이 정리할 수 있다.\r\n\r\n* 스택은 후입선출(LIFO) 방식이다.\r\n* 스택은 원소의 추가/삭제 모두 스택의 위(TOP)에서 발생한다.\r\n* 스택 중간에 원소를 삽입하려면, 해당 위치에 도달할 때까지 모든 원소를 삭제해야한다.\r\n* 큐는 선입선출(FIFO) 방식이다.\r\n* 큐는 원소의 추가가 한 쪽, 삭제가 다른 쪽에서 각각 따로 발생한다.\r\n\r\n스택과 큐의 개념 자체는 어렵지 않았지만, JAVA에서 이를 다루는 것은 익숙치 않았었다. 이 장을 정리하면서 스택과 큐의 특성은 물론, JAVA에서 이를 어떻게 다루는 지도 알 수 있었다.\r\n\r\n다음 장에서는 반복적인 연산을 단축하는데 매우 효과적인 재귀에 대해 다룰 예정이다.","url":["2021-07-31-about-algorithm-chapter08","2021","07","31","about-algorithm-chapter08"]},{"header":{"title":"해시 테이블로 매우 빠른 룩업","excerpt":"현재까지 다룬 데이터 형식 중 다수의 데이터를 다루는 데 가장 효과적인 형식은 배열일 것이다. 하지만 배열의 경우, 요소별로 단 하나의 값이 들어가는 데 특화되어 있다. 만약 하나의 요소에 두 값을 넣고자 한다면 어떻게 될까? [[A, 1], [B, 2], [C, 3]]과 같은 형태로 나타낼 것이다. 배열의 단점 중 하나는, 값을 빠르게 찾기 위해선 반드시 정렬을 수행해야 한다는 것이다. 하지만 저렇게 배열 안에 또다른 배열이 포함되는 것처럼 배열의 depth가 심해질 경우 구조가 복잡해서 배열을 다루기 점점 난해해진다. 더군다나 배열의 경우 원하는 요소를 탐색하기 위해선 적어도 O(logN) 이상의 시간복잡도를 필요로 한다. 만약, 배열과 같이 특정 데이터의 모음에서 내가 원하는 데이터를 O(1)과 같이 상수 시간으로 탐색할 수 있는 데이터가 있다면 어떨까? 왠지 이 장에서 그 해답을 찾을 수 있을 것 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-29T23:02:27","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","해시 테이블"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-29-about-algorithm-chapter07.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 7장 해시 테이블로 매우 빠른 룩업\r\n\r\n현재까지 다룬 데이터 형식 중 다수의 데이터를 다루는 데 가장 효과적인 형식은 <span class=\"primary\">배열</span>일 것이다. 하지만 배열의 경우, 요소별로 단 하나의 값이 들어가는 데 특화되어 있다. 만약 하나의 요소에 두 값을 넣고자 한다면 어떻게 될까? $[ [ \"A\", 1 ], [ \"B\", 2 ], [ \"C\", 3 ] ]$과 같은 형태로 나타낼 것이다.\r\n\r\n배열의 단점 중 하나는, 값을 빠르게 찾기 위해선 반드시 정렬을 수행해야 한다는 것이다. 하지만 저렇게 배열 안에 또다른 배열이 포함되는 것처럼 배열의 depth가 심해질 경우 구조가 복잡해서 배열을 다루기 점점 난해해진다.\r\n\r\n더군다나 배열의 경우 원하는 요소를 탐색하기 위해선 적어도 $O(\\log N)$ 이상의 시간복잡도를 필요로 한다. 만약, 배열과 같이 특정 데이터의 모음에서 내가 원하는 데이터를 $O(1)$과 같이 상수 시간으로 탐색할 수 있는 데이터가 있다면 어떨까? 왠지 이 장에서 그 해답을 찾을 수 있을 것 같다.\r\n\r\n## 7-1. 해시 테이블 소개\r\n\r\n<span class=\"orange-A400\">JAVA</span>를 포함한 대부분의 프로그래밍 언어에선 <span class=\"teal-400\">Hash Table</span>(해시 테이블)이란 개념이 존재한다. 언어에 따라 부르는 용어는 해시나 맵, 해시 맵 등으로 불리지만 궁극적인 개념은 해시 테이블이다.\r\n\r\n``` java\r\nHashMap<String, String> map = new HashMap<>();\r\nmap.put(\"A\", \"1\");\r\nmap.put(\"B\", \"2\");\r\nmap.put(\"C\", \"3\");\r\nmap.put(\"D\", \"4\");\r\n```\r\n\r\n자바는 이를 `HashMap` 클래스로 관리한다. <span class=\"yellow-700\">JavaScript</span>와 다르게 미리 선언된 데이터 형식만 입력 가능하다는 특징이 있다. `A: 1`, `B: 2`와 같이 하나의 쌍으로 이루어진 데이터를 흔히 <span class=\"blue-400\">key-value</span> 데이터라고 한다. 해시 테이블은 이러한 key-value 데이터를 관리하는데 매우 효과적이다.\r\n\r\n``` java\r\nHashMap<String, String> map = new HashMap<>();\r\nmap.put(\"A\", \"1\");\r\nmap.put(\"B\", \"2\");\r\nmap.put(\"C\", \"3\");\r\nmap.put(\"D\", \"4\");\r\n\r\nSystem.out.println(map.get(\"A\"));\r\n```\r\n\r\nHashMap의 데이터에 접근하기 위해선 위처럼 원하는 value의 key를 입력하여 접근할 수 있다. 그런데 재밌는 점은, 해시 테이블의 경우 이렇게 탐색하는 데 필요한 작업량이 1이다. 즉, $O(1)$의 시간 복잡도를 가진다. 우리가 배열에서 갖가지 정렬을 배워가면서 탐색 속도를 향상시키기 위해 노력했는데, 이 친구는 뭐길래 이런 작업량이 가능한걸까?\r\n\r\n## 7-2. 해시 함수로 해싱\r\n\r\n<span class=\"primary\">해싱</span>이라는 개념에 대해 들어본 적이 있는가? 데이터를 고유한 값으로 반환하는 것을 해싱이라고 한다. 간단한 예를 들자면, 아래와 같이 매칭되는 표가 있다고 가정하자.\r\n\r\n|    키    |    값    |\r\n| :------: | :------: |\r\n|    A     |    1     |\r\n|    B     |    2     |\r\n|    C     |    3     |\r\n| $\\dotsb$ | $\\dotsb$ |\r\n|    Y     |    25    |\r\n|    Z     |    26    |\r\n\r\n위 표에 의거하면, `ABC = 123`, `EAD = 514`와 같이 변환될 것이다. 매우 허술하지만, 이러한 변환도 일종의 해싱이라고 할 수 있다. 위 표와 같이 변환해주는 알고리즘을 <span class=\"primary\">해시 함수</span>라 부른다.\r\n\r\n만약, 우리가 사용하려는 해시 함수가 A-Z의 키를 위 표에 매칭되는 숫자로 변경하고, 이를 다 더하는 알고리즘이라고 가정해보자. `FAD`를 변환하면 아래의 순서로 변환이 진행된다.\r\n\r\n1. 해시 함수에 의해 FAD가 614로 변환된다.\r\n2. 각 숫자를 더하여 6 + 1 + 4를 연산한다.\r\n3. 11이라는 해시값을 얻는다.\r\n\r\n이렇게 `FAD = 11`이라는 해싱을 얻을 수 있다. 해싱에는 아래와 같은 조건이 중요하다.\r\n\r\n* 정해진 값을 해싱하면 항상 동일한 결과를 반환한다. (FAD는 언제나 11을 반환해야 함)\r\n* 서로 다른 값이 동일한 해시값을 가질 수 없다.\r\n\r\n> 🔒 **해시 함수**  \r\n> 위의 예제와 달리, 해싱 함수는 대부분 복호화가 불가능한 비대칭 암호화 방식을 취한다. 또한 보안을 위해 Salt라는 임의의 난수를 포함하여 해싱함으로써, Brute Force를 방지하기도 한다.  \r\n> 이러한 특성으로 해싱은 사용자 이외에 그 누구도 알아서는 안 되는 비밀번호, 개인정보 등을 암호화하는데 쓰이며, 그 종류는 MD5, SHA-1, SHA-256, SHA-512 등이 있다.\r\n\r\n하지만 예제의 해싱 함수는 단순 이해를 돕기 위한 예시로, 실제 해싱과는 맞지 않다. 위 해시 함수에 의하면 `FAD`와 `ADF`, `DAF` 모두 동일한 값 11을 가진다. 이는 해시의 요건 중 하나인 <span class=\"red-500\">서로 다른 값이 동일한 해시값을 가질 수 없다</span>는 조건을 정면으로 위반한다.\r\n\r\n이러한 문제점에 대한 얘기는 후에 다룬다.\r\n\r\n## 7-3. 재미와 이익, 특히 이익을 남길 유의어 사전 만들기\r\n\r\n책에서 표현한 대로, 특정 단어를 입력하면 가장 핫한 유의어를 반환해주는 키치한 사전을 만든다고 가정해보자.\r\n\r\n해시는 이전 문단에서 사용한 표를 기준으로 하며, 변환된 숫자를 각각 곱한 값이 해싱 결과가 된다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   |       |\r\n|   7   |       |\r\n|   8   |       |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   |       |\r\n|  16   |       |\r\n\r\n이 때 내부적으로 동작하는 해시 테이블을 도식화하면 위와 같을 것이다. `bad: evil`이라는 key-value가 있을 경우, 해시 함수에 의해 아래와 같이 변환된다.\r\n\r\n1. `bad: evil`의 키 `bad`를 변환한다.\r\n2. 변환값 214를 얻는다.\r\n3. 각 숫자를 곱하여 해시값 $2 \\times 1 \\times 4 = 8$을 얻는다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   |       |\r\n|   7   |       |\r\n|   8   | evil  |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   |       |\r\n|  16   |       |\r\n\r\n위와 같이 8에 evil 데이터가 삽입된다. 추가로 `cab: taxi`를 해싱해보자. 해시값이 6이다, 또한 `ace: star`의 경우 해시값이 15다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   | taxi  |\r\n|   7   |       |\r\n|   8   | evil  |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   | star  |\r\n|  16   |       |\r\n\r\n해시 테이블의 현황은 위와 같을 것이다. 여기서 만약 이전에 저장된 값을 호출하려면 어떻게 될까?\r\n\r\n사용했던 키 중 하나dls `cab`의 데이터를 호출해보자. 해싱 알고리즘에 의해 6으로 변환된다.\r\n\r\n해시값을 구했으므로, 인덱스 6의 요소 `taxi`에 접근하면 된다. 별다른 탐색 없이도 간단하게 원하는 값에 접근한 것이다.\r\n\r\n이러한 방식으로 해시 테이블은 $O(1)$의 시간복잡도를 가진다.\r\n\r\n## 7-4. 충돌 해결\r\n\r\n이전에 잠깐 언급했던 해시의 요건이 있다.\r\n\r\n* 서로 다른 값이 동일한 해시값을 가질 수 없다.\r\n\r\n이전 문단의 해시 테이블에 `dab: pat`을 추가한다고 생각해보자. `dab`의 해시값은 8이다. 이제 테이블에 넣어주기만 하면 되는데, 문제가 있다.\r\n\r\n|  키   |                  값                   |\r\n| :---: | :-----------------------------------: |\r\n|   8   | evil <span class=\"red-400\">pat</span> |\r\n\r\n이미 8번 인덱스에 evil이 들어가있다. 이렇게 서로 다른 값의 해시값이 동일한 현상을 <span class=\"primary\">충돌</span>이라고 한다.\r\n\r\n가장 전통적이고 간단하 방법은, 동일한 위치에 값이 할당될 경우, 배열과 같이 이중 구조를 추가하는 것이다.\r\n\r\n|  키   |        값         |\r\n| :---: | :---------------: |\r\n|   8   | [ \"evil\", \"pat\" ] |\r\n\r\n즉, 위와 같이 배치하면 된다. 그렇다면 이 경우 검색은 어떻게 진행될까? 키가 `dab`인 테이터를 탐색해보자.\r\n\r\n1. `dab`의 해시값 8을 구한다.\r\n2. 8번 인덱스에 충돌로 인해 배열이 있음을 확인한다.\r\n3. 각 배열의 key를 확인하여 일치 여부를 반한다.\r\n\r\n이 경우 검색은 잘 될지 모르나, $O(N)$이라는 시간 복잡도를 가진다. $O(1)$의 시간 복잡도를 가질 정도로 빠른 데이터 형식이 순식간에 일반적인 배열와 동급이 되어버렸다. 아무리 봐도 좋은 현상은 아니다.\r\n\r\n결론적으론 해싱은 최대한 충돌이 일어나지 않도록 설계해야한다.\r\n\r\n## 7-5. 훌륭한 충돌 조정\r\n\r\n책에서는 해시 테이블의 효율성은 아래의 세 가지 요인에 좌우된다고 설명한다.\r\n\r\n* 해시 테이블에 얼마나 많은 데이터를 저장하는가\r\n* 해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가\r\n* 어떤 해시 함수를 사용하는가\r\n\r\n이전에 사용한 표의 매칭을 기준으로, 이번엔 변환된 각각의 숫자를 1의 자리가 될 때까지 더하는 함수를 사용한다고 가정하자.\r\n\r\n`put`의 경우 16 + 21 + 20 = 57의 변환값을 가지며, 다시 이 57을 각각 더하 5 + 7 = 12, 1 + 2 = 3으로 최종적으로 `put = 3`이 된다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   |       |\r\n|   7   |       |\r\n|   8   |       |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   |       |\r\n|  16   |       |\r\n\r\n위와 같은 해시 테이블이 있다고 가정하자. 16개의 할당 가능한 공간이 있지만, 해시 함수의 특성 상 언제나 1 ~ 9 사이의 해시값을 가지므로 10 ~ 16은 언제나 비어있다.\r\n\r\n즉, 해싱 테이블의 크기는 최소한 예상되는 해시값의 범위만큼 가지고 있어야한다. 만약 해시 범위가 1 ~ 10인데, 해시 테이블의 크기는 100이라고 한다면 충돌이 일어날 가능성은 매우 적겠지만 메모리 낭비가 너무 심하다.\r\n\r\n즉, <span class=\"red-400\">너무 많은 메모리를 낭비하지 않으면서 해시값을 전부 수용</span>할 수 있도록 적절히 충돌 조정을 수행해야한다.\r\n\r\n연구에 의하면 데이터가 7개일 때, 10개의 테이블 행이 있는 것이 이상적이다. 이를 <span class=\"primary\">부하율</span>이라고 하며, 부하율이 70%일 때가 최적이다. 다행히도 해시 테이블의 세부적인 사항은 컴파일러 단계에서 관리하니, 디테일한 튜닝을 하지 않는 이상 개발자가 신경쓸 부분은 없다.\r\n\r\n## 7-6. 실제 예제\r\n\r\n해시의 특성 덕분에 해시 테이블은 많은 곳에서 많은 용도로 사용되지만, 이 책에서는 해시 테이블을 통해 알고리즘의 속도를 높이는 데 초점을 맞추었다.\r\n\r\n1장에서 모든 요소가 중복되지 않는 <span class=\"primary\">집합</span>에 대해 다뤘다. 집합 알고리즘을 배열로 구성하면 탐색과 삽입 작업이 필요하며, 이 작업은 $O(N)$의 시간 복잡도를 가진다.\r\n\r\n모든 요소가 중복되지 않는 고유한 값을 가지는 집합의 특성은 여러 곳에서 굉장히 유용하게 쓸 수 있지만, $O(N)$이라는 선형적 시간 복잡도가 걸린다. 만약 여기서 탐색의 시간 복잡도가 $O(1)$을 가지는 해시 테이블을 적용한다면 어떨까?\r\n\r\n| 작업  |  집합  | 해시 테이블 |\r\n| :---: | :----: | :---------: |\r\n| 탐색  | $O(N)$ |   $O(1)$    |\r\n| 삽입  | $O(1)$ |   $O(1)$    |\r\n| 총합  | $O(N)$ |   $O(1)$    |\r\n\r\n위와 같이 작업량을 획기적으로 줄일 수 있을 것이다. 우리는 이미 4장에서 배열의 중복 요소를 체크하는 로직을 작성한 바 있다. 처음 설계한 알고리즘의 시간 복잡도는 $O(N^2)$였지만, 이후 개선을 통해 $O(N)$으로 단축할 수 있었다.\r\n\r\n``` java\r\n/**\r\n * 요소의 중복 여부 반환 함수\r\n *\r\n * @param array: [int[]] 배열\r\n *\r\n * @return [boolean] 중복 여부\r\n */\r\nprivate static boolean isDuplicated(int[] array)\r\n{\r\n\tfor (int i = 0; i < array.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < array.length; j++)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\tif (i != j && array[i] == array[j])\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n위 소스는 4장에서 다룬 중복 요소 체크 알고리즘 중 $O(N^2)$를 가지는 알고리즘이다. \r\n\r\n``` java\r\n/**\r\n * 요소의 중복 여부 반환 함수\r\n *\r\n * @param array: [int[]] 배열\r\n *\r\n * @return [boolean] 중복 여부\r\n */\r\nprivate static boolean isDuplicated(int[] array)\r\n{\r\n\tArrayList<Integer> list = new ArrayList<>();\r\n\t\r\n\tfor (int item : array)\r\n\t{\r\n\t\tcount++;\r\n\t\t\r\n\t\t// 중복되지 않았을 경우\r\n\t\tif (!list.contains(item))\r\n\t\t{\r\n\t\t\tlist.add(item);\r\n\t\t}\r\n\t\t\r\n\t\t// 중복된 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n위 소스는 4장에서 다룬 중복 요소 체크 알고리즘 중 $O(N)$을 가지는 알고리즘이다. 이러한 종류의 알고리즘을 해시 테이블을 활용하여 $O(1)$의 시간 복잡도를 가지게끔 줄여보자.\r\n\r\n책에서 제시한 주제대로, 투표자가 후보자 목록 중 하나를 고르거나, 임의의 후보를 추가할 수 있는 전자 투표 기계를 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 전자 투표 기계 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/29/about-algorithm-chapter07/\">해시 테이블로 매우 빠른 룩업</a>\r\n * @since 2021.07.29 Thu 22:15:32\r\n */\r\npublic class Vote\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString name = reader.readLine().trim();\r\n\t\t\t\r\n\t\t\t// x가 입력되었을 경우\r\n\t\t\tif (name.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 빈 문자가 입력되었을 경우\r\n\t\t\telse if (name.equals(\"\") || name.isEmpty())\r\n\t\t\t{\r\n\t\t\t\twriter.newLine();\r\n\t\t\t\twriter.write(\"올바른 이름을 입력하세요.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 일반적인 이름이 입력되었을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlist.add(name);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(list.toString());\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nJay\r\nPark\r\nKim\r\nPark\r\nKim\r\nJay\r\nJay\r\nJay\r\nPark\r\nKim\r\nx\r\n```\r\n\r\n``` output\r\n[Jay, Park, Kim, Park, Kim, Jay, Jay, Jay, Park, Kim]\r\n```\r\n\r\n소스와 입력, 출력은 위와 같다. 단순히 입력을 받아서 중복 여부 상관없이 배열에 이어 붙이므로, 시간 복잡도는 삽입 과정 하나만 있으며 $O(1)$이다.\r\n\r\n빠르기야 하다만, 후보자가 많거나, 투표자가 많아지면 정리하기 매우 힘들다. 전자는 분류할 케이스가 많아지고, 후자는 분류할 데이터가 많아지기 때문\r\n\r\n해시 테이블을 활용하여 후보의 이름과 후보의 투표수를 서로 매칭해서 심플하게 보여주면 어떨까?\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 해시 테이블을 적용한 전자 투표 기계 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/29/about-algorithm-chapter07/\">해시 테이블로 매우 빠른 룩업</a>\r\n * @since 2021.07.29 Thu 22:27:23\r\n */\r\npublic class HashVote\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString name = reader.readLine().trim();\r\n\t\t\t\r\n\t\t\t// x가 입력되었을 경우\r\n\t\t\tif (name.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 빈 문자가 입력되었을 경우\r\n\t\t\telse if (name.equals(\"\") || name.isEmpty())\r\n\t\t\t{\r\n\t\t\t\twriter.newLine();\r\n\t\t\t\twriter.write(\"올바른 이름을 입력하세요.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 일반적인 이름이 입력되었을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlist.add(name);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor (String name : list)\r\n\t\t{\r\n\t\t\t// 이미 등록된 이름일 경우\r\n\t\t\tif (map.containsKey(name))\r\n\t\t\t{\r\n\t\t\t\tmap.put(name, map.get(name) + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 등록되지 않은 이름일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmap.put(name, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(map.toString());\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nJay\r\nPark\r\nKim\r\nPark\r\nKim\r\nJay\r\nJay\r\nJay\r\nPark\r\nKim\r\nx\r\n```\r\n\r\n``` output\r\n{Jay=4, Kim=3, Park=3}\r\n```\r\n\r\n소스와 입출력은 위와 같다. Jay가 4표, 나머지가 3표를 받았다. 깔끔하게 잘 동작하지만, 투표가 끝난 뒤 일괄적으로 표를 계산하므로, 탐색 $O(N)$ 작업이 추가되어 시간 복잡도가 상수에서 선형으로 늘어나게 됐다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 해시 테이블을 적용한 향상된 전자 투표 기계 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/29/about-algorithm-chapter07/\">해시 테이블로 매우 빠른 룩업</a>\r\n * @since 2021.07.29 Thu 22:31:45\r\n */\r\npublic class ImproveHashVote\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString name = reader.readLine().trim();\r\n\t\t\t\r\n\t\t\t// x가 입력되었을 경우\r\n\t\t\tif (name.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 빈 문자가 입력되었을 경우\r\n\t\t\telse if (name.equals(\"\") || name.isEmpty())\r\n\t\t\t{\r\n\t\t\t\twriter.newLine();\r\n\t\t\t\twriter.write(\"올바른 이름을 입력하세요.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 일반적인 이름이 입력되었을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 이미 등록된 이름일 경우\r\n\t\t\t\tif (map.containsKey(name))\r\n\t\t\t\t{\r\n\t\t\t\t\tmap.put(name, map.get(name) + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 등록되지 않은 이름일 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmap.put(name, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(map.toString());\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nJay\r\nPark\r\nKim\r\nPark\r\nKim\r\nJay\r\nJay\r\nJay\r\nPark\r\nKim\r\nx\r\n```\r\n\r\n``` output\r\n{Jay=4, Kim=3, Park=3}\r\n```\r\n\r\n표 수를 계산하는 과정을 마지막이 아닌, 투표를 할 때마다 실시간으로 카운팅한다. 기본적인 원리나 결과가 같지만, 그 속도가 다르다.\r\n\r\n이미 등록되었는지 아닌지에 따라 탐색 + 삽입 혹은 단순히 삽입으로 나누어지지만, 탐색 또한 $O(1)$의 시간 복잡도를 가지므로 최종적으로는 $O(1)$로 표현할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서 핵심 내용은 아래와 같다.\r\n\r\n* 해시 테이블은 key-value 형태의 값을 저장한다.\r\n* 해시 테이블은 key를 임의의 함수로 해싱하여 관리한다.\r\n* 해시 테이블의 탐색 시간 복잡도는 $O(1)$이다.\r\n* 해시 함수는 충돌이 적어야 한다.\r\n\r\nkey-value로 데이터를 저장하는 특성, 빠른 탐색 속도는 여러 알고리즘에서 유용하게 쓰일 것이다. 다음 장에서는 이와 더불어 매우 클래식한 자료구조인 <span class=\"amber-500\">스택</span>(Stack)과 <span class=\"amber-500\">큐</span>(Queue)에 대해 다뤄본다.","url":["2021-07-29-about-algorithm-chapter07","2021","07","29","about-algorithm-chapter07"]},{"header":{"title":"블로그 개편기","excerpt":"이 블로그를 처음 개발한지가 한 5월 쯤으로 기억한다. 4월부터 접한 리액트에 흥미가 생겨 두서없이 만든게 시작이였으니, 결과물은 내 생각보다 훨씬 조잡하지 않았나 생각했다. 다행스럽게(?)도 블로그 또한 그런 내 믿음을 져버리기 싫었는지, 동작 과정에서 크고 작은 문제들을 보여주곤 했다. 동작 자체에 영향을 미칠 정도로 크리티컬한 문제는 아니였다만, 내 신경엔 영향을 미칠 정도로 거슬리는 부분이 몇 가지 있었다. 아무도 관심 없지만 이왕 만든거 이번 포스팅을 통해 블로그의 개선점을 정리해놓고자 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/127343484-697c4678-edf3-49fa-8a4d-86775a804428.png","date":"2021-07-26T04:54:40","type":"posts","category":"React","tag":["React(리액트)","Next.js","개발 블로그","TypeScript","SCSS"],"comment":true,"publish":true},"name":"2021-07-26-brand-new.md","content":"\r\n# 리모델링\r\n\r\n이 블로그를 처음 개발한지가 한 5월 쯤으로 기억한다. 4월부터 접한 리액트에 흥미가 생겨 두서없이 만든게 시작이였으니, 결과물은 내 생각보다 훨씬 조잡하지 않았나 생각했다.\r\n\r\n다행스럽게(?)도 블로그 또한 그런 내 믿음을 져버리기 싫었는지, 동작 과정에서 크고 작은 문제들을 보여주곤 했다.\r\n\r\n동작 자체에 영향을 미칠 정도로 크리티컬한 문제는 아니였다만, 내 신경엔 영향을 미칠 정도로 거슬리는 부분이 몇 가지 있었다. 아무도 관심 없지만 이왕 만든거 이번 포스팅을 통해 블로그의 개선점을 정리해놓고자 한다.\r\n\r\n# 문제점\r\n\r\n크고작은 여러 문제점들이 있었는데, 목록은 아래와 같다.\r\n\r\n## 1. 렌더링 지연 현상\r\n\r\n여러 문제들 중 가장 가시적이고 불편한 문제였다. 어떠한 이유에서인지 이상하리만치 렌더링이 늦었다. 처음으로 페이지에 접근할 경우 렌더링하느라 버벅이는게 보일 정도. 사양에 따라서 CSS가 입혀지기 전인 날 것의 HTML 프레임이 그대로 보이기도 했다.\r\n\r\n이 괴상한 렌더링 지연은 React의 고질적인 블랙박스 문제로 디버깅조차 잘 되지 않았다.\r\n\r\n> **블랙... 뭔 박스요?**  \r\n> 소스코드가 동작할 때, 어떤 특정한 모듈을 통해 동작하는 경우가 빈번하다. 잘 구성된 모듈은 은닉화, 모듈화가 잘 되어 있는 경우가 대부분이다. 하지만 이러한 모듈의 폐쇄성은 해당 모듈의 사용자로 하여금 모듈 내부의 오류로 인해 발생하는 이슈를 디버깅하기 매우 어렵게 만든다.  \r\n> 이러한 모듈의 은닉된 영역을 가리켜 **블랙박스**라 칭한다.\r\n\r\n간혹 어떤 페이지는 렌더링이 두 번씩 되기도 했다. 설상가상으로 React의 다중 렌더링 문제는 꽤 고질적이라고 한다.\r\n\r\n## 2. Unified.js과 관련 플러그인 커스터마이징 문제\r\n\r\n해당 블로그는 JAMStack 기반 블로그다. 통상 JAMStack 기반 블로그의 경우 게시글을 Markdown으로 관리한다. 하지만 아쉽게도 웹 페이지는 HTML 기반으로 동작한다. 즉, Markdown에서 HTML로 적절히 변환해줄 로직이 필요하다.\r\n\r\n> **JAMStack**  \r\n> **J**avaScript  \r\n> **A**PI  \r\n> **M**arkup\r\n\r\n단순히 변환만 해준다고 다가 아니다. 코드 하이라이팅을 위한 Prism.js, 수식 작성을 위한 LaTex 등 여러 플러그인을 적용해야한다.\r\n\r\n하지만 Unified.js는 내 바램과 달리 공식 문서가 그리 친절하지도 않았으며, 커스터마이징을 위한 API 또한 찾아보기 힘들었다. 그 말인즉슨 `remark-prism`, `remark-toc`와 같은 플러그인에 의존해야 하는데, 정해진 형태로 변환만 해줄 뿐, 내가 끼어들어 커스터마이징할 여지는 없어보였다.\r\n\r\n## 3. CSS-in-JS 방식\r\n\r\n이 블로그의 CSS는 [Material-UI](https://material-ui.com/)를 적극적으로 사용했다. Material-UI는 CSS를 적용할 때, `makeStyles`와 같은 메소드를 통해 JavaScript 내부에서 스타일링을 하도록 안내하고 있다.\r\n\r\nReact를 독학으로 배운데다가, 그 체계에 익숙하지 않아 그 당시만 해도 이렇게 해야만하는 줄 알았다.\r\n\r\n## 4. 부실한 RESTful URL\r\n\r\nNextJS는 Dynamic Routing을 지원한다. 파일 이름을 `[page].js`와 같이 생성하고 `getStaticPaths` 메소드에서 page 변수에 적절한 값을 할당하면 해당 값을 가진 URL을 생성해준다.\r\n\r\nGitHub에 호스팅하기 위해선 좋든 싫든 CSR 정적 방식을 차용할 수 밖에 없다. 때문에 내가 잘 하던 기존의 query 방식을 차용했었다.\r\n\r\n게시글 2 페이지를 나타내는 URL이 `/posts?page=2`와 같은 방식이였다. 현재 트렌드로 미루어보아, 그리 좋은 방식은 아니지 싶다.\r\n\r\n# 개선점\r\n\r\n자잘한 문제들은 제외하고, 굵직한 것들만 생각나는대로 적으면 저 정도 나오는 것 같다.\r\n\r\n블로그가 개발된 5월 이래로 개편을 시작한 7월 중순까지 그래도 나름 내적인 성장을 했던 건지, 이전보단 훨씬 나은 방향으로 개선할 수 있었다.\r\n\r\n개선 내용은 아래와 같다.\r\n\r\n## 1. TypeScript 적용\r\n\r\nJavaScript의 가장 큰 장점이자 단점은 변수 타입의 모호성이다. 첫 언어를 C#, JAVA와 같이 경직된 객체지향 언어로 접한 내겐 거슬리는 부분 중 하나였다.\r\n\r\n![TypsScript](https://user-images.githubusercontent.com/50317129/127337733-e43081ab-71f8-4906-89b2-b33cd7b4320e.png)\r\n\r\n<span class=\"blue-400\">TypeScript</span>는 JavaScript에 변수 타입이라는 개념을 도입함으로써, 변수의 모호함에서 유발되는 오류를 최소화한다.\r\n\r\nNext.js는 TypeScript 기반의 템플릿을 제공해준다. TypeScript를 전혀 해보진 않았지만, \"어차피 JavaScript에 타입 선언만 추가된 거 아닌가?\"라는 생각이 들어 적용했다.\r\n\r\nTypeScript에 적응하는 데 그리 오랜 시간이 걸리진 않은 걸로 기억한다. 내 생각대로 타입 선언 말곤 크게 달라진 게 없으니. 오히려 타입이 명시되니 해당 변수에 사용할 수 있는 올바른 내부함수라던가, 자동완성이 적용되서 훨씬 쾌적한 개발을 할 수 있었다.\r\n\r\n단, 짜증나는 점이 하나 있었는데, 바로 라이브 서버와 컴파일 간의 차이였다. Next.js에서는 작성한 소스코드를 즉시 반영해주는 일종의 라이브 서버를 구동할 수 있다. 여기서 좀 짜증나는 차이가 발생하는데, <span class=\"red-400\">TypeScript에서 오류가 나는 문장이나 문법이 라이브 서버에선 영향을 미치지 않는다.</span> 즉, 보기에 멀쩡한 코드도 라이브 서버에선 실행까지 잘 되지만 빌드를 수행하면 갖가지 오류를 뱉어낸다.\r\n\r\n<p align=\"center\">\r\n\t<i>타입이 정확하지 않아아아아아앙아ㅏㅇㄲㄲㄱㅇㅇ악!! 이딴 \"불분명한\"거 내 앞에서 치워!!!</i>\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<i>이거 타입 선언 안 한 새x끼가 너냐?? ㅋㅋㅋㅋㅋㅋ 컴파일 오류 보고싶지 않으면 처---신 잘 하라고-</i>\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<i>아니 이거 \"null\"일 가능성이 있는뎁쇼?? 아 렌더링 후에 반드시 생성되는 DOM이라 확실히 있는 놈이라구요? 아 DOM 그딴건 모르겠고 암튼 null일 수도 있다고 아ㅋㅋㅋㅋㅋㅋ</i>\r\n</p>\r\n\r\n더 환장하는건, 실제론 동작 자체에 문제가 없는 소스다. JavaScript라면 무사통과할 수 있는 매우 정상적인 소스라는 뜻이다.\r\n\r\n하지만 작고 소중한 TypeScript는 아무도 막을 수 없어서 조금만 의심스러운 부분이 있다면 바로 찡찡대기 시작한다.\r\n\r\n특히 라이브러리의 내부 함수를 쓸 때가 좀 고역이였다. 정확한 타입을 선언해주기 위해서 소스 내부를 까서 어떤 타입의 파라미터를 받는지, 어떤 타입을 반환하는지를 확인해야했다. 물론 이게 TypeScript의 존재 의의다만...\r\n\r\n이러한 문제에도 불구하고 TypeScript는 내가 JavaScript에서 불편하다고 느낀 것들을 해소해줬다. 문제는 전혀 다른 불편함을 준다는 점이지만..\r\n\r\n그래도 나름 재밌는 개발 경험을 줬지 싶다.\r\n\r\n## 2. CSS-in-CSS 적용\r\n\r\n어렸을 때, 이런 문구 들어본 적 있을 거다.\r\n\r\n<p align=\"center\">\r\n\t<i>진료는 의사에게, 약은 약사에게</i>\r\n</p>\r\n\r\n의약분업을 위한 캐치프레이즈다. 내 블로그에는 통용되지 않는 말이기도 하다.\r\n\r\n이전까지의 내 블로그는 CSS-in-JS가 적용되어 있었다. 위에서도 언급했듯이, 내 블로그의 CSS는 전적으로 Material-UI에 의존하고 있었다. 이로 인해 의존할 수 있는 래퍼런스 또한 많지 않았고, 불행히도 Material-UI는 CSS-in-JS 방식의 래퍼런스를 제공한 탓에 지금까지 이런 방식을 적용했었다.\r\n\r\n> **CSS-in-JS?** **CSS-in-CSS??**  \r\n> `CSS-in-JS`: JavaScript에서 CSS 담당  \r\n> `CSS-in-CSS`: CSS에서 CSS 담당\r\n\r\n몰론 장점도 있었다. CSS-in-JS의 가장 큰 장점은 CSS를 JavaScript에서 관리하므로 CSS의 동적 생성이 쉽다. 더군다나 내 블로그는 다크, 라이트 모드를 토글할 수 있기 때문에 이러한 장점은 더더욱 강력하게 다가왔다.\r\n\r\n하지만 위에서도 언급했듯이, 렌더링 및 성능 문제가 가장 큰 이슈로 대두됐고, 이 중 스타일링 구문이 가장 의심이 됐다.\r\n\r\n모든 컴포넌트 마다 JavaScript에서 스타일링 구문을 생성해야했고, 게시글 같은 경우 스타일링 요소가 많아 JSX 코드보다도 스타일링 코드가 훨씬 더 길어지는 주객전도가 일어나기도 했다.\r\n\r\n더군다나 CSS-in-JS에서 일어나는 치명적인 문제가 있는데, CSS가 적용되기 전인 날 것의 HTML이 잠깐 보이는 현상이다. 이러한 현상을 <span class=\"priamry\">FOUC</span>(Flash of Unstyled Content)라고 부른다.\r\n\r\nNextJS에선 emotion.js를 적극적으로 차용하도록 유도하여 이러한 문제를 줄인다고 하는데.. 특별한 이유가 없다면 CSS는 CSS가 담당하는 게 맞다고 생각하여, CSS-in-CSS를 차용하기로 했다.\r\n\r\n## 3. SCSS 적용\r\n\r\n위에서 언급한 CSS-in-CSS를 위해, 처음엔 CSS를 사용하고자 했다. 하지만 사소한 문제가 하나 있었는데, 기존 소스와의 호환성을 위해선 CSS만으로는 안 된다.\r\n\r\n``` javascript\r\n/**\r\n * 스타일 객체 반환 함수\r\n *\r\n * @returns {JSON} 스타일 객체\r\n */\r\nfunction getStyles()\r\n{\r\n\treturn makeStyles((theme) => ({\r\n\t\tfab_bright: {\r\n\t\t\tposition: \"fixed\",\r\n\t\t\tbottom: 50,\r\n\t\t\tright: 50,\r\n\t\t\tbackgroundColor: grey[800],\r\n\t\t\tcolor: grey[200],\r\n\t\t\t\"&:hover\": {\r\n\t\t\t\tbackgroundColor: grey[700]\r\n\t\t\t},\r\n\t\t\t\"& svg\": {\r\n\t\t\t\tcolor: orange[600]\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.up(\"md\")]: {\r\n\t\t\t\t\"& span\": {\r\n\t\t\t\t\tmarginLeft: theme.spacing(1)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.down(\"sm\")]: {\r\n\t\t\t\tbottom: 70,\r\n\t\t\t\tright: 20\r\n\t\t\t}\r\n\t\t},\r\n\t\tfab_dark: {\r\n\t\t\tposition: \"fixed\",\r\n\t\t\tbottom: 50,\r\n\t\t\tright: 50,\r\n\t\t\tbackgroundColor: grey[200],\r\n\t\t\tcolor: grey[900],\r\n\t\t\t\"&:hover\": {\r\n\t\t\t\tbackgroundColor: grey[300]\r\n\t\t\t},\r\n\t\t\t\"& svg\": {\r\n\t\t\t\tcolor: blue[600]\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.up(\"md\")]: {\r\n\t\t\t\t\"& span\": {\r\n\t\t\t\t\tmarginLeft: theme.spacing(1)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t[theme.breakpoints.down(\"sm\")]: {\r\n\t\t\t\tbottom: 70,\r\n\t\t\t\tright: 20\r\n\t\t\t}\r\n\t\t},\r\n\t\tdiv: {\r\n\t\t\theight: 24\r\n\t\t}\r\n\t}))();\r\n}\r\n```\r\n\r\n기존에 사용 중인 CSS-in-JS 소스는 이와 같다. Material-UI의 `makeStyles`를 활용한 것으로, 구조를 보면 알겠지만 일반적인 CSS와는 좀 다르다.\r\n\r\n``` css\r\n.alpha {\r\n\tcolor: red;\r\n}\r\n\r\n.alpha:hover {\r\n\tcolor: blue;\r\n}\r\n\r\n.alpha .beta {\r\n\tbackground: black;\r\n}\r\n```\r\n\r\n``` scss\r\n.alpha {\r\n\tcolor: red;\r\n\r\n\t&:hover {\r\n\t\tcolor: blue;\r\n\t}\r\n\r\n\t.beta {\r\n\t\tbackground: black;\r\n\t}\r\n}\r\n```\r\n\r\n각각 동일한 동작을 CSS와 SCSS로 표현했다. 보다시피, `makeStyles`와 SCSS의 표기가 매우 흡사함을 알 수 있다. 즉, 구버전의 스타일링 시스템와 호환성을 최대한 높이기 위해선 SCSS 내지는 SASS와 같은 스타일 전처리기가 반드시 필요했다.\r\n\r\n![SCSS](https://user-images.githubusercontent.com/50317129/127337877-974ffb27-90a1-4013-a2d3-08494e5d0ebb.png)\r\n\r\n그 중 내가 차용한 건 SCSS. SASS는 기존의 CSS와는 살짝 다른 문법을 가지고 있다는 점이 거슬렸다. SCSS는 단순한 스타일링 이외에도 `@mixin`, `@for`나 변수 선언과 같이 좀 더 프로그래밍적인 요소가 강해 더욱 간편한 스타일링 개발 경험을 제공했다.\r\n\r\n일장일단이 있던 TypeScript와 달리, 앞으로도 계속 쓰고 싶을 정도로 마음에 들었다.\r\n\r\n## 4. marked.js 차용\r\n\r\n내가 제대로 알아보질 않아서 그런지 모르겠으나, 기존에 썼던 `unified.js`, `remark`, `rehype` 계열 플러그인의 경우 사용자가 커스터마이징할 여력이 없었던 걸로 기억한다. 때문에 이와 연관된 수 많은 플러그인을 설치해야했다.\r\n\r\n더 골때리는건, 적용된 결과물을 커스텀할 명확한 방법을 제공해주지 않았다. 즉, 주는 대로 쓰라는 말인데.. 여러모로 달갑지 않았다.\r\n\r\n특히 코드 블록의 경우, 복사 버튼이나 언어 표시 등 다채로운 기능을 추가하고 싶었으나, 그럴 수 없어 난감했다. 굳이 거창한 플러그인이 아니더라도, 변환된 HTML 구문만 던져주면 wrapper라도 하나 만들어서 감싸줄텐데, 그런 것도 없으니 여의치 않았다. 물론 전체 HTML은 갖고 있었다만, 이걸 일일히 파싱해서 추출한다는 것도 다소 무식하기도 하고.\r\n\r\n그렇게 찾은 차선책이 `marked.js`다. 이유는 단 한 가지로, 사용자가 결과물을 기본적인 구문 혹은 직접 커스텀한 구문별로 자유로운 커스터마이징이 가능했기 때문.\r\n\r\n그래도 `Prism.js`와 `LaTeX`를 적용하는 건 녹록치 않았었다. 특히 LaTeX는 완벽히 적용하는데 3일 정도는 걸리지 않았나 싶다. LaTeX의 경우 `$`로 감싼 구문에 적용되는데, 마크다운이 기본적으로 `$`에 뭔가 특수한 구문이 적용되는게 아니기 때문에 해당 문자열 토큰을 구문별로 감지할 수 있는 로직을 작성해야했다.\r\n\r\n그나마 Prism.js는 마크다운에 코드블럭 문법 자체가 있어서 그리 어렵지는 않았지만, LaTeX는 구문 분리부터 끝까지 다 만드느라 정말 힘들었다. \r\n\r\n그래도 어쨌든 unified.js와 달리 커스터마이징 API가 잘 설명되어 있어서, 이런 것들도 만들 수 있었다.\r\n\r\n``` java\r\npublic static void main(String[] args)\r\n{\r\n\t// 이런 것도 구현했다.\r\n\tSystem.out.println(\"여기에 텍스트 입력\");\r\n}\r\n```\r\n\r\n* 코드블럭 디자인\r\n* 언어 표시\r\n* 복사 버튼\r\n\r\n코드블럭의 Mac 스타일 디자인은 외국 블로그들을 많이 참고했다. 간간히 구글링하다보면 좋든 싫든 외국 사이트에 접근하게 되는데, 저런 형식의 디자인이 많았다. 막상 직접 보면서 만드려고 하니 안 나오길래, 기억을 살려서 비슷하게 만들었다.\r\n\r\n복사 버튼도 간단한 JS를 통해 그리 어렵지 않게 구현했다. 원래 Prism.js에 여러 플러그인이 있긴 한데, 리액트 상에서 적용하려니 잘 되지 않았다. 특히 라인 표시는 꼭 넣고 싶었는데, 다른건 어찌어찌 직접 만들었다만, 이런 류의 디자인은 좀 난이도가 있기도 하고, 라인을 세서 동적으로 넣어줘야 해서 따로 만들진 않았다. 나중에 여유가 되면 한 번 시도해볼 수도..?\r\n\r\n또 하나, 테이블의 경우 중앙 정렬에 스크롤을 만들어주려면 반드시 div로 한 번 감싸줘야 했는데, 이 부분도 커스터마이징을 통해 어렵지않게 만들었다.\r\n\r\n|   구분   |    값    |\r\n| :------: | :------: |\r\n| 마우스를 |  올리면  |\r\n|   색이   |  바뀐다  |\r\n| 수평으로 | 길어지면 |\r\n| 스크롤도 |  생긴다  |\r\n\r\n여러모로 블로그 개편 중 가장 빡세고 난감했던 부분이였다.\r\n\r\n찾다보니 Markdown과 React를 혼용할 수 있는 <span class=\"primary\">MDX</span>라는 것도 있던데, 나름 키치했지만, 마크다운은 순수한 마크다운일 때가 더 나을 것 같기도 하고... 뭐 그렇다.\r\n\r\n## 5. 카테고리별, 태그별 리스트 페이지 추가\r\n\r\n기존의 블로그에도 카테고리가 select 형태로 존재하긴 했었다. 태그의 경우 아예 관련 페이지가 존재하지도 않았었고. 처음 만들 당시에만 해도 NextJS에 대한 기능을 환전히 이해하지 못 해서, 동적 라우팅이 있는지조차 몰랐었다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127339546-9ba96b92-b580-4081-a1a1-12e98bbdcf24.png\" alt=\"카테고리\" width=\"500px\" />\r\n\r\n카테고리와 태그별로 해당하는 리스트를 보여주는 페이지를 동적 라우팅으로 만들었다. 카테고리의 경우 기존의 select 방식이 그닥 이쁘지 않은 것 같아서 카드뷰 형식으로 간단하게 만들었는데, 그렇게 이쁘단 느낌은 안 드는 것 같다. 우선은 마땅한 디자인이 구상되지 않아서 냅둘 생각이다.\r\n\r\n* /posts/category/{카테고리}/1\r\n* /posts/tags/{태그}/1\r\n\r\nURL은 위와 같이 정의했다.\r\n\r\n## 6. RESTful URL 적용\r\n\r\n기존의 URL은 아래와 같이 적용되어 있었다.\r\n\r\n* `/posts/?page=1&category=all`: 전체 카테고리의 게시글 리스트 1 페이지\r\n* `/posts/brand-new/`: 현재 게시글 URL\r\n\r\n게시글 URL은 그렇다 치고, 게시글 리스트는 정말 꼴보기 싫은 형태다.\r\n\r\nNextJS는 동적 라우팅을 지원한다. TypeScript 기준으로 `[page].tsx`, `[...page].tsx`와 같이 생성하면 된다. 이름의 page는 단순히 할당되는 라우팅 변수명을 의미하므로, 어떤 것이 와도 상관없다. `[...page].tsx`와 같은 형태는 동적 변수가 여러개가 올 경우 사용한다.\r\n\r\n블로그 개편하기 이전에 적용하긴 했지만, 게시글 URL에도 약간의 변화를 줬다. 이는 기존의 Jekyll 블로그를 사용하면서 겪었던 경험을 토대로 개선한건데, Jekyll의 경우 블로그 제목을 `yyyy-MM-dd-title.md`와 같은 형태로 관리한다. 즉, 날짜정보를 제목에서 관리하는데, 이게 또 게시글을 시간순으로 정렬하기 편해서 보기가 쉬웠다. 또한 요즘 블로그 보니 `/yyyy/MM/title`과 같이 URL을 구성하던데, URL에 덩그러니 제목만 있는 것보다 이쪽이 뭔가 더 이뻐보여서 이렇게 구성하기로 했다.\r\n\r\n굳이 `/yyyy/MM/dd/title` 형식으로 일자까지 포함시킨 이유는, NextJS 특성 상 URL 정보만으로 완전한 마크다운 파일 이름을 역으로 만들 수 있어야 라우팅하기 편하기 때문.\r\n\r\n최종적으로 변경된 URL은 아래와 같다.\r\n\r\n* `/posts/1`: 전체 카테고리의 게시글 리스트 1 페이지\r\n* `/posts/JAVA/2`: JAVA 카테고리의 게시글 리스트 2 페이지\r\n* `/posts/2021/07/26/brand-new`: 현재 게시글\r\n\r\nURL 끝에 `/`가 붙는데, NextJS에서 trailing slash 옵션을 켰기 때문이다. 해당 옵션을 키면 해당 페이지를 항상 `index.html`로 만들어준다. 예를 들어, `/pages/posts.tsx`가 있다면 옵션 여부에 따라 아래와 같이 변환된다.\r\n\r\n* `/posts.html`: 옵션을 끌 경우\r\n* `/posts/index.html`: 옵션을 킬 경우\r\n\r\n톰캣에서 개발 서버를 테스트할 때, 반드시 `.html`을 붙여줘야 하길래, 해당 옵션을 켰었는데, GitHub는 `.html` 확장자를 생략 가능해서 굳이 안 해줘도 상관없었다.\r\n\r\n끝에 `index.html`이 있을 경우 `/posts/`로 접속하기 때문에 구글 서치엔진의 URL이 꼬여버렸다... 새로 갱신은 해놨는데, 구글 서치엔진 반영이 워낙 느려서 당분간은 유입이 잘 안 될 것 같다.\r\n\r\n## 7. 기타 UI 개선\r\n\r\n그 밖에 크고 작은 UI를 개선했다. 가장 큰 변경점은 Bottom Nav 삭제.\r\n\r\n모바일의 브라우저는 상단의 주소창과 하단의 메뉴가 나타났다 안 나타났다 하는데, 이 과정에서 페이지의 높이가 바뀌어버린다. 이에 따라서 Bottom Nav의 위치가 수시로 왔다갔다해서 UX를 너무 해친다.\r\n\r\nBottom Nav를 없엔 대신 슬라이드 메뉴를 추가했는데, 이게 그리 이쁘지 않아서 적절하게 디자인을 다시 해 줄 생각이다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127339739-950f4948-51da-4f9f-976d-225cef201aa3.png\" alt=\"게시물 아이템\" width=\"600px\" />\r\n\r\n또한 기존의 게시글 아이템도 좀 더 카드뷰스럽게 만들었고, 사진을 좀 더 강조했다. 또한 태그같은 난잡한 부분은 슬라이드 메뉴 형태로 깔끔하게 정리했다.\r\n\r\n# 여담\r\n\r\n근 며칠 간 블로그 개편 작업에 몰두해서 진행 중이던 백준 알고리즘 풀이가 홀딩됐다. 1020번을 풀었는데, 중간 정도 풀이만 써놓고 아직 마무리하질 못 했다. 이거 풀이도 까먹을 지경인데...\r\n\r\n아직 완전히 완성된 건 아니지만, 어느정도 정리가 된 것 같으니, 그동안 멈춘 작업을 다시 진행해야겠다.","url":["2021-07-26-brand-new","2021","07","26","brand-new"]},{"header":{"title":"긍정적인 시나리오 최적화","excerpt":"지금까지는 항상 알고리즘을 비관적인 관점으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다. 이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-24T04:54:40","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","삽입 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-24-about-algorithm-chapter06.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 6장 긍정적인 시나리오 최적화\r\n\r\n지금까지는 항상 알고리즘을 <span class=\"orange-400\">비관적인 관점</span>으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다.\r\n\r\n이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.\r\n\r\n## 6-1. 삽입 정렬\r\n\r\n이 장에서는 <span class=\"primary\">삽입 정렬</span> 알고리즘을 토대로 전개한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834021-dcb0625e-80fb-4567-bd8d-982ae60a04c0.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬할 배열은 위와 같으며, 원리는 아래와 같다.\r\n\r\n1. 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" />\r\n</p>\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" />\r\n</p>\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n3. 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n## 6-2. 삽입 정렬해보기\r\n\r\n이전 문단의 원리를 토대로 삽입 정렬을 수행한다.\r\n\r\n1. 패스스루 1: 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 패스스루 1: 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" />\r\n</p>\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" />\r\n</p>\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n1. 패스스루 1: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n4. 패스스루 2: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834064-d8e10cd3-d825-47d4-9a29-ee3a95b9cb60.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 9\r\n* 비교값: -\r\n\r\n세 번째 요소의 값인 9를 임시 변수로 할당한다.\r\n\r\n5. 패스스루 2: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834073-83c7f417-d7ac-43ce-8421-0119ef5d4712.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 9\r\n* 비교값: 7\r\n\r\n임시 변수보다 비교값이 작을 경우, 비교를 종료하고 현재 공백에 임시 변수를 삽입한다. 이 케이스의 경우 바로 왼쪽에 위치한 요소가 7로 9보다 작으므로, 그 즉시 비교가 종료되며 삽입을 진행한다.\r\n\r\n5. 패스스루 2: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834078-3e4fda60-79af-4f58-9915-aca42d5babfd.png\" width=\"600px\" />\r\n</p>\r\n\r\n공교롭게도, 원래의 위치에 임시 변수 9가 삽입된다.\r\n\r\n6. 패스스루 3: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834085-ce09440c-11a9-418c-ac7e-07c307bb16b5.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: -\r\n\r\n네 번째 요소의 값인 2를 임시 변수로 할당한다.\r\n\r\n7. 패스스루 3: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834098-f4dbef5a-0a59-4668-aa73-0e98b431895a.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 9\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834107-74cc6e75-3a59-4fa3-8c66-56160cdb6913.png\" width=\"600px\" />\r\n</p>\r\n\r\n비교값 9가 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834113-25e6eac5-d5eb-4380-918f-249eaf9de4d1.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834120-2df440ae-cad4-4f7b-a3fd-708b2ec0b6d3.png\" width=\"600px\" />\r\n</p>\r\n\r\n비교값 7이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834129-5ee81114-faf3-43cd-ba96-4e3f46a705a8.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 3\r\n\r\n비교값 3이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834134-09db5b58-6c7a-49af-a1e9-b3125e85dd6b.png\" width=\"600px\" />\r\n</p>\r\n\r\n8. 패스스루 3: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834141-cc23a70b-f809-4783-affb-cefae7faa2cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n가장 맨 첫 요소에 임시 변수 2가 삽입된다.\r\n\r\n9. 패스스루 4: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834150-6cd89c4c-6f2a-4360-b4cc-677d073ccd85.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 5\r\n* 비교값: -\r\n\r\n다섯 번째 요소의 값인 5를 임시 변수로 할당한다.\r\n\r\n10. 패스스루 4: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834157-416ea349-6684-496b-bb98-cbd456232e54.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 5\r\n* 비교값: 9\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834166-f03e3731-66b8-4b66-95e8-51d176a92bee.png\" width=\"600px\" />\r\n</p>\r\n\r\n비교값 9가 임시 변수 5보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/127515837-4e39a0aa-3acb-465d-aede-b6b888d7816a.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 5\r\n* 비교값: 7\r\n\r\n비교값 7이 임시 변수 5보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/127515847-d1acdce7-805a-4f4a-9f5e-886955836dd7.png\" width=\"600px\" />\r\n</p>\r\n\r\n네 번째 요소에 임시 변수 5가 삽입된다.\r\n\r\n11. 패스스루 4: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/127515856-478930c0-b866-4b54-a0d7-13f49dfca11e.png\" width=\"600px\" />\r\n</p>\r\n\r\n세 번째 요소에 임시 변수 5가 삽입된다.\r\n\r\n가장 마지막 요소까지 기준 인덱스가 이동했으므로, 해당 패스스루를 마지막으로 종료한다.\r\n\r\n## 6-3. 삽입 정렬 구현\r\n\r\n삽입 정렬의 과정을 토대로 이를 <span class=\"orange-400\">JAVA</span>로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 삽입 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 02:40:19\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int shiftCount = 0;\r\n\tprivate static int deleteCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tselectionSort(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 시프트 작업량: \");\r\n\t\twriter.write(String.valueOf(shiftCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삭제 작업량: \");\r\n\t\twriter.write(String.valueOf(deleteCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + shiftCount + deleteCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 삽입 정렬 알고리즘\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t */\r\n\tprivate static void selectionSort(int[] array)\r\n\t{\r\n\t\tfor (int i = 1; i < array.length; i++)\r\n\t\t{\r\n\t\t\t// 임시 변수\r\n\t\t\tint temp = array[i];\r\n\t\t\t\r\n\t\t\t// 빈 공간\r\n\t\t\tint blank = i;\r\n\t\t\t\r\n\t\t\t// 삭제 작업 추가\r\n\t\t\tdeleteCount++;\r\n\t\t\t\r\n\t\t\t// 공백 표시\r\n\t\t\tarray[i] = Integer.MIN_VALUE;\r\n\t\t\t\r\n\t\t\tfor (int j = i - 1; j > -1; j--)\r\n\t\t\t{\r\n\t\t\t\t// 비교 작업 추가\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소가 임시 변수보다 클 경우\r\n\t\t\t\tif (array[j] > temp)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 시프트 작업 추가\r\n\t\t\t\t\tshiftCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = array[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tblank--;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아닐 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 삽입 작업 추가\r\n\t\t\tinsertCount++;\r\n\t\t\t\r\n\t\t\tarray[blank] = temp;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n10 9 8 7 6 5 4 3 2 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n - 비교 작업량: 45\r\n - 시프트 작업량: 45\r\n - 삭제 작업량: 9\r\n - 삽입 작업량: 9\r\n - 총 작업량: 108\r\n```\r\n\r\n소스와 입력, 출력값은 위와 같다. 사용자로부터 임의의 배열을 입력받아 삽입 정렬을 수행하고, 졍렬 결과와 각 작업량을 구분하여 표시한다.\r\n\r\n실제 핵심 동작은 `selectionSort` 메소드에서 이루어진다. 공백은 `Integer.MIN_VALUE`를 삽입하여 표시하며, 삭제됨을 표현하기 위한 것으로 작업량에 포함되지 않는다.\r\n\r\n``` java\r\nfor (int i = 1; i < array.length; i++)\r\n{\r\n\t// 임시 변수\r\n\tint temp = array[i];\r\n\t\r\n\t// 빈 공간\r\n\tint blank = i;\r\n\t\r\n\t// 삭제 작업 추가\r\n\tdeleteCount++;\r\n\t\r\n\t// 공백 표시\r\n\tarray[i] = Integer.MIN_VALUE;\r\n\t\r\n\t// ...\r\n}\r\n```\r\n\r\n첫 번째 `for`문은 각 패스스루를 의미한다. 각 패스스루마다 기준 인덱스 `i`, 임시 변수 `temp`, 삭제된 요소의 인덱스 `blank`가 새로 정의된다. 이 과정에서 삭제 연산이 고정으로 한 번 수행된다.\r\n\r\n``` java\r\nfor (int j = i - 1; j > -1; j--)\r\n{\r\n\t// 비교 작업 추가\r\n\tcompareCount++;\r\n\t\r\n\t// 현재 요소가 임시 변수보다 클 경우\r\n\tif (array[j] > temp)\r\n\t{\r\n\t\t// 시프트 작업 추가\r\n\t\tshiftCount++;\r\n\t\t\r\n\t\tarray[blank] = array[j];\r\n\t\t\r\n\t\tblank--;\r\n\t\t\r\n\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n두 번째 `for`문은 각 기준 인덱스 `i`의 왼쪽 요소부터 0까지 비교 및 시프트 작업을 의미한다. 각 사이클마다 비교 작업 한 번이 반드시 발생하며, 임시 변수와 현재 요소 간의 크기에 따라 시프트 작업이 발생할 수 있다.\r\n\r\n``` java\r\nfor (int i = 1; i < array.length; i++)\r\n{\r\n\t// ...\r\n\t\r\n\t// 삽입 작업 추가\r\n\tinsertCount++;\r\n\t\r\n\tarray[blank] = temp;\r\n}\r\n```\r\n\r\n모든 비교가 끝나면 현재 공백인 요소에 임시 변수를 삽입한다. 이 과정에서 삽입 작업 한 번이 반드시 발생한다.\r\n\r\n## 6-4. 삽입 정렬의 효율성\r\n\r\n삽입 정렬 시 발생하는 작업을 분석하여 그 효율성에 대해 알아보자. 삽입 정렬은 <span class=\"orange-400\">삭제</span>, <span class=\"orange-400\">비교</span>, <span class=\"orange-400\">시프트</span>, <span class=\"orange-400\">삽입</span>의 4개 작업으로 이루어져있다.\r\n\r\n삽입 정렬에서 가장 최악의 케이스는 요소가 역순으로 정렬된 배열이다. 모든 요소가 역순으로 정렬될 경우, 발생할 수 있는 모든 작업이 발생한다. 최악의 경우에 발생하는 각 작업량을 일반식으로 정의하면 아래와 같다.\r\n\r\n* 삭제: $N - 1$\r\n* 비교: $N^2 \\div 2$ (대략적인 값)\r\n* 시프트: $N^2 \\div 2$ (대략적인 값)\r\n* 삽입: $N - 1$\r\n\r\n이를 토대로 삽입 정렬의 시간 복잡도는 $O(N^2 + 2N - 2)$임을 알 수 있다. 빅 오 표기법은 <span class=\"blue-400\">상수를 무시</span>하므로 $O(N^2 + N)$으로 간략하게 표기할 수 있다. 하지만 빅 오 표기법은 상수만 무시하는 게 아니다. <span class=\"blue-400\">가장 높은 차수를 제외한 나머지 차수 또한 무시</span>한다. 그말인 즉슨, $N^2 + N$에서 가장 높은 차수는 $N^2$이므로, $N$은 무시한다. 따라서 최종적으로 삽입 정렬의 시간 복잡도는 $O(N^2)$이 된다.\r\n\r\n|  $N$  |   $N^2$   |     $N^3$     |       $N^4$       |\r\n| :---: | :-------: | :-----------: | :---------------: |\r\n|   2   |     4     |       8       |        16         |\r\n|   5   |    25     |      125      |        625        |\r\n|  10   |    100    |     1,000     |      10,000       |\r\n|  100  |  10,000   |   1,000,000   |    100,000,000    |\r\n| 1,000 | 1,000,000 | 1,000,000,000 | 1,000,000,000,000 |\r\n\r\n요소 $N$의 갯수가 100일 때, $N^4$와 $N^3$은 $N$의 값인 100배 차이가 난다. $N^4$ 입장에서는 $N^3$ 작업 한 사이클이 발생해도, 자신의 작업량의 1%밖에 되지 않는다. 차수가 높아질 수록 작업량의 차이가 기하급수적으로 벌어지기 때문에 무시하는 것이다.\r\n\r\n지금까지 버블, 선택, 삽입 정렬 세 가지를 다뤄봤다. 각 알고리즘의 시간 복잡도를 정리하면 아래와 같다.\r\n\r\n|       구분        | 버블 정렬 |    선택 정렬    |     삽입 정렬     |\r\n| :---------------: | :-------: | :-------------: | :---------------: |\r\n|   빅 오 표기법    | $O(N^2)$  |    $O(N^2)$     |     $O(N^2)$      |\r\n| 실제 빅 오 표기법 | $O(N^2)$  | $O(N^2 \\div 2)$ | $O(N^2 + 2N - 2)$ |\r\n\r\n4장 부터 6장까지 오면서, 우리는 각 정렬의 빅 오 표기법과 실제 나타나는 빅 오 표기법에 대해 알고있다. 위 표를 토대로 본다면, 세 정렬 기법 중 선택 정렬이 가장 빠르다고 할 수 있을 것이다. 단, 누누히 말했듯이 최악의 경우에 가깝다는 전제가 수반된다.\r\n\r\n그렇다면 평균적인 경우는 어떨까?\r\n\r\n## 6-5. 평균적인 경우\r\n\r\n데이터가 1억, 1조가 넘어간다면 모를까, 대부분의 일반적인 환경에선 그리 많은 데이터를 처리하지 않는다. 즉, 대부분의 경우 최악의 케이스에 도달하지 않는다는 뜻이기도 하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834185-4dfa70f6-0a15-4069-a7a4-7f3ed43809f4.png\" width=\"600px\" />\r\n</p>\r\n\r\n대부분의 케이스는 위와 같은 정규 분포도를 따른다. 좌측으로 수렴할 수록 최악의 케이스, 우측으로 수렴할 수록 최선의 케이스, 정 가운데로 수렴할 수록 평균적인 케이스다. <span class=\"green-400\">대다수는 평균적인 영역에 포함</span>되며, 양 옆의 극단적인 케이스는 상대적으로 양이 적다.\r\n\r\n지금까지 다룬 정렬 알고리즘의 대부분은 역순으로 정렬될 경우가 최악의 케이스였다. 완전 무작위의 배열이 입력된다고 가정할 때, 정확히 역순으로 나열된 배열이 나올 확률이 얼마나 될지 생각해보자. 대부분의 배열은 어떠한 규칙도 없이 무작위로 나열됐을 것이다. 굳이 위 같은 정규 분포도가 아니더라도 일상 생활에서 비슷한 사례는 많이 있다. 여러 케이스 중 발생하는 특이 케이스는 다른 대다수의 케이스와는 어떠한 방향으로든 다르다는 뜻이다. 최선, 최악의 케이스는 어찌 보면 이러한 특이 케이스의 범주에 속한다.\r\n\r\n우리가 이번 장에서 다룬 삽입 정렬을 토대로 확인해보자.\r\n\r\n* 최악의 경우, $O(N^2 + 2N - 2)$. 즉, $O(N^2)$를 가진다.\r\n* 최선의 경우, $O(3(N - 1))$. 즉, $O(N)$를 가진다.\r\n* 일반적인 경우, $O(N^2 \\div 2)$. 즉, $O(N^2)$를 가진다.\r\n\r\n이를 표로 나타내면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834196-63471f0e-41df-4715-ac15-8c79fd606fae.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 케이스에 따라 유의미한 성능의 차이가 존재한다. 반대로 선택 정렬의 경우 꽤 난감한데, 선택 정렬은 어떠한 케이스에서든 $O(N^2)$의 시간 복잡도를 가진다.\r\n\r\n``` java\r\n/**\r\n * 선택 정렬 함수\r\n *\r\n * @param array : [int[]] 대상 배열\r\n *\r\n * @return [int[]] 작업 갯수 배열\r\n */\r\nprivate static int[] selectionSort(int[] array)\r\n{\r\n\tint compareCount = 0;\r\n\tint swapCount = 0;\r\n\t\r\n\tfor (int i = 0; i < array.length; i++)\r\n\t{\r\n\t\t// 패스스루의 최소값 인덱스\r\n\t\tint min = i;\r\n\t\t\r\n\t\tfor (int j = i + 1; j < array.length; j++)\r\n\t\t{\r\n\t\t\tcompareCount++;\r\n\t\t\t\r\n\t\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\t\tif (array[j] < array[min])\r\n\t\t\t{\r\n\t\t\t\tmin = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 최소 인덱스에 변화가 있었을 경우\r\n\t\tif (min != i)\r\n\t\t{\r\n\t\t\tint temp = array[min];\r\n\t\t\t\r\n\t\t\tarray[min] = array[i];\r\n\t\t\tarray[i] = temp;\r\n\t\t\t\r\n\t\t\tswapCount++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn new int[] { compareCount, swapCount };\r\n}\r\n```\r\n\r\n위 소스는 5장에서 다룬 선택 정렬 소스다. 보시다시피 `for`문이 2개나 존재함으로 $O(N^2)$의 시간 복잡도를 가진다는 것을 어렵지 않게 유추할 수 있다. 더군다나 소스를 자세히 보자. 중간에 반복문을 종료할 수 있는 `break` 또한 존재하지 않는다. 좋든 싫든 항상 $N^2$의 작업을 수행한다는 뜻이다. 실제로 5장의 소스를 구동하면 케이스별로 작업량의 차이가 그리 크지 않다.\r\n\r\n만약 사용할 데이터의 대부분이 어느정도 정렬되어있을 경우, 삽입 정렬이 훨씬 유리하다고 판단할 수 있다. 만약 데이터가 완전히 무작위라면 선택 정렬이나 삽입 정렬이나 크게 차이가 없다고 볼 수 있다.\r\n\r\n## 6-6. 실제 예제\r\n\r\n두 배열이 존재하며, 각 배열에 공통으로 존재하는 요소를 추출하여 반환하는 교집합 알고리즘을 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 25\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n이중 `for` 구조이므로 시간 복잡도는 당연히 $O(N^2)$일 것이다. 두 배열의 요소의 크기가 완전히 동일할 때, 나타날 수 있는 최악의 케이스는 $O(N^2 + N)$이다. 간략히 $O(N^2)$라고 할 수 있다.\r\n\r\n위 알고리즘의 경우 불필요한 연산을 수행하기도 한다. 이를 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class ImproveIntersection\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 24\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n차이점은 `for`문 안의 `if` 구문에 있다.\r\n\r\n``` java\r\n// 두 배열의 요소가 같을 경우\r\nif (item1 == item2)\r\n{\r\n\tinsertCount++;\r\n\t\r\n\tlist.add(item1);\r\n\t\r\n\tbreak;\r\n}\r\n```\r\n\r\n이처럼 동일한 요소가 탐색되었을 경우, `break`를 통해 패스스루 강제 종료 기능을 추가했다. 최악의 시나리오에선 $O(N^2)$로 동일하지만, 최선의 시나리오에선 $O(N)$으로 동작할 것이다. 이전의 알고리즘이 항상 $O(N^2)$임을 감안한다면 적절한 최적화라 할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서 주로 얘기한 내용은 아래와 같다.\r\n\r\n* 알고리즘을 꼭 비관적으로만 바라보는 것은 아니다.\r\n* 오히려 대부분의 케이스는 평균의 범주에 속한다.\r\n* 알고리즘의 로직에 따라 케이스의 양에 따라시간 복잡도가 유의미하게 달라지기도 한다.\r\n\r\n이 장에서는 알고리즘의 또 다른 관점에 대해 알아봤다. 대부분의 케이스가 평균의 범주에 속하므로, 평균 시간 복잡도 역시 성능을 측정함에 있어서 중요한 요소 중 하나일 것이다.\r\n\r\n다음 장에서는 새로운 개념인 해시 테이블에 대해 알아본다.","url":["2021-07-24-about-algorithm-chapter06","2021","07","24","about-algorithm-chapter06"]},{"header":{"title":"빅 오를 사용하거나 사용하지 않는 코드 최적화","excerpt":"지금까지 알고리즘의 퍼포먼스를 비교하면서 빅 오 표기법을 통해 수치화했다. 하지만 빅 오 표기법도 알고리즘의 퍼포먼스를 측정함에 있어서 완벽함을 보여주진 않는다. 이전 장에서 N(O^2)이나 N(N^2 - N) 모두 빅 오 표기법에선 N(O^2)로 간주한다고 설명했다. 이러한 특성으로 인해, 실제로는 명백한 차이를 보이는 알고리즘임에도 불구하고 빅 오 표기법으론 성능이 거의 동일하게 측정되기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-23T23:42:33","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","선택 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-23-about-algorithm-chapter05.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 5장 빅 오를 사용하거나 사용하지 않는 코드 최적화\r\n\r\n지금까지 알고리즘의 퍼포먼스를 비교하면서 <span class=\"primary\">빅 오 표기법</span>을 통해 수치화했다. 하지만 빅 오 표기법도 알고리즘의 퍼포먼스를 측정함에 있어서 완벽함을 보여주진 않는다.\r\n\r\n이전 장에서 $N(O^2)$이나 $N(N^2 - N)$ 모두 빅 오 표기법에선 $N(O^2)$로 간주한다고 설명했다. 이러한 특성으로 인해, 실제로는 명백한 차이를 보이는 알고리즘임에도 불구하고 빅 오 표기법으론 성능이 거의 동일하게 측정되기도 한다.\r\n\r\n알고리즘의 속도는 알고리즘을 선택하는 데 있어서 매우 중요한 척도이므로, 이를 정확비 측정하는 것은 매우 중요하다. 이 장에서는 앞서 설명한 것과 같이 대체로 성능이 <span class=\"pink-400\">비슷해</span>보이는 알고리즘을 구별하여 더욱 빠른 알고리즘을 판별해본다.\r\n\r\n## 5-1. 선택 정렬\r\n\r\n이전 장에서는 <span class=\"orange-400\">버블 정렬</span> 알고리즘을 통해 내용을 서술했다. 이번 장에서는 다른 정렬 알고리즘인 <span class=\"orange-400\">선택 정렬</span> 알고리즘을 통해 서술해본다.\r\n\r\n선택 정렬 알고리즘은 패스스루마다 요소를 탐색하여 최소값을 탐지하고, 이를 앞으로 보내어 정렬하는 방식이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793171-d9677021-0ff9-414c-b83b-165dc037222f.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬에 사용할 배열은 위와 같으며, 과정은 아래의 순서대로 진행된다.\r\n\r\n1. 맨 첫 번째 값을 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793179-854c05e3-04cc-420a-8a42-22fe0145c4cb.png\" width=\"600px\" />\r\n</p>\r\n\r\n한 패스스루에서 가장 작은 요소를 찾는 것이 핵심이다. 아직 첫 단계이므로, 첫 요소는 그 자체로 최소값이 된다.\r\n\r\n2. 탐색 포인터를 한 칸 이동하여 패스스루 최소값과 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793193-d865b162-9c02-44a0-a59c-d2e1674f4e5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 5\r\n* 탐색값: 3\r\n\r\n패스스루 최소값을 3으로 갱신한다.\r\n\r\n3. 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793202-90a4dfc3-d40c-4073-9127-763781156693.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n4. 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793209-88b076db-fe26-4cee-9a0c-1f0540beb0c8.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 2\r\n\r\n패스스루 최소값을 2로 갱신한다.\r\n\r\n5. 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793215-a5a7dde7-8fbf-42a4-b585-5b5778297cc3.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 2\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다. 마지막 요소이므로, 탐색이 종료되고 요소 하나를 정렬한다.\r\n\r\n6. 패스스루 최소값의 요소를 맨 앞으로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793223-3580ae05-867b-464d-9d58-831e93b6142b.png\" width=\"600px\" />\r\n</p>\r\n\r\n맨 앞의 요소 5와 최소값 2의 자리를 서로 교환한다. 2는 완전히 매칭되었으므로, 앞으로의 패스스루에서 제외된다.\r\n\r\n## 5-2. 선택 정렬 실제로 해보기\r\n\r\n이전 문단에서 선택 정렬의 원리에 대해 알았으니, 전체 배열에 대한 선택 정렬을 수행해보자.\r\n\r\n<small class=\"red-A400\">패스스루 1은 이전 문단의 과정과 동일하다.</small>\r\n\r\n1. 패스스루 1: 맨 첫 번째 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793179-854c05e3-04cc-420a-8a42-22fe0145c4cb.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 5\r\n\r\n한 패스스루에서 가장 작은 요소를 찾는 것이 핵심이다. 아직 첫 단계이므로, 첫 요소는 그 자체로 최소값이 된다.\r\n\r\n2. 패스스루 1: 탐색 포인터를 한 칸 이동하여 패스스루 최소값과 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793193-d865b162-9c02-44a0-a59c-d2e1674f4e5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 5\r\n* 탐색값: 3\r\n\r\n패스스루 최소값을 3으로 갱신한다.\r\n\r\n3. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793202-90a4dfc3-d40c-4073-9127-763781156693.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n4. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793209-88b076db-fe26-4cee-9a0c-1f0540beb0c8.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 2\r\n\r\n패스스루 최소값을 2로 갱신한다.\r\n\r\n5. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793215-a5a7dde7-8fbf-42a4-b585-5b5778297cc3.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 2\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다. 마지막 요소이므로, 탐색이 종료되고 요소 하나를 정렬한다.\r\n\r\n6. 패스스루 1: 패스스루 최소값의 요소를 맨 앞으로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793223-3580ae05-867b-464d-9d58-831e93b6142b.png\" width=\"600px\" />\r\n</p>\r\n\r\n맨 앞의 요소 5와 최소값 2의 자리를 서로 교환한다. 2는 완전히 매칭되었으므로, **앞으로의 패스스루에서 제외**된다.\r\n\r\n7. 패스스루 2: 두 번째 요소를 탐색한다.\r\n\r\n* 최소값: -\r\n* 탐색값: 3\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793231-7c8448af-29e1-4d65-9c37-630dcec47e24.png\" width=\"600px\" />\r\n</p>\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n8. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793239-cefccd38-954e-4c49-85be-a007698d072b.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n9. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793255-354bc82f-0c65-4a75-bfde-c192f97344dc.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 5\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n10. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793276-bd4020c4-fcda-4b45-b993-2575ff7c1b69.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n11. 패스스루 2: 패스스루 최소값의 요소를 두 번째 위치로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793282-277dc152-91d4-47a8-bdcb-3f5280593040.png\" width=\"600px\" />\r\n</p>\r\n\r\n최소값 3이 우연히도 올바른 자리에 위치하고 있어서 자리 교환이 일어나지 않는다. 두 번째 요소까지 정렬되었으므로, 마찬가지로 다음 패스스루부터 제외된다.\r\n\r\n12. 패스스루 3: 세 번째 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793296-8e9c6a9b-8aff-4634-86cc-684338c990dc.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n13. 패스스루 3: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793310-19358a00-e527-405d-8033-1eef2c11060b.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 9\r\n* 탐색값: 5\r\n\r\n패스스루 최소값을 5로 갱신한다.\r\n\r\n14. 패스스루 3: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793315-ca00a872-d867-40e5-95c3-c9de2b7c7851.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 5\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n15. 패스스루 3: 패스스루 최소값의 요소를 세 번째 위치로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793330-af0a7836-5bfd-477c-b614-c8c2fc8f108f.png\" width=\"600px\" />\r\n</p>\r\n\r\n세 번째 요소 9와 최소값 5와의 자리를 서로 교환한다.\r\n\r\n16. 패스스루 4: 네 번째 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793337-f90959c9-c798-46f5-b64a-68807621edad.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n17. 패스스루 4: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793345-4f6a2819-4dac-4c81-b9c6-4ca7fd4c8749.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 9\r\n* 탐색값: 6\r\n\r\n패스스루 최소값을 6으로 갱신한다.\r\n\r\n18. 패스스루 4: 패스스루 최소값의 요소를 네 번째 위치로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793357-e0e62399-9d03-48a8-8f23-721e43022a65.png\" width=\"600px\" />\r\n</p>\r\n\r\n네 번째 요소 9와 최소값 6와의 자리를 서로 교환한다.\r\n\r\n19. 패스스루 5: 마지막 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793365-b658adfc-df4b-4e56-b130-e78e81826d54.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n패스스루 최소값을 9로 갱신한다.\r\n\r\n마지막 요소이므로 그 자체로 정렬된 위치에 있으며, 패스스루가 종료된다.\r\n\r\n이로써 선택 정렬을 통해 최종적으로 정렬된 배열의 형태는 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793370-a6ec0819-47c7-49c6-8f30-b953d9311336.png\" width=\"600px\" />\r\n</p>\r\n\r\n## 5-3. 선택 정렬 구현\r\n\r\n선택 정렬의 과정을 토대로 이를 <span class=\"orange-400\">JAVA</span>로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 선택 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/23/about-algorithm-chapter05/\">빅 오를 사용하거나 사용하지 않는 코드 최적화</a>\r\n * @since 2021.07.23 Fri 01:12:20\r\n */\r\npublic class SelectionSort\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] processes = selectionSort(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[0]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 스왑 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[0] + processes[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 선택 정렬 함수\r\n\t *\r\n\t * @param array : [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 작업 갯수 배열\r\n\t */\r\n\tprivate static int[] selectionSort(int[] array)\r\n\t{\r\n\t\tint compareCount = 0;\r\n\t\tint swapCount = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < array.length; i++)\r\n\t\t{\r\n\t\t\t// 패스스루의 최소값 인덱스\r\n\t\t\tint min = i;\r\n\t\t\t\r\n\t\t\tfor (int j = i + 1; j < array.length; j++)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\t\t\tif (array[j] < array[min])\r\n\t\t\t\t{\r\n\t\t\t\t\tmin = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 최소 인덱스에 변화가 있었을 경우\r\n\t\t\tif (min != i)\r\n\t\t\t{\r\n\t\t\t\tint temp = array[min];\r\n\t\t\t\t\r\n\t\t\t\tarray[min] = array[i];\r\n\t\t\t\tarray[i] = temp;\r\n\t\t\t\t\r\n\t\t\t\tswapCount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { compareCount, swapCount };\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n5 3 4 1 2\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 2, 3, 4, 5]\r\n - 비교 작업량: 10\r\n - 스왑 작업량: 4\r\n - 총 작업량: 14\r\n```\r\n\r\n사용자로부터 공백으로 구분된 숫자 배열을 입력받아 선택 정렬을 수행하고, 작업량을 구분에 따라 표시한다. 핵심 동작은 `selectionSort` 메소드에서 수행한다.\r\n\r\n* 첫 번째 `for`: 패스스루\r\n* 두 번째 `for`: 비교 작업\r\n* `if`문: 스왑 작업\r\n\r\n``` java\r\nfor (int i = 0; i < array.length; i++)\r\n{\r\n\t// 패스스루의 최소값 인덱스\r\n\tint min = i;\r\n\t\r\n\tfor (int j = i + 1; j < array.length; j++)\r\n\t{\r\n\t\tcompareCount++;\r\n\t\t\r\n\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\tif (array[j] < array[min])\r\n\t\t{\r\n\t\t\tmin = j;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 최소 인덱스에 변화가 있었을 경우\r\n\tif (min != i)\r\n\t{\r\n\t\tint temp = array[min];\r\n\t\t\r\n\t\tarray[min] = array[i];\r\n\t\tarray[i] = temp;\r\n\t\t\r\n\t\tswapCount++;\r\n\t}\r\n}\r\n```\r\n\r\n패스스루마다 첫 요소를 최소값 `min`에 할당한다. 이후 다음 요소부터 마지막 요소까지 순차적으로 `min`과 비교한다.\r\n\r\n`min`보다 더 작은 요소가 탐색될 경우 이를 교체한다. 최종적으로 `min`에는 검색한 요소들 중 가장 최소값이 할당된다.\r\n\r\n`if`문에서 `min`에 변화가 있었는지를 확인한다. 패스스루의 첫 요소의 인덱스가 아닐 경우, `min`이 변경된 것이므로 스왑을 진행한다.\r\n\r\n\r\n## 5-4. 선택 정렬의 효율성\r\n\r\n선택 정렬의 효율성을 따져보자. 위에서 언급했듯이, 선택 정렬은 <span class=\"blue-400\">비교</span>, <span class=\"blue-400\">교환</span> 작업으로 이루어진다. 비교는 항상 일어나고, 교환의 경우 조건부로 일어난다.\r\n\r\n요소가 5개인 배열을 선택 정렬할 경우 발생하는 비교 작업량은 아래와 같다.\r\n\r\n| 패스스루 | 작업량 |\r\n| :------: | :----: |\r\n|    1     |   4    |\r\n|    2     |   3    |\r\n|    3     |   2    |\r\n|    4     |   1    |\r\n\r\n$4 + 3 + 2 + 1 = 10$으로 총 10번의 비교 작업이 수행된다. 일반화하면 $(N - 1) + (N - 2) + \\dots + 1$와 같이 정의할 수 있다.\r\n\r\n교환의 경우, 비교와 달리 패스스루 당 최대 한 번만 발생하며, 이 또한 조건에 따라 아예 일어나지 않기도 한다.\r\n\r\n가장 최악의 경우, 각 패스스루마다 교환이 발생하므로 요소가 5개 일 때, 최대 4번의 교환 작업을 예상할 수 있다.\r\n\r\n예시로, $[ 5, 3, 4, 1, 2 ]$의 경우 모든 패스스루에서 스왑이 일어난다.\r\n\r\n> **책에서는 역순일 때가 최악의 경우라는데요??**  \r\n> 역순 배열일 경우 오히려 교환이 두 번 밖에 일어나지 않는다. 반만 정렬하면 나머지 뒤쪽은 알아서 정렬하기 때문.\r\n\r\n버블 정렬과 선택 정렬을 비교하면 아래와 같다.\r\n\r\n|  $N$  | 버블 정렬 | 선택 정렬 | 차이  |\r\n| :---: | :-------: | :-------: | :---: |\r\n|   5   |    20     |    14     |  30%  |\r\n|  10   |    90     |    54     |  40%  |\r\n|  20   |    380    |    199    | 52.4% |\r\n|  40   |   1560    |    819    | 52.5% |\r\n|  80   |   6320    |   3229    | 51.1% |\r\n|  100  |   9900    |   5049    |  51%  |\r\n\r\n버블 정렬 대비 선택 정렬의 속도가 50%로 수렴한다. 즉, 최악의 경우에도 선택 정렬이 두 배 가량 빠르다는 걸 알 수 있다.\r\n\r\n## 5-5. 상수 무시하기\r\n\r\n이전 문단에서의 디테일한 비교로 버블 정렬과 선택 정렬 간의 유의미한 차이가 있음을 확인했다. 선택 정렬을 빅 오 표기법으로 나타내면 $O(N^2 / 2)$가 된다.\r\n\r\n|  $N$  | $N^2 / 2$ | 선택 정렬의 작업량 |\r\n| :---: | :-------: | :----------------: |\r\n|   5   |   12.5    |         14         |\r\n|  10   |    50     |         54         |\r\n|  20   |    200    |        199         |\r\n|  40   |    800    |        819         |\r\n|  80   |   3200    |        3229        |\r\n|  100  |   5000    |        5049        |\r\n\r\n위 표가 이를 뒷받침해준다. 하지만 실제 버블 정렬과 선택 정렬의 빅 오 표기법은 둘 다 동일하게 $O(N^2)$이다. 실제로 선택 정렬 또한 <span class=\"red-400\">반복문이 두 번 중첩</span>되어있다. $O(N^2)$의 특징이 그대로 나타나있는 것이다. 이는 빅 오 표기법이 처음 소개된 3장부터 꾸준히 언급되었던 특징으로, <span class=\"teal-400\">빅 오 표기법은 상수를 무시</span>한다.\r\n\r\n분명히 상수도 유의미한 수인데, 명색이 **성능**을 측정한다는 기법이 왜 이렇게 느슨한 형태를 가지는 걸까?\r\n\r\n## 5-6. 빅 오의 역할\r\n\r\n빅 오 표기법은 왜 상수를 무시할까? 이는 빅 오 표기법이 가지는 관점 때문이라고 설명할 수 있다. $O(N)$과 $O(N^2)$, $O(100N)$과 $O(N^2)$의 작업량을 비교하면서 빅 오 표기법이 알고리즘을 어떤 관점으로 바라보는지 확인해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793374-db4248af-daf1-4e02-8622-c16d2a2c9f69.png\" width=\"800px\" />\r\n</p>\r\n\r\n$O(N^2)$의 경우, 어떠한 경우에든 $O(N)$보다 같거나 느리다. 하지만 $O(100N)$의 경우는 살짝 다르다. 데이터가 적은 앞 구간에선 오히려 $O(N^2)$이 더 빠르지만, 충분히 데이터가 많아진 이후로는 $O(100N)$이 더 빠르다.\r\n\r\n빅 오 표기법이 상수에 크게 미련을 갖지 않는 이유다. $O(N)$, $O(N^2)$과 같이 구간이 완전히 다를 경우 항상 빠르거나, 반대로 느리다.\r\n\r\n그러나 $O(100N)$, $O(N^2)$의 경우 데이터의 양에 따라 상대적으로 빠르기도 하고, 느리기도 하다. 이런 경우의 알고리즘을 서로 구분하기 위해 빅 오 표기법은 상수를 무시한다. 어차피 $O(N)$이나 $O(100N)$이나 장기적으론 $O(N^2)$보다는 빨라지기 때문이다.\r\n\r\n빅 오 표기법은 여전히 구간이 전혀 다른 알고리즘을 상대로는 유효한 성능 판단의 척도다. 시간 복잡도가 동일하더라도, 실제로 보여주는 알고리즘의 성능은 차이가 있을 수 있다는 점을 감안하자.\r\n\r\n## 5-7. 실제 예제\r\n\r\n요소 $N$개를 가진 배열에서 두 요소 중 하나만 선택하여 $N \\div 2$의 요소를 가지는 새로운 배열을 만드는 알고리즘을 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 선택 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/23/about-algorithm-chapter05/\">빅 오를 사용하거나 사용하지 않는 코드 최적화</a>\r\n * @since 2021.07.23 Fri 22:32:54\r\n */\r\npublic class HalfArray\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = solve(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 결과 배열\r\n\t */\r\n\tprivate static int[] solve(int[] array)\r\n\t{\r\n\t\tint length = (int) Math.ceil(array.length / 2D);\r\n\t\t\r\n\t\tint[] result = new int[length];\r\n\t\t\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < array.length; i++)\r\n\t\t{\r\n\t\t\t// 인덱스가 짝수일 경우\r\n\t\t\tif (i % 2 == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[count] = array[i];\r\n\t\t\t\t\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[0, 2, 4, 6, 8]\r\n```\r\n\r\n위 알고리즘은 배열의 모든 원소를 순회하며, 인덱스가 짝수일 경우 해당 값을 추출하여 새로운 배열로 만들어 반환한다.\r\n\r\n해당 알고리즘은 <span class=\"orange-400\">탐색</span>과 <span class=\"orange-400\">삽입</span>으로 이루어져있다.\r\n\r\n* 탐색: $N$개\r\n* 삽입: $N / 2$개\r\n\r\n즉, 위 알고리즘의 정확한 시간 복잡도는 $O(1.5N)$이며, 위에서 언급했듯이 상수를 무시하므로 $O(N)$으로 표기한다.\r\n\r\n위 알고리즘을 조금 더 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 배열 선택 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/23/about-algorithm-chapter05/\">빅 오를 사용하거나 사용하지 않는 코드 최적화</a>\r\n * @since 2021.07.23 Fri 22:51:52\r\n */\r\npublic class ImproveHalfArray\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"요소의 갯수가 짝수개인 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = solve(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 결과 배열\r\n\t */\r\n\tprivate static int[] solve(int[] array)\r\n\t{\r\n\t\tint length = (int) Math.ceil(array.length / 2D);\r\n\t\t\r\n\t\tint[] result = new int[length];\r\n\t\t\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < array.length; i += 2)\r\n\t\t{\r\n\t\t\tresult[count] = array[i];\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[0, 2, 4, 6, 8]\r\n```\r\n\r\n위 알고리즘은 `solve` 메소드의 `for`부분을 향상시킨 알고리즘이다.\r\n\r\n``` java\r\nfor (int i = 0; i < array.length; i += 2)\r\n{\r\n\tresult[count] = array[i];\r\n\t\r\n\tcount++;\r\n}\r\n```\r\n\r\n요소를 하나한 탐색하여 그 중 짝수인 인덱스를 판별하는 것이 아니라, 애초에 짝수 인덱스만을 탐색하여 삽입한다. 즉, 탐색의 작업이 50% 감소했다.\r\n\r\n* 탐색: $N / 2$개\r\n* 삽입: $N / 2$개\r\n\r\n이 알고리즘은 정직하게 $O(N)$의 시간 복잡도를 가진다. 엄밀히 따지면 아래의 알고리즘이 더 우수한 성능을 가지지만, 시간 복잡도의 관점에서는 둘 다 동일하다.\r\n\r\n같은 시간 복잡도를 가진다고 해도, 데이터의 양이 무수히 많을 경우 아래의 알고리즘이 더 적합할 것이다.\r\n\r\n# 마무리\r\n\r\n이 장에서 주로 얘기한 내용은 아래와 같다.\r\n\r\n* 빅 오 표기법은 비관적인 관점을 가지므로 시간 복잡도의 상수를 무시한다.\r\n* 시간 복잡도가 같아도, 실제 성능은 유의미하게 차이날 수 있다.\r\n\r\n간혹 여러 사람을 만나다보면 인생을 항상 부정적인 관점으로 바라보는 사람이 더러 있다. 아마 빅 오 표기법이 의인화된다면 이런 사람이 되지 않을까 싶다.\r\n\r\n부정적으로 보는 것이 좋을 때도 있겠지만, **언제나**라는 말이 통용되진 않는다. 세상엔 수 많은 관점이 존재하고, 이는 알고리즘도 예외는 아니다. 다행히, 현실에서 대부분의 일은 평범의 범주 안에서 일어난다.\r\n\r\n다음 장에서는 부정적인 관점에서 벗어나, 평균적인 관점으로 바라보는 시간을 가져보자.","url":["2021-07-23-about-algorithm-chapter05","2021","07","23","about-algorithm-chapter05"]},{"header":{"title":"빅 오로 코드 속도 올리기","excerpt":"이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-16T21:39:54","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","버블 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-16-about-algorithm-chapter04.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 4장 빅 오로 코드 속도 올리기\r\n\r\n이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.\r\n\r\n## 4-1 버블 정렬\r\n\r\n배열을 효과적으로 다루기 위해 <span class=\"primary\">정렬</span> 기법이 폭넓게 이용된다. <span class=\"orange-A400\">이진 검색</span>에서도 겪었듯이, 정렬된 배열은 배열의 요소를 어느정도 **예측**할 수 있도록 규칙성을 부여한다. 이러한 이유로 배열을 정렬하는 다양한 기법이 고안되었으며, 이 문단에서는 정렬 중 가장 기본적이면서 상대적으로 비효율적인 <span class=\"orange-A400\">버블 정렬</span>에 대해 알아본다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947608-e434441d-f735-44d6-8634-32431c152333.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같은 배열이 존재할 때, 버블 정렬은 이를 어떻게 오름차순으로 정렬하는 지 알아보자.\r\n\r\n1. 우선 맨 첫 요소와 그 다음 요소를 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\" />\r\n</p>\r\n\r\n2. 앞의 요소가 뒤의 요소보다 클 경우 서로 교환(swap)한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\" />\r\n</p>\r\n\r\n3. 각각 한 칸씩 이동하여 다음 요소를 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\" />\r\n</p>\r\n\r\n4. 1 ~ 3의 과정을 반복한다.\r\n\r\n더 이상 교환이 이루어지지 않을 때까지 1 ~ 3의 과정을 반복한다. 이러한 반복을 <span class=\"primary\">패스스루(passthrough)</span>라 명칭한다.\r\n\r\n## 4-2. 버블 정렬 실제로 해보기\r\n\r\n이전 문단에서 <span class=\"orange-A400\">버블 정렬</span>의 원리를 알았으니 실제로 적용하여 배열을 완전히 정렬해보자.\r\n\r\n대상 배열은 이전 문단에서 사용된 배열과 동일하다.\r\n\r\n1. 패스스루 1: 8과 4 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 4를 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\" />\r\n</p>\r\n\r\n2. 패스스루 1: 8과 6 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 6을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947635-b30df0e3-2b2b-4bee-b727-8bf070c82c73.png\" width=\"600px\" />\r\n</p>\r\n\r\n3. 패스스루 1: 8과 7 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947646-ce35e2d1-0428-4e84-b8da-c2b17a13485c.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 7을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947652-f53b26ef-f291-4c64-9719-e4886aff91b6.png\" width=\"600px\" />\r\n</p>\r\n\r\n4. 패스스루 1: 8과 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947657-a374227c-855e-4b88-aba0-a8eb9ee881ca.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947666-5574d74d-9d9a-4ff3-b145-9e9b341df0c3.png\" width=\"600px\" />\r\n</p>\r\n\r\n가장 마지막 배열의 요소까지 도달했으므로, 가장 마지막 요소인 8은 올바른 위치에 정렬되어 있다. 오름차순에서 배열의 가장 마지막 요소에는 가장 큰 값이 와야하므로, 배열의 요소 중 가장 큰 값인 8이 오는 것이 적절하다.\r\n\r\n이미 정렬되어있으므로, 다음 패스스루에선 마지막 요소는 비교하지 않아도 된다. 즉, <span class=\"teal-400\">패스스루가 진행될 수록 비교할 요소의 범위가 작아진다.</span>\r\n\r\n정렬이 완료된 요소는 <span class=\"yellow-400\">노란색</span>으로 표시한다.\r\n\r\n5. 패스스루 2: 4와 6 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947681-5b8ec91b-9da1-41da-9906-6d9e99c4fdd8.png\" width=\"600px\" />\r\n</p>\r\n\r\n4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n6. 패스스루 2: 6과 7 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947698-af6eae59-b9e5-4075-a7e5-e433c8888a6b.png\" width=\"600px\" />\r\n</p>\r\n\r\n6과 7을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n7. 패스스루 2: 7과 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947709-19eefa54-e834-41cc-9ba2-f57d23424e9c.png\" width=\"600px\" />\r\n</p>\r\n\r\n7과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947720-2fca7b88-3f84-422b-af78-77e57779270f.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소 7이 완전히 정렬됐다. 다음 패스스루를 시작한다.\r\n\r\n8. 패스스루 3: 4와 6 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947722-d73f88f3-3c12-4c19-9c85-0feb6bd4b3a9.png\" width=\"600px\" />\r\n</p>\r\n\r\n4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n9. 패스스루 3: 6과 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947729-b420b29e-3c9b-42c2-8fe2-88d509da6b91.png\" width=\"600px\" />\r\n</p>\r\n\r\n6과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947744-2d71db3b-e35b-457f-ba35-84d05e2a6088.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소 6이 완전히 정렬됐다. 다음 패스스루를 시작한다.\r\n\r\n10. 패스스루 4: 4와 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947755-4833cd65-a86e-48c7-8413-d5e8df9c624c.png\" width=\"600px\" />\r\n</p>\r\n\r\n4와 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947767-d8163c94-8fbc-43ec-9b17-5567b9714eb5.png\" width=\"600px\" />\r\n</p>\r\n\r\n가장 마지막 패스스루이므로, 모든 요소가 정렬됐다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947774-a376dc47-0102-4ff1-8b08-d65cb8175cf0.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬된 배열은 위와 같으며, 총 10번의 작업이 이루어졌다.\r\n\r\n## 4-3. 버블 정렬 구현\r\n\r\n<span class=\"orange-A400\">버블 정렬</span>을 직접 코드로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 버블 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/16/about-algorithm-chapter04/\">빅 오로 코드 속도 올리기</a>\r\n * @since 2021.07.16 Fri 19:11:19\r\n */\r\npublic class BubbleSort\r\n{\r\n\t// 배열\r\n\tprivate static int[] array;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"버블 정렬할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tarray = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] count = bubbleSort();\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(count[0]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 스왑 작업량: \");\r\n\t\twriter.write(String.valueOf(count[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(count[0] + count[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 버블 정렬 및 작업량 반환 함수\r\n\t *\r\n\t * @return [int[]] 비교 작업량과 스왑 작업량\r\n\t */\r\n\tprivate static int[] bubbleSort()\r\n\t{\r\n\t\t// 비교 작업량\r\n\t\tint compareCount = 0;\r\n\t\t\r\n\t\t// 스왑 작업량\r\n\t\tint swapCount = 0;\r\n\t\t\r\n\t\t// 스왑 여부\r\n\t\tboolean isSwaped = true;\r\n\t\t\r\n\t\t// 비교 인덱스\r\n\t\tint index = array.length - 1;\r\n\t\t\r\n\t\t// 스왑이 일어나지 않을 때까지\r\n\t\twhile (isSwaped)\r\n\t\t{\r\n\t\t\tisSwaped = false;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < index; i++)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소가 다음 요소보다 클 경우\r\n\t\t\t\tif (array[i] > array[i + 1])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 스왑 발생\r\n\t\t\t\t\tisSwaped = true;\r\n\t\t\t\t\tswapCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint temp = array[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[i] = array[i + 1];\r\n\t\t\t\t\tarray[i + 1] = temp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tindex--;\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { compareCount, swapCount };\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 사용자로부터 공백으로 구분된 숫자를 입력받아 버블 정렬을 수행하는 알고리즘이다.\r\n\r\n* 입력\r\n\r\n``` tc\r\n5 4 12 6 77 32 1 9 11 59\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 4, 5, 6, 9, 11, 12, 32, 59, 77]\r\n\r\n - 읽기 작업량: 42\r\n - 스왑 작업량: 16\r\n - 총 작업량: 58\r\n```\r\n\r\n실제 버블 정렬이 수행되는 알고리즘은 아래와 같다.\r\n\r\n``` java\r\n/**\r\n * 버블 정렬 및 작업량 반환 함수\r\n *\r\n * @return [int[]] 비교 작업량과 스왑 작업량\r\n */\r\nprivate static int[] bubbleSort()\r\n{\r\n\t// 비교 작업량\r\n\tint compareCount = 0;\r\n\t\r\n\t// 스왑 작업량\r\n\tint swapCount = 0;\r\n\t\r\n\t// 스왑 여부\r\n\tboolean isSwaped = true;\r\n\t\r\n\t// 비교 인덱스\r\n\tint index = array.length - 1;\r\n\t\r\n\t// 스왑이 일어나지 않을 때까지\r\n\twhile (isSwaped)\r\n\t{\r\n\t\tisSwaped = false;\r\n\t\t\r\n\t\tfor (int i = 0; i < index; i++)\r\n\t\t{\r\n\t\t\tcompareCount++;\r\n\t\t\t\r\n\t\t\t// 현재 요소가 다음 요소보다 클 경우\r\n\t\t\tif (array[i] > array[i + 1])\r\n\t\t\t{\r\n\t\t\t\t// 스왑 발생\r\n\t\t\t\tisSwaped = true;\r\n\t\t\t\tswapCount++;\r\n\t\t\t\t\r\n\t\t\t\tint temp = array[i];\r\n\t\t\t\t\r\n\t\t\t\tarray[i] = array[i + 1];\r\n\t\t\t\tarray[i + 1] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tindex--;\r\n\t}\r\n\t\r\n\treturn new int[] { compareCount, swapCount };\r\n}\r\n```\r\n\r\n* `compareCount`: 비겨 작업량 카운트\r\n* `swapCount`: 스왑 작업량 카운트\r\n* `isSwaped`: 스왑 여부\r\n* `index`: 정렬 인덱스\r\n\r\n`index`는 정렬을 하기위한 배열의 최대 인덱스다. 1을 빼주는 이유는 버블 정렬의 특성 때문이다. $[0, 1, 2]$와 같은 배열의 최대 인덱스는 3이다. 배열의 최대 인덱스가 3일 때 첫 패스스루의 작업 갯수는 0과 1, 1과 2로 2번 일어난다. 최대 인덱스를 하나 빼주지 않으면 0과 1, 1과 2, 2와 무엇인가를 비교하려 하기 때문에 배열 초과 예외인 `ArrayIndexOutOfBoundsException`가 발생한다.\r\n\r\n`while`문을 통해 스왑이 일어나지 않을 때까지 반복한다. <span class=\"pink-A400\">패스스루 내에서 스왑이 한 번도 일어나지 않으면 정렬이 완료</span>된 것으로 간주하여 종료한다.\r\n\r\n`for`문을 통해 인덱스 크기까지 비교하여 현재 배열보다 다음 배열이 더 클 경우 스왑한다. 이 과정에서 `isSwaped`이 `true`로 할당된다. `isSwaped`가 `true`이므로 다음 프로세스가 패스스루가 진행될 것이다.\r\n\r\n해당하는 각 과정은 카운팅된다.\r\n\r\n## 4-4. 버블 정렬의 효율성\r\n\r\n버블 정렬은 두 가지 작업으로 이루어진다.\r\n\r\n* **비교**: 더 큰 수를 찾기위해 비교한다.\r\n* **교환**: 정렬하기 위해 스왑한다.\r\n\r\n요소 5개가 있을 때, 아래와 같은 <span class=\"blue-400\">비교</span>작업이 이루어진다.\r\n\r\n* 패스스루 1: 총 4번의 비교\r\n* 패스스루 2: 총 3번의 비교\r\n* 패스스루 3: 총 2번의 비교\r\n* 패스스루 4: 총 1번의 비교\r\n* 패스스루 5: 비교 없음 (정렬 완료)\r\n\r\n즉, 4 + 3 + 2 + 1로 총 10번의 비교가 일어난다.\r\n\r\n그렇다면 <span class=\"blue-400\">스왑</span>작업은 어떨까? 스왑은 상황에 따라 일어날 수도, 일어나지 않을 수도 있다.\r\n\r\n이전 장에서 <span class=\"red-400\">알고리즘은 언제나 비관적인 관점</span>으로 접근한다고 했으니, 스왑이 언제나 일어날 경우를 가정하자.\r\n\r\n> 가장 최악의 버블 정렬 케이스  \r\n> 버블 정렬은 하나의 요소와 다음 요소를 비교하여 정렬하는 알고리즘이다. 만약 오름차순으로 정렬할 경우, 내림차순으로 정렬된 배열을 입력할 때 가장 최악의 케이스가 된다. 이 경우 모든 요소에 비교와 스왑이 일어난다.\r\n\r\n최악의 케이스인 내림차순으로 정렬된 요소 5개가 있을 때, 아래와 같은 <span class=\"blue-400\">스왑</span>작업이 이루어진다.\r\n\r\n* 패스스루 1: 총 4번의 스왑\r\n* 패스스루 2: 총 3번의 스왑\r\n* 패스스루 3: 총 2번의 스왑\r\n* 패스스루 4: 총 1번의 스왑\r\n* 패스스루 5: 스왑 없음 (정렬 완료)\r\n\r\n비교와 동일한 작업량이 발생한다. 이를 표로 정리하면 아래와 같다.\r\n\r\n|  $N$  | 작업 수 | $N^2$ |\r\n| :---: | :-----: | :---: |\r\n|   5   |   20    |  25   |\r\n|  10   |   90    |  100  |\r\n|  20   |   380   |  400  |\r\n|  40   |  1560   | 1600  |\r\n|  80   |  6320   | 6400  |\r\n|  100  |  9900   | 10000 |\r\n\r\n요소 $N$개 배열에서 버블 정렬의 최대 작업량은 $N(N - 1)$이다. 이전 장에서도 언급했 듯이, 알고리즘은 $O(N^2)$와 $O(N^2 - N)$과 크게 차이를 두지 않는다. 즉, 버블 정렬의 시간 복잡도는 $O(N^2)$가 된다.\r\n\r\n$O(N^2)$은 $O(N)$ 보다도 작업량이 급격히 증가한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947786-fb410c06-799f-4041-8827-9a946a8d076e.png\" width=\"600px\" />\r\n</p>\r\n\r\n이를 비교하면 더욱 한눈에 알 수 있다. 이 $O(N^2)$을 <span class=\"orange-A400\">이차 시간</span>이라고 명칭한다.\r\n\r\n## 4-5. 이차 문제\r\n\r\n위에서 버블 정렬에 대한 알고리즘을 설계했다. 시간 복잡도는 무려 $O(N^2)$을 가진다. 이전 장에서 선형 검색과 이진 검색을 비교하며 최대한 시간 복잡도를 줄이는게 좋다고 손아프게 적은게 무색할 정도로, 이 알고리즘의 효율은 지면을 뜷고 추락하고있다.\r\n\r\n여기 비슷한 이차 시간 알고리즘이 있다. 입력한 요소의 중복 여부를 판별하는 알고리즘이다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 중복 확인 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/16/about-algorithm-chapter04/\">빅 오로 코드 속도 올리기</a>\r\n * @since 2021.07.16 Fri 20:46:15\r\n */\r\npublic class DuplicateCheck\r\n{\r\n\tprivate static int count = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tboolean result = isDuplicated(array);\r\n\t\t\r\n\t\t// 중복된 요소가 있을 경우\r\n\t\tif (result)\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재합니다.\");\r\n\t\t}\r\n\t\t\r\n\t\t// 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재하지 않습니다.\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\"작업량: \");\r\n\t\twriter.write(String.valueOf(count));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소의 중복 여부 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t *\r\n\t * @return [boolean] 중복 여부\r\n\t */\r\n\tprivate static boolean isDuplicated(int[] array)\r\n\t{\r\n\t\tfor (int i = 0; i < array.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < array.length; j++)\r\n\t\t\t{\r\n\t\t\t\tcount++;\r\n\t\t\t\t\r\n\t\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\t\tif (i != j && array[i] == array[j])\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력\r\n\r\n``` java\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` java\r\n중복된 요소가 존재하지 않습니다.\r\n작업량: 100\r\n```\r\n\r\n위 알고리즘도 마찬가지로 $N = 10$일 때 최악의 경우 $O(N^2)$의 시간 복잡도를 가진다.\r\n\r\n중복을 판별하는 핵심 동작을 보자.\r\n\r\n``` java\r\n/**\r\n * 요소의 중복 여부 반환 함수\r\n *\r\n * @param array: [int[]] 배열\r\n *\r\n * @return [boolean] 중복 여부\r\n */\r\nprivate static boolean isDuplicated(int[] array)\r\n{\r\n\tfor (int i = 0; i < array.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < array.length; j++)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\tif (i != j && array[i] == array[j])\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n버블 정렬과 마찬가지로 중첩 반복문이 존재한다. 중첩 반복문이 있을 경우, 반복문의 갯수만큼 시간 복잡도가 급격히 올라간다.\r\n\r\n중첩 반복문은 $N$개의 요소를 $N$번 만큼 작업한다. 반복문의 중첩이 심해지면 심해질 수록 $N$번의 $N$번의 $N$번의... 와 같은 작업을 반복할 것이다. 물론 시간 복잡도의 크기가 하늘 높은줄 모르고 치솟는 것도 포함된다.\r\n\r\n즉, 어디가서 중첩 반복문을 사용하는 알고리즘을 봤다면 그 알고리즘의 시간 복잡도는 최소 $O(N^2)$임을 바로 유추할 수 있다.\r\n\r\n## 4-6. 선형 해결법\r\n\r\n이전 장에서, 선형 검색과 이진 검색의 시간복잡도를 비교하며 $O(N)$이 $O(\\log N)$보다 얼마나 비효율적인지 손가락이 아플 정도로 설명했던 걸로 기억한다. 그런데 방금의 두 알고리즘은 아픈 손가락이 무색해질 정도로 미칠듯한 비효율을 선사하고 있다.\r\n\r\n<i align=\"center\">아니, 니가 알고리즘을 많이 안 짜봐서 그런가본데, 그렇게 설계할 수 밖에 없는 알고리즘도 있거든??</i>\r\n\r\n물론 맞는 말이다. 백준만 해도 로직이 복잡해서 중첩 반복문을 사용하기도 한다. 실무에서도 마찬가지다. 로직이 복잡하거나, 소스 최적화의 비용이 너무 높거나 혹은 효율이 극악이거나. 아니면 컴퓨터 성능이 충분히 좋아서 굳이 그렇게 머리 아픈일에 투자할 필요를 못 느낄 수도 있다.\r\n\r\n여담으로, 실제로 큰 기업은 이런 최적화 보다도 컴퓨팅 성능을 극대화시키는 방법을 많이 선택한다고 한다. 로직이야 어차피 한정적으로 적용되고, 차라리 컴퓨터 성능을 올리는게 오히려 싸게 먹히기도 한다. 로직과 달리 컴퓨팅 자원은 다른 곳에 써먹을 수도 있으니 이쪽이 더 범용적이다.\r\n\r\n필자의 컴퓨터도 작성일 기준으로 그리 못난 편은 아니지만, 안타깝게도 위에 작성한 중복 판별 알고리즘은 최적화의 비용이 매우 저렴한 편이다. 우리는 공부를 목적으로 하니 한 번 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 중복 확인 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/16/about-algorithm-chapter04/\">빅 오로 코드 속도 올리기</a>\r\n * @since 2021.07.16 Fri 21:18:05\r\n */\r\npublic class ImproveDuplicateCheck\r\n{\r\n\tprivate static int count = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tboolean result = isDuplicated(array);\r\n\t\t\r\n\t\t// 중복된 요소가 있을 경우\r\n\t\tif (result)\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재합니다.\");\r\n\t\t}\r\n\t\t\r\n\t\t// 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재하지 않습니다.\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\"작업량: \");\r\n\t\twriter.write(String.valueOf(count));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소의 중복 여부 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t *\r\n\t * @return [boolean] 중복 여부\r\n\t */\r\n\tprivate static boolean isDuplicated(int[] array)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item : array)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 중복되지 않았을 경우\r\n\t\t\tif (!list.contains(item))\r\n\t\t\t{\r\n\t\t\t\tlist.add(item);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 중복된 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력\r\n\r\n``` java\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` java\r\n중복된 요소가 존재하지 않습니다.\r\n작업량: 10\r\n```\r\n\r\nJAVA의 가변 배열 `ArrayList` 클래스를 활용하여 구현했다. 요소가 한 번도 나오지 않았을 경우, `list`에 존재하지 않을 것이므로 넣어준다. 이후 동작 중에 이미 `list`에 존재하는 숫자가 발견될 경우, 중복된 요소이므로 종료하고 결과를 반환한다.\r\n\r\n$N = 10$일 때 $O(N)$의 시간 복잡도로 대폭 개선됨을 확인할 수 있다. 이전의 결과와 비교하면 무려 <span class=\"lightBlue-A400\">10배의 차이</span>로, 산술적으로 이전 알고리즘이 1번 동작할 동안 개선된 알고리즘은 10번 동작할 수 있다.\r\n\r\n지금은 $N = 10$으로 요소 자체가 작아서 체감이 되지 않을 수도 있지만, $N = 10,000$일 경우 무려 <span class=\"lightBlue-A400\">10,000배의 차이</span>가 발생한다.\r\n\r\n알고리즘의 최적화가 중요한 이유가 여기에 있다. 처리하는 데이터가 빅데이터에 가까워질수록 그 효율이 미친듯이 상승하기 때문.\r\n\r\n# 마무리\r\n\r\n이 장에서 배운 점을 정리하면 아래와 같다.\r\n\r\n* 반복문의 중첩 여부, 갯수를 통해 시간 복잡도를 유추할 수 있다.\r\n* 시간 복잡도를 통해 알고리즘의 성능 향상을 수치상으로 비교, 표시할 수 있다.\r\n\r\n사실 정리해놓고 보니 뭐 별 거 아닌, 당연한 얘기를 가지고 광활하게 설명했나 싶기도 하다. 난 이 당연한 걸 제대로 몰랐던 거고.\r\n\r\n이런 알고리즘도 있다. 속도가 비슷해서 빅 오 표기로는 그 차이가 보이지 않을 경우. 하지만 그럼에도 확실히 어떠한 요인으로든 차이가 발생할 것이다. 다음 장에서는 이러한 알고리즘에 대한 최적화에 대해 알아본다.","url":["2021-07-16-about-algorithm-chapter04","2021","07","16","about-algorithm-chapter04"]},{"header":{"title":"빅 오 표기법","excerpt":"하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 문제를 해결하는 효율성의 차이 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-14T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","빅 오 표기법"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-14-about-algorithm-chapter03.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 3장 빅 오 표기법\r\n\r\n하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 <span class=\"orange-A400\">문제를 해결하는 효율성의 차이</span> 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.\r\n\r\n이러한 알고리즘의 성능을 하나의 규칙으로 표기한 것이 <span class=\"primary\">빅 오 표기법</span>이다. 이 장에서는 알고리즘의 빅 오 표기법에 대해 설명한다.\r\n\r\n## 3-1. 빅 오: 단계 수 계산\r\n\r\n보통 알고리즘의 성능을 측정한다고 하면 소요시간을 생각하겠지만, 의외로 소요시간은 객관적인 성능 지표가 되지 못 한다. 그 이유는 컴퓨터마다 성능이 제각각이기 때문. 똑같은 게임을 구동해도 어떤 컴퓨터는 울트라옵으로 165 프레임을 뽑는다고 하면, 다른 컴퓨터는 최하옵으로도 버벅일 수 있다. <span class=\"teal-400\">동일한 작업을 수행해도 컴퓨터의 성능에 따라 그 소요시간이 천차만별</span>로 달라진다.\r\n\r\n때문에 <span class=\"green-A400\">알고리즘의 성능을 측정하는 적절한 지표는 처리 단계</span>라 할 수 있다. 이전 장의 <span class=\"primary\">읽기 연산</span>과 <span class=\"primary\">선형 검색</span>을 통해 예를 들어보자.\r\n\r\n읽기 연산의 경우, 배열이 10개가 있던 1억개가 있던 관계없이 인덱스 i의 요소를 읽는데 필요한 단계는 하나다. 반대로 선형 검색의 경우, 요소가 많아지면 많아질 수록 연산에 요구되는 단계가 늘어난다. 배열 $N$개가 있을 때, 찾는 요소가 배열 맨 끝에 있는 최악의 경우 $N$개의 단계가 필요하다.\r\n\r\n즉, 읽기 연산의 경우 언제나 한 단계만 필요하므로 $O(1)$로 표기할 수 있으머, 선형 검색의 경우 $O(N)$으로 표기할 수 있다. 이러한 표기를 <span class=\"amber-400\">시간 복잡도</span>라 한다.\r\n\r\n## 3-2. 상수 시간과 선형 시간\r\n\r\n읽기 연산처럼 요소의 갯수에 상관없이 일정한 단계만을 필요로하는 연산이 있는가 하면, 선형 검색처럼 요소의 크기에 따라 단계가 가변하는 연산도 존재한다. 이전 문단에서 언급했듯이 읽기 연산의 시간 복잡도는 $O(1)$, 선형 검색의 시간 복잡도는 $O(N)$으로 표기할 수 있다. 이를 그래프로 비교하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599099-db099ea5-e3e9-4b79-ad19-700870b07891.png\" width=\"600px\" />\r\n</p>\r\n\r\n$O(N)$의 경우 우리가 흔히 접한 1차원 그래프 $y = x$와 패턴이 동일하다. 요소의 수가 1씩 증가할 수록 단계 또한 1씩 정직하게 증가한다. 이러한 패턴을 <span class=\"primary\">선형 시간</span>이라고 표현한다. 그러나 $O(1)$의 경우 단계에 관계없이 일정한 상수 그래프 $y = 1$와 패턴이 동일하다. 이러한 패턴을 <span class=\"primary\">상수 시간</span>이라고 표현한다.\r\n\r\n$O(1)$의 경우 조금 특이한데, 아래의 모든 그래프는 $O(1)$의 시간 복잡도를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599889-72b5cbb9-ca20-4b19-9f49-6d363b8ebec5.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 수에 관계 없이 두 단계를 요구하면 $O(2)$, 100 단계를 요구하면 $O(100)$일 것 같지만, 빅 오 표기법은 단계가 일정할 경우 이를 크게 신경쓰지 않는다. 즉, 설령 단계가 1억개가 된다 하더라도 시간 복잡도는 $O(1)$이 된다.\r\n\r\n<span class=\"red-400\">상수 시간의 경우 기본적으로 선형 시간보다 효율적</span>이라고 판단한다. 그 이유는 아래 그래프와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599827-0f58c448-9ab5-44dc-9bca-80d3ffd49d64.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n깊게 생각하지 않더라도, 선형적으로 증가하는 그래프는 언젠가 상수 그래프를 넘어서게 된다. 즉, 요소가 무수히 많아지는 거시적 관점으로 보면 <span class=\"red-400\">언젠가 선형 시간의 효율이 상수 시간보다 떨어지는 시점에 도달</span>한다. 예제를 보면 요소가 10개 이상일 경우 선형 시간의 효율성이 점점 떨어진다.\r\n\r\n그런데 선형 시간의 경우를 생각해보자. 분명히 단계가 최대 $N$개가 소요될 수 있다는 뜻이지, 항상 $N$개가 소요된다는 것은 아니다. 예를 들어, 1부터 오름차순으로 정렬된 1억개의 배열에서 5를 검색한다고 가정하면, 필요한 단계는 5밖에 안 된다. 그럼에도 책에서는 선형 시간보다 상수 시간이 비교적 효율적이라고 설명하고 있다. 그 이유는 뭘까? 다음 문단에서 그 해답을 찾을 수 있다.\r\n\r\n## 3-3. 같은 알고리즘, 다른 시나리오\r\n\r\n선형 검색은 검색하려는 요소의 위치에 따라서 생각보다 많은 시간이 소요되지 않을 수도 있다. 최선의 경우 요소가 맨 앞에 있으므로 단계가 하나만 필요하여 $O(1)$과 동일한 시간 복잡도를 가질 수도 있다. 그러나 최악의 경우 요소가 맨 끝에 있으므로 온전히 $N$개의 단계가 필요하여 $O(N)$의 시간 복잡도를 가진다.\r\n\r\n통상 알고리즘이 어떤 데이터를 얼마나 많이 처리할지 미리 알 수 없다. $O(N)$의 시간 복잡도를 가지는 임의의 알고리즘에 최선의 케이스를 적용하여 처리하면 $O(1)$에 가깝게 동작할 것이고, 최악의 케이스를 적용하여 처리하면 $O(N)$에 가깝게 동작할 것이다. <span class=\"orange-A400\">알고리즘은 기본적으로 가장 비관적인 접근</span>으로 바라본다.\r\n\r\n우리가 어떤 물건을 온라인으로 주문한다고 생각해보자. 내가 원하는 물건을 여러 업체에서 동일한 가격에 팔고 있지만, 택배 도착에 걸리는 시간이 다르다. 이는 업체의 페이지에 각각 아래와 같이 써있으며, 택배 도착은 이 시간을 절대로 벗어나지 않는다고 가정하자.\r\n\r\n* A업체: 빠르면 오늘, 늦으면 일주일 뒤\r\n* B업체: 빠르면 내일, 늦으면 3일 뒤\r\n* C업체: 빠르면 3일, 늦으면 5일 뒤\r\n\r\n우리가 3일 안으로 물건을 반드시 받아야 한다면 B업체가 가장 안전할 것이다. 물론 A업체에 주문하면 오늘 당장이라도 올 가능성이 있지만, 최악의 경우 일주일을 꼬박 기다려야 받게 될 수도 있기 때문에 3일을 넘어버릴 가능성 또한 무시할 수 없다. 빠르게 오면 단순히 좋은 정도지만, 3일을 넘어서면 안 되므로 A업체 또한 적절하지 않은 것이다. C업체는 말할 필요도 없고.\r\n\r\n알고리즘도 이러한 관점과 동일하다. $N$이 최대 100인 $O(N)$ 알고리즘이 있을 때, 성능 상의 이유로 단계가 50이 넘어가면 크래쉬를 유발할 경우 이 알고리즘은 적절하지 않다. 이와 같이 최악의 상황을 알아야 장애를 대비할 수 있다. 이러한 이유로 알고리즘의 성능은 항상 최악을 기준으로 표시한다.\r\n\r\n## 3-4 세 번째 유형의 알고리즘\r\n\r\n물론 시간 복잡도가 $O(1)$, $O(N)$만 있는 것은 아니다. 우리가 2장에서 다뤘던 이진 검색의 경우, 요소에 따라 단계가 증가하긴 하지만 $O(N)$과 같이 선형적으로 증가하지는 않는다. 즉, $O(1)$도 아니고, $O(N)$도 아닌 그 사이의 시간 복잡도를 가진다.\r\n\r\n이진 검색의 시간 복잡도는 기본적으로 $O(\\log_2N)$을 가진다. $O(1)$, $O(\\log_2N)$, $O(N)$가 요구하는 단계를 표로 표현하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125602081-0cc6075b-ba14-43c5-8aa6-52d8561559a3.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$, $O(\\log N)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n## 로가리즘\r\n\r\n우리가 흔히 부르는 $\\log$. 즉, 로그는 로가리즘(Logarithm)의 줄임말이다. $x^n = y$가 성립할 경우, 이를 로그로 표현하면 $\\log_xy = n$과 같다.\r\n\r\n예를 들어, $3^2 = 9$가 성립한다. 이를 로그로 표현하면 $\\log_39 =  2$가 된다. 이렇게 로그를 통해 수의 제곱수를 구할 수 있다.\r\n\r\n## $O(\\log N)$의 해석\r\n\r\n위 문단에서 로그에 대해 어느정도 이해를 했으니, $O(\\log N)$에 대해 논의해보자. 통상 수학에선 $\\log_{10}x$을 간략화하여 $\\log$로 표현했지만, 빅 오 표기법에서는 $\\log_2x$의 간략화다. <span class=\"orange-A400\">현실에선 십진법이 통용</span>되지만, <span class=\"orange-A400\">컴퓨터는 이진법을 사용</span>하기 때문.\r\n\r\n$O(N)$과 $O(\\log N)$를 비교하면 아래와 같다.\r\n\r\n|    $N$    |  $O(N)$   | $O(\\log N)$ |\r\n| :-------: | :-------: | :---------: |\r\n|     2     |     2     |      1      |\r\n|     4     |     4     |      2      |\r\n|     8     |     8     |      3      |\r\n|    16     |    16     |      4      |\r\n|    32     |    32     |      5      |\r\n|    64     |    64     |      6      |\r\n|    128    |    128    |      7      |\r\n|    256    |    256    |      8      |\r\n|    512    |    512    |      9      |\r\n|   1024    |   1024    |     10      |\r\n| $2^{100}$ | $2^{100}$ |     100     |\r\n\r\n$O(N)$는 $N$이 증가함에 따라 정직하게 같이 증가하지만, $O(\\log N)$은 $N$이 정확히 두 배가 될 때 1씩 증가한다.\r\n\r\n여담으로, 천문학같은 거시세계에서 로그가 중요한 이유가 위 표만으로도 쉽게 확인할 수 있다. $2^{100}$은 126,7650,6002,2822,9401,4967,0320,5376이다. 약 100양에 육박하는 수치로, 양은 수의 단위인 조를 아득히 뛰어넘는 단위다.\r\n\r\n> 거시적 수의 단위  \r\n> 일반적으로 사람이 접할 수 있는 의미 있는 단위는 조 단위로, 1억씩 천 번을 모아야 만들어지는 수치다.  \r\n> 조 단위 뒤로는 경, 해, 자, 양 순으로 나열되며, 현실에서 경 이후로는 그 수의 크기를 논하는게 의미가 없는 정도\r\n\r\n현실세계와 달리 수학이나 천문학과 같은 경우 우리에게 의미가 없을 정도로 큰 수를 다루기도 하는데, 이를 로그로 표현하면 이를 효과적으로 다룰 수 있다.\r\n\r\n## 3-7. 실제 예제\r\n\r\n지금까지 기술한 내용을 토대로 실제 코드에 적용해보자. 4개의 요소를 가진 배열이 있고, 배열의 값을 하나씩 출력하는 알고리즘이 있다고 가정해보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/14/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:40:00\r\n */\r\npublic class BigO\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열\r\n\t\tString[] things = { \"apples\", \"baboons\", \"cribs\", \"delcimers\" };\r\n\t\t\r\n\t\t// 배열마다 하나씩 순회\r\n\t\tfor (String thing : things)\r\n\t\t{\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(\"Here's a thing: \");\r\n\t\t\tbuilder.append(thing);\r\n\t\t\t\r\n\t\t\twriter.write(builder.toString());\r\n\t\t\twriter.newLine();\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHere's a thing: apples\r\nHere's a thing: baboons\r\nHere's a thing: cribs\r\nHere's a thing: delcimers\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n요소마다 하나씩 읽어 요소의 내용을 출력한다. 즉, <span class=\"blue-400\">요소가 많아지면 많아질 수록 같이 선형적으로 증가</span>하므로, 이 알고리즘의 시간 복잡도는 $O(N)$으로 표현할 수 있다.\r\n\r\n반대로 가장 기본적인 문자열 하나를 출력하는 알고리즘을 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/14/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:56:49\r\n */\r\npublic class BigO2\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"Hello world!\");\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHello world!\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n알고리즘이라 부르기는 조금 뭐하지만, 어쨌든 이 알고리즘을 수행하는 데 <span class=\"blue-400\">필요한 단계는 무조건 하나</span>다. 즉 시간 복잡도는 $O(1)$이다.\r\n\r\n좀 더 실속있는 예제를 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 소수 판별 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/14/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 18:01:20\r\n */\r\npublic class CheckPrime\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"소수를 판별할 값 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 입력값\r\n\t\tint target = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 소수일 경우\r\n\t\tif (isPrime(target))\r\n\t\t{\r\n\t\t\twriter.write(\"소수로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"소수가 아닌 것으로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 함수\r\n\t *\r\n\t * @param num: [int] 대상 값\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate static boolean isPrime(int num)\r\n\t{\r\n\t\tfor (int i = 2; i < num; i++)\r\n\t\t{\r\n\t\t\t// 나누어 떨어지는 수가 있을 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력값\r\n\r\n``` tc\r\n156842101\r\n```\r\n\r\n* 출력값\r\n\r\n``` tc\r\n소수가 아닌 것으로 판별됨\r\n```\r\n\r\n이 소스는 임의의 값을 입력받아 소수인지 아닌지를 판별하는 알고리즘이다. 이 알고리즘을 통해 156842101은 소수가 아님을 쉽게 알 수 있다.\r\n\r\n해당 알고리즘은 가장 작은 소수인 2부터 입력값 `target`까지 하나씩 증가시킨 값을 `target`과 나눠서 정확히 나눠떨어지는지 아닌지를 통해 소수를 판별하는 매우 기초적인 알고리즘이다.\r\n\r\n최악의 케이스는 판별값이 소수일 경우로,  2부터 `target - 1`까지의 작업 전체를 요구하므로 총 `target - 2`의 작업이 발생한다. $N = target$일 때, -2는 그렇게 의미있는 값이 아니므로 위 알고리즘의 시간 복잡도는 $O(N)$으로 봐도 무방하다.\r\n\r\n# 마무리\r\n\r\n알고리즘을 정석적으로 공부하지 않아서, 빅 오 표기법과 같은 시간 복잡도를 제대로 이해하지 않았었다. 시간 복잡도의 개념과 그 계산 방식을 알 수 있었던 매우 의미있는 장이였다.\r\n\r\n다음 장에선 이 빅 오 표기법을 활용하여 알고리즘을 개선하는 방법에 대해 설명한다.","url":["2021-07-14-about-algorithm-chapter03","2021","07","14","about-algorithm-chapter03"]},{"header":{"title":"알고리즘이 중요한 까닭","excerpt":"IT영역에서의 알고리즘이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. 개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구된다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열","정렬","이진 검색"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-10-about-algorithm-chapter02.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 2장 알고리즘이 중요한 까닭\r\n\r\nIT영역에서의 <span class=\"primary\">알고리즘</span>이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. <span class=\"teal-400\">개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구</span>된다.\r\n\r\n이러한 특징으로 알고리즘은 뛰어난 문제 해결력과 수학적 사고 능력을 요한다. 때문에 많은 사람들이 어려워하는 분야 중 하나지만, 그 강력함과 효율로 인해 개발 역량의 척도를 확인하는데 사용하기도 한다. 흔히 기업에서 보는 <span class=\"teal-400\">코딩 테스트</span>가 좋은 예시다.\r\n\r\n이 장에서는 <span class=\"primary\">알고리즘</span>을 통해 검색 연산을 더욱 효과적으로 개선하는 방법에 대해 설명한다. 이전 장에서 언급했듯이, 검색 연산은 무수히 많은 읽기 연산의 모음이나 다름없다. 알고리즘이 어떻게 읽기 연산을 최적화시키는지 알아보자.\r\n\r\n## 2-1. 정렬된 배열\r\n\r\n<span class=\"primary\">정렬된 배열</span>이란, 기존의 배열에서 요소들이 특정 조건으로 정렬된 배열을 의미한다. 정렬된 배열은 그 요소들이 항상 정해진 조건에 따라 순서대로 배치된다. 이는 삽입을 할 때도 동일하다. 정렬된 배열이 항상 정렬된 상태를 유지하기 위해선 <span class=\"red-A400\">삽입 시에도 요소의 정렬에 따라 정렬을 훼손하지 않는 올바른 자리에 삽입</span>되어야 한다.\r\n\r\n기존의 배열이라면 배열의 크기가 허락하는 한, 원하는 위치 어디에서나 삽입이 가능하다. 배열에 55를 삽입할 때, 일반적인 배열은 아래처럼 삽입에 제한이 없다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144062-a3b6c280-e157-11eb-88d6-20689d8f05b1.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 정렬된 배열이라면 어떨까? 이번엔 배열이 오름차순으로 정렬된 배열이라고 가정해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144070-aa453a00-e157-11eb-9390-1550623a57bd.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬된 위 배열에서 55를 삽입한다면 어떨까?\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144072-aca79400-e157-11eb-8939-cc0beb583b9b.png\" width=\"600px\" />\r\n</p>\r\n\r\n반드시 44와 94의 사이에 삽입되어야 오름차순 정렬을 유지할 수 있다. 그렇다면 우리는 여기서 정렬된 배열의 삽입은 기존의 삽입 연산에 비해 로직이 추가됨을 유추할 수 있다. 원리는 간단하다. 요소를 순차적으로 읽어서 55보다 큰 수가 나올 때까지 반복한다. 배열이 정렬되어 있으므로, 55보다 큰 수를 만나게 되면 이전의 요소는 모두 55보다 작을 것이다. 이 위치를 기준으로 삽입을 진행하면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144075-ae715780-e157-11eb-92ed-71ee06140c5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 그림과 같이 순차적으로 요소를 검색하여 55보다 큰 요소를 찾는다. 94는 배열에서 55보다 큰 가장 작은 수다.\r\n\r\n94의 인덱스인 4번째 요소에 55를 삽입하고, 94를 한 칸 뒤로 미룬다. 이 과정을 통해 정렬된 배열의 연산을 수행할 수 있다.\r\n\r\n그렇다면 이 고생을 뭐하러 사서하는 것일까? 그 이유는 검색의 최적화에 있다. <span class=\"orange-A400\">정렬된 배열은 그 자체로 순서라는 규칙성을 지니기 때문에 이를 활용한 알고리즘 적용이 가능</span>하기 때문이다. 이를 통해 검색의 작업량을 효과적으로 줄여 더욱 빠른 검색이 가능하다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 정렬된 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 02:41:14\r\n */\r\npublic class SortedArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 9, 14, 43, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tint result = run(item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(result);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 및 삽입된 인덱스 반환 함수\r\n\t *\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [int] 삽입된 인덱스\r\n\t */\r\n\tprivate static int run(int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\tinsert(result, item);\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자보다 배열의 값이 클 경우\r\n\t\t\tif (target < ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 인덱스에 55 삽입: [6, 9, 14, 43, 55, 94, -1, -1, -1, -1]\r\n```\r\n\r\n`insert` 함수는 이전 장에 나왔던 함수와 동일하지만, `find`의 경우 조금 달라졌다. `target == ARRAY[i]`로 동일한 값을 찾는 것이 아니라, `target < ARRAY[i]`로 삽입할 요소보다 큰 값을 찾도록 변경됐다. `run` 함수는 이를 적절히 구동하여 삽입된 인덱스를 반환한다.\r\n\r\n> **JAVA의 정렬 함수**  \r\n> 자바는 `Arrays.sort()`라는 함수가 제공되며, 인수로 정렬할 배열을 전달한다. 기본적으로 오름차순으로 정렬되며, 본인이 직접 정렬 함수를 오버라이딩함으로써 자신만의 조건으로 정렬되도록 설계할 수도 있다.\r\n\r\n## 2-3. 이진 검색\r\n\r\n우리가 앞에서 배열을 정렬한 이유가 바로 이 것이다. <span class=\"primary\">이진 검색</span>이라는 알고리즘을 적용하면 검색의 속도를 상당부분 개선할 수 있다. 심지어 이진 검색은 알고리즘 축에서는 매우 쉬운 편에 속한다. 심지어 우리는 이미 다른 형태로 이진 검색이라는 알고리즘을 접한 적이 있다.\r\n\r\n어렸을 때나, 혹은 술자리에서 Up & Down이라는 게임을 해본적이 있을 것이다. 진행자가 임의의 구간에 해당하는 임의의 수 하나를 머릿속으로 생각하면, 참가자들이 이 수를 맞추는 것이다. 참가자가 수를 말하면 진행자는 그 수가 자신의 수보다 큰 지, 작은 지 알려준다. 이걸 누군가 맞출 때까지 반복한다. 이진 검색의 원리는 이와 정확히 일치한다.\r\n\r\n<span class=\"red-A400\">이진 검색은 그 특성 상 정렬된 배열에서만 가능</span>하다. 1 ~ 100의 구간으로 순차적으로 정렬된 배열이 있다고 가정해보자. 찾아야 할 수가 68일 때, 이진 검색은 아래와 같이 이루어진다.\r\n\r\n1. 1과 100의 중간인 50과 비교한다. (작업 +1)\r\n2. 50은 68보다 작으로 51 ~ 100의 구간을 검색한다.\r\n3. 51과 100의 중간인 75와 비교한다. (작업 +1)\r\n4. 75는 68보다 크므로 51 ~ 74의 구간을 검색한다.\r\n5. 51과 74의 중간인 62와 비교한다. (작업 +1)\r\n6. 62는 68보다 작으므로 63 ~ 74의 구간을 검색한다.\r\n7. 63과 74의 중간인 68과 비교한다. (작업 +1)\r\n8. 검색이 종료된다.\r\n\r\n만약 순차적으로 검색했다면 1 부터 68까지 총 68번의 작업이 발생할 것을 단 4번의 작업으로 검색을 완료했다. 간단한 알고리즘을 적용하는 것으로도 작업량이 17배 줄어든 것이다. 지금은 구간이 작지만, 구간의 끝이 만 단위가 넘어간다면 검색하려는 숫자의 위치에 따라 작업량이 기하급수적으로 감소한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색을 구현한 소스는 위와 같다. 눈여겨 볼 부분은 `binarySearch` 함수다. 시작값 `start`는 1로 초기화되고, 끝값 `max`는 배열의 크기와 동일하다.\r\n\r\n`mid`를 계산하여 `target`과 크기비교를 한다. `target`이 더 클 경우, 중간값을 기준으로 윗 구간이므로 `start`를 `mid + 1`로 보정한다. 반대로 `target`이 더 작을 경우, 중간값을 기준으로 아랫 구간이므로 `end`를 `mid - 1`로 보정한다. 검색 대상값인 `target`과 중간값 `mid`가 동일할 때까지 알고리즘을 반복한다.\r\n\r\n1 ~ 100까지 차례대로 배치되어 있으므로, 1은 `ARRAY[0]`, 43은 `ARRAY[42]`로 값 자체로 인덱스나 다름없기 때문에 인덱스는 따로 구하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색의 단점이 있는데, 1 ~ 100의 구간이 있다고 가정하면, 1이나 100과 같은 <span class=\"orange-A400\">구간의 시작과 끝을 검색하는데 시간이 매우 오래 걸린다.</span> 이는 이진 검색이 중간값을 기준으로 검색한다는 특징으로 인한 단점이다. 위의 소스는 구간의 시작과 끝도 비교함으로써 이진 검색을 강화한 소스다.\r\n\r\n``` java\r\n// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\nif (target == start || target == end)\r\n{\r\n\tbreak;\r\n}\r\n```\r\n\r\n눈여겨 볼 부분은 `binarySearch` 함수의 해당 부분이다. 기존에 없던 `start`와 `end`의 비교 로직이 추가되어, <span class=\"orange-A400\">구간의 시작과 끝이 목표일 경우 더욱 빠르게 검색</span>할 수 있도록 보정한 것이다.\r\n\r\n| 구분  | 보정 전 | 보정 후 |\r\n| :---: | :-----: | :-----: |\r\n|   1   |    6    |    1    |\r\n|  51   |    6    |    2    |\r\n|  100  |    7    |    1    |\r\n\r\n## 2-4. 이진 검색 대 선형 검색\r\n\r\n1부터 순차적으로 하나하나 검색하는 알고리즘을 <span class=\"primary\">선형 검색</span>, 구간의 중간값을 기준으로 검색하는 알고리즘을 <span class=\"primary\">이진 검색</span>이라 한다. 우리가 2장까지 진행하면서, 배열의 일반적인 검색과 이진 검색에 대해 설계하고 차이점을 비교했다.\r\n\r\n선형 검색의 경우 요소의 갯수 $N$이 늘어나면 늘어날수록 예상되는 최대 작업량도 $N$개로 비례하여 늘어난다. 이에 비해 이진 검색의 경우 $N = 10,000$일 때, 책에 의하면 최대 작업량이 13이라고 한다. $N = 1,000,000$이면 작업량은 20으로, 선형 검색의 작업량이 1,000,000임을 감안하면 <span class=\"green-A400\">데이터가 많아질 수록 이진 검색으로 절약할 수 있는 기대 비용이 더욱 큼</span>을 알 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 검색 퍼포먼스 비교 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 04:21:37\r\n */\r\npublic class SearchCompare\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100000000;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 86421478;\r\n\t\t\r\n\t\tlong tic = System.nanoTime();\r\n\t\t\r\n\t\tint linearResult = find(target);\r\n\t\t\r\n\t\tlong toc1 = System.nanoTime() - tic;\r\n\t\t\r\n\t\ttic = System.nanoTime();\r\n\t\t\r\n\t\tint binaryResult = binarySearch(target);\r\n\t\t\r\n\t\tlong toc2 = System.nanoTime() - tic;\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 선형 검색 프로세스: \");\r\n\t\tbuilder.append(linearResult);\r\n\t\tbuilder.append(\"(\").append(toc1).append(\"ns)\\n\");\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 이진 검색 프로세스: \");\r\n\t\tbuilder.append(binaryResult);\r\n\t\tbuilder.append(\"(\").append(toc2).append(\"ns)\\n\\n\");\r\n\t\tbuilder.append(\"이진 검색이 약 \").append(toc1 / toc2).append(\"배 더 빠릅니다.\");\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n86421478을 탐색하는데 소요된 선형 검색 프로세스: 86421477(26936600ns)\r\n86421478을 탐색하는데 소요된 이진 검색 프로세스: 26(5100ns)\r\n\r\n이진 검색이 약 5281배 더 빠릅니다.\r\n```\r\n\r\n위 소스는 선형 검색과 이진 검색을 통합해 퍼포먼스를 비교할 수 있는 소스다. 100,000,000(1억)의 구간에서 임의의 수 `target`을 검색한다. 해당 소스에서는 86,421,478으로 지정했다.\r\n\r\n|    구분     | 선형 검색  | 이진 검색 |    차이    |\r\n| :---------: | :--------: | :-------: | :--------: |\r\n| 프로세스 수 | 86,421,477 |    26     |     -      |\r\n|  테스트 1   | $2.442ms$  |  $5.2us$  | 약 4,699배 |\r\n|  테스트 2   | $2.463ms$  |  $5.3us$  | 약 4,648배 |\r\n|  테스트 3   | $2.434ms$  |  $5.5us$  | 약 4,424배 |\r\n|  테스트 4   | $2.536ms$  |  $5.3us$  | 약 4,785배 |\r\n|  테스트 5   | $2.383ms$  |   $5us$   | 약 4,766배 |\r\n|  테스트 6   | $2.509ms$  |  $5.1us$  | 약 4,919배 |\r\n|  테스트 7   | $2.487ms$  |  $5.4us$  | 약 4,605배 |\r\n|  테스트 8   | $2.394ms$  |  $4.5us$  | 약 5,320배 |\r\n|  테스트 9   | $2.666ms$  |  $5.3us$  | 약 5,030배 |\r\n|  테스트 10  | $2.352ms$  |  $5.3us$  | 약 4,438배 |\r\n\r\n<small class=\"red-400\">※ 위 테스트는 CPU i7-10700K, RAM 32GB에서 테스트한 결과물로, 구동 환경에 따라 연산 결과가 달라질 수 있음</small>\r\n\r\n이진검색이 선형검색에 비해 약 5000배 까지도 차이가 남을 확인할 수 있다. 단위가 $ms$, $us$니까 사람 입장에선 그게 그거지만, 기계 입장에선 이진 검색으로 5000번 수행할 동안 선형 검색은 한 번 수행하는 셈이니 실로 어마어마한 차이다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 알고리즘을 적용한 이진 검색을 구현하고 이를 기존의 선형 검색과 비교함으로써 알고리즘의 강력함을 체감할 수 있었다.\r\n\r\n현업에서 일하면서 알고리즘이 강력하다는 건 알고있었지만, 이렇게 간단하게 구현해서 직접 비교해보니 역시나 알고리즘이 중요한 이유를 알 것 같다.\r\n\r\n원래 오늘같이 내일 쉬는 날이면 새벽 네 다섯시까지 공부하긴 하는데, 포스팅 때문에 풀타임으로 집중하다 보니 유난히 더 피곤하다....","url":["2021-07-10-about-algorithm-chapter02","2021","07","10","about-algorithm-chapter02"]},{"header":{"title":"자료구조가 중요한 까닭","excerpt":"혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T01:30:56","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-10-about-algorithm-chapter01.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 개요\r\n\r\n혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다.\r\n\r\n마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.\r\n\r\n비전공자가 자료구조같은 기초지식이 항상 아킬레스건이였다. 특히 백준 풀 때 뼈저리게 느끼지만. 이 스터디가 끝나면 자료구조에 대해 기초정도는 알 수 있었음 한다.\r\n\r\n언어는 가급적 <span class=\"orange-400\">JAVA</span>로 진행한다.\r\n\r\n# 1장 자료 구조가 중요한 까닭\r\n\r\n이 장에서는 배열의 기초와 그에 해당하는 연산들에 대한 내용을 소개하면서 사용자에게 배열에 관한 러프한 개념을 설명해준다.\r\n\r\n배열과 <span class=\"primary\">집합</span>이라는 개념에 대한 내용을 기술한다. 저자에 의하면 챕터가 진행될 수록 연산 성능에 대한 점진적인 비교를 한다고 하니, 알고리즘 적용에 따른 성능 향상의 차이를 확인해 볼 수 있을 것이다.\r\n\r\n## 1-1. 배열: 기초 자료 구조\r\n\r\n<span class=\"primary\">배열</span>은 거의 모든 언어에 존재하는 매우 기초적인 자료구조다.\r\n\r\nJAVA에는 `int`, `boolean`과 같은 <span class=\"green-A400\">기본형 타입(Primitive Type)</span>과 `String`, `HashMap`과 같은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>으로 구분된다.\r\n\r\n이와 같은 데이터들은 각각 단일로 사용할 수도 있지만, 다수의 데이터를 동시에 다뤄야하는 경우가 심심치않게 발생한다. 이러한 데이터들이 모여 하나의 배열이 될 수 있다.\r\n\r\n`String` 데이터가 모여 `String[]`이라는 <span class=\"primary\">문자열 배열</span>이 되며, `int` 데이터가 모여 `int[]`라는 <span class=\"primary\">정수 배열</span>이 된다.\r\n\r\nJAVA에서의 배열은 이처럼 특정한 데이터가 여러개 모인 자료 구조이며, 반드시 <span class=\"red-A400\">지정된 데이터만을 요소로 받아들일 수 있다.</span>\r\n\r\n예를 들어, `boolean`은 `true`, `false`로 이루어진 데이터 형식이다. `boolean[]`은 `boolean` 데이터가 여러개 모인 배열이며, 이렇게 선언된 배열은 `boolean`에 해당하는 `true`, `false`만 받아들일 수 있다. 즉, 1이나 \"A\"와 같은 문자열은 배열에 삽입할 수 없다.\r\n\r\n또한 <span class=\"red-A400\">배열은 고정 길이를 가진다.</span> 한 번 할당된 배열의 길이는 재할당되지 않는 이상 절대로 길이가 변경되지 않는다.\r\n\r\n> **⚠잠깐! 이건 어디까지나 JAVA 얘기에요!**  \r\n> 지금 설명하는 배열의 특징은 JAVA에 국한되는 예시다. 당장 JavaScript만 봐도, 배열에 별다른 제약이 존재하지 않는다. 길이는 필요에 따라 증축할 수 있으며, 요소에 아무 데이터 타입이나 할당 가능하다.\r\n\r\nJAVA에서 배열은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>에 해당한다.\r\n\r\n배열에서 수행 가능한 연산에는 4가지가 존재한다.\r\n\r\n* 읽기\r\n* 검색\r\n* 삽입\r\n* 삭제\r\n\r\n위 4가지 연산은 배열의 가장 기초적인 연산이다. 이 4가지 연산을 JAVA로 직접 구현하며 어떤 단계를 거치는지 확인해보자.\r\n\r\n## 1-2 읽기\r\n\r\n<span class=\"primary\">읽기</span>연산은 배열의 특정 인덱스에 어떠한 값이 있는지 읽는 연산이다.\r\n\r\n대부분 모든 언어의 런타임에서 할당되는 데이터들은 메모리에 기록된다. 많은 양의 데이터가 할당될수록 프로그램이 요구하는 메모리, 즉 RAM의 요구사항이 높아진다. 배틀그라운드나, 스타크래프트2와 같은 게임들은 많은 양의 메모리를 요구한다. 그 만큼 기록되고 처리되는 데이터의 양이 매우 방대하기 때문이다.\r\n\r\n데이터가 메모리에 할당될 때, 가용한 임의의 메모리 주소에 저장된다. 해당 메모리 주소에 원하는 값이 존재할 것이므로, 값을 호출하기 위해선 해당 값이 저장된 메모리 주소에 접근하여 값을 조회한다. JAVA를 포함한 대부분의 언어들은 이러한 과정이 개발자에게까지 노출되지 않는 내부의 영역에 존재한다. 이걸 직접 다루는 것이 C언어의 그 악명높은 포인터다.\r\n\r\nJAVA의 메모리는 JVM(Java Virtual Machine, 자바 가상머신)이 관리한다. JVM의 메모리 구조부터 시작하면 한도끝도 없이 브랜치가 뻗어나가니, 핵심만 찝어보자.\r\n\r\n위에서 언급했듯이, 배열은 참조형 타입이며, 이 참조형 타입은 JVM의 Heap 영역에서 관리한다. 메모리를 간략하게 도식화하면 아래와 같이 표현할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111131-7dc1fb80-e120-11eb-8a75-0cf615c9c020.png\" width=\"600px\" />\r\n</p>\r\n\r\n네모 한 칸에 하나의 데이터를 할당할 수 있다고 해보자. 만약 6, 43, 14, 9, 94 5개의 정수로 이루어진 정수형 배열을 메모리에 할당한다고 가정하자. JVM이 해당 배열의 크기를 메모리에 기록할 수 있는지 확인하고, 가능하다면 기록한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111294-b2ce4e00-e120-11eb-8a6e-d5fc241db0ee.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 처럼 메모리 상의 적절한 위치에 배열이 기록될 것이다. 여기서 배열의 4번째 데이터를 읽어보자.\r\n\r\n프로그램은 해당 배열의 주소를 알고있다. 자기가 직접 할당했으니 당연하다. 배열의 주소를 0x0404라고 가정하면 아래와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n0x0404에서 4번째 데이터를 호출하므로 0x0407의 데이터를 조회하면 된다.\r\n\r\n> **😒아니 4번째 데이터라면서요...**  \r\n> 거의 대부분의 컴퓨터 언어는 시작 인덱스를 0으로 지정한다. 그 이유는 메모리에 있는데, 메모리를 기준으로 배열의 첫 번째 데이터는 주소의 이동이 없다.  \r\n> 만약 주소가 0x0101이라면, 첫 번째 데이터는 0x0101이 되기 때문에 주소의 이동이 없으므로 0번째 데이터라고 정의하는 것이다. 이는 관점의 차이로, 초대 프로그램의 언어가 이와 같은 방식을 차용했다. 이후 이를 기반으로 생겨난 수 많은 언어들이 이 영향을 받았다.\r\n\r\n이처럼 배열의 주소에서 해당 인덱스만큼 주소에 더해 데이터를 읽는 것이므로, 동작은 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111156-887c9080-e120-11eb-94db-46545b8a5e9c.png\" width=\"600px\" />\r\n</p>\r\n\r\n주소 0x0404를 시작으로 4번째 데이터인 0x0407인 주소에 접근한다. 배열의 주소와 배열의 인덱스를 알고 있으므로 별도의 연산 없이 바로 접근 가능하다. 이로써 0x0407의 값 9에 접근할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 읽기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 22:53:39\r\n */\r\npublic class ArrayRead\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 읽을 인덱스\r\n\t\tint index = 4;\r\n\t\t\r\n\t\tint result = read(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(\"4번 째 아이템: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 읽기 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t *\r\n\t * @return [int] 인덱스에 해당하는 값\r\n\t */\r\n\tprivate static int read(int index)\r\n\t{\r\n\t\treturn ARRAY[index];\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 아이템: 9\r\n```\r\n\r\nJAVA 소스는 위와 같다. 배열 `array`을 선언하고, `array[3]`을 호출하면 배열의 4번째 값인 94가 변수 `four`에 할당된다. 목표에 바로 접근하므로 작업에 필요한 단계는 단 하나다.\r\n\r\n## 1-3. 검색\r\n\r\n이처럼 주소의 값이나 인덱스를 정확히 알고 있다면, 별도의 연산 없이 바로 해당하는 값을 갖고올 수 있다. 하지만 실제로 배열을 다루다보면 꼭 이렇게 간단한 케이스만 있지는 않다.\r\n\r\n우리가 구조를 알지 못하는 배열이 있다고 가정할 때, 해당 배열에서 우리가 원하는 값을 찾아야할 경우가 적지않게 발생한다. 이 경우 원하는 값의 인덱스를 가지고 있지도 않으며, 심지어 배열 내부에 원하는 값이 존재하는지조차 알 수 없다. 이 경우 <span class=\"primary\">검색</span>연산을 통해 배열의 값을 찾아야 한다.\r\n\r\n위에서 선언했던 배열을 다시 가져와보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n이번엔 우리가 이 배열에 대한 정확한 정보를 가지고있지 않다고 가정해보자. 현재 우리는 이 배열의 어떤 인덱스에 어떤 값이 있는지 전혀 모르는 상태다.\r\n\r\n이 상황에서 14라는 값을 검색해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111164-8a465400-e120-11eb-9432-8c127bfed9b2.png\" width=\"600px\" />\r\n</p>\r\n\r\n검색은 읽기 작업의 반복이라고 봐도 무방하다. 위 그림은 이러한 검색의 특성을 여실히 보여준다. 목표값인 14를 찾기 위해 `array[0]` 부터 순차적으로 읽음으로써 14를 찾는다.\r\n\r\n만약 어떠한 방법으로든 읽기과정을 줄이면서도 정상적인 검색이 가능하다면 소요시간이 효과적으로 감소할 것이다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 23:47:03\r\n */\r\npublic class ArrayFind\r\n{\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 목표 숫자\r\n\t\tint target = 14;\r\n\t\t\r\n\t\tint result = find(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"이 포함된 인덱스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n14이 포함된 인덱스: 2\r\n```\r\n\r\n하지만 위는 가장 기초적인 검색 알고리즘을 적용한 것이다. 3번째 요소를 찾기 위해선 3개 과정이 필요하고, 5484번째 요소를 찾기 위해선 5484개 과정이 필요하다.\r\n\r\n그러나, 요소가 맨 끝에 있거나, 불행히도 배열 내에 존재하지 않을 경우 배열 전체를 검색해야할 수도 있다. 즉 배열에 $N$개의 요소가 있다면, 검색의 최대 작업 갯수는 $N$개가 된다.\r\n\r\n## 1-4. 삽입\r\n\r\n배열에 새로운 요소를 넣는 작업을 <span class=\"primary\">삽입</span> 연산이라 한다. 배열에서 55를 삽입하는 과정을 통해 삽입 연산에 대해 알아보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111179-8d414480-e120-11eb-9c36-965d4506fd8c.png\" width=\"600px\" />\r\n</p>\r\n\r\n런타임 시 배열을 할당했다면 우리는 배열의 주소를 알고 있을 것이다. 배열의 맨 끝에 요소를 추가한다면 그냥 이어붙이면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111188-8fa39e80-e120-11eb-8576-aee6d30ae3a7.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간에 삽입한다면 이야기가 조금 달라진다. 삽입하려는 위치 이후의 요소를 한 칸씩 뒤로 미루고, 해당 위치에 값을 삽입하게 된다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치에 요소를 삽입한다면 모든 배열의 요소를 한 칸씩 뒤로 미룬뒤 55를 삽입해야한다. 즉, 배열에 $N$개의 요소가 있을 경우 삽입에 필요한 작업량은 $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $N + 1$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:27:47\r\n */\r\npublic class ArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tinsert(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 요소에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 요소에 55 삽입: [6, 43, 55, 14, 9, 94, -1, -1, -1, -1]\r\n```\r\n\r\n삽입 소스는 위와 같다.\r\n\r\n> **@SuppressWarnings는 뭔가요?**  \r\n> Eclipse, IntelliJ와 같은 IDE는 코드를 분석하는 과정에서 오류 또는 경고를 개발자에게 알려줌으로써 잠재적 위험을 제거할 수 있도록 유도한다. 간혹 의도된 동작임에도, IDE의 최적화 설정과 맞지 않아 경고를 띄우기도 한다. 이 경우 @SuppressWarnings 애노테이션을 쓰면 해당 경고를 무시할 수 있다. @@SuppressWarnings를 지워도 소스 동작엔 아무런 문제가 없다.\r\n\r\n위에서도 언급했지만, JAVA의 배열은 고정길이를 가진다. 삽입 연산을 하기 위해선 필연적으로 현재 배열의 크기보다 하나 이상 커야하므로, 이전과 달이 총 길이가 10인 배열을 선언했다. 배열의 요소가 -1일 경우, 해당 요소는 아직 할당되지 않은 빈 요소로 간주한다.\r\n\r\n> **가변 길이를 가지는 List**  \r\n> JAVA에서도 얼마든지 가변길이 배열이 필요한 경우가 생긴다. 이 경우 `ArrayList`와 같은 `List` 데이터를 활용하면 된다. `List`는 가변길이를 가짐으로써 비정형화된 배열 데이터를 다루는데 유리하다.\r\n\r\n배열의 가장 끝 요소부터 삽입하려는 인덱스 이전까지 순차적으로 내려오며 현재 요소의 값을 이전 요소의 값으로 할당하여 요소를 이동시킨다. 이후 삽입하려는 인덱스에 요소를 할당함으로써 삽입이 완료된다.\r\n\r\n## 1-5. 삭제\r\n\r\n삽입을 했으니, 반대로 <span class=\"primary\">삭제</span>도 필요할 수 있다. 삭제 연산은 원하는 인덱스의 요소를 삭제하는 것이다. 간단히 말하자면, 삽입과 정 반대의 프로세스를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111198-93372580-e120-11eb-9949-aa21aef11dfa.png\" width=\"600px\" />\r\n</p>\r\n\r\n마찬가지로, 배열의 맨 끝에 요소를 삭제한다면 그냥 끝의 요소를 삭제하면 그만이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111204-9500e900-e120-11eb-8c44-c45faeb459fd.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간을 삭제한다면 동일한 작업이 필요하다. 삭제하려는 위치의 요소를 삭제하고, 요소를 한 칸씩 당겨야 한다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치의 요소를 삭제한다면 해당 요소를 삭제한 뒤 모든 배열의 요소를 한 칸씩 앞으로 당길 것이다. 즉, 배열에 $N$개의 요소가 있을 경우 삭제에 필요한 작업량은 해당 인덱스의 요소를 삭제하는 작업 1개, $N - 1$개의 요소를 하나씩 이동하는 작업 $N - 1$개로 최대 $N$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삭제 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:59:02\r\n */\r\npublic class ArrayDelete\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삭제할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\tremove(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번째 요소 삭제 \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삭제 함수\r\n\t *\r\n\t * @param index: [int] 삭제 위치\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void remove(int index)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = index; i < ARRAY.length - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i + 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tARRAY[ARRAY.length - 1] = -1;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번째 요소 삭제 [6, 43, 9, 94, -1, -1, -1, -1, -1, -1]\r\n```\r\n\r\n삭제 소스는 위와 같다.\r\n\r\n삭제는 삽입과 달리 배열의 크기가 증가할 필요가 없다. 마찬가지로 배열의 요소가 -1일 경우, 해당 요소는 삭제된 빈 요소로 간주한다.\r\n\r\n삽입과는 반대로, 삭제하려는 인덱스부터 배열의 끝까지 순차적으로 올라가며 현재 요소의 값을 이후 요소의 값으로 할당하여 요소를 이동시킨다. 이후 배열의 끝 요소를 제거함으로써 삭제가 완료된다.\r\n\r\n## 1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다\r\n\r\n배열의 경우 요소의 타입만 맞다면 별다른 신경을 쓰지 않는다. 이말인즉슨, 중복되는 요소에 대한 처리도 이루어지지 않는다. 하지만 종종 중복되는 값을 허용하지 않는 배열의 필요성이 생기기도 한다. 책에서는 이를 <span class=\"primary\">집합</span>이라는 개념으로 설명한다.\r\n\r\n배열에 요소를 삽입할 때, 중복여부를 확인하기 위해선 검색 작업이 선행되어야 한다. 검색을 통해 집합에 해당 요소가 없는 것이 확인될 경우에만 삽입이 이루어지는 방식이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111212-97634300-e120-11eb-8d2e-c024761e23ff.png\" width=\"600px\" />\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111220-992d0680-e120-11eb-97a2-3e1e8eda7518.png\" width=\"600px\" />\r\n</p>\r\n\r\n위의 두 그림은 집합 개념이 적용된 배열에서 존재하지 않는 값 55와, 존재하는 값 14를 삽입했을 때 나타나는 결과를 도식화한 것이다.\r\n\r\n55의 경우 기존에 존재하지 않았으므로 삽입이 가능하지만, 14의 경우 이미 2번 째 인덱스에 동일한 값이 있으므로 삽입이 불가능하다.\r\n\r\n검증이 완료된 이후의 삽입 과정은 기존의 삽입 과정과 동일하다. 단, 작업량은 달라진다. 기존의 삽입 작업량에서 검색의 작업량이 추가되기 때문이다.\r\n\r\n가장 최악의 케이스는 중복되지 않는 임의의 값을 배열의 0번 째 인덱스에 삽입하는 것이다. $N$개의 요소를 가진 배열에서 $N$개 요소를 검색하는 작업량 $N$개, $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $2N + 1$개의 작업량이 발생한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 집합 배열 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/07/10/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 01:30:56\r\n */\r\npublic class UniqueArray\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tboolean result = hasInserted(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입 결과: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [boolean] 삽입 결과\r\n\t */\r\n\tprivate static boolean hasInserted(int index, int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\t// 중복되지 않을 경우\r\n\t\tif (result == -1)\r\n\t\t{\r\n\t\t\tinsert(index, item);\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 중복될 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 인덱스에 55 삽입 결과: true\r\n```\r\n\r\n집합 배열의 삽입 소스는 위와 같다.\r\n\r\n`find`와 `insert` 함수는 검색과 삽입 파트에서 사용한 로직과 동일한 로직이다. 집합 배열은 반드시 고유한 요소만을 삽입해야 하므로, `hasInserted` 함수를 구성하여 중복 여부를 검증한 뒤 삽입을 진행한다.\r\n\r\n`find` 함수는 검색되는 요소가 없을 경우 -1을 반환한다. 즉, -1을 반환하는 숫자는 고유한 숫자다. `find`가 -1을 반환할 경우 `insert` 함수로 삽입을 진행한다.\r\n\r\n> **Set 객체는 중복을 허용하지 않아요**  \r\n> JAVA의 배열은 기본적으로 요소의 중복같은건 신경쓰지 않는다. 때문에, 요소의 중복을 감지하기 위해선 별도의 검증 로직을 구성해야한다.  \r\n> 하지만 `HashSet`과 같은 `Set` 객체를 활용하면 항상 고유한 값만 삽입할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 최대한 개념 위주로 설명하며, 설명에 어떠한 알고리즘 지식이 들어가지 않은 것으로 보인다. 이러한 저자의 의도를 최대한 반영하여, 내 로직 역시 가능한 기본 데이터 타입을 사용했으며, 복잡한 로직을 최대한 지양했다. 철저히 연산이 동작하는 기본 원리에 입각하도록 소스를 구성했다.\r\n\r\n다음 장에서는 알고리즘에 대한 본격적인 내용이 기술될 것이다.","url":["2021-07-10-about-algorithm-chapter01","2021","07","10","about-algorithm-chapter01"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1019번 책 페이지","excerpt":"지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1페이지이고, 마지막 페이지는 N페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-28T12:28:50","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-28-a1019.md","content":"\r\n# 책 페이지\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/15.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1019번 문제](https://www.acmicpc.net/problem/1019)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 전체 페이지의 수가 $N$인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 $N$페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$이 주어진다. $N$은 $1,000,000,000$보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 4 1 1 1 1 1 1 1 1\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 명확하고 직관적이다. 1페이지부터 $N$페이지까지 나열할 때, <span class=\"green-400\">숫자가 사용된 수를 각 숫자별로 나타내는 문제</span>.\r\n\r\n165라는 숫자를 표기하기 위해선 $[ 1, 5, 6 ]$이 사용된다. 이렇게 <span class=\"green-400\">1부터 해당 숫자까지의 모든 숫자를 표현하기 위해 사용한 숫자의 수를 0부터 오름차순으로 출력</span>하면 된다. \r\n\r\n즉, $N = 5$라고 가정하면, 페이지 배열은 $[ 1, 2, 3, 4, 5 ]$까지 나열된다. 각 숫자가 사용된 수를 표로 나타내면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n1부터 5까지 나열하는데, 각각 숫자 하나씩 사용했으니 위 처럼 표시할 수 있다. 그렇다면 예제의 11은 어떨까?\r\n\r\n$[ 1, 2, 3, \\dots, 10, 11 ]$까지 나열된다. \r\n\r\n1부터 9까지는 각각 숫자가 하나씩 사용되며, 10은 1과 0이 사용되고, 11은 1이 두 개 사용된다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n위의 표만큼 숫자가 사용됐다. 이해를 위해 $N = 13$일 경우를 하나 더 해보자.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n$12 = [ 1, 2 ]$, $13 = [ 1, 3 ]$이 된다. 1 ~ 13에는 11도 포함되기 때문에, 11의 결과에 12, 13의 값을 각각 더해줘도 상관없다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n이 정도면 알고리즘이 원하는 게 무엇인지 이해했으리라 생각한다.\r\n\r\n## 🔎규칙 찾아보기\r\n\r\n사실 무식하게 접근하면, 그리 어려운 문제는 아니다. 하나하나 반복문 돌려가며 숫자 분해해서 해당하는 숫자의 배열에 집어넣으면 그만이니. 하지만 안타깝게도, 변수 $N$의 최대값은 10억 ~~(다행히 int의 최대값은 넘지 않는다.)~~ 에 육박한다. 그 말인즉는 무식하게 접근하면 안 된다는 의미.\r\n\r\n그렇다면 어딘가에 존재하는 규칙성을 발견해서 일반식을 설계해야한다는 뜻인데, 이럴땐 하나하나 나열해보면 알 수 있을 것이다.\r\n\r\n|   N   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   0   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   2   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   3   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   4   |   0   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |\r\n|   5   |   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   6   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |\r\n|   7   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |\r\n|   8   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |\r\n|   9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  10   |   1   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  11   |   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  12   |   1   |   5   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  13   |   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  14   |   1   |   7   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |\r\n|  15   |   1   |   8   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |\r\n|  16   |   1   |   9   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |\r\n|  17   |   1   |  10   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |\r\n|  18   |   1   |  11   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |\r\n|  19   |   1   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  20   |   2   |  12   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  21   |   2   |  13   |   4   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  22   |   2   |  13   |   6   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  23   |   2   |  13   |   7   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n\r\n규칙성을 찾아보기 위해 20 받고 살짝 더 얹어서 사용된 숫자를 나열해보았다. 어떤 패턴이 보이는 것 같긴 하다.\r\n\r\n1. 0은 10의 배수마다 1씩 증가한다.\r\n2. 각 1의 자리마다 해당하는 숫자가 1씩 증가하며, 값은 10의 자릿수 + 1이다.\r\n3. 10의 자릿수는 해당하는 숫자를 1씩 증가시킨다.\r\n\r\n그냥 쳐다보면 규칙성을 찾기 좀 어려울 수 있다. 해답은 <span class=\"red-400\">*0 ~ *9</span> 구간에 있다. 예를 들어, 10 ~ 29까지 나열해보자. 1부터 시작하는 것이 아니라, 임의의 구간 $A ~ B$를 기준으로 알고리즘을 계산한다고 가정하는 것이다.\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>10</td>\r\n\t\t\t\t<td>11</td>\r\n\t\t\t\t<td>12</td>\r\n\t\t\t\t<td>13</td>\r\n\t\t\t\t<td>14</td>\r\n\t\t\t\t<td>15</td>\r\n\t\t\t\t<td>16</td>\r\n\t\t\t\t<td>17</td>\r\n\t\t\t\t<td>18</td>\r\n\t\t\t\t<td>19</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>20</td>\r\n\t\t\t\t<td>21</td>\r\n\t\t\t\t<td>22</td>\r\n\t\t\t\t<td>23</td>\r\n\t\t\t\t<td>24</td>\r\n\t\t\t\t<td>25</td>\r\n\t\t\t\t<td>26</td>\r\n\t\t\t\t<td>27</td>\r\n\t\t\t\t<td>28</td>\r\n\t\t\t\t<td>29</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n위 표의 숫자들을 잘 보면, 1의 자리 숫자는 각각 하나씩 사용하는 것을 확인할 수 있다.\r\n\r\n## 1의 자리에서의 규칙\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>1<span class=\"red-A400\">0</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">1</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">2</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">3</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">4</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">5</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">6</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">7</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">8</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">9</span></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>2<span class=\"red-A400\">0</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">1</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">2</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">3</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">4</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">5</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">6</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">7</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">8</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">9</span></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n이제 좀 규칙성이 눈에 띄기 시작한다. 20 ~ 39와 같은 <span class=\"red-400\">*0 ~ *9</span> 형태의 범위에선 1의 자리에 해당하는 모든 숫자가 동일하게 사용된다. 10 ~ 19, 20 ~ 29 두 구간이 있으므로 각 구간별로 1씩 모든 숫자가 두 번 사용됐다.\r\n\r\n시작 페이지를 $n$, 마지막 페이지를 $N$이라고 가정할 때, 위 규칙을 일반식으로 표현하면 아래와 같다.\r\n\r\n$$\r\n(N \\div 10) - (n \\div 10) + 1 = \\text{1의 자리에 사용된 각각의 숫자 갯수}\r\n$$\r\n\r\n따라서 10 ~ 29 범위에서 모든 숫자는 두 번 사용된 것임을 알 수 있다.\r\n\r\n## p의 자리에서의 규칙\r\n\r\n문제는 위 식은 <span class=\"orange-400\">1의 자리에서만 적용되는 수식</span>이다. 페이지는 최대 10의 자리까지 존재할 수 있다. 즉, 통용되는 일반식을 구해야한다.\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>0</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>1</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>2</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>3</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>4</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>5</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>6</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>7</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>8</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>9</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>0</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>1</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>2</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>3</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>4</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>5</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>6</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>7</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>8</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>9</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n반대로 10의 자리수를 자세히 보자. 1이 10번 사용된다. 만약 100 ~ 199 구간이라면 1은 100개가 사용될 것이고, 1000 ~ 1999 구간이라면 1은 1000개가 사용될 것이다.\r\n\r\n쉽게 설명하기 위해 10 ~ 19, 100 ~ 199, 1000 ~ 1999 등 $n0* ~ n9*$ 같은 형태의 구간을 단위 구간이라고 정의하자. 이 때, 해당 구간에서 $n$이 사용되는 갯수는 아래와 같이 정의할 수 있다.\r\n\r\n$$\r\n((N \\div 10) - (n \\div 10) + 1) \\times \\text{p} = \\text{각각의 숫자 갯수}\r\n$$\r\n\r\n* $n$: 구간 시작 값\r\n* $N$: 구간 끝 값\r\n* $p$: 자릿수\r\n\r\n## 구간 보정하기\r\n\r\n이제 구간만 맞으면 호출되는 숫자를 구할 수는 있지만, 아직 제한적이다.\r\n\r\n우선, 본 알고리즘에서 시작 값은 1로 고정이다. 끝 값인 $N$ 역시 반드시 199와 같은 단위 구간의 형태로 들어오지도 않는다. 만약 $N = 35$라면 우리는 1 ~ 35 구간에 알고리즘을 적용해야 한다. 구간이 10 ~ 39라면 모를까, 형태가 전혀 다른 구간에는 위 일반식이 적용되지 않는다.\r\n\r\n해결 방법은 간단하다. 가늠좌 클리크 조정하듯이 구간에 맞게 값을 더하고 빼서 조정해주면 된다.\r\n\r\n1 ~ 35 구간에서, 1의 경우, 1보다 크며 0을 포함한 수 중 가장 가까운 값은 10이다. 따라서, 시작 값은 10까지 증가시키며, 증가시킨 숫자를 카운팅한다. 1부터 9까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n35의 경우 35보다 작으며 9를 포함한 수 중 가장 가까운 수는 29다. 마찬가지로 마지막 값은 29까지 감소시키며, 감소한 숫자를 카운팅한다. 35부터 30까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n즉, 초기값은 위 보정값을 더한 배열이며, 이후 계산은 계산된 초기값에 누적한다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| **1** | **2** | **2** | **8** | **2** | **2** | **1** | **1** | **1** | **1** |\r\n\r\n## 자릿수 보정하기\r\n\r\n$N = 1999$, $n = 1000$일 때, 1의 자리에 사용된 숫자의 갯수를 구하면 아래와 같다.\r\n\r\n$$\r\n((1999 / 10) - (1000 / 10) + 1) \\times 1 = 100\r\n$$\r\n\r\n1의 자리에서 각 숫자는 100개씩 사용됐다. 10의 자리에서는 어떨까?\r\n\r\n$N$, $n$을 각각 10으로 나누면 10의 자리에 대한 구간을 얻을 수 있다. 나눠진 숫자를 위의 일반식에 적용하면 된다.\r\n\r\n$$\r\n((199 / 10) - (100 / 10) + 1) \\times 10 = 100\r\n$$\r\n\r\n100의 자리는 $N$, $n$을 각각 100으로 나누어 계산하면 된다.\r\n\r\n$$\r\n((19 / 10) - (10 / 10) + 1) \\times 100 = 100\r\n$$\r\n\r\n1000의 자리는 $N$, $n$을 각각 1000으로 나누어 계산하면 된다. 그러나 $N = n = 1$이므로, 1에만 1000개가 사용된다.\r\n\r\n|  $p$  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  10   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n| 1000  |   0   | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|       |  300  | 1300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n따라서 1000 ~ 1999 구간은 위와 같이 계산된다.\r\n\r\n## 📃일반식 적용하기\r\n\r\n완벽한 이해를 위해, 위 개념을 토대로 $N = 4153$일 경우의 알고리즘을 계산해보자.\r\n\r\n$N = 4153$이므로, 구간은 1 ~ 4153이다.\r\n\r\n### 시작 페이지 구간 보정하기\r\n\r\n1보다 큰 수 중 1의 자리가 0인 가장 가까운 수 10까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n1부터 9까지 이동하여 10에 도착하므로, 1 ~ 9를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n### 마지막 페이지 구간 보정하기\r\n\r\n4153보다 작은 수 중 1의 자리가 9인 가장 가까운 수 4149까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n4153부터 4150까지 이동하여 4149까지 도착하므로, 이를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 4153  |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4152  |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4151  |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4150  |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n### 1의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 4149을 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((4149 / 10) - (10 / 10) + 1) \\times 1 = 414 - 1 + 1 = 414\r\n$$\r\n\r\n|   구분   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1의 자리 |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n\r\n### 10의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 1의 자리 일반식 구간 4149, 10을 각각 10으로 나눈다.\r\n\r\n10의 자리에 대한 구간은 $1 ~ 414$가 된다. 마찬가지로 일반식 적용을 위해 구간을 보정한다. 10의 자리이므로, <span class=\"red-400\">1 -> 2로의 이동은 실제로 10 -> 20으로의 이동임에 주의</span>하자.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  414  |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|  413  |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  412  |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  411  |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  410  |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 10의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 409를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((409 / 10) - (10 / 10) + 1) \\times 10 = (40 - 1 + 1) \\times 10 = 400\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n\r\n### 100의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 10의 자리 일반식 구간 409, 10을 각각 10으로 나눈다.\r\n\r\n100의 자리에 대한 구간은 $1 ~ 40$이 된다. 나머지는 10의 자리 프로세스와 동일하다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  40   |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 100의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 39를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((39 / 10) - (10 / 10) + 1) \\times 100 = (3 - 1 + 1) \\times 100 = 300\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n### 1000의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 100의 자리 일반식 구간 39, 10을 각각 10으로 나눈다.\r\n\r\n1000의 자리에 대한 구간은 $1 ~ 3$이 된다.\r\n\r\n여기서 문제가 하나 있는데, 마지막 구간에서 일의 자리가 9인 가장 작은 수는 -9다. 음수가 올 수 없으므로, 더 이상의 일반식 연산은 불가능하며, 개별적으로 더해주면 된다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 3 |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 총합 계산하기\r\n\r\n단계별로 구한 숫자를 정리하여 총합을 표로 나타낸다.\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1 ~ 9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   4153    |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4152    |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4151    |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4150    |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 1의 자리  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n|   1 ~ 9   |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n|    414    |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|    413    |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    412    |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    411    |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    410    |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n|   1 ~ 9   |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|    40     |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n|   1 ~ 3   |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   총합    | 1225  | 2290  | 2236  | 2236  | 1389  | 1229  | 1225  | 1225  | 1225  | 1225  |\r\n\r\n구간 1 ~ 4153에 대한 알고리즘 결과는 위와 같다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 백준 전체 1019 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/28/a1019\">1019 풀이</a>\r\n * @since 2021.06.28 Mon 12:28:50\r\n */\r\npublic class Main\r\n{\r\n\t// 숫자 카운트 배열\r\n\tprivate static final int[] COUNTER = new int[10];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 마지막 페이지\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tsolve(N);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int item : COUNTER)\r\n\t\t{\r\n\t\t\tbuilder.append(item).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(builder.toString().trim());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\treader.close();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 동작 함수\r\n\t *\r\n\t * @param num: [int] 마지막 페이지\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\t// 시작 페이지\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 자릿수\r\n\t\tint digit = 1;\r\n\t\t\r\n\t\twhile (start <= num)\r\n\t\t{\r\n\t\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\t\tcount(num, digit);\r\n\t\t\t\t\r\n\t\t\t\tnum--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\t\tif (num < start)\r\n\t\t\t{\r\n\t\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\t\tcount(start, digit);\r\n\t\t\t\t\r\n\t\t\t\tstart++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstart /= 10;\r\n\t\t\tnum /= 10;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 10; i++)\r\n\t\t\t{\r\n\t\t\t\tCOUNTER[i] += (num - start + 1) * digit;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 자릿수 증가\r\n\t\t\tdigit *= 10;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 카운트 함수\r\n\t *\r\n\t * @param num: [int] 대상 숫자\r\n\t * @param digit: [int] 자릿수\r\n\t */\r\n\tprivate static void count(int num, int digit)\r\n\t{\r\n\t\twhile (num > 0)\r\n\t\t{\r\n\t\t\tCOUNTER[num % 10] += digit;\r\n\t\t\tnum /= 10;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$N = 4153$일 때, 구간을 보정하는 과정에서 4153, 4152와 같은 수를 별도로 카운팅해야한다.\r\n\r\n``` java\r\n/**\r\n * 카운트 함수\r\n *\r\n * @param num: [int] 대상 숫자\r\n * @param digit: [int] 자릿수\r\n */\r\nprivate static void count(int num, int digit)\r\n{\r\n\twhile (num > 0)\r\n\t{\r\n\t\tcounter[num % 10] += digit;\r\n\t\tnum /= 10;\r\n\t}\r\n}\r\n```\r\n\r\n로직은 어렵지 않다. 4152의 경우 $[ 4, 1, 5, 2 ]$로 이루어져있으므로, 해당하는 숫자에 자릿수만큼 카운팅(1이면 1개, 10이면 10개)하면 된다.\r\n\r\n1의 자리는 $4152 \\,\\,\\, \\% \\,\\,\\, 10 = 2$와 같이 구할 수 있다. 10의 자리는 4152를 10으로 한 번 나누고 방금의 연산을 다시 진행하면 된다.  \r\n100, 1000 등 자릿수만큼 반복하여 계산하면 된다.\r\n\r\n``` java\r\n/**\r\n * 알고리즘 동작 함수\r\n *\r\n * @param num: [int] 마지막 페이지\r\n */\r\nprivate static void solve(int num)\r\n{\r\n\t// 시작 페이지\r\n\tint start = 1;\r\n\t\r\n\t// 자릿수\r\n\tint digit = 1;\r\n\t\r\n\twhile (start <= num)\r\n\t{\r\n\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t{\r\n\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\tcount(num, digit);\r\n\t\t\t\r\n\t\t\tnum--;\r\n\t\t}\r\n\t\t\r\n\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\tif (num < start)\r\n\t\t{\r\n\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t{\r\n\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\tcount(start, digit);\r\n\t\t\t\r\n\t\t\tstart++;\r\n\t\t}\r\n\t\t\r\n\t\tstart /= 10;\r\n\t\tnum /= 10;\r\n\t\t\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t}\r\n\t\t\r\n\t\t// 자릿수 증가\r\n\t\tdigit *= 10;\r\n\t}\r\n}\r\n```\r\n\r\n시작 페이지는 무조건 1로 고정이다. 시작 페이지가 마지막 페이지보다 커질 때까지 반복한다.\r\n\r\n첫 번째 `while`문에서 마지막 페이지를 1씩 감소시켜 9로 끝나는 구간으로 보정한다. 중간에 조건문이 있는데, 이 처리를 해주지 않으면 `num`이 9보다 작을 경우 연산 과정에서 `start`가 `num`을 초과하지 못해 무한루프를 타게 된다.\r\n\r\n두 번째 `while`문은 1페이지를 1씩 증가시켜 0으로 끝나는 구간으로 보정한다. 보정된 모든 값은 `count` 메소드를 통해 별도로 카운팅된다.\r\n\r\n위 과정을 통해 구간을 맞췄으니, 나머지는 위에 언급한 수식을 적용하고, 이를 반복한다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-28-a1019","2021","06","28","a1019"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1018번 체스판 다시 칠하기","excerpt":"지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8*8 크기의 체스판으로 만들려고 한다. 체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다. 보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8 X 8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-26T16:46:20","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER V","Brute Force(무차별 대입 공격)"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-26-a1018.md","content":"\r\n# 체스판 다시 칠하기\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/6.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1018번 문제](https://www.acmicpc.net/problem/1018)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 $M \\times N$ 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 $8 \\times 8$ 크기의 체스판으로 만들려고 한다.\r\n\r\n체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.\r\n\r\n보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 $8 \\times 8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 $8 \\times 8$ 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$과 $M$이 주어진다. $N$과 $M$은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 $N$개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n8 8\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBBBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n10 13\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nWWWWWWWWWWBWB\r\nWWWWWWWWWWBWB\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n12\r\n```\r\n\r\n# 풀이\r\n\r\n각 칸이 흰색 또는 검은색으로 칠해진 커다란 판에서 임의의 위치부터 $8 \\times 8$ 크기로 잘라 체스판을 만든다. 그 중 가장 적은 칸을 칠하여 체스판을 만들고자 할 때, 칠해야하는 최소값을 구하는 문제. 주어진 변수의 범위가 적어 그냥 무식하게 하나하나 비교하면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507886-2430ea00-d6a7-11eb-8c98-eecd7655f352.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 처럼 $N \\times M$의 배열에서 무작위 $8 \\times 8$ 크기의 배열을 뽑아내야한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507891-2c892500-d6a7-11eb-85b3-eb4d7803450d.png\" width=\"800px\" />\r\n</p>\r\n\r\n$10 \\times 10$짜리 배열을 기준으로, 해당 판에서 $8 \\times 8$ 배열을 선택하는 경우의 수는 총 9가지이며, 이를 도식화하면 위 그림과 같다. 이처럼 전체 배열에서 $8 \\times 8$만큼 한 칸씩 이동하며 비교하면 된다.\r\n\r\n``` java\r\nfor (int n = 0; n < N - 7; n++)\r\n{\r\n\tfor (int m = 0; m < M - 7; m++)\r\n\t{\r\n\t\t// TODO\r\n\t}\r\n}\r\n```\r\n\r\n위 코드와 같이 기술하면 가로부터 한 칸씩 이동하며, 끝에 도달할 경우 세로로 한 칸 이동한 뒤 다시 가로부터 한 칸씩 이동할 것이다. `n < N - 7`인 이유는 비교할 배열의 세로 길이가 8이기 때문. 살짝 헷갈린다면 `n <= N - 8`으로 대체해도 무방하다.\r\n\r\n체스판에는 두 가지 경우의 수가 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507898-33179c80-d6a7-11eb-9f2e-71a4829134df.png\" width=\"700px\" />\r\n</p>\r\n\r\n체스판의 상단 좌측을 기준으로 하얀색으로 시작하는 판과, 검은색으로 시작하는 판으로 두 가지가 존재한다. 하얀색을 `true`, 검은색을 `false`로 치환하여 하얀색 체스판과 검은색 체스판을 만들어 비교할 것이다.\r\n\r\n``` java\r\n// 상단 좌측이 하얀색으로 시작하는 체스판\r\nprivate static final boolean[][] WHITE = {\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n};\r\n\r\n// 상단 좌측이 검은색으로 시작하는 체스판\r\nprivate static final boolean[][] BLACK = {\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n};\r\n```\r\n\r\n코드는 위와 같다. 흑백과 같이 이지선다일 경우 `boolean`을 사용하는 것을 더 선호하므로 위와 같이 설계했다. `String` 배열로 \"W\", \"B\"를 넣어 만들어도 비교만 잘 해준다면 크게 상관없다. 이를 $8 \\times 8$의 모든 경우의 수와 비교하여 가장 작은 수를 출력하면 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1018 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/26/a1018\">1018 풀이</a>\r\n * @since 2021.06.26 Sat 16:46:20\r\n */\r\npublic class Main\r\n{\r\n\t// 상단 좌측이 하얀색으로 시작하는 체스판\r\n\tprivate static final boolean[][] WHITE = {\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t};\r\n\t\r\n\t// 상단 좌측이 검은색으로 시작하는 체스판\r\n\tprivate static final boolean[][] BLACK = {\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t};\r\n\t\r\n\t// 체스판\r\n\tprivate static boolean[][] board;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tint[] temp = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 세로 길이\r\n\t\tint N = temp[0];\r\n\t\t\r\n\t\t// 가로 길이\r\n\t\tint M = temp[1];\r\n\t\t\r\n\t\tboard = new boolean[N][M];\r\n\t\t\r\n\t\tfor (int n = 0; n < N; n++)\r\n\t\t{\r\n\t\t\tString[] line = reader.readLine().split(\"\");\r\n\t\t\t\r\n\t\t\tfor (int m = 0; m < M; m++)\r\n\t\t\t{\r\n\t\t\t\tboard[n][m] = line[m].equals(\"W\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 결과\r\n\t\tint result = Integer.MAX_VALUE;\r\n\t\t\r\n\t\t// 0 ~ 7까지 총 8칸을 전달하므로 최대값에서 7을 뺀다.\r\n\t\tfor (int n = 0; n < N - 7; n++)\r\n\t\t{\r\n\t\t\tfor (int m = 0; m < M - 7; m++)\r\n\t\t\t{\r\n\t\t\t\tint count = solve(n, m);\r\n\t\t\t\t\r\n\t\t\t\t// 현재 결과보다 더 작은 수일 경우\r\n\t\t\t\tif (result > count)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = count;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(Integer.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 새로 덧칠할 칸의 갯수 반환 함수\r\n\t *\r\n\t * @param x: [int] x의 시작좌표\r\n\t * @param y: [int] y의 시작좌표\r\n\t *\r\n\t * @return [int] 새로 덧칠할 칸의 갯수\r\n\t */\r\n\tprivate static int solve(int x, int y)\r\n\t{\r\n\t\tint white = 0;\r\n\t\tint black = 0;\r\n\t\t\r\n\t\tfor (int n = x; n < x + 8; n++)\r\n\t\t{\r\n\t\t\tfor (int m = y; m < y + 8; m++)\r\n\t\t\t{\r\n\t\t\t\t// 하얀색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\t\tif (board[n][m] != WHITE[n - x][m - y])\r\n\t\t\t\t{\r\n\t\t\t\t\twhite++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 검은색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\t\tif (board[n][m] != BLACK[n - x][m - y])\r\n\t\t\t\t{\r\n\t\t\t\t\tblack++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 둘 중 더 적게 칠할 수 있는 체스판의 값을 반환\r\n\t\treturn Math.min(white, black);\r\n\t}\r\n}\r\n```\r\n\r\n처음에 설계했을 땐, 잘라낸 $8 \\times 8$ 배열 `board`의 좌측 상단값인 `board[x][y]`의 색을 찾아서, 하얀색(true)일 경우 `WHITE`를, 검은색(false)일 경우 `BLACK`을 갖고 비교했는데 계속 틀렸다. 아래 케이스를 보면 이해가 쉽다.\r\n\r\n+ 입력\r\n\r\n``` tc\r\n8 8\r\nBBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\n```\r\n\r\n+ 출력\r\n\r\n```\r\n1\r\n```\r\n\r\n전체 판 자체가 $8 \\times 8$이므로 경우의 수는 판 자체로 하나다. 만약 처음 설계한대로 동작한다면 위 케이스에서 문제가 발생한다.\r\n\r\n위 케이스의 $board[0][0] = false$이므로 `BLACK`과 비교하게 된다. 이러면 $board[0][0]$를 제외한 나머지 63개의 칸을 전부 칠해야한다. 그런데 저 케이스, 자세히 한 번 보자. 사실 $board[0][0]$만 하얀색(true)로 칠해주면 그만이다. 즉, `BLACK`이 아닌 `WHITE`와 비교하면 값이 1인 것이다.\r\n\r\n``` java\r\n/**\r\n * 새로 덧칠할 칸의 갯수 반환 함수\r\n *\r\n * @param x: [int] x의 시작좌표\r\n * @param y: [int] y의 시작좌표\r\n *\r\n * @return [int] 새로 덧칠할 칸의 갯수\r\n */\r\nprivate static int solve(int x, int y)\r\n{\r\n\tint white = 0;\r\n\tint black = 0;\r\n\t\r\n\tfor (int n = x; n < x + 8; n++)\r\n\t{\r\n\t\tfor (int m = y; m < y + 8; m++)\r\n\t\t{\r\n\t\t\t// 하얀색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\tif (board[n][m] != WHITE[n - x][m - y])\r\n\t\t\t{\r\n\t\t\t\twhite++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 검은색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\tif (board[n][m] != BLACK[n - x][m - y])\r\n\t\t\t{\r\n\t\t\t\tblack++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 둘 중 더 적게 칠할 수 있는 체스판의 값을 반환\r\n\treturn Math.min(white, black);\r\n}\r\n```\r\n\r\n`solve()` 메소드는 알고리즘의 핵심 동작이다. `WHITE`와 `BLACK`을 전부 비교하는 이유가 여기에 있는데, 현재 배열에서 `WHITE`와 `BLACK`을 만드는데 필요한 칸의 숫자를 각각 구해서, 그 중 더 작은 수를 반환해야 올바르게 동작한다.\r\n\r\n## 분류\r\n\r\n* 브루트포스 알고리즘","url":["2021-06-26-a1018","2021","06","26","a1018"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1017번 소수 쌍","excerpt":"지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, {1, 4, 7, 10, 11, 12}가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다. 1 + 4 = $, 7 + 10 = 17$, $11 + 12 = 23 또는 1 + 10 = 11, 4 + 7 = 11, 11 + 12 = 23 수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 1 + 12 = 13으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-26T03:19:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM III","에라토스 테네스의 체","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-26-a1017.md","content":"\r\n# 소수 쌍\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/18.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1017번 문제](https://www.acmicpc.net/problem/1017)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, ${1, 4, 7, 10, 11, 12}$가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다.\r\n\r\n$1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$  \r\n또는  \r\n$1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$\r\n\r\n수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 $1 + 12 = 13$으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 리스트의 크기 $N$이 주어진다. N은 50보다 작거나 같은 자연수이며, 짝수이다. 둘째 줄에 리스트에 들어있는 수가 주어진다. 리스트에 들어있는 수는 1,000보다 작거나 같은 자연수이며, 중복되지 않는다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 정답을 출력한다. 없으면 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n6\r\n1 4 7 10 11 12\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4 10\r\n```\r\n\r\n# 풀이\r\n\r\n[1014번 컨닝](/posts/2021/06/18/a1014)문제를 통해 <span class=\"primary\">이분 매칭</span>을 접한 덕분인지, 지금까지 푼 <span class=\"teal-A400\">플래티넘</span> 중에서는 그나마 좀 이해되는 문제였다.\r\n\r\n역시 내용이 다소 난해한데, 알고리즘이 요구하는 동작은 다음과 같이 정리할 수 있다. 입력된 6개의 숫자 배열 ${ 1, 4, 7, 10, 11, 12 }$이 있다고 가정하자. 배열의 숫자를 한 쌍씩 짝지어 더하면 총 3개의 수가 나온다. 이렇게 <span class=\"red-A400\">짝지어 더한 수가 모두 소수일 경우, 입력의 첫 번째 숫자와 매칭된 숫자들을 오름차순으로 정렬하여 출력</span>하는 문제다.\r\n\r\n예제에서도 설명해주듯이, 짝지은 수가 모두 소수인 경우는 $1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$과 $1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$가 된다. 입력의 가장 첫 번째 숫자가 1이므로, 1와 매칭된 4, 10이 정답이 된다.\r\n\r\n## 소수 판별하기🍳\r\n\r\n이제 좀 더 세부적인 내용을 살펴보자. 문제 해결의 핵심은 <span class=\"primary\">소수</span>다. 이 알고리즘에선 소수 판별이 필요하다. 많은 판별방법이 있지만, 가장 대표적인 <span class=\"primary\">에라토스 테네스의 체</span>를 활용하면 어렵지 않게 해결할 수 있다.\r\n\r\n## 요소 한 쌍씩 그룹화하기\r\n\r\n소수 판별 방법도 마련했겠다, 입력된 숫자 배열을 적절히 짝지어야한다. <span class=\"lightBlue-A400\">핵심은 짝지은 수의 합이 소수</span>가 되는 것. 요소를 한번씩 다 더해보는 방법도 있겠지만, 배열의 크기가 커질 수록 요구되는 연산량 또한 높아지므로 적절하지 않다. 즉, 가능성 있는 조합으로만 그룹화해야한다.\r\n\r\n소수에 대해 생각해보자. <span class=\"green-A400\">소수는 1과 자기 자신으로만 나눠지는 수</span>다. 즉, 반드시 **소수는 홀수**여야 한다. 이 전제를 확장하면 <span class=\"green-A400\">짝지은 수의 합이 홀수</span>여야한다. 두 수를 더했을 때 홀수가 나오는 경우는 **홀수 + 짝수**로 한 가지 경우의 수만 존재한다.\r\n\r\n따라서 우리는 입력값을 홀수와 짝수 그룹으로 나누어 각 그룹끼리만 더하면 결과는 모두 홀수일 것이므로, 해당 수는 소수일 가능성이 있다. 두 개의 그룹을 겹치지 않게 조합해야하므로 <span class=\"primary\">이분 매칭</span>이 적절한 해답이 될 수 있다. 각 그룹은 홀수와 짝수로 나누고, 더했을 때 소수가 되는 쌍을 노드로 연결하면 <span class=\"primary\">이분 매칭</span>으로 접근 가능하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png)\r\n\r\n위 그림은 예제 1을 홀수와 짝수 그룹으로 나눠 이분매칭으로 표시한 그림이다. 위 숫자를 6개의 숫자를 매칭하면 3개의 노드가 나올 것이다. 각 숫자를 더하기 위해선 반드시 하나의 쌍을 이뤄야하므로, <span class=\"primary\">이분 매칭</span>의 결과는 반드시 $N \\div 2$가 되어야 한다.\r\n\r\n예제의 가장 첫 번째 수는 1이다. 즉, 우리는 <span class=\"green-A400\">모든 요소쌍의 합이 모두 소수가 되는 조합을 찾고 해당 조합들에서 각각 1과 매칭되는 숫자</span>를 구해야한다. 이를 확장시키면, 1과 짝을 이루는 수를 더한 값이 소수가 아닐 경우 애초에 비교할 필요가 없다.\r\n\r\n위 그림의 매칭 결과가 3이 나온다면, 모든 요소를 적절히 짝지어 더한 값이 모두 소수가 되는 조합이 있다는 뜻이다. 해당 조합을 저장하여 1과 짝지은 값을 찾으면 될 것이다.  \r\n만약, 홀수와 짝수의 갯수가 일치하지 않을 경우, 매칭이 불가능하므로 문제에 제시한 조건에 따라 -1을 반환해야 한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png)\r\n\r\n1과 더했을 때 소수가 되는 요소는 4, 10, 12 모두 해당하므로 이를 모두 노드로 연결할 수 있다. 1과 매칭 가능한 요소 중 하나를 연결하면, 나머지 4개 요소에 대해서만 <span class=\"primary\">이분 매칭</span>을 진행할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/123501823-9216ea80-d682-11eb-96de-8c01b66677bb.png)\r\n\r\n만약, 1과 4를 매칭했다면 나머지 4개 요소에 대한 소수 매칭은 그림과 같이 표현할 수 있다. $[ 7, 10 ]$, $[ 11, 12 ]$ 조합의 합이 모두 소수이므로, $[ 1, 4 ]$, $[ 7, 10 ]$, $[ 11, 12 ]$ 조합은 알고리즘의 조건에 부합한다. 따라서 4는 정답에 포함된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/123501853-c8546a00-d682-11eb-86e2-6eef5c65ef69.png)\r\n\r\n만약, 1과 12가 매칭된다면 어떨까? 이는 위 그림과 같이 표시할 수 있다. 7의 경우 4와 10 중 어떤걸 조합해도 소수지만, 11의 경우 4와 10 모두 소수가 아니므로 어떤식으로 매칭해도 4개 요소의 매칭 결과는 1이 된다. 즉, 1과 매칭된 조합 하나를 더한 최종 매칭 수는 2이므로 $N / 2$의 값에 부합하지 않으므로 해당 조합은 정답이 될 수 없다.  \r\n따라서 예제의 결과는 출력과 같이 `4 10`이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\n\r\n/**\r\n * 백준 전체 1017 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/26/a1017\">1017 풀이</a>\r\n * @since 2021.06.26 Sat 03:19:32\r\n */\r\npublic class Main\r\n{\r\n\t// 에라토스 테네스의 체 배열 (소수 판별용)\r\n\tprivate static final boolean[] IS_NOT_PRIME = eratosthenes();\r\n\t\r\n\t// 왼쪽 배열 (이분매칭의 기준)\r\n\tprivate static int[] left;\r\n\t\r\n\t// 오른쪽 배열\r\n\tprivate static int[] right;\r\n\t\r\n\t// 노드 연결 여부\r\n\tprivate static boolean[][] hasNode;\r\n\t\r\n\t// 방문 여부\r\n\tprivate static boolean[] isVisit;\r\n\t\r\n\t// 매칭된 수\r\n\tprivate static int[] matched;\r\n\t\r\n\t// 현재 선택 중인 수\r\n\tprivate static int selected;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 입력값 갯수\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 입력값 배열\r\n\t\tint[] numbers = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 첫 번째 수가 홀수일 경우\r\n\t\tif (numbers[0] % 2 != 0)\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 홀수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 첫 번째 수가 짝수일 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 짝수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일할 경우 (이분매칭 가능)\r\n\t\tif (left.length == right.length)\r\n\t\t{\r\n\t\t\thasNode = new boolean[left.length][right.length];\r\n\t\t\t\r\n\t\t\t// left의 첫 번째 행은 기준 매칭이므로 이분 매칭에서 제외한다.\r\n\t\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t\t{\r\n\t\t\t\tfor (int j = 0; j < right.length; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint ref = left[i] + right[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// left[i] + right[j]의 값이 소수일 경우\r\n\t\t\t\t\tif (!IS_NOT_PRIME[ref])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 노드를 연결한다.\r\n\t\t\t\t\t\thasNode[i][j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tLinkedList<Integer> list = new LinkedList<>();\r\n\t\t\t\r\n\t\t\t// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\n\t\t\tfor (int i = 0; i < N / 2; i++)\r\n\t\t\t{\r\n\t\t\t\t// left[0]와 right[i]의 합이 소수일 경우\r\n\t\t\t\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\tselected = i;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint size = bipartite();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 모든 요소가 매칭될 경우\r\n\t\t\t\t\tif (size == N / 2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlist.add(right[selected]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 하나도 매칭되지 않은 경우\r\n\t\t\tif (list.size() == 0)\r\n\t\t\t{\r\n\t\t\t\twriter.write(\"-1\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 매칭이 하나 이상 있을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 오름차순으로 정렬\r\n\t\t\t\tlist.sort(Integer::compareTo);\r\n\t\t\t\t\r\n\t\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\t\t\r\n\t\t\t\tfor (int item : list)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuilder.append(item).append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\twriter.write(builder.toString().trim());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일하지 않을 경우 (이분매칭 불가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"-1\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\t\tint size = 1;\r\n\t\t\r\n\t\tmatched = new int[left.length];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t{\r\n\t\t\tisVisit = new boolean[left.length];\r\n\t\t\t\r\n\t\t\t// 매칭 가능할 경우\r\n\t\t\tif (dfs(i))\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static boolean dfs(int num)\r\n\t{\r\n\t\t// 첫 방문일 경우\r\n\t\tif (!isVisit[num])\r\n\t\t{\r\n\t\t\tisVisit[num] = true;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 아레토스 테네스의 체 배열 반환 함수\r\n\t *\r\n\t * @return [boolean[]] 아레토스 테네스의 체\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tboolean[] isNotPrime = new boolean[2000];\r\n\t\t\r\n\t\tisNotPrime[0] = true;\r\n\t\tisNotPrime[1] = true;\r\n\t\t\r\n\t\tint maxPrime = (int) Math.ceil(Math.sqrt(2000));\r\n\t\t\r\n\t\tfor (int i = 2; i < maxPrime; i++)\r\n\t\t{\r\n\t\t\t// 소수일 경우\r\n\t\t\tif (!isNotPrime[i])\r\n\t\t\t{\r\n\t\t\t\tfor (int j = i + i; j < isNotPrime.length; j += i)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 소수가 아님을 표시하지 않았을 경우\r\n\t\t\t\t\tif (!isNotPrime[j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 소수의 배수는 소수가 아니므로 제외함\r\n\t\t\t\t\t\tisNotPrime[j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPrime;\r\n\t}\r\n}\r\n```\r\n\r\n편의상 항상 왼쪽을 기준으로 매칭한다. 올바른 조합 중 첫 번째 수와 매칭되는 수를 찾는 것이 목표인데, 첫 번째 수는 홀수, 짝수 모두 올 수 있다. 따라서 홀수가 먼저오냐, 짝수가 먼저오냐에 따라 해당하는 분류를 기준 배열로 할당한다.\r\n\r\n``` java\r\n// 첫 번째 수가 홀수일 경우\r\nif (numbers[0] % 2 != 0)\r\n{\r\n\t// 왼쪽 배열에 홀수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n}\r\n\r\n// 첫 번째 수가 짝수일 경우\r\nelse\r\n{\r\n\t// 왼쪽 배열에 짝수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n}\r\n```\r\n\r\n해당 소스는 위와 같다. 왼쪽 배열 `left`를 기준으로하여 홀수가 올 경우 `left`에 홀수 배열을, 아닐 경우 짝수 배열을 할당한다.\r\n\r\n소수 판별은 <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘을 통해, 요소로 올 수 있는 최대값인 2,000개 배열에 대한 소수 배열을 준비한다.\r\n\r\n> **잠깐, 문제에서는 요소로 올 수 있는 최대값이 1,000이라는데요?**  \r\n> 홀수와 짝수를 더하므로, 요소의 최대값은 각 요소의 최대값을 더한 999 + 1,000 = 1,999가 됩니다.\r\n\r\n배열이 2000개까지밖에 안 되므로, 연산할 때마다 비교하는 것 보다 미리 배열을 선언해서 비교하는 게 훨씬 효율적이라 판단했다.  \r\n만약 연산할 때마다 비교하려면, 비교할 수의 제곱근을 구하고, 2부터 제곱근까지 나눈다. 중간에 정확히 나누어 떨어지는 수가 있을 경우, 그 수는 소수가 아니다.\r\n\r\n``` java\r\n// 대상 숫자\r\nint number = 1000;\r\n\r\n// 소수 여부\r\nboolean isPrime = true;\r\n\r\n// 가장 작은 소수인 2부터 대상의 제곱근까지 나누기\r\nfor (int i = 2; i <= Math.sqrt(number); i++)\r\n{\r\n\t// 나누어 떨어지는 수가 있을 경우\r\n\tif (number % i == 0)\r\n\t{\r\n\t\tisPrime = false;\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n대충 위 형식처럼 짜면 된다.\r\n\r\n``` java\r\n// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\nfor (int i = 0; i < N / 2; i++)\r\n{\r\n\t// left[0]와 right[i]의 합이 소수일 경우\r\n\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t{\r\n\t\tselected = i;\r\n\t\t\r\n\t\tint size = bipartite();\r\n\t\t\r\n\t\t// 모든 요소가 매칭될 경우\r\n\t\tif (size == N / 2)\r\n\t\t{\r\n\t\t\tlist.add(right[selected]);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n그룹을 나누었으면, 입력값의 첫 번째 수 $left[0]$와 하나씩 매칭하여 기준 매칭을 선정한다. `!IS_NOT_PRIME[left[0] + right[i]]`을 통해 매칭이 소수일 경우에만 진행한다. 소수가 아닐 경우 비교해볼 필요도 없으니. `selected`는 현재 $left[0]$와 매칭된 요소를 의미한다. 이게 왜 필요하냐면, $left[0]$와 매칭된 요소의 경우 다른 요소와 매칭될 수 없으므로 매칭에서 제외해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501834-a3f88d80-d682-11eb-8e27-968a1c71e342.png\" width=\"600px\" />\r\n</p>\r\n\r\n이는 위 그림과 같이 나타낼 수 있다. 이미 1이 10과 매칭되었으므로, 10과 연결된 7, 11의 노드를 제거해야 정상적으로 매칭할 수 있다. 연결된 노드는 `hasNode` 배열에서 관리하고 있다. 예제 1을 기준으로 `hasNode`의 값은 다음과 같다.\r\n\r\n| $N, M$ |   4   |  10   |  12   |\r\n| :----: | :---: | :---: | :---: |\r\n|   1    | true  | true  | true  |\r\n|   7    | true  | true  | true  |\r\n|   11   | false | false | true  |\r\n\r\n만약 여기서, 1과 10을 매칭할 경우 hasNode는 아래와 같다.\r\n\r\n| $N, M$ |     4     |  **10**   |    12     |\r\n| :----: | :-------: | :-------: | :-------: |\r\n| **1**  | **false** | **true**  | **false** |\r\n|   7    |   true    | **false** |   true    |\r\n|   11   |   false   | **false** |   true    |\r\n\r\n1과 10에 연결된 다른 노드를 모두 제거하고, `hasNode[1][10] = true`로 지정해야 한다. 임시 배열을 선언해서 변경하는 경우도 있겠지만, 배열 연산 오버헤드를 줄이기 위해 `selected = 10`으로 지정하여 DFS 알고리즘 수행 시 `selected`와 동일한 인덱스를 false로 인식하게끔 설계했다.\r\n\r\n``` java\r\n/**\r\n * 이분 매칭 갯수 반환 함수\r\n *\r\n * @return [int] 이분 매칭 갯수\r\n */\r\nprivate static int bipartite()\r\n{\r\n\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\tint size = 1;\r\n\t\r\n\tmatched = new int[left.length];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int i = 1; i < left.length; i++)\r\n\t{\r\n\t\tisVisit = new boolean[left.length];\r\n\t\t\r\n\t\t// 매칭 가능할 경우\r\n\t\tif (dfs(i))\r\n\t\t{\r\n\t\t\tsize++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n\r\n/**\r\n * DFS 알고리즘 결과 반환 함수\r\n *\r\n * @param num: [int] 시작점\r\n *\r\n * @return [int] 매칭 갯수\r\n */\r\nprivate static boolean dfs(int num)\r\n{\r\n\t// 첫 방문일 경우\r\n\tif (!isVisit[num])\r\n\t{\r\n\t\tisVisit[num] = true;\r\n\t\t\r\n\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t{\r\n\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t{\r\n\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n<span class=\"primary\">이분 매칭</span> 소스는 위와 같다. `bipartite()`는 기본적인 이분 매칭 알고리즘과 크게 다르지 않다. `size`가 1부터 시작하는 이유는, 이미 입력의 첫 번째 수 `left[0]`과 합이 소수를 만족하는 `right[m]`과 매칭되었기 때문이다.\r\n\r\n`dfs()`에서 조건에 따라 필터링이 진행된다. 조건식은 `hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]]`와 같다.\r\n\r\n* `hasNode[num][i]`: `left[num]`과 `right[i]`가 서로 연결되어 있는지 (소수)\r\n* `i != selected`: `left[num]`이 `right[i]`와 매칭되지 않았는지\r\n* `!IS_NOT_PRIME[left[num] + right[i]]`: `left[num]`과 `right[i]` 소수인지\r\n\r\n위 조건식을 모두 만족할 경우에만 매칭을 수행한다.\r\n\r\n$N$이 반드시 짝수거나, 입력된 숫자의 홀수, 짝수가 반드시 동일하다는 조건이 존재하지 않으므로, 이 경우 -1을 출력해야한다. 또한, 모든 조건이 일치해도 매칭이 하나도 되지 않을 경우 역시 -1을 출력해야한다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 이분 매칭\r\n* 에라토스 테네스의 체","url":["2021-06-26-a1017","2021","06","26","a1017"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1016번 제곱 ㄴㄴ수","excerpt":"어떤 수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-23T00:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I","에라토스 테네스의 체"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-23-a1016.md","content":"\r\n# 제곱 ㄴㄴ수\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/15.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1016번 문제](https://www.acmicpc.net/problem/1016)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n어떤 수 $X$가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 두 정수 min과 max가 주어진다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 [min,max]구간에 제곱ㄴㄴ수가 몇 개인지 출력한다.\r\n\r\n## 제한\r\n\r\n* $1 ≤ \\text{min} ≤ 1,000,000,000,000$\r\n* $\\text{min} ≤ \\text{max} ≤ \\text{min} + 1,000,000$\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 10\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n7\r\n```\r\n\r\n# 풀이\r\n\r\n주어진 구간에서 제곱수(4, 9, 16 등)으로 나누어지지 않는 수의 갯수를 구하면 되는 문제.\r\n\r\n개념은 생각보다 간단하다. <span class=\"primary\">에라토스 테네스의 체</span>에 대해 알고있다면 생각보다 쉽게 접근할 수 있기도 하고. 의외로 문제는 다른 쪽에 있다.\r\n\r\n1. min, max의 최대값이 1조 단위다.\r\n2. 구간이 반드시 1부터 시작하지 않는다.\r\n3. 배열의 인덱스는 반드시 `int` 데이터만 가능하다.\r\n\r\n보편적인 정수 데이터인 `int`의 최대값이 약 21억인걸 감안하면 턱없이 큰 수. 때문에 `long` 데이터의 사용이 강제된다. 반면 배열의 인덱스는 `int` 데이터만 사용 가능하므로, `int`와 `long`의 적절한 데이터 선언 및 변환이 필요하다.\r\n\r\n최소값 <span class=\"lightBlue-A400\">min</span>과 최대값 <span class=\"lightBlue-A400\">max</span>는 그 수가 매우 클 수는 있어도, 그 차이는 백만 이하로만 나오므로 배열로 다루는데 무리가 없다.\r\n\r\n만약, min = 1,000,000,000,000(1조)이고, max = 1,000,000,500,000(1조 50만)일 경우, 실제로 비교해야할 구간은 약 50만개밖에 되지 않는다. 이 구간을 배열 $A$로 표시하면 $A[0] = 1,000,000,000,000\\text{(min)}$가 된다. 즉, $A[i] = i + \\text{min}$으로 다뤄야한다.\r\n\r\n**제곱수의 배수를 제외**해야한다는 점에서 소수의 배수를 제외하여 소수를 판별하는 <span class=\"primary\">에라토스 테네스의 체</span>의 개념와 매우 흡사하다. 즉, <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘에서 소수가 아닌 제곱수의 배수를 판별하게끔 살짝 변형시켜주면 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1016 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/23/a1016\">1016 풀이</a>\r\n * @since 2021.06.23 Fri 00:22:31\r\n */\r\npublic class Main\r\n{\r\n\t// 최소값\r\n\tprivate static long min;\r\n\t\r\n\t// 최대값\r\n\tprivate static long max;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tlong[] temp = Arrays.stream(reader.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\r\n\t\t\r\n\t\tmin = temp[0];\r\n\t\tmax = temp[1];\r\n\t\t\r\n\t\twriter.write(Integer.toString(solve()));\r\n\t\twriter.newLine();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @return [int] 제곱수로 나누어 떨어지지 않는 수의 갯수\r\n\t */\r\n\tprivate static int solve()\r\n\t{\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tboolean[] isNotPow = eratosthenes();\r\n\t\t\r\n\t\tfor (boolean item : isNotPow)\r\n\t\t{\r\n\t\t\t// 제곱수로 나누어 떨어지지 않는 수일 경우\r\n\t\t\tif (!item)\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 에라토스 테네스의 체 배열 반환 함수\r\n\t * true: 제곱ㄴㄴ수가 아닌 수\r\n\t * false: 제곱ㄴㄴ수\r\n\t *\r\n\t * @return [boolean[]] 에라토스 테네스의 체 배열\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tint length = (int) (max - min + 1);\r\n\t\t\r\n\t\tboolean[] isNotPow = new boolean[length];\r\n\t\t\r\n\t\tfor (long i = 2; i * i <= max; i++)\r\n\t\t{\r\n\t\t\tlong pow = i * i;\r\n\t\t\t\r\n\t\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\t\r\n\t\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t\t{\r\n\t\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPow;\r\n\t}\r\n}\r\n```\r\n\r\n`solve()` 메소드는 단순히 갯수를 파악하는 로직이므로 그 의도만 알면 된다. 가장 핵심인 부분은 <span class=\"primary\">에라토스 테네스의 체</span>를 변형한 아래 코드다.\r\n\r\n``` java\r\n/**\r\n * 에라토스 테네스의 체 배열 반환 함수\r\n *\r\n * true: 제곱ㄴㄴ수가 아닌 수\r\n * false: 제곱ㄴㄴ수\r\n *\r\n * @return [boolean[]] 에라토스 테네스의 체 배열\r\n */\r\nprivate static boolean[] eratosthenes()\r\n{\r\n\tint length = (int) (max - min + 1);\r\n\t\r\n\tboolean[] isNotPow = new boolean[length];\r\n\t\r\n\tfor (long i = 2; i * i <= max; i++)\r\n\t{\r\n\t\tlong pow = i * i;\r\n\t\t\r\n\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\r\n\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t{\r\n\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn isNotPow;\r\n}\r\n```\r\n\r\n총 2개의 반복문이 돌아간다. 인덱스는 각각 $i$, $j$다.\r\n\r\n* $i$: 제곱수의 제곱근\r\n* $j$: 제곱수의 배수를 구하기 위한 인덱스\r\n\r\n1보다 큰 제곱수는 4이므로, 인덱스 $i$의 시작값은 2이며, 제곱수인 $i^2$의 크기가 max 이하일때 까지 반복한다. 만약, 구간이 10부터 30까지라면, $i$는 2<span class=\"grey-500\">(4)</span>부터 5<span class=\"grey-500\">(25)</span>까지 증가할 것이다.\r\n\r\n인덱스 $j$는 약간 복잡한데, 이는 구간의 존재 때문이다. 기본적으로 <span class=\"primary\">에라토스 테네스의 체</span>는 1부터 시작하므로 상관없지만, 해당 문제는 <span class=\"red-500\">시작값이 1이 아닐 경우</span>가 존재한다.\r\n\r\n예를 들어, $i = 2$이고 구간이 10 ~ 20까지라고 가정하자. $i^2 = 4$이므로 제곱수 4의 배수를 제거해야한다. 만약 평상시처럼 곱셈의 인덱스를 1부터 시작해서 $4 \\times 1$, $4 \\times 2$, $\\dots$와 같이 시작한다면 문제가 생긴다. 구간은 10부터인데 비해, 10 이하인 4, 8을 제거하게되니 이를 걸러내야한다. 만약 구간이 1000부터 시작이라면 250개의 쓸모없는 연산이 발생한다. 구간이 최대 1조부터 시작할 수 있음을 생각한다면 구간의 시작에 따라 곱셈 인덱스 $j$를 적절히 계산해야한다.\r\n\r\n$i = 2$일 경우, $i^2 = 4$이다. 구간의 시작이 10일 경우, 10 이하인 수 $4 \\times 1$, $4 \\times 2$는 건너뛰므로 곱셈 인덱스 $j$는 3부터 시작해야한다.\r\n\r\n$$\r\nj_{\\text{min}} = \r\n\\begin{cases}\r\n\t\\text{min} \\div i^2 \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 == 0)\\\\\r\n\t(\\text{min} \\div i^2) + 1 \\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 \\,\\,\\, !=  0)\r\n\\end{cases}\r\n$$\r\n\r\n즉, 곱셈 인덱스 $j$의 시작값의 일반식은 위와 같다.\r\n\r\n$\\text{제곱수의 배수} = j \\times i^2 \\,\\,\\, (j = 1, 2, 3, \\dots)$이므로, 해당값을 모두 제외하면 된다. 단, $j \\times i^2$는 실제 값이므로, 배열의 인덱스는 $(j \\times i^2) - \\text{min}$이다.\r\n\r\n배열에 `true`를 할당하는 이유는 `boolean[]`의 초기값이 `false`이기 때문. `Arrays.fill()` 메소드를 활용하여 `true`로 초기화할 수도 있으나, 의미론적으론 좋지만 불필요한 연산이므로 `false`를 제곱ㄴㄴ수로, `true`를 제곱ㄴㄴ수가 아닌 수로 지칭한다. 배열 이름이 `isNotPow`인 이유도 이때문.\r\n\r\n이후 `isNotPow` 배열을 순회하며, 값이 `false`인 수만 카운팅하면 된다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 에라토스 테네스의 체","url":["2021-06-23-a1016","2021","06","23","a1016"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1015번 수열 정렬","excerpt":"P[0], P[1], ..., P[N - 1]은 0부터 N - 1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다. 적용하는 방법은 B[P[i]] = A[i]이다. 배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-22T01:23:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER IV","정렬"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-22-a1015.md","content":"\r\n# 수열 정렬\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/7.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1015번 문제](https://www.acmicpc.net/problem/1015)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n$P[0], P[1], \\, \\dots \\, P[N - 1]$은 $0$부터 $N - 1$까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 $P$를 길이가 $N$인 배열 $A$에 적용하면 길이가 $N$인 배열 $B$가 된다. 적용하는 방법은 $B[P[i]] = A[i]$이다.\r\n\r\n배열 $A$가 주어졌을 때, 수열 $P$를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 배열 $A$의 크기 $N$이 주어진다. 둘째 줄에는 배열 $A$의 원소가 0번부터 차례대로 주어진다. $N$은 50보다 작거나 같은 자연수이고, 배열의 원소는 1,000보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 비내림차순으로 만드는 수열 $P$를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n2 3 1\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 2 0\r\n```\r\n\r\n# 풀이\r\n\r\n정렬에 대해 잘 알고 있다면 쉬어가는 문제. 한 마디로, <span class=\"amber-A400\">배열 속 요소들을 크기별 등수로 바꾸어 동일한 자리에 표시</span>해주면 된다.\r\n\r\n예제의 경우, 배열 $A$가 $[ 2, 3, 1 ]$로 주어졌는데, 이를 오름차순으로 표시하여 배열 $A1$로 만들면 $[ 1, 2, 3 ]$이 된다. 즉 $A1[0] = 1$이 된다. $A1$의 인덱스를 $A$의 요소의 순서에 맞게 출력하는 것이 알고리즘의 최종 동작이다.\r\n\r\n## 배열 A의 순서 기억하기\r\n\r\n첫 번째로, 정수형 배열의 오름차순 정렬은 매우 쉽다. `Arrays.sort(A);`만 적용해주면 될 일이기 때문. 문제는 정렬한 인덱스를 원본 배열 $A$의 순서대로 출력해야 한다는 것.\r\n\r\n이를 기억하는 장치로 배열 $A$를 2차원 배열로 만들어 $A[i][0]$에는 <span class=\"orange-A400\">i번째 입력값의 값</span>, $A[i][1]$에는 순번 인덱스 <span class=\"orange-A400\">i</span>를 입력한다.\r\n\r\n이를 표로 도식화하면 아래와 같다.\r\n\r\n|    $i$    |   0   |   1   |   2   |\r\n| :-------: | :---: | :---: | :---: |\r\n| $A[i][0]$ |   2   |   3   |   1   |\r\n| $A[i][1]$ |   0   |   1   |   2   |\r\n\r\n따라서 배열 $A$를 정렬해도, 순서를 기억할 수 있게 된다.\r\n\r\n|    $i$    |   0   |   1   |   2   |\r\n| :-------: | :---: | :---: | :---: |\r\n| $A[i][0]$ |   1   |   2   |   3   |\r\n| $A[i][1]$ |   2   |   0   |   1   |\r\n\r\n위 표는 오름차순 정렬을 적용한 것으로, $A[i][1]$을 통해 원래의 순서로 되돌릴 수 있을 것이다.\r\n\r\n## 정렬 후 되돌리기\r\n\r\n배열 $A$에 수열 $P$를 적용한 결과인 $B$를 구한다. 위에서 정렬을 통해 크기 순위를 계산했으므로, 이를 <span class=\"green-A400\">위치에 맞게 순서를 되돌려 출력</span>하면 된다.\r\n\r\n원래의 위치값은 $A[i][1]$이 가지고 있으므로, 이 인덱스를 활용하자. 배열 $B$의 식은 $B[A[i][1]] = i$와 같은 형태로 계산할 수 있다. 예를 들어, $i = 1$일 때 정렬된 배열 $A[1][1] = 0$이므로 $B[0] = 1$이 된다. 이를 코드로 구현하면 완성된다.\r\n\r\n## 이차원 배열 정렬하기\r\n\r\n여기서 작은 문제가 하나 생기는데, 바로 정렬이다. 대표적인 정렬 메소드인 `Arrays.sort(A);`의 경우 1차원 배열에서는 의도에 맞게 동작하나, 그 이상인 $n$차원 배열부터는 의도한대로 동작하지 않는다. 또한 `Arrays.sort(A);`는 무조건 오름차순으로만 동작한다.\r\n\r\n이를 해결하기 위해선, `sort()` 메소드를 직접 오버라이딩하면 된다. 물론 아예 구현해도 되지만, 여기서는 기본 API를 최대한 살려 sort 함수를 우리 의도에 맞게 오버라이딩한다.\r\n\r\n``` java\r\nArrays.sort(A, (next, current) -> {\r\n\t// 다음 원소가 현재 원소보다 클 경우\r\n\tif (next[0] < current[0])\r\n\t{\r\n\t\t// 현재 원소를 다음 원소의 뒤로 정렬\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// 다음 원소가 현재 원소보다 작을 경우\r\n\telse if (next[0] > current[0])\r\n\t{\r\n\t\t// 현재 원소를 다음 원소의 앞으로 정렬\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t// 다음 원소가 현재 원소와 동일할 경우\r\n\telse\r\n\t{\r\n\t\t// 현 위치 유지\r\n\t\treturn 0;\r\n\t}\r\n})\r\n```\r\n\r\n`Comparater` 인터페이스를 lambda 함수의 형태로 구현한 코드다. `current`는 <span class=\"blue-400\">현재 요소</span>를, `next`는 <span class=\"blue-400\">다음 요소</span>를 의미하며 <span class=\"blue-400\">반환값이 양수일 경우 현재 요소가 다음 요소보다 뒤로 정렬</span>되며, <span class=\"blue-400\">반환값이 음수일 경우 현재 요소가 다음 요소보다 앞으로 정렬</span>된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1015 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/22/a1015\">1015 풀이</a>\r\n * @since 2021.06.22 Tue 01:23:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열의 크기\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 원본 배열\r\n\t\tint[][] A = new int[N][2];\r\n\t\t\r\n\t\t// 정렬 배열\r\n\t\tint[] B = new int[N];\r\n\t\t\r\n\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tA[i][0] = Integer.parseInt(temp[i]);\r\n\t\t\tA[i][1] = i;\r\n\t\t}\r\n\t\t\r\n\t\t// 정렬 수행\r\n\t\tsort(A);\r\n\t\t\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tint index = A[i][1];\r\n\t\t\t\r\n\t\t\tB[index] = i;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int b : B)\r\n\t\t{\r\n\t\t\tbuilder.append(b).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString().trim());\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정렬 함수\r\n\t *\r\n\t * @param A: [int[][]] 대상 배열\r\n\t */\r\n\tprivate static void sort(int[][] A)\r\n\t{\r\n\t\tArrays.sort(A, (next, current) ->\r\n\t\t{\r\n\t\t\t// 현재값이 더 클 경우\r\n\t\t\tif (next[0] < current[0])\r\n\t\t\t{\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 다음값이 더 클 경우\r\n\t\t\telse if (next[0] > current[0])\r\n\t\t\t{\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 현재값과 다음값이 같을 경우, 사전순 정렬\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn Integer.compare(next[1], current[1]);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 정렬","url":["2021-06-22-a1015","2021","06","22","a1015"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1014번 컨닝","excerpt":"최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다. 시험은 N행 X M열 크기의 직사각형 교실에서 이루어진다. 교실은 1 X 1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다. 최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-18T16:42:44","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM IV","네트워크 플로우","최소 버텍스 커버","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-18-a1014.md","content":"\r\n# 컨닝\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/17.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1014번 문제](https://www.acmicpc.net/problem/1014)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.\r\n\r\n시험은 $N$행 $\\times$ $M$열 크기의 직사각형 교실에서 이루어진다. 교실은 $1 \\times 1$ 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.\r\n\r\n최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122051353-78bea480-ce1f-11eb-92c3-5fa4e3dc96b9.png)\r\n\r\n위의 그림을 보자. $A$, $C$, $D$ 혹은 $E$에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, $B$에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.\r\n\r\n위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.\r\n\r\n최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $C$가 주어진다. 각각의 테스트 케이스는 아래와 같이 두 부분으로 이루어진다.\r\n\r\n첫 번째 부분에서는 교실의 세로길이 N과 가로길이 M이 한 줄에 주어진다. $(1 ≤ M ≤ 10, 1 ≤ N ≤ 10)$\r\n\r\n두 번째 부분에서는 정확하게 N줄이 주어진다. 그리고 각 줄은 M개의 문자로 이루어져있다. 모든 문자는 ‘.’(앉을 수 있는 자리) 또는 ‘x’(앉을 수 없는 자리, 소문자)로 구성된다.\r\n\r\n## 출력\r\n\r\n각각의 테스트 케이스에 대해 그 교실에서 시험을 볼 수 있는 최대 학생의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n4\r\n2 3\r\n...\r\n...\r\n2 3\r\nx.x\r\nxxx\r\n2 3\r\nx.x\r\nx.x\r\n10 10\r\n....x.....\r\n..........\r\n..........\r\n..x.......\r\n..........\r\nx...x.x...\r\n.........x\r\n...x......\r\n........x.\r\n.x...x....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4\r\n1\r\n2\r\n46\r\n```\r\n\r\n# 풀이\r\n\r\n또 한번의 <span class=\"teal-A400\">플래티넘</span> 문제. 하....\r\n\r\n문제 이름 그대로 컨닝을 못 참게 만드는 문제다. 문제를 푸는 방식에는 두 가지가 있다. <span class=\"primary\">네트워크 플로우</span>와 <span class=\"primary\">비트마스킹</span>. 본 포스팅에서는 <span class=\"primary\">네트워크 플로우</span> 방식을 차용한다. 이게 정석이라고 하기도 하고, JAVA 풀이는 죄다 <span class=\"primary\">비트마스킹</span> 방식이라서.\r\n\r\n나 같이 전공지식이 전무한 코더에게는 너무나도 가혹한 문제다. 지금까지 살면서 하나 깨달은 게 있다면, 아무리 처음 보는 개념이라도 계속 쳐다보면 언젠가 이해된다. 하루가 됐든 한 달이 됐든. 그 난리를 펴가며 이해한 내용은 아래와 같다.\r\n\r\n## 문제 분석하기\r\n\r\n문제 해결에 영향을 미치는 조건은 아래와 같다.\r\n\r\n1. 임의의 자리를 기준으로 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위 자리를 컨닝할 수 있다.\r\n2. 파손되어 앉을 수 없는 자리가 존재한다.\r\n\r\n임의의 자리가 있다고 가정하고 이를 도식화해보자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956338-de7cd480-d3bb-11eb-93ce-5c1ea19185af.png)\r\n\r\n위 사진과 같이 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 자신의 주변엔 최대 8개의 <span class=\"indigo-200\">자리</span>가 존재할 수 있다. 1번 규칙에 따라 컨닝이 가능한 자리를 도식하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956398-eccaf080-d3bb-11eb-9d2b-91e4aaa7ea40.png)\r\n\r\n<span class=\"red-400\">컨닝 가능한 자리</span>는 위와 같이 6개로 표시된다. 엥? 분명히 1번 규칙에서는 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위만 가능하다고 했다. 해당 규칙에 따르면 4개 자리여야 할텐데, 왼쪽 대각선 아래, 오른쪽 대각선 아래는 왜 해당되는걸까?\r\n\r\n<span class=\"indigo-A400\">특정 자리</span>에서 왼쪽 대각선 아래, 오른쪽 대각선 아래를 컨닝할 순 없지만, 반대로 왼쪽 대각선 아래, 오른쪽 대각선 아래에선 <span class=\"indigo-A400\">특정 자리</span>를 컨닝할 수 있기 때문. <span class=\"lightBlue-A400\">컨닝을 할 수 있는 자리와 당할 수 있는 자리</span> 모두를 고려해야한다.\r\n\r\n반대로 컨닝이 불가능한 자리를 도식하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956442-f7858580-d3bb-11eb-8154-2bfe476ae278.png)\r\n\r\n<span class=\"green-A400\">컨닝이 불가능한 자리</span>는 위와 같이 2개로 표시된다. 자신의 앞 뒤는 컨닝할 수 없다. 우리가 설계한 알고리즘이 이와 같은 결과를 계산할 수 있어야 한다. 그렇다면 이를 어떤 방법으로 해결할 수 있을까?\r\n\r\n이 문제를 해결하는 방법은 크게 두 가지가 있다.\r\n\r\n1. 최소 버텍스 커버, 이분 매칭\r\n2. DP, 비트마스킹\r\n\r\n이 중 1번 최소 버텍스 커버와 이분 매칭을 사용하여 풀고자 한다.\r\n\r\n## Miminum Vertex Cover(최소 버텍스 커버)\r\n\r\n<span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>는 모든 노드가 연결된 점(Vertex)의 최소 집합을 의미한다. 예를 들어, 아래와 같은 그림이 있다고 가정하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956504-05d3a180-d3bc-11eb-8006-7f22037020b9.png)\r\n\r\n위 사진에서의 $A$ ~ $I$에 해당하는 9개 점이 Vertex, 각 점마다 연결된 선이 노드가 된다. 버텍스가 모든 노드를 커버할 수 있다면 <span class=\"amber-A400\">버텍스 커버</span>라 볼 수 있다. 그 중 <span class=\"green-A400\">모든 노드를 커버하는 가작 적은 버텍스의 집합</span>이 <span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>라 할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956549-108e3680-d3bc-11eb-802e-53765cacf3ed.png)\r\n\r\n버텍스 $E$의 경우, 대다수의 노드를 포함하고 있지만 $\\overline{AB}$, $\\overline{BC}$, $\\overline{FI}$ 노드를 포함하지 않으므로 버텍스 $E$만으로는 <span class=\"amber-A400\">최소 버텍스 커버</span> 조합이 될 수 없다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956594-1b48cb80-d3bc-11eb-8b48-cf263fd7bcfe.png)\r\n\r\n위와 같이 $B$, $F$ 버텍스를 포함할 경우 존재하는 모든 노드를 포함하는 가장 적은 버텍스의 조합이므로 <span class=\"amber-A400\">최소 버텍스 커버</span>가 된다.\r\n\r\n유의깊게 봐야할 점은, <span class=\"amber-A400\">최소 버텍스 커버</span>를 통해 <span class=\"primary\">최대 독립 집합</span>을 구할 수 있다. <span class=\"amber-A400\">최소 버텍스 커버</span>에 해당하는 버텍스와 모든 노드를 제거해보자. 아래와 같이 도식할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956663-2996e780-d3bc-11eb-97f7-d24bd59126fd.png)\r\n\r\n이처럼, 전체 그룹에서 <span class=\"amber-A400\">최소 버텍스 커버</span>를 제거하면 <span class=\"orange-A400\">나머지 버텍스들은 그 어떤 버텍스끼리도 연결되지 않는 독립 버텍스</span>다. <span class=\"amber-A400\">최소 버텍스 커버</span>가 모든 노드를 연결한 버텍스의 최소 집함임을 생각한다면, 이를 뺀 나머지는 어떤 버텍스와도 연결되지 않는 버텍스 집합의 최대 조합이라고 할 수 있다. 즉, 최대 독립 집합 $=$ 전체 그룹 $-$ 최소 버텍스 커버로 표현할 수 있다.\r\n\r\n그래, 그건 그렇다 치고, 위 개념이 이 문제와 무슨 연관성이 있길래 이렇게 장황하게 서술할까? 이번엔 조금 다르게 이 문제와 연관지어 예시를 들어본다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956705-33204f80-d3bc-11eb-8e58-c1c96509d4fe.png)\r\n\r\n그 어떤 자리도 파손되지 않은 온전한 9개 자리가 있다고 가정하자. 각 자리별로 컨닝이 가능한 자리를 노드로 연결하면 위와 같이 도식할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956771-42070200-d3bc-11eb-908c-fc5c5db4f583.png)\r\n\r\n위 사진에서 <span class=\"amber-A400\">최소 버텍스 커버</span>는 $B$, $E$, $H$가 된다. 이 자리 3개로 위 사진의 모든 노드를 포함할 수 있기 때문이다. 이 자리들을 제거하여 <span class=\"primary\">최대 독립 집합</span>을 표현하면 어떻게 될까?\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956808-4cc19700-d3bc-11eb-82ff-dc32d98960c4.png)\r\n\r\n나머지 자리인 $A$, $C$, $D$, $F$, $G$, $H$만 남게 되며, 각 자리는 그 어떤 노드와도 연결되어있지 않다. 이 사진에서의 노드는 컨닝 가능한 자리이므로, **노드가 없다는 것은 컨닝할 수 있는 자리가 없다**는 뜻이 된다. 즉, <span class=\"amber-A400\">최소 버텍스 커버</span> 로직을 설계하는 것이 이번 알고리즘의 키 포인트다.\r\n\r\n## 이분 매칭\r\n\r\n자, <span class=\"amber-A400\">최소 버텍스 커버</span>가 알고리즘의 키인 건 알았으니, 이를 구현하기만 하면 된다. 안타깝게도 <span class=\"amber-A400\">최소 버텍스 커버</span>를 코딩으로 계산하는 것은 매우 복잡한 일이다.\r\n\r\n**König's Theorem**(쾨닉의 정리)에 의하면 <span class=\"red-400\">모든 이분 그래프의 최대 매칭은 최소 버텍스 커버와 같다</span>고 증명한다. 즉, 위 그래프를 이분 그래프로 변경하여 최대 매칭을 구하면 <span class=\"amber-A400\">최소 버텍스 커버</span>를 구할 수 있다는 뜻이다.\r\n\r\n결론적으로, <span class=\"amber-A400\">최소 버텍스 커버</span>를 구하기 위해 <span class=\"teal-A400\">이분 매칭</span> 알고리즘을 구현해야 한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>의 연산에 사용하는 **이분 그래프**는 아래와 같은 특징을 가진다.\r\n\r\n* 모든 정점을 두 그룹으로 나눌 수 있다.\r\n* 모든 노드는 한 그룹에서 다른 그룹으로 연결된다.\r\n* 같은 그룹끼리는 연결되지 않는다.\r\n\r\n고등수학을 배웠다면 우리는 이미 이분 그래프를 접한적이 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956906-6367ee00-d3bc-11eb-8612-b27579146961.png)\r\n\r\n위 사진은 임의의 함수 $f(x)$에 대한 식을 도식화한 것이다. 위 함수 도식은 이분 그래프의 적절한 예시가 될 수 있다. 모든 그룹이 $x$ 혹은 $y$그룹으로 나뉘며, 모든 노드가 $x$에서 $y$로 연결된다.\r\n\r\n**이분 그래프의 매칭**은 각 그룹의 버텍스를 매칭하는 노드의 집합이다. 단, 각 노드의 끝 점은 다른 노드와 중복되지 않는다. **이분 그래프의 최대 매칭**은 이분 그래프의 매칭의 노드 수가 최대인 조합이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122956970-71b60a00-d3bc-11eb-9019-0ffaef2ac35b.png)\r\n\r\n위와 같이 연결된 이분 그래프가 있다고 가정하자. $1$번 버텍스를 기준으로 $A$와 $B$에 노드가 연결되어있다. $\\overline{A1}$을 선택할 경우, $\\overline{B1}$은 매칭에서 제외된다. 노드의 끝 선이 $1$번 버텍스로 동일하기 때문이다. 각 노드의 끝 점은 다른 노드와 중복되지 않는다는 말의 의미는 이와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122957021-7e3a6280-d3bc-11eb-8b24-07a0662def70.png)\r\n\r\n1. $A$와 $1$번 버텍스를 잇는 노드 $\\overline{A1}$을 선택한다.\r\n2. $B$와 $1$번 버텍스를 잇는 노드 $\\overline{B1}$은 노드 $\\overline{A1}$이 $1$번 버텍스를 포함하므로 선택할 수 없다.\r\n3. 노드 $\\overline{A1}$의 시작 버텍스인 $A$에부터 다른 노드가 있는지 탐색한다.\r\n4. $A$ 버텍스와 연결된 다른 노드가 없으므로 노드 $\\overline{A1}$의 선택을 유지한다.\r\n5. $C$와 $1$번 버텍스를 잇는 노드 $\\overline{C1}$을 선택한다.\r\n6. 마지막 버텍스이므로 탐색을 종료하고 갯수를 계산한다.\r\n\r\n이와 같은 과정으로 이분 그래프의 최대 매칭의 수는 `2`가 된다. 물론 최대 매칭의 조합은 여러개가 될 수 있겠지만, 이 알고리즘에선 \"조합\"이 아니라 \"수\"가 중요하므로 경우의 수를 구할 필요는 없다.\r\n\r\n> **이분 그래프의 최대 매칭 조합**  \r\n> 위 그래프의 최대 매칭 조합은 $[ \\overline{A1}, \\overline{C2} ]$, $[ \\overline{A1}, \\overline{C3} ]$, $[ \\overline{B1}, \\overline{C2} ]$, $[ \\overline{B1}, \\overline{C3} ]$으로 최대 매칭의 수는 2이며 4가지 경우의 수가 존재한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>을 문제에 적용하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122957080-898d8e00-d3bc-11eb-84f6-7b504b2d93b3.png)\r\n\r\n이번엔 조금 복합적인 예시다. 버텍스 $A$와 $E$가 파손되어 앉을 수 없는 상황이다. 이러한 조건에서 컨닝 가능한 자리를 노드로 표현하면 위 사진과 같이 표현할 수 있다. 규칙의 특성 상, 한 쪽 열은 양 옆의 열에 영향을 준다. 즉, 홀수열과 짝수열로 그룹을 나눌 수 있다. 열의 홀짝을 기준으로 나눠 이분 그래프를 표시하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/122957152-9ca05e00-d3bc-11eb-8a63-1c7ae6e5edfb.pnghttps://user-images.githubusercontent.com/50317129/122957152-9ca05e00-d3bc-11eb-8a63-1c7ae6e5edfb.png)\r\n\r\n위 이분 그래프의 최대 매칭은 2가 된다. 즉, 최소 버텍스 커버의 조합은 $B$, $H$고 파손되서 착석이 불가능한 자리는 $A$, $E$가 된다. 따라서 $C$, $D$, $F$, $G$, $I$가 컨닝 불가능한 자리가 된다. 단순히 자리의 \"수\"만 계산하면 되므로 `컨닝 불가능한 자리 = 전체 자리 - 최소 버텍스 커버 수 - 파손된 자리`가 된다. 따라서 위 그래프의 알고리즘 수행 결과는 5가 된다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>은 <span class=\"blue-400\">BFS(Breadth First Search, 너비 우선 탐색)</span> 혹은 <span class=\"blue-400\">DFS(Depth First Search, 깊이 우선 탐색)</span>으로 구현할 수 있다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1014 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/18/a1014\">1014 풀이</a>\r\n * @since 2021.06.18 Fri 16:42:44\r\n */\r\npublic class Main\r\n{\r\n\t// 교실 세로 길이 (y)\r\n\tprivate static int N;\r\n\t\r\n\t// 교실 가로 길이 (x)\r\n\tprivate static int M;\r\n\t\r\n\t// 자리 번호\r\n\tprivate static int[][] room;\r\n\t\r\n\t// 컨닝 가능한 자리\r\n\tprivate static boolean[][] nodes;\r\n\t\r\n\t// 방문 횟수\r\n\tprivate static int visitCount;\r\n\t\r\n\t// 버텍스별 방문 횟수\r\n\tprivate static int[] visit;\r\n\t\r\n\t// 버텍스 매칭 여부\r\n\tprivate static int[] matched;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 현재 자리에서 컨닝이 가능한 자리의 위치 상대좌표\r\n\t\tint[][] scopes = { { -1, 1 }, { -1, 0 }, { -1, -1 }, { 1, 1 }, { 1, 0 }, { 1, -1 } };\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint C = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\twhile (C-- > 0)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\tM = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 자리의 파손 여부\r\n\t\t\tboolean[][] canSit = new boolean[N][M];\r\n\t\t\t\r\n\t\t\t// 자리의 번호\r\n\t\t\tint numbering = 1;\r\n\t\t\t\r\n\t\t\t// 파손된 자리의 총 갯수\r\n\t\t\tint broken = 0;\r\n\t\t\t\r\n\t\t\troom = new int[N][M];\r\n\t\t\tnodes = new boolean[N * M][N * M];\r\n\t\t\t\r\n\t\t\tvisitCount = 1;\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\"\");\r\n\t\t\t\t\r\n\t\t\t\tfor (int m = 0; m < M; m++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 자리 번호 기록\r\n\t\t\t\t\troom[n][m] = numbering++;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 앉을 수 있는 경우\r\n\t\t\t\t\tif (temp[m].equals(\".\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 파손된 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// 파손 갯수 1 추가\r\n\t\t\t\t\t\tbroken++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\t// 홀수 열만 대상으로 동작함\r\n\t\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 앉을 수 있는 좌석일 경우\r\n\t\t\t\t\tif (canSit[n][m])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int[] scope : scopes)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// 컨닝 가능성 있는 자리의 상대좌표\r\n\t\t\t\t\t\t\tint no = n + scope[1];\r\n\t\t\t\t\t\t\tint mo = m + scope[0];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 상대좌표가 교실을 벗어나지 않으면서, 앉을 수 있을 경우\r\n\t\t\t\t\t\t\tif (no > -1 && mo > -1 && no < N && mo < M && canSit[no][mo])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// 노드 연결 표시\r\n\t\t\t\t\t\t\t\tnodes[room[n][m] - 1][room[no][mo] - 1] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tint result = bipartite();\r\n\t\t\t\r\n\t\t\twriter.write(Integer.toString(N * M - broken - result));\r\n\t\t\twriter.newLine();\r\n\t\t\twriter.flush();\r\n\t\t}\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 매칭 갯수\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tvisit = new int[N * M];\r\n\t\t\r\n\t\tmatched = new int[N * M];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int n = 0; n < N; n++)\r\n\t\t{\r\n\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t{\r\n\t\t\t\tvisitCount++;\r\n\t\t\t\t\r\n\t\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static int dfs(int num)\r\n\t{\r\n\t\t// 같은 버텍스가 아닐 경우\r\n\t\tif (visit[num] != visitCount)\r\n\t\t{\r\n\t\t\tvisit[num] = visitCount;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t\t{\r\n\t\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\t\tif (nodes[num][i])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn 0;\r\n\t}\r\n}\r\n```\r\n\r\n유의깊게 봐야할 코드는 아래와 같다.\r\n\r\n``` java\r\nprivate static int bipartite()\r\n{\r\n\t// 매칭 갯수\r\n\tint size = 0;\r\n\t\r\n\tvisit = new int[N * M];\r\n\t\r\n\tmatched = new int[N * M];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int n = 0; n < N; n++)\r\n\t{\r\n\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t{\r\n\t\t\tvisitCount++;\r\n\t\t\t\r\n\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n```\r\n\r\n위 코드가 이분매칭을 <span class=\"primary\">DFS 알고리즘</span>을 통해 구현한 것이다.  `for`문의 변수 선언 중 `m += 2`인 이유는 홀수열만 체크하기 위함이다.\r\n\r\n``` java\r\nprivate static int dfs(int num)\r\n{\r\n\t// 같은 버텍스가 아닐 경우\r\n\tif (visit[num] != visitCount)\r\n\t{\r\n\t\tvisit[num] = visitCount;\r\n\t\t\r\n\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t{\r\n\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\tif (nodes[num][i])\r\n\t\t\t{\r\n\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n이분매칭을 구현하는 <span class=\"primary\">DFS 알고리즘</span>의 코드는 위와 같다. `matched` 배열은 -1로 초기화되며, 매칭되는 버텍스의 번호를 할당받는다.\r\n\r\n$A$ 버텍스가 $B$ 버텍스와 연결된 노드 $\\overline{AB}$를 가질 경우, 이를 `matched[A] = B`와 같이 표시한다. 만약, $A$ 버텍스가 $B$ 버텍스를 연결하는 와중에 이미 $B$가 $C$와 연결되어있을 경우, $C$ 버텍스에 $B$가 아닌 다른 버텍스와 연결된 노드가 있는지 확인한다. 만약 가능할 경우, $\\overline{BC}$를 제거하고 $C$와 연결할 수 있는 다른 버텍스를 연결한다. 이후 $\\overline{AB}$를 연결한다.\r\n\r\n이 과정을 반복하여 연결을 수립할 수 있을 경우 1, 없을 경우 0을 반환한다. 이는 `boolean` 타입으로도 대체할 수 있으나, `dfs()`연산 결과를 더하기 때문에 편의상 `int`로 반환한다.\r\n\r\n## 비공식 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n10 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n42\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n21\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 8\r\n.X...X..\r\n..X.....\r\nX.......\r\n.X......\r\n..X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n18\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 7\r\nX...X..\r\n.X.....\r\n.......\r\nX......\r\n.X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n17\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 비트마스킹\r\n* 최대 유량\r\n* 비트필드를 이용한 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n[습격자 초라기](/posts/2021/06/06/a1006)가 매우 복잡한 케이스들을 이해하는데 할애했다면, 이 문제는 케이스가 복잡하다기 보단, 네트워크 플로우를 이해하고 적용하는데 대부분의 시간을 할애했다. 문제 보니까 가면 갈수록 플래티넘이 계속해서 나오는 구간도 있던데, 순서대로 푸는 규칙에 대해 진지하게 생각해봐야하나 싶다.\r\n\r\n## 참고\r\n\r\n* [개발괴발](https://m.blog.naver.com/kelle111/221537563173)\r\n* [Crocus](https://www.crocus.co.kr/814)","url":["2021-06-18-a1014","2021","06","18","a1014"]},{"header":{"title":"IntelliJ(인텔리제이) 시작 시 오류(java.net.BindException: Address already in use: bind)","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/121893356-d6d48480-cd58-11eb-80bb-d4611be3bd40.png","date":"2021-06-14T21:59:16","type":"posts","category":"JAVA","tag":["IntelliJ(인텔리제이)","Hyper-V","오류 해결책"],"comment":true,"publish":true},"name":"2021-06-14-intellij-error-onstart.md","content":"\r\n# 않이 갑자기 왜요ㅠㅠ\r\n\r\n분명히 어제까지만 해도 아무 이상없이 썼던 <span class=\"primary\">IntelliJ</span>를 퇴근 후에 키니 오류를 뱉으며 뻗어버렸다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121893316-c6bca500-cd58-11eb-9c2a-658c604ee6d1.png\" width=\"600px\" />\r\n</p>\r\n\r\n두 개의 오류창이 떴는데, 하나는 위와 같은 <span class=\"red-A400\">java.net.BindException: Address already in use: bind</span>에러였고 다른 하나는 왠 <span class=\"red-A400\">NullPointerException</span>이 떴었다. 하필 <span class=\"red-A400\">NullPointerException</span>이 맨 위에 뜨는 바람에 엉뚱한걸 찾고 있었는데, 창 옮기니까 뒤에 저 오류창이 숨어있었다.\r\n\r\n# 원인?\r\n\r\nWindows의 가상 OS머신인 <span class=\"lightBlue-A400\">Hyper-V</span>와 연관이 있는 모양이다. Windows 부팅 시 <span class=\"lightBlue-A400\">Hyper-V</span>에서 자신이 사용할 포트를 지정하는데, 이게 <span class=\"primary\">IntelliJ</span>와 겹쳐서 생긴다고 한다. 아니 갑자기 이제와서?\r\n\r\n실제로 난 <span class=\"lightBlue-A400\">Hyper-V</span>를 사용한다. CentOS 8과 Windows 10을 구동하고 있다. CentOS 8은 리눅스도 다뤄볼 겸 DB 하나 설치해서, 집에서 코딩할 때 DB 쓸 일 있으면 전부 저기다가 갖다 붙여서 쓰고 있다. Windows 10은 클린 PC가 필요하거나, 내가 극혐해 마지않는 인터넷뱅킹을 할 때 사용 중 ~~(플러그인 ㅂㄷㅂㄷ.....)~~ 이긴 한데, 거의 3개월 가까이 사용한 적이 없다. 간혹 Windows Update가 설정을 지멋대로 변경하기도 한다는데 그 때문인가.. 갑자기 잘 되던게 어떠한 문제로 인해 안 된다고 하는 경우가 왕왕있다. 지금까지 잘 돌아간 이유는 내가 알지 못 하는 어떤 신비의 힘이라도 작용했는 모양이다.\r\n\r\n# 해결방법\r\n\r\n<span class=\"green-A400\">윈도우 콘솔을 관리자 권한으로 실행</span>한다. <span class=\"primary\">cmd</span>, <span class=\"primary\">PowerShell</span> 등 어떠한 콘솔이든 명령어만 보낼 수 있으면 상관없다. 콘솔에 아래의 명령어를 입력한다.\r\n\r\n``` batch\r\n# Hyper-V 비활성화 (윈도우 재부팅 필요)\r\ndism.exe /Online /Disable-Feature:Microsoft-Hyper-V\r\n\r\n# TCPv6 6942 ~ 6952 포트 예약\r\nnetsh int ipv6 add excludedportrange protocol=tcp startport=6942 numberofports=10\r\n\r\n# Hyper-V 활성화 (윈도우 재부팅 필요)\r\ndism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All\r\n```\r\n\r\n<span class=\"lightBlue-A400\">Hyper-V</span> 활성화/비활성화에 각각 재부팅을 요구한다. 이후 <span class=\"primary\">IntelliJ</span>는 정상적으로 켜지는데, <span class=\"lightBlue-A400\">Hyper-V</span>가 제대로 안 되는 거 같았다. OS를 켜도 \"시작하는 중\"에서 넘어가질 않는다. <span class=\"lightBlue-A400\">Hyper-V</span> 기능 재설치하고 재부팅하고 다시 시도했는데 안 된다.... 싶었는데 냅둬놓고 기다리니 잘 되더라. IntelliJ 계열 프로그램 모두에게 발생 가능성이 있다고 한다.\r\n\r\n개운하진 않지만, 어쨌든 잘 해결됐으니 다행.","url":["2021-06-14-intellij-error-onstart","2021","06","14","intellij-error-onstart"]},{"header":{"title":"[JAVA] split vs StringTokenizer","excerpt":"알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.","coverImage":"https://www.textrazor.com/img/letters3.png","date":"2021-06-14T01:56:01","type":"posts","category":"JAVA","tag":["JAVA(자바)","String(문자열)","split","StringTokenizer"],"comment":true,"publish":true},"name":"2021-06-14-split-and-stringtokenizer.md","content":"\r\n# 개요\r\n\r\n알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.\r\n\r\n$$\r\n[ \"A\", \"B\", \"C\", \"D\" ] -> \"A B C D\"\r\n$$\r\n\r\n이를테면, 위와 같이 $[ \"A\", \"B\", \"C\", \"D\" ]$와 같은 배열을 전달하기 위해, 각 요소를 공백으로 구분하여 $\"A B C D\"$와 같이 전달하게 된다. 보통 내 경우 `split` 메소드를 활용하는데, 알고리즘 풀이를 찾아보다보니 `StringTokenizer`이라는 <span class=\"orange-400\">class</span>를 쓰는 코드들이 더러있었다. 처음보는 <span class=\"orange-400\">class</span>인데다, 접근성이 훨씬 뛰어난 `split`를 굳이 대체해서 쓰는 이유가 있을거라 판단. 직접 퍼포먼스를 비교해보기로 했다. 알고리즘은 수행속도 역시 중요한 지표로 작용하기 때문에, 조금이라도 시간을 줄일 필요가 있다. 안타깝게도 나는 코드 최적화 실력이 최악이라, 이런식으로 줄일 수 있는 자잘한 부분은 줄여야한다. 핵심 코드를 최적화할 생각은 안 하고 이런데서 시간을 단축하는게 꼭 다이어트한답시고 피자 먹으면서 제로콜라 마시는 느낌이긴 하나, `StringTokenizer`이 더 성능이 뛰어나다면 앞으로 푸는 알고리즘에 적용할 가치가 있을 것이다.\r\n\r\n## 테스트 환경\r\n\r\n| 구분  |                                                        내용                                                         |\r\n| :---: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| 언어  | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n|  OS   |                                                  Windows 10 64bit                                                   |\r\n|  CPU  |                                                   Intel i7-10700K                                                   |\r\n|  RAM  |                                                        32GB                                                         |\r\n\r\n# split 메소드\r\n\r\n`split` 메소드는 특정 <span class=\"lightBlue-400\">구분자</span>로 문자열을 분리하는 전통적인 메소드다. 굳이 JAVA가 아니더라도 C(++, #), JavaScript, Python 등 여러 언어에 존재하는 키워드라 어떤 언어든 문자열을 구분할 때 제일 먼저 시도하는 방법이다.\r\n\r\nJAVA의 `split`은 문자열 데이터 형식인 `String` <span class=\"orange-400\">class</span>에 포함된 메소드다. 문자열 데이터라면 `split`를 호출하여 문자열을 구분할 수 있다. 반환값은 `String[]` 객체.\r\n\r\n사용법은 아래와 같다.\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.13 Sun 22:50:57\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tString text = \"A B C D\";\r\n\t\t\r\n\t\tString[] splited = text.split(\" \");\r\n\t\t\r\n\t\tSystem.out.println(Arrays.toString(splited));\r\n\t}\r\n}\r\n```\r\n\r\n출력은 아래와 같다.\r\n\r\n``` tc\r\n[A, B, C, D]\r\n```\r\n\r\n문자열 `A B C D`가 공백을 기준으로 `[A, B, C, D]`로 분리된걸 확인할 수 있다. 그 밖에 한 가지 특이한 점이 있는데, JAVA의 `split` 메소드는 <span class=\"red-A400\">구분자에 정규식을 적용</span>할 수 있다. 이를 잘만 이용하면 복합적인 구분자를 사용할 수도 있다.\r\n\r\n# StringTokenizer\r\n\r\n이 포스팅을 쓰게 만든 직접적인 원인. `StringTokenizer` 역시 문자열을 구분하는데 특화된 <span class=\"orange-400\">class</span>의 일종이다. `String[]`을 반환하는 `split`과 달리 그 자체로 하나의 개별적인 <span class=\"orange-400\">class</span>라는 차이가 있다.\r\n\r\n`StringTokenizer tokenizer = new StringTokenizer(\"문자열\");`과 같은 형태로 초기화해서 사용한다. `StringTokenizer` 인스턴스를 사용하는데 알아두면 좋을법한 메소드는 아래와 같다.\r\n\r\n|    메소드     | 반환값  |         내용          |\r\n| :-----------: | :-----: | :-------------------: |\r\n|  countToken   |   int   |      토큰의 갯수      |\r\n|   nextToken   | String  |       다음 토큰       |\r\n| hasMoreTokens | boolean | 다음 토큰의 존재 유무 |\r\n\r\n`StringTokenizer tokenizer = new StringTokenizer(\"문자열\", \"구분자\");`와 같이 생성자의 인수에 구분자를 추가하여 원하는 구분자로 구분하게 할 수도 있다. 별도로 지정하지 않는다면 구분자는 `\\t\\n\\r\\t`로, 줄바꿈, 공백, 탭을 구분한다. 여기서 주의할 점이 하나 있는데, 기본 구분자 `\\t\\n\\r\\t`는 <span class=\"red-A400\">줄바꿈, 공백, 탭을 전부 포함</span>한다. 즉, `A B C D\\nA B C D`와 같이 공백과 줄바꿈이 혼용되어 있을 경우, 공백과 줄바꿈을 전부 구분하여 `[A, B, C, D, A, B, C, D]`와 같이 출력된다. 생성자에 구분자를 강제로 지정해줄 경우, 이를 막을 수 있다. 직접 지정할 경우 공백이나 줄바꿈이 아니더라도 여러 문자열을 사용할 수 있다.\r\n\r\n``` java\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.13 Sun 23:48:14\r\n */\r\npublic class Test\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tString text = \"A B C D\";\r\n\t\t\r\n\t\tStringTokenizer tokenizer = new StringTokenizer(text);\r\n\t\t\r\n\t\tString[] splited = new String[tokenizer.countTokens()];\r\n\t\t\r\n\t\tfor (int i = 0; i < splited.length; i++)\r\n\t\t{\r\n\t\t\tsplited[i] = tokenizer.nextToken();\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(Arrays.toString(splited));\r\n\t}\r\n}\r\n```\r\n\r\n출력은 동일하다.\r\n\r\n``` tc\r\n[A, B, C, D]\r\n```\r\n\r\n# 속도 비교\r\n\r\n그렇다면 `split`과 `StringTokenizer`의 성능은 어떨까? 이를 비교하기 위해 간단한 테스트 프로그램을 만들었다.\r\n\r\n1. 반복횟수 `t`가 할당된다.\r\n2. 케이스마다 5 ~ 20자의 랜덤한 문자열을 생성한다. 각 문자 사이엔 공백이 포함된다.\r\n3. 공백을 구분자로 문자열을 구분한다\r\n   1. `split` 사용\r\n   2. `StringTokenizer` 사용\r\n4. 총 소요 시간 및 평균 소요 시간을 계산한다\r\n5. 결과를 표시한다\r\n\r\n소스는 아래와 같다.\r\n\r\n``` java\r\nimport java.text.DecimalFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Random;\r\nimport java.util.StringTokenizer;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tint t = 10000;\r\n\t\t\r\n\t\tlong[] timer = { 0, 0 };\r\n\t\t\r\n\t\tint[] sum = { 0, 0 };\r\n\t\t\r\n\t\tfor (int i = 0; i < t; i++)\r\n\t\t{\r\n\t\t\tint random = (int) ((Math.random() * (20 - 5)) + 5);\r\n\t\t\t\r\n\t\t\tString text = getTestString(random);\r\n\t\t\t\r\n\t\t\t// split 로직 ----------------------------------------\r\n\t\t\tlong timeStart = System.nanoTime();\r\n\t\t\t\r\n\t\t\tString[] a1 = useSplit(text);\r\n\t\t\t\r\n\t\t\tlong timeEnd = System.nanoTime() - timeStart;\r\n\t\t\t\r\n\t\t\tsum[0] += a1.length;\r\n\t\t\t\r\n\t\t\ttimer[0] += timeEnd;\r\n\t\t\t\r\n\t\t\tSystem.out.println(Arrays.toString(a1) + \": \" + addComma(timeEnd) + \"ns\");\r\n\t\t\t// split 로직 ----------------------------------------\r\n\t\t\t\r\n\t\t\t// StringTokenizer 로직 ----------------------------------------\r\n\t\t\ttimeStart = System.nanoTime();\r\n\t\t\t\r\n\t\t\tString[] a2 = useStringTokenizer(text);\r\n\t\t\t\r\n\t\t\ttimeEnd = System.nanoTime() - timeStart;\r\n\t\t\t\r\n\t\t\tsum[1] += a2.length;\r\n\t\t\t\r\n\t\t\ttimer[1] += timeEnd;\r\n\t\t\t\r\n\t\t\tSystem.out.println(Arrays.toString(a2) + \": \" + addComma(timeEnd) + \"ns\");\r\n\t\t\t// StringTokenizer 로직 ----------------------------------------\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(addComma(t) + \"개 데이터 그룹 수행\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"split 결과\");\r\n\t\tSystem.out.println(\" * 총 소요: \" + addComma(timer[0]) + \"ns\");\r\n\t\tSystem.out.println(\" * 평균 소요: \" + addComma((timer[0] / t)) + \"ns\");\r\n\t\tSystem.out.println(\" * 분해한 요소: \" + addComma(sum[0]) + \"개\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"StringTokenizer 결과\");\r\n\t\tSystem.out.println(\" * 총 소요: \" + addComma(timer[1]) + \"ns\");\r\n\t\tSystem.out.println(\" * 평균 소요: \" + addComma((timer[1] / t)) + \"ns\");\r\n\t\tSystem.out.println(\" * 분해한 요소: \" + addComma(sum[1]) + \"개\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"split \" + (timer[0] == timer[1] ? \"==\" : (timer[0] > timer[1]) ? \"<\" : \">\") + \" StringTokenizer\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 구분된 문자열 반환 함수 (split)\r\n\t *\r\n\t * @param text: [String] 대상 문자열\r\n\t *\r\n\t * @return [String[]] 구분된 문자열\r\n\t */\r\n\tprivate static String[] useSplit(String text)\r\n\t{\r\n\t\treturn text.split(\" \");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 구분된 문자열 반환 함수 (StringTokenizer)\r\n\t *\r\n\t * @param text: [String] 대상 문자열\r\n\t *\r\n\t * @return [String[]] 구분된 문자열\r\n\t */\r\n\tprivate static String[] useStringTokenizer(String text)\r\n\t{\r\n\t\tStringTokenizer tokenizer = new StringTokenizer(text, \" \");\r\n\t\t\r\n\t\tint count = tokenizer.countTokens();\r\n\t\t\r\n\t\tString[] result = new String[count];\r\n\t\t\r\n\t\tfor (int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tresult[i] = tokenizer.nextToken();\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무작위 문자열 반환 함수\r\n\t *\r\n\t * @param n: [int] 문자 갯수\r\n\t *\r\n\t * @return [String] 무작위 문자\r\n\t */\r\n\tprivate static String getTestString(int n)\r\n\t{\r\n\t\tRandom random = new Random();\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tbuilder.append((char) ((random.nextInt(26)) + 97)).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString().trim();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 1000 단위 구분 숫자 반환 함수\r\n\t *\r\n\t * @param num: [long] 대상 숫자\r\n\t *\r\n\t * @return [String] 1000 단위 구분 숫자\r\n\t */\r\n\tprivate static String addComma(long num)\r\n\t{\r\n\t\tDecimalFormat format = new DecimalFormat(\",###\");\r\n\t\t\r\n\t\treturn format.format(num);\r\n\t}\r\n}\r\n```\r\n\r\n횟수별로 10번씩 돌린 결과를 아래의 표로 정리했다.\r\n\r\n* $t = 1$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    80.3us     |         44.8us          | split < StringTokenizer |\r\n|      2      |    83.7us     |         46.2us          | split < StringTokenizer |\r\n|      3      |    136.6us    |         31.8us          | split < StringTokenizer |\r\n|      4      |    111.3us    |         40.4us          | split < StringTokenizer |\r\n|      5      |    93.4us     |         32.2us          | split < StringTokenizer |\r\n|      6      |    104.5us    |         28.7us          | split < StringTokenizer |\r\n|      7      |    40.1us     |         42.7us          | split > StringTokenizer |\r\n|      8      |    40.1us     |         42.7us          | split > StringTokenizer |\r\n|      9      |    104.7us    |         28.3us          | split < StringTokenizer |\r\n|     10      |    38.3us     |         29.2us          | split < StringTokenizer |\r\n\r\n한 번만 반복할 경우, 8:2로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 100$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    1.12ms     |         0.602ms         | split < StringTokenizer |\r\n|      2      |    1.11ms     |         0.612ms         | split < StringTokenizer |\r\n|      3      |    1.06ms     |         0.562ms         | split < StringTokenizer |\r\n|      4      |    1.02ms     |         0.595ms         | split < StringTokenizer |\r\n|      5      |     1.ms      |         0.550ms         | split < StringTokenizer |\r\n|      6      |    1.16ms     |         0.651ms         | split < StringTokenizer |\r\n|      7      |     98ms      |         0.558ms         | split < StringTokenizer |\r\n|      8      |    1.11ms     |         0.627ms         | split < StringTokenizer |\r\n|      9      |    0.981ms    |         0.555ms         | split < StringTokenizer |\r\n|     10      |    1.23ms     |         0.666ms         | split < StringTokenizer |\r\n\r\n100번을 반복할 때 역시 10:0으로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 1,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    3.00ms     |         3.17ms          | split > StringTokenizer |\r\n|      2      |    2.53ms     |         2.71ms          | split > StringTokenizer |\r\n|      3      |    2.79ms     |         2.84ms          | split > StringTokenizer |\r\n|      4      |    2.53ms     |         2.67ms          | split > StringTokenizer |\r\n|      5      |    2.67ms     |         2.97ms          | split > StringTokenizer |\r\n|      6      |    2.58ms     |         2.87ms          | split > StringTokenizer |\r\n|      7      |    2.48ms     |         2.65ms          | split > StringTokenizer |\r\n|      8      |    2.69ms     |         3.01ms          | split > StringTokenizer |\r\n|      9      |    2.50ms     |         2.90ms          | split > StringTokenizer |\r\n|     10      |    2.62ms     |         2.94ms          | split > StringTokenizer |\r\n\r\n$2^1$, $2^3$처럼 끊어가다가 뜬금없이 1000을 넣은 이유는, 이상하게 $t = 1,000$일 땐 `split`이 압승한다.\r\n\r\n* $t = 10,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    9.91ms     |         9.27ms          | split < StringTokenizer |\r\n|      2      |    9.49ms     |         9.19ms          | split < StringTokenizer |\r\n|      3      |    9.02ms     |         8.61ms          | split < StringTokenizer |\r\n|      4      |    9.95ms     |         9.25ms          | split < StringTokenizer |\r\n|      5      |    9.03ms     |         8.87ms          | split < StringTokenizer |\r\n|      6      |    8.83ms     |         9.08ms          | split > StringTokenizer |\r\n|      7      |    9.14ms     |         8.68ms          | split < StringTokenizer |\r\n|      8      |    9.28ms     |         9.07ms          | split < StringTokenizer |\r\n|      9      |    9.49ms     |         9.66ms          | split > StringTokenizer |\r\n|     10      |    11.79ms    |         11.20ms         | split < StringTokenizer |\r\n\r\n다시 8:2로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 1,000,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |   306.86ms    |        373.06ms         | split > StringTokenizer |\r\n|      2      |   287.26ms    |        262.05ms         | split < StringTokenizer |\r\n|      3      |   289.92ms    |        255.51ms         | split < StringTokenizer |\r\n|      4      |   272.43ms    |        267.96ms         | split < StringTokenizer |\r\n|      5      |   278.35ms    |        322.28ms         | split > StringTokenizer |\r\n|      6      |   285.23ms    |        264.57ms         | split < StringTokenizer |\r\n|      7      |   273.37ms    |        268.18ms         | split < StringTokenizer |\r\n|      8      |   278.65ms    |        264.34ms         | split < StringTokenizer |\r\n|      9      |   278.56ms    |        266.62ms         | split < StringTokenizer |\r\n|     10      |   306.00ms    |        256.56ms         | split < StringTokenizer |\r\n\r\n8:2로 `StringTokenizer`이 압승한다.\r\n\r\n$t = 1,000$이라는 특수한 상황을 제외하고는 보편적으로 `StringTokenizer`가 성능이 더 우수하다. 저런 현상이 왜 발생하는지 이해는 잘 안 된다. 물론 통계라는게 숫자가 클 수록 의미가 커지므로 10번이라는 작은 횟수만으로 단정짓긴 어렵다.\r\n\r\n회사 컴퓨터(AMD Ryzen 2700X)에서는 모든 케이스에서 `StringTokenizer`의 속도가 빨랐다. CPU에 따라 연산 결과나 방식에 조금씩 차이가 있을 순 있겠다.\r\n\r\n[JAVA API](https://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html)에 의하면, `StringTokenizer`은 하위 호환성을 보장하기 위한 레거시 클래스라고 한다. JAVA API는 가급적 `StringTokenizer`보다 `split` 내지는 `regex` <span class=\"orange-400\">패키지</span>를 활용하도록 권고하고 있다.\r\n\r\n> **원문**  \r\n> `StringTokenizer` is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the `split` method of String or the `java.util.regex` package instead.\r\n\r\n# 결론\r\n\r\n표의 수치 상 `StringTokenizer`가 `split`에 비해 최대 약 20% 정도 더 빠르다. 하지만 JAVA API에서 가급적 다른 대체제를 사용하도록 권고하고 있고, 백만번의 연산에도 $ms$ 단위에서 움직인다. 상대적으론 차이가 있어도 객관적인 지표로 봤을땐 별다른 차이가 없는 셈. 문자열 분리하자고 새로운 <span class=\"orange-400\">class</span>를 다룰 바에 그냥 문자열 자체를 다루는 `split`을 사용하는 게 더 효율적이라 생각한다.","url":["2021-06-14-split-and-stringtokenizer","2021","06","14","split-and-stringtokenizer"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1013번 Contact","excerpt":"푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다. 이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-13T04:53:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","정규 표현식","GOLD","GOLD V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-13-a1013.md","content":"\r\n# Contact\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/11.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1013번 문제](https://www.acmicpc.net/problem/1013)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n> “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”\r\n\r\n푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다.\r\n\r\n이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.\r\n\r\n전파의 기본 단위는 $\\{ 0 , 1 \\}$ 두 가지로 구성되어있으며, $x+ (  )$ 는 임의의 개수(최소 1개) $x$의 반복으로 이루어진 전파의 집합을 나타낸다.\r\n\r\n$(xyx)+ (  )$ 는 괄호 내의 $xyx$의 반복으로 이루어진 전파의 집합을 뜻한다. 아래는 이해를 돕기 위한 예제이다.\r\n\r\n* 1+ = { 1, 11, 111, 1111, 11111, … }\r\n* 10+ = { 10, 100, 1000, 10000, 100000, … }\r\n* (01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }\r\n* (1001)+ = { 1001, 10011001, 100110011001, … }\r\n* 10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }\r\n* (10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }\r\n\r\n반복을 의미하는 + 외에도 or 를 의미하는 $|$ 기호가 있다. $\\{ x | y \\}$ 는 $x$ 혹은 $y$를 의미하는 것으로, $\\{ 0+ | 1+ \\}$ 는 $\\{ 0 , 1 , 00 , 11 , 000 , 111 , \\dotsm \\}$ 의 집합을 의미한다. 아래는 두 기호를 복합적으로 사용한 예이다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n최근 김동혁 박사는 아레시보 전파망원경에서 star Vega(직녀성) 으로부터 수신한 전파 기록의 일부를 조사하여 그 전파들의 패턴을 분석하여 아래와 같이 기록하였다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n김동혁 박사는 다양한 전파 기록 중에서 위의 패턴을 지니는 전파를 가려내는 프로그램을 필요로 한다. 이를 수행할 수 있는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 전파를 표현하는, $\\{ 0, 1 \\}$만으로 이루어진 문자열이 공백 없이 주어진다. 문자열 길이는 $(1 ≤ N ≤ 200)$의 범위를 갖는다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 전파가 문제에서 제시한 패턴이면 “YES”를 그렇지 않은 경우는 “NO”를 출력한다. 출력 문자열은 모두 대문자로 구성되어 있다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n10010111\r\n011000100110001\r\n0110001011001\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\nNO\r\nNO\r\nYES\r\n```\r\n\r\n# 풀이\r\n\r\n정규식을 대강 알고있다면 이게 왜 <span class=\"amber-A400\">GOLD V</span>인지 다소 이해되지 않는 수준의 문제다. 정규식이 어려운 이유는 원하는 패턴에 맞춰 정규식을 설계하는 건데, 그 정규식을 대놓고 준다. 사실상 정규식의 개념을 아냐 모르느냐를 물어보는 문제.\r\n\r\n나의 경우, 일하다가 간간히 쓸 일이 생겨서 몇 번 다뤄본적이 있어 그리 생소하지 않았다. [regexr](https://regexr.com/)에서 정규식을 설계하고 테스트를 할 수 있으니 참고하자. 정규식 관련해서는 유명한 사이트.\r\n\r\n문제에 대놓고 $(100+1+ | 01)+$라는 정규식 자체를 제공하기 때문에, 그냥 문자열 받아서 정규식과 일치하는지 보면 된다.\r\n\r\nJAVA에서는 `Pattern.matches({정규식 문자열}, {문자열});`과 같이 사용하며, 일치여부를 `boolean`으로 반환한다.\r\n\r\n아래 소스를 보면 알겠지만 진짜 간단하다. 정규식을 아는 사람에겐 <span class=\"brown-500\">BRONZE</span> 수준의 문제.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * 백준 전체 1013 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/13/a1013\">1013 풀이</a>\r\n * @since 2021.06.13 Sun 04:34:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString text = reader.readLine();\r\n\t\t\t\r\n\t\t\t// 정규식 일치 여부\r\n\t\t\tString result = Pattern.matches(\"(100+1+|01)+\", text) ? \"YES\" : \"NO\";\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 문자열\r\n* 정규 표현식\r\n\r\n## 여담\r\n\r\n문제가 생각보다 쉬워서, \"사실 이렇게 하면 안 되는게 아닐까?\"하고 찾아보니 역시나 다른 방식으로 접근하는 방법이 공유되어 있었다. 정규표현식이 아닌 DFA(오토마타 전이 그래프)를 활용하는 방식이다. 정규표현식을 공식적으로 지원해주지 않는 언어라면 대체제로 시도해봄직하다. 백준에선 외부 라이브러리를 사용할 수 없을테니.","url":["2021-06-13-a1013","2021","06","13","a1013"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1012번 유기농 배추","excerpt":"차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-13T01:42:10","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","DFS(깊이 우선 탐색)","BFS(너비 우선 탐색)","SILVER","SILVER II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-13-a1012.md","content":"\r\n# 유기농 배추\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/9.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1012번 문제](https://www.acmicpc.net/problem/1012)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)\r\n\r\n한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.\r\n\r\n예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.\r\n\r\n(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">밭</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 $M(1 ≤ M ≤ 50)$과 세로길이 $N(1 ≤ N ≤ 50)$, 그리고 배추가 심어져 있는 위치의 개수 $K(1 ≤ K ≤ 2500)$이 주어진다. 그 다음 $K$줄에는 배추의 위치 $X(0 ≤ X ≤ M-1)$, $Y(0 ≤ Y ≤ N-1)$가 주어진다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n10 8 17\r\n0 0\r\n1 0\r\n1 1\r\n4 2\r\n4 3\r\n4 5\r\n2 4\r\n3 4\r\n7 4\r\n8 4\r\n9 4\r\n7 5\r\n8 5\r\n9 5\r\n7 6\r\n8 6\r\n9 6\r\n10 10 1\r\n5 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n5\r\n1\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 3 6\r\n0 2\r\n1 2\r\n2 2\r\n3 2\r\n4 2\r\n4 0\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n2\r\n```\r\n\r\n# 풀이\r\n\r\n<span class=\"primary\">DFS(깊이 우선 탐색)</span> 혹은 <span class=\"primary\">BFS(너비 우선 탐색)</span>을 활용하는 기본적인 알고리즘. 추가적인 연산 없이 두 알고리즘 중 익숙한걸 적용하면 끝난다.\r\n\r\n배추흰지렁이는 배추 위에 놓을 수 있으며, 이 벌레는 <span class=\"green-A400\">배추에서 상하좌우로 인접한 배추로 이동</span>할 수 있다. 즉, 배추가 상하좌우로 연결되어있는 구역들의 갯수가 벌레가 필요한 갯수다.\r\n\r\n문제에 예시로 주어진 테이블을 기준으로 보면 아래와 같이 배추가 심어진 구역을 나눌 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121783894-45e09a80-cbec-11eb-99b4-5ed3f3acecd1.png)\r\n\r\n위 그림과 같이 총 5개의 구역이 있으므로 벌레 또한 5마리가 필요하다.\r\n\r\nDFS를 적용하면 아래와 같은 절차로 동작한다.\r\n\r\n1. 현재 구역에 배추가 있는지 확인한다.\r\n   1. 배추가 없을 경우 통과한다.\r\n2. 배추가 있을 경우 현재 구역을 처음 탐색하는지 확인한다.\r\n   1. 이미 탐색한 구역일 경우 통과한다.\r\n3. 현재 구역을 방문처리하고, 벌레의 수를 하나 추가한다.\r\n4. 상하좌우로 인접한 구역에 배추가 있는지 확인한다.\r\n   1. 상: $(x, y - 1)$\r\n   2. 하: $(x, y + 1)$\r\n   3. 좌: $(x - 1, y)$\r\n   4. 우: $(x + 1, y)$\r\n5. 배추가 있고, 처음 탐색하는지 확인한다.\r\n   1. 이미 탐색한 구역일 경우 통과한다.\r\n6. 현재 구역을 방문처리한다. 같은 구역이므로 벌레의 수는 추가하지 않는다.\r\n7. 1 ~ 7과정을 반복한다.\r\n\r\nDFS에서의 깊이는 각 구역의 상하좌우 개념과 동일하다. 상하좌우를 비교할 경우, $x$, $y$값이 정해진 밭의 크기 안에 포함되어야 함을 잊지 말자.\r\n\r\n이를 도식화하면 아래와 같이 나타낼 수 있다. 이미 방문한 구역을 녹색으로 표시한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"teal-A400 large\">탐색을 수행한다.</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121786679-82b48d80-cbfc-11eb-8360-9dae381cc44d.png)\r\n\r\n탐색 중인 위치에 배추가 있는지, 처음 방문한 곳인지 확인한다. 그림의 $(0, 0)$의 경우 배추가 있으며 처음 방문한 구역이므로 조건에 해당된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"teal-A400 large\">벌레를 추가하고 방문 표시를 한다.</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121786686-94963080-cbfc-11eb-9a6a-722d7e3723f2.png)\r\n\r\n새로운 구역이므로 벌레 하나를 추가한다. 방문한 구역은 방문 표시를 함으로써 중복 검색을 방지한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"teal-A400 large\">인접구역을 탐색한다.</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121786712-a677d380-cbfc-11eb-8150-daf8d827a0eb.png)\r\n\r\n인접구역인 상하좌우 구역을 탐색한다. $(0, 0)$을 기준으로 $(0, 1)$, $(0, -1)$, $(-1, 0)$, $(1, 0)$이다. 구역의 좌표는 0 이상이어야 하므로, 유효한 구역은 $(0, 1)$, $(1, 0)$ 두 곳이다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"teal-A400 large\">인접구역에 대해 방문 표시를 한다.</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121786730-c27b7500-cbfc-11eb-822c-1956cfd2b954.png)\r\n\r\n$(1, 0)$ 역시 방문 전이며, 배추가 있는 구역이다. 인접구역이므로 벌레는 추가하지 않으며, 방문 표시만 한다. 또 다른 인접구역에 대해 동일한 과정을 반복한다.\r\n\r\n위와 같은 과정을 반복하여 구역의 수를 계산할 수 있다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1012 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/13/a1012\">1012 풀이</a>\r\n * @since 2021.06.13 Sun 01:30:12\r\n */\r\npublic class Main\r\n{\r\n\t// 배추밭의 가로 길이(x)\r\n\tprivate static int M;\r\n\t\r\n\t// 배추밭의 세로 길이(y)\r\n\tprivate static int N;\r\n\t\r\n\t// 배추밭\r\n\tprivate static int[][] area;\r\n\t\r\n\t// 구역 방문 여부\r\n\tprivate static boolean[][] isVisit;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tM = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\tN = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 배추 갯수\r\n\t\t\tint K = Integer.parseInt(temp[2]);\r\n\t\t\t\r\n\t\t\tarea = new int[M][N];\r\n\t\t\t\r\n\t\t\tisVisit = new boolean[M][N];\r\n\t\t\t\r\n\t\t\t// 필요한 배추흰지렁이 수\r\n\t\t\tint bugs = 0;\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(temp[0]);\r\n\t\t\t\tint y = Integer.parseInt(temp[1]);\r\n\t\t\t\t\r\n\t\t\t\tarea[x][y] = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int y = 0; y < N; y++)\r\n\t\t\t{\r\n\t\t\t\tfor (int x = 0; x < M; x++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 방문하지 않은 구역에 배추가 있을 경우\r\n\t\t\t\t\tif (area[x][y] == 1 && !isVisit[x][y])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbugs++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdfs(x, y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(bugs);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 깊이 우선 탐색 알고리즘\r\n\t *\r\n\t * @param x: [int] x좌표\r\n\t * @param y: [int] y좌표\r\n\t */\r\n\tprivate static void dfs(int x, int y)\r\n\t{\r\n\t\t// x의 상하좌우 이동\r\n\t\tint[] dx = { 0, 0, -1, 1 };\r\n\t\t\r\n\t\t// y의 상하좌우 이동\r\n\t\tint[] dy = { -1, 1, 0, 0 };\r\n\t\t\r\n\t\tisVisit[x][y] = true;\r\n\t\t\r\n\t\tfor (int i = 0; i < 4; i++)\r\n\t\t{\r\n\t\t\tint xn = x + dx[i];\r\n\t\t\tint yn = y + dy[i];\r\n\t\t\t\r\n\t\t\t// x, y좌표가 구역 내부에 있으며, 방문하지 않은 구역에 배추가 있을 경우\r\n\t\t\tif ((xn > -1 && xn < M) && (yn > -1 && yn < N) && area[xn][yn] == 1 && !isVisit[xn][yn])\r\n\t\t\t{\r\n\t\t\t\tdfs(xn, yn);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 그래프 이론\r\n* 그래프 탐색\r\n* 너비 우선 탐색\r\n* 깊이 우선 탐색","url":["2021-06-13-a1012","2021","06","13","a1012"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1011번 Fly me to the Alpha Centauri","excerpt":"우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다. 그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k - 1 , k 혹은 k + 1 광년만을 다시 이동할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-11T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-11-a1011.md","content":"\r\n# 다리 놓기\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/10.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1011번 문제](https://www.acmicpc.net/problem/1011)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.\r\n\r\n그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 $k$광년을 이동하였을 때는 $k - 1$ , $k$ 혹은 $k + 1$ 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다)\r\n\r\n![image](https://www.acmicpc.net/upload/201003/rlaehdgur.JPG)\r\n\r\n김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 $x$지점에서 $y$지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 $y$지점에 도착해서도 공간 이동장치의 안전성을 위하여 $y$지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.\r\n\r\n김우현을 위해 $x$지점부터 정확히 $y$지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $T$가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 $x$와 목표 위치 $y$가 정수로 주어지며, $x$는 항상 $y$보다 작은 값을 갖는다. $(0 ≤ x < y < 2^31)$\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 $x$지점으로부터 $y$지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0 3\r\n1 5\r\n45 50\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n3\r\n4\r\n```\r\n\r\n# 풀이\r\n\r\nFrank Sinatra의 [Fly me to the moon](https://www.youtube.com/embed/ZEcqHA7dbwM)을 오마주한 제목인 거 같다.\r\n\r\n<p align=\"center\">\r\n\t<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZEcqHA7dbwM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\r\n</p>\r\n\r\n시나트라를 Fallout NV의 Blue Moon으로 처음 접했었는데, 그 후에 Come fly with me나 Theme from Newyork Newyork 같이 좋은 곡들이 너무 많아서 자주 듣는 편이다.\r\n\r\n문제로 돌아와서, 러프하게 보면 \"무작정 빨리가면 되지 않나?\"라고 생각할 수 있다. 하지만 아래 두 조건이 발목을 잡는다.\r\n\r\n1. 처음, 끝 구간은 반드시 <span class=\"primary\">한 칸만 워프</span>할 수 있다.\r\n2. $k$만큼 이동할 경우, <span class=\"primary\">$k - 1$ ~ $k + 1$만큼만 이동 가능</span>함\r\n3. 반드시 <span class=\"primary\">정확한 지점에 도착</span>해야함 (통과 X)\r\n\r\n위 조건들 때문에 새벽 2시 강남의 \"과학\"마냥 쏘다니면 안 된다.\r\n\r\n경우의 수는 아니고, 정해진 규칙이 있으니 이를 계산하여 순서대로 나열하면 단서를 발견할 수 있을 것 같다.\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   2   | 1 1           |     2     |\r\n|   3   | 1 1 1         |     3     |\r\n|   4   | 1 2 1         |     3     |\r\n|   5   | 1 2 1 1       |     4     |\r\n|   6   | 1 2 2 1       |     4     |\r\n|   7   | 1 2 2 1 1     |     5     |\r\n|   8   | 1 2 2 2 1     |     5     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  10   | 1 2 3 2 1 1   |     6     |\r\n|  11   | 1 2 3 2 2 1   |     6     |\r\n|  12   | 1 2 3 3 2 1   |     6     |\r\n|  13   | 1 2 3 3 2 1 1 |     7     |\r\n|  14   | 1 2 3 3 2 2 1 |     7     |\r\n|  15   | 1 2 3 3 3 2 1 |     7     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n잘 안 보일 수도 있으나, 규칙성 찾을 때 가장 만만한 제곱수(1, 4, 9...)를 기준으로 규칙을 정의할 수 있다. 특징은 아래와 같다.\r\n\r\n* 제곱수 이후로 가동 횟수가 1 증가한다.\r\n* 현재 제곱수와 다음 제곱수의 중간에서 가동 횟수가 1 증가한다.\r\n\r\n즉, 제곱수 이후로 가시적인 변화가 있으며, 제곱수를 기준으로 구간의 중간에서 가동률이 1 증가한다.\r\n\r\n### 제곱수의 가동 횟수 일반식\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   4   | 1 2 1         |     3     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n제곱수의 가동률은 아래와 같다. 제곱수 $n$의 가동 횟수 일반식은 아래와 같다.\r\n\r\n$$\r\n2\\sqrt{n} - 1\r\n$$\r\n\r\n9의 경우 $2 * 3 - 1 = 5$이므로 식이 성립함을 알 수 있다.\r\n\r\n### 제곱수가 아닌 수의 가동 횟수 일반식\r\n\r\n제곱수 사이의 중간에서 가동 횟수가 바뀌므로, 이 중간값을 계산하면 된다. 제곱수가 아닌 일반적인 숫자 $k$가 있다고 가정하자. 이 규칙은 제곱수를 중심으로 돌아가므로, $k$를 통해 제곱수를 구해야 한다. 구해야 할 요소는 아래와 같다.\r\n\r\n* $k$보다 크면서 가장 가까운 제곱수\r\n* $k$가 속한 제곱수 구간의 중간값\r\n\r\n1. $k$에 제곱근 연산을 수행하고 이를 반올림한다. $k$보다 크면서 $k$와 가장 가까운 제곱수의 제곱근 $\\sqrt{n}$이 계산된다.\r\n2. $\\sqrt{n}$을 제곱하여 가장 근접한 제곱수 $n$을 계산한다.\r\n3. $n - \\sqrt{n}$의 식으로 $k$가 속한 제곱수 구간의 중간값$t$을 계산한다.\r\n4. $k > t$일 경우, $n$의 가동 횟수와 동일한 $2\\sqrt{n} - 1$식을 적용한다.\r\n5. $k <= t$일 경우, $n$의 가동 횟수에서 1을 뺀 $2\\sqrt{n} - 2$식을 적용한다.\r\n\r\n위 방법을 토대로 7의 가동 횟수를 계산해보자.\r\n\r\n$\\sqrt{7} \\fallingdotseq 2.646$이므로, 이를 반올림하면 3이 계산된다. 즉, 7보다 크면서 가장 가까운 제곱수는 $3^2 = 9$다.\r\n\r\n$9 - \\sqrt{9} = 9 - 3 = 6$이므로, $k$가 속한 제곱수 구간의 중간값은 6이다. 숫자가 6보다 클 경우 9와 가동 횟수가 동일하다. 주어진 숫자는 7이므로 9의 가동 횟수와 동일하다.\r\n\r\n9의 가동횟수는 $2\\sqrt{9} - 1 = 6 - 1 = 5$이므로 7의 가동 횟수 역시 5가 된다.\r\n\r\n위 절차를 코드로 녹여내면 된다. 코드 구현 난이도는 낮다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1011 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/11/a1011\">1011 풀이</a>\r\n * @since 2021.06.11 Fri 09:06:34\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 현재 위치\r\n\t\t\tdouble x = Double.parseDouble(temp[0]);\r\n\t\t\t\r\n\t\t\t// 목표 위치\r\n\t\t\tdouble y = Double.parseDouble(temp[1]);\r\n\t\t\t\r\n\t\t\t// x, y 사이의 거리\r\n\t\t\tdouble distance = y - x;\r\n\t\t\t\r\n\t\t\tSystem.out.println(solve(distance));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가동횟수 반환 함수\r\n\t *\r\n\t * @param distance: [double] 거리\r\n\t *\r\n\t * @return [int] 가동횟수\r\n\t */\r\n\tprivate static int solve(double distance)\r\n\t{\r\n\t\tint result;\r\n\t\t\r\n\t\tdouble ref = Math.sqrt(distance);\r\n\t\t\r\n\t\t// 제곱수일 경우\r\n\t\tif (ref % 1 == 0)\r\n\t\t{\r\n\t\t\tresult = (int) (2 * ref - 1);\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tdouble next = Math.ceil(ref);\r\n\t\t\t\r\n\t\t\t// 이전 제곱수와 다음 제곱수의 중간보다 큰 수일 경우\r\n\t\t\tif (distance > Math.pow(next, 2) - next)\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 2);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n주의할 점이 하나 있는데, $x$와 $y$의 최대값이 $2^31$이다. int의 최대값은 2,147,483,647이지만, $2^31$은 2,147,483,64<span class=\"red-A200\">8</span>이므로 $x$, $y$의 거리 계산 시 int를 사용하면 안 된다. 결과만 int형으로 출력해야 한다.\r\n\r\n메모이제이션을 적용할까 했지만, 배열을 $2^31$ 크기만큼 초기화해야 하므로 오히려 오버헤드가 더 심하게 발생할 것 같다. 재귀함수도 아니니 메모이제이션을 적용해도 별차이 없을 것 같다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-11-a1011","2021","06","11","a1011"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1010번 다리 놓기","excerpt":"재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Combination(조합)","SILVER","SILVER V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1010.md","content":"\r\n# 다리 놓기\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/6.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1010번 문제](https://www.acmicpc.net/problem/1010)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|  0.5초   |    128MB    |\r\n\r\n## 문제\r\n\r\n재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 <span class=\"primary\">사이트</span>라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 $N$개의 사이트가 있고 동쪽에는 $M$개의 사이트가 있다는 것을 알았다. $(N ≤ M)$\r\n\r\n재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. <span class=\"red-600\">(이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.)</span> 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 ($N$개) 다리를 지으려고 한다. <span class=\"red-600\">다리끼리는 서로 겹쳐질 수 없다</span>고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.\r\n\r\n![image](https://www.acmicpc.net/upload/201003/pic1.JPG)\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 $N$, $M$ $(0 < N ≤ M < 30)$이 주어진다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n2 2\r\n1 5\r\n13 29\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n5\r\n67863915\r\n```\r\n\r\n# 풀이\r\n\r\n규칙을 정리하면 아래와 같다.\r\n\r\n1. $N$구역에서 $M$구역으로 다리를 건설한다.\r\n2. $N <= M$이다.\r\n3. 사이트 당 연결된 다리는 하나다.\r\n4. 다리끼리는 서로 겹쳐서 연결되면 안 된다.\r\n\r\n1000번 부터 문제 풀면서, [1007번 벡터](/posts/2021/06/09/a1007)로 인해 조합이라는 키워드를 쉽게 연상할 수 있었다. 문제에서 $N$구역에서 $M$구역으로 다리를 건설한다고 서술하므로 $N$을 기준으로 생각하기 쉽다. 반대로 $M$을 기준으로 생각하면 해결의 실마리가 보인다. $M$구역의 사이트에서 $N$구역의 사이트 갯수만큼 연결할 사이트에 대한 조합을 계산하면 되기 때문.\r\n\r\n예를 들어 $N$구역에 3개의 사이트가 있고, $M$구역에 5개의 사이트가 있다고 가정하자.\r\n\r\n| 구분  | $M_1$ | $M_2$ | $M_3$ | $M_4$ | $M_5$ |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   O   |   O   |   O   |       |       |\r\n|   2   |   O   |   O   |       |   O   |       |\r\n|   3   |   O   |   O   |       |       |   O   |\r\n|   4   |   O   |       |   O   |   O   |       |\r\n|   5   |   O   |       |   O   |       |   O   |\r\n|   6   |   O   |       |       |   O   |   O   |\r\n|   7   |       |   O   |   O   |   O   |       |\r\n|   8   |       |   O   |   O   |       |   O   |\r\n|   9   |       |   O   |       |   O   |   O   |\r\n|  10   |       |       |   O   |   O   |   O   |\r\n\r\n총 10개의 경우의 수가 존재한다. 이는 $_5C_3$의 계산 결과와 일치한다.\r\n\r\n$$\r\n_5C_3 = \\frac{5!}{3! \\times 2!} = \\frac{5 \\times 4 \\times 3 \\times 2 \\times 1}{(3 \\times 2 \\times 1) \\times (2 \\times 1)} = \\frac{5 \\times 4}{2 \\times 1} = 10\r\n$$\r\n\r\n> ❓ **숫자가 왜 감탄(!)을 하죠?**  \r\n> Factorial(팩토리얼) 연산자로 $n! = n \\times (n - 1) \\times (n - 2) \\times ... \\times 1$과 같은 형태로 연산한다.\r\n\r\n더도말고 덜도말고 조합 알고리즘을 설계하면 된다. 조합의 요소를 반환할 필요 없이, 조합의 갯수만 구하면 되므로 [1007번 벡터](/posts/2021/06/09/a1007)문제보다 더 간단하다.\r\n\r\n## Gotta Go FAST!\r\n\r\n무턱대로 위 식으로 조합 알고리즘을 짜면 <span class=\"red-A400\">시간 초과</span> 오류를 볼 수 있다. 그도 그럴 것이, 원리 자체는 쉽지만 시간제한이 0.5s로 매우 짧기 때문. $M$의 값이 최대 30이므로, 최대 $30!$에 대한 연산을 수행해야하기 때문이다. 그러므로 <span class=\"blue-A400\">Memoization(메모이제이션)</span>이라는 최적화를 적용해야 한다.\r\n\r\n> ❓ **Memoization(메모이제이션)이란?**  \r\n> 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장해놓고 필요 시 사용하여 반복적인 연산 작업을 제거하는 기술.\r\n\r\n조합을 재귀적으로 표현하면 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\n_nC_r = _{n-1}C_{r-1} + _{n-1}C_r\r\n$$\r\n\r\n아래의 그림을 보면 이해하기 쉽다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121479130-b036e680-ca04-11eb-96ed-620c4fc3086a.png)\r\n\r\n만약, $_5C_3$을 연산한다면 아래와 같이 진행된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121479160-b6c55e00-ca04-11eb-97da-a4708798a715.png)\r\n\r\n이 중, $_3C_2$의 경우 $_4C_2$, $_4C_3$을 계산할 때 필요하므로 여러번 호출된다. 만약, 메모이제이션이 적용되지 않았다면, $_3C_2$이 필요할 때마다 1에서부터 다시 연산해야한다. $_{30}C_{14}$와 같이 숫자가 커지면 위 그림의 깊이도 깊어지기 때문에 많은 오버헤드가 발생한다.\r\n\r\n만약 이렇게 연산된 값을 버리지 않고 메모리상에 저장한 뒤 쓸 수 있다면 연산에서 엄청난 이점이 발생한다. $_3C_2$을 이미 저장했다면 $_4C_2$, $_4C_3$을 계산할 때 저장된 $_3C_2$을 즉시 꺼내 사용할 수 있다. 복잡한 연산을 건너뛸 수 있으며, 동일한 값이 여러번 호출되도 상관없다.\r\n\r\n해당 문제의 조합 알고리즘의 연산에서 한 번 연산된 값을 임의의 배열에 저장하여 이를 활용하면 0.5초라는 짧은 시간을 충족할 수 있을 것이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1010 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/09/a1010\">1010 풀이</a>\r\n * @since 2021.06.09 Tue 14:14:09\r\n */\r\npublic class Main\r\n{\r\n\t// 다리 건설 경우의 수\r\n\tprivate static final int[][] dp = new int[31][31];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint N = Integer.parseInt(temp[0]);\r\n\t\t\tint M = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\tSystem.out.println(combination(M, N));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 결과 반환 함수\r\n\t *\r\n\t * @param n: [int] 원소 갯수\r\n\t * @param r: [int] 조합 갯수\r\n\t *\r\n\t * @return [int] 조합\r\n\t */\r\n\tprivate static int combination(int n, int r)\r\n\t{\r\n\t\t// 이미 계산된 값일 경우\r\n\t\tif (dp[n][r] > 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r];\r\n\t\t}\r\n\t\t\r\n\t\t// 원소의 갯수가 조합의 갯수와 동일하거나 0일 경우\r\n\t\telse if (n == r || r == 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r] = 1;\r\n\t\t}\r\n\t\t\r\n\t\t// 일반적인 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn dp[n][r] = combination(n - 1, r - 1) + combination(n - 1, r);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$dp[n][r]$는 int형 배열이므로 기본값이 0이다. 즉, $dp[n][r] > 0$일 경우 $_nC_r$가 이미 계산되었다는 뜻이므로, 이미 저장된 값을 반환한다.\r\n\r\n$_5C_0$, $_5C_5$와 같이 $_nC_0$, $_nC_n$일 경우 그 값은 1이다. 해당 케이스의 경우 1을 반환한다. (전체를 선택하거나, 아무것도 선택하지 않는 방법은 하나뿐이다.)\r\n\r\n나머지 일반적인 경우 $_nC_r$의 재귀적 표현 방식인 $_{n-1}C_{r-1} + _{n-1}C_{r}$을 적용하면 된다.\r\n\r\n또한 $dp$ 이차원 배열은 31행렬로 초기화되는데, 그 이유는 $dp$의 행렬이 되는 $N$과 $M$의 최대값이 30이기 때문. 배열은 인덱스가 0부터 시작하므로 1을 더해야 한다.\r\n\r\n또한 케이스별로 $dp$를 초기화하지 않는데, 이는 <span class=\"green-A400\">조합이 범용적이므로 재사용이 가능하기 때문</span>이다. 1번 케이스나 100번 케이스나 $_5C_3$의 값은 10이다. 따라서 초기화를 하지 않으면 오히려 이전 케이스에서 계산했던 내용을 그대로 사용할 수 있어서 이득이다. 만약 첫 번째 케이스에서 $_{30}C_{12}$와 같이 큰 수를 계산했다면, 이후 케이스의 $_{12}C_{5}$와 같은 모든 하위 조합들은 연산을 통째로 건너뛸 수도 있을 것이다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 다이나믹 프로그래밍\r\n* 조합론","url":["2021-06-09-a1010","2021","06","09","a1010"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1009번 분산처리","excerpt":"재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T11:06:38","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","수학","BRONZE","BRONZE IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1009.md","content":"\r\n# 분산처리\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/2.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1009번 문제](https://www.acmicpc.net/problem/1009)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    128MB    |\r\n\r\n## 문제\r\n\r\n재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.\r\n\r\n1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터 ...\r\n\r\n10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터 ...\r\n\r\n총 데이터의 개수는 항상 $a^b$개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 $a$와 $b$가 주어진다. $(1 ≤ a < 100, 1 ≤ b < 1,000,000)$\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n1 6\r\n3 7\r\n6 2\r\n7 100\r\n9 635\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n7\r\n6\r\n1\r\n9\r\n```\r\n\r\n# 풀이\r\n\r\n문제속에 답이 있다. 1번 컴퓨터부터 10번 컴퓨터까지 데이터를 처리하는데, 가장 마지막에 데이터를 처리하는 컴퓨터의 번호를 반환하면 된다.\r\n\r\n데이터 12개가 주어졌다고 가정해보자\r\n\r\n| 컴퓨터 | 데이터 |\r\n| :----: | :----: |\r\n|   1    |   1    |\r\n|   2    |   2    |\r\n|   3    |   3    |\r\n|   4    |   4    |\r\n|   5    |   5    |\r\n|   6    |   6    |\r\n|   7    |   7    |\r\n|   8    |   8    |\r\n|   9    |   9    |\r\n|   10   |   10   |\r\n|   1    |   11   |\r\n|   2    |   12   |\r\n\r\n위 표를 통해 어렵지않게 규칙을 찾을 수 있다. <span class=\"green-A400\">데이터를 처리하는 컴퓨터의 번호는 데이터의 1의 자릿수가 가진 값과 동일</span>하다.\r\n\r\n즉, 789235번째 테이터는 5번 컴퓨터가 처리한다는 것이다. 789235에서 1의 자릿수가 5이기 때문.\r\n\r\n따라서 <span class=\"green-A400\">우리는 주어진 데이터 번호에서 1의 자릿수를 추출</span>하면 된다. 고맙게도 컴퓨터의 갯수가 10으로 고정이다. <span class=\"green-A400\">데이터의 번호를 10으로 나누면 1의 자리가 나머지로 남으므로, 이를 활용</span>하면 된다.\r\n\r\n즉 $a^b \\% 10$을 사용하면 된다.\r\n\r\n단, 몇가지 주의할 사항이 있다. 첫 번째로, $a^b$의 값이 너무 커지게 되면 연산 퍼포먼스에도 영향을 미치게된다. 그 전에 값이 너무 커지게되면 약간의 오차도 발생한다.\r\n\r\n어차피 우리는 1의 자리만 필요하므로 이를 나름 센스있게 우회할 수 있다.\r\n\r\n| $a^b$ |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n| $7^3$ |   7   |  49   |  343  |\r\n\r\n위 표는 7의 3제곱을 차례로 계산한 표다. 어차피 우리는 1의 자리만 필요하므로, 굳이 <span class=\"orange-A400\">전체를 계산할 필요 없이, 1의 자리를 기준으로 계산</span>해도 상관없다. 아래의 식을 보면 더욱 명확하다.\r\n\r\n$$\r\n7^3\\text{의 1의 자리} = 49 * 7 \\, \\% \\, 10 = 3\r\n$$\r\n\r\n$$\r\n7^3\\text{의 1의 자리} = (49 \\, \\% \\, 10) * 7 \\% 10 = 9 * 7 \\, \\% \\, 10 = 3\r\n$$\r\n\r\n49에서 7을 곱하는게 아니라 <span class=\"green-A400\">일의 자리 9만 구하여 곱함</span>에 주목하자. 두 번째 식과 같이 <span class=\"green-A400\">수의 일의 자리만 계산하는 방법</span>으로 연산의 오버헤드를 줄일 수 있다.\r\n\r\n두 번째는 10번 째 컴퓨터에 대한 처리다. 예시로, 30번 째 데이터에 대한 처리 공식은 $30 \\, \\% \\, 10 = 0$과 같다. <span class=\"orange-A400\">계산 결과가 0일 경우 10으로 치환</span>해야 한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1009 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/09/a1009\">1009 풀이</a>\r\n * @since 2021.06.09 Tue 11:06:38\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint a = Integer.parseInt(temp[0]);\r\n\t\t\tint b = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\tint result = 1;\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j <= b; j++)\r\n\t\t\t{\r\n\t\t\t\tresult = result * a % 10;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 0일 경우 10으로 처리\r\n\t\t\tresult = result == 0 ? 10 : result;\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현","url":["2021-06-09-a1009","2021","06","09","a1009"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1008번 A / B","excerpt":"두 정수 A와 B를 입력받은 다음, A / B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T10:25:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1008.md","content":"\r\n# A / B\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/2.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1008번 문제](https://www.acmicpc.net/problem/1008)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 $A$와 $B$를 입력받은 다음, $A / B$를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $A$와 $B$가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 $A / B$를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 $10^{-9}$ 이하이면 정답이다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 3\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.33333333333333333333333333333333\r\n```\r\n\r\n$10^{-9}$ 이하의 오차를 허용한다는 말은 꼭 소수 9번째 자리까지만 출력하라는 뜻이 아니다.\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n4 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.8\r\n```\r\n\r\n# 풀이\r\n\r\n[백준 1000 A + B](/posts/2021/05/21/a1000), [백준 1001 A - B](/posts/2021/05/21/a1001)에 이은 사칙연산 문제. 틀리기도 어렵다.\r\n\r\nJAVA의 경우, <span class=\"deepOrange-A400\">int</span>로 나누면 정수 부분만 반환하기 때문에, 반드시 <span class=\"deepOrange-A400\">double</span> 같은 실수형 데이터로 선언하여 나눠야 한다는 점만 주의하자.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1008 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/09/a1008\">1008 풀이</a>\r\n * @since 2021.06.09 Tue 10:23:59\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] line = reader.readLine().split(\" \");\r\n\t\t\r\n\t\tdouble a = Double.parseDouble(line[0]);\r\n\t\tdouble b = Double.parseDouble(line[1]);\r\n\t\t\r\n\t\tSystem.out.println(a / b);\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-06-09-a1008","2021","06","09","a1008"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1007번 벡터","excerpt":"평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다. V에 있는 벡터의 갯수는 P에 있는 점의 절반이다. 평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T00:50:26","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Brute Force(무차별 대입 공격)","Combination(조합)","GOLD","GOLD II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1007.md","content":"\r\n# 습격자 초라기\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/14.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1007번 문제](https://www.acmicpc.net/problem/1007)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n평면 상에 $N$개의 점이 찍혀있고, 그 점을 집합 $P$라고 하자. 집합 $P$의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 $P$의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, $P$에 속하는 모든 점은 한 번씩 쓰여야 한다.\r\n\r\n$V$에 있는 벡터의 갯수는 $P$에 있는 점의 절반이다.\r\n\r\n평면 상의 점이 주어졌을 때, 집합 $P$의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n테스트 케이스의 첫째 줄에 점의 갯수 $N$이 주어진다. $N$은 짝수이다. 둘째 줄부터 $N$개의 줄에 점의 좌표가 주어진다. $N$은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4\r\n5 5\r\n5 -5\r\n-5 5\r\n-5 -5\r\n2\r\n-100000 -100000\r\n100000 100000\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.000000000000\r\n282842.712474619038\r\n```\r\n\r\n# 풀이\r\n\r\n두 개의 점으로 하나의 벡터를 만들 수 있다. $N <= 20$이므로 주어지는 점의 최대 갯수는 20개다. $N = 20$이라고 가정하면, 만들 수 있는 벡터의 수는 그 절반인 10개다. 20개의 점을 어떻게 잇느냐에 따라서 벡터 10개를 만드는 수 많은 경우의 수가 발생한다. 이 경우의 수에서 <span class=\"red-A400\">벡터의 총합이 가장 작은 값을 계산</span>하는 게 이 알고리즘의 결과다.(10개의 벡터 중 가장 짧은 벡터를 계산하는 것이 아님에 유의하자.)\r\n\r\n이 알고리즘의 핵심은 <span class=\"green-A400\">$N$개의 원소에서 $N / 2$개의 벡터를 만들 수 있는 경우를 계산해서 최소값을 계산</span>하면 된다. $N$의 최대값이 20으로 매우 작으므로 하나하나 비교하는 것이 가능하다. 애초에 알고리즘 자체가 Brute Force(무차별 대입 공격)으로 분류돼있기도 하고.\r\n\r\n좌표 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$가 있으며, 이 좌표에서 두 벡터인 $v_1$, $v_2$를 만든다고 가정하자.(조건은 알고리즘 문제와 동일) $v_1$이 $(x_1, y_1), (x_2, y_2)$으로 이루어져 있으며, $v_2$는 $(x_3, y_3), (x_4, y_4)$로 이루어져있다고 가정하자. 각 벡터를 좌표를 통해 표현하면 아래와 같다.\r\n\r\n$$\r\nv_1 = (x_2 - x_1, y_2 - y_1)\r\n$$\r\n\r\n$$\r\nv_2 = (x_4 - x_3, y_4 - y_3)\r\n$$\r\n\r\n벡터의 합은 벡터 좌표의 단순합으로 이루어진다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121457485-b4520c80-c9e2-11eb-8de4-660f9a86a7a1.png)\r\n\r\n즉, 벡터의 총합 $v$는 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\nv = v_1 + v_2 = (x_2 + x_4 - x_1 - x_3, y_2 + y_4 - y_1 - y_3)\r\n$$\r\n\r\n$$\r\n||v|| = \\sqrt{(x_2 + x_4 - x_1 - x_3)^2 + (y_2 + y_4 - y_1 - y_3)^2}\r\n$$\r\n\r\n위 식으로 계산한 값의 최소값이 알고리즘의 해답이 된다. 즉, 우리는 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$을 조건에 맞게 조합해야한다. 각 조합의 $||v||$를 계산한 뒤, 이 중 최소값을 반환하면 될 것 같다.\r\n\r\n무턱대고 10개의 벡터를 for문 돌려가며 하나하나 만드는 방법은 안 된다. 좀 더 효율적으로 벡터를 계산하는 방법을 생각해보자.\r\n\r\n$v$식을 자세히 보면 쓸만한 특징일 하나 찾을 수 있는데, 각각의 좌표 $x$, $y$를 계산할 때 좌표의 절반은 더해지고, 절반은 빼진다. 좌표가 4개일 경우 2개는 더해지고, 나머지 2개는 빼진다. 만약 10개라면? 5개는 더해지고, 5개는 빼질 것이다.\r\n\r\n이를 활용하면 전체 좌표 $N$의 절반인 $N / 2$만큼의 좌표 조합을 구한다면 어떨까? 반은 더해지는 좌표, 나머지 반은 빼지는 좌표로 구분할 수 있다. 이후 각 좌표를 더하고 빼주면 손쉽게 $||v||$를 계산할 수 있을 것이다.\r\n\r\n따라서, 점을 반으로 나누어 <span class=\"green-A400\">양의 연산에 사용할 점과 음의 연산에 사용될 점의 경우의 수를 구하는 것이 이번 알고리즘의 핵심</span>이다. $_nC_r$(조합, Combination)을 사용하면 이를 쉽게 구할 수 있을 겻이다. $_nC_{(n / 2)}$를 계산하여, 선택된 좌표는 더하고, 선택되지 않은 좌표는 뺀다.\r\n\r\n예제 1의 $_4C_2$의 경우의 수는 아래와 같다.\r\n\r\n|     양의 좌표     |     음의 좌표     |   $v$    | $\\Vert v \\Vert$ |\r\n| :---------------: | :---------------: | :------: | :-------------: |\r\n|  (5, 5), (5, -5)  | (-5, 5), (-5, -5) | (20, 0)  |       20        |\r\n|  (5, 5), (-5, 5)  | (5, -5), (-5, -5) | (0, 20)  |       20        |\r\n| (5, 5), (-5, -5)  | (5, -5), (-5, 5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, 5)  | (5, 5), (-5, -5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, -5) |  (5, 5), (-5, 5)  | (0, -20) |       20        |\r\n| (-5, 5), (-5, -5) |  (5, 5), (5, -5)  | (-20, 0) |       20        |\r\n\r\n위와 같은 이유로 예제 1에서 벡터 총합의 최소값은 0이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1007 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/09/a1007\">1007 풀이</a>\r\n * @since 2021.06.09 Tue 00:50:26\r\n */\r\npublic class Main\r\n{\r\n\t// 결과\r\n\tprivate static double result;\r\n\t\r\n\t// 조합 선택 여부\r\n\tprivate static boolean[] isChecked;\r\n\t\r\n\t// 점의 배열\r\n\tprivate static int[][] P;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 점의 갯수\r\n\t\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\t\r\n\t\t\tresult = Double.MAX_VALUE;\r\n\t\t\t\r\n\t\t\tisChecked = new boolean[N];\r\n\t\t\t\r\n\t\t\tP = new int[N][2];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < N; j++)\r\n\t\t\t{\r\n\t\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tP[j][0] = Integer.parseInt(temp[0]);\r\n\t\t\t\tP[j][1] = Integer.parseInt(temp[1]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcombination(0, N / 2);\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t * @param count: [int] 조합할 원소 갯수\r\n\t */\r\n\tprivate static void combination(int index, int count)\r\n\t{\r\n\t\t// 조합할 원소 갯수가 더 이상 없을 경우\r\n\t\tif (count == 0)\r\n\t\t{\r\n\t\t\tresult = Math.min(result, getVector());\r\n\t\t}\r\n\t\t\r\n\t\t// 조합할 원소 갯수가 아직 남아있을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = index; i < P.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisChecked[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(i + 1, count - 1);\r\n\t\t\t\t\r\n\t\t\t\tisChecked[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 벡터 계산 함수\r\n\t *\r\n\t * @return [double] 벡터 크기\r\n\t */\r\n\tprivate static double getVector()\r\n\t{\r\n\t\tint x = 0;\r\n\t\tint y = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < P.length; i++)\r\n\t\t{\r\n\t\t\t// 양수로 선택된 점일 경우\r\n\t\t\tif (isChecked[i])\r\n\t\t\t{\r\n\t\t\t\tx += P[i][0];\r\n\t\t\t\ty += P[i][1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 음수로 선택된 점일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx -= P[i][0];\r\n\t\t\t\ty -= P[i][1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 브루트포스 알고리즘","url":["2021-06-09-a1007","2021","06","09","a1007"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 4. Jekyll 쇼핑하기","excerpt":"GitHub는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 Git을 이용하여 관리할 수 있다. GitHub 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 Git을 활용하는 것이 권장된다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-07T23:42:11","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-07-jekyll-blog-jekyll-shopping.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">GitHub Pages</span>는 꼭 <span class=\"primary\">Jekyll</span>로만 호스팅해야하는 것은 아니다. 해당 Repository에 전통적인 HTML, CSS, JavaScript 파일을 저장해도 호스팅엔 무리가 없다. 하지만 이 경우, 자신이 직접 모든 페이지를 디자인해야하고, 코딩 이상의 깊은 미적 감각이 요구된다. 디자인은 상황에 따라 코딩보다도 더욱 고난이도의 지식과 정교한 작업을 요구하기 때문.\r\n\r\n다행히 <span class=\"primary\">Jekyll</span> 기반 테마를 사용하면 이러한 문제를 해소할 수 있다.\r\n\r\n# Jekyll 쇼핑\r\n\r\n아래의 사이트들에서 <span class=\"primary\">Jekyll</span> 테마를 다운로드 받거나 데모 페이지를 확인해볼 수 있다. 기본적으로 무료이며, 테마에 따라 일부는 비용 청구를 통해 더욱 향상된 테마를 제공해주기도 한다.\r\n\r\n* [Jekyll Themes](http://jekyllthemes.org/)\r\n* [Free Jekyll Themes](https://jekyllthemes.io/free)\r\n* [Jekyllrc](http://themes.jekyllrc.org/)\r\n\r\n찾아보면 이 밖에도 여러 사이트가 존재한다. [Jekyll Themes](http://jekyllthemes.org/)를 예시로 확인해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90974202-ec778400-e563-11ea-83c6-b3456a678e27.png\" width=\"820px\" />\r\n</p>\r\n\r\n이렇게 수 많은 테마들이 준비되어있다. 테마별로 적합한 용도가 있기 때문에, 제공하는 기능을 잘 확인해야한다. 오로지 디자이너 개인의 의도와 가치관이 담겨있기 때문에, 내가 원하는 블로그와 테마의 방향이 일치한지 확인하자.\r\n\r\n> 어떤 테마는 블로그에 적합하고, 어떤 테마는 포트폴리오에 적합하다.\r\n\r\n내가 <span class=\"primary\">Jekyll</span> 시절 사용했던 테마는 [Moon Theme](http://taylantatli.github.io/Moon/)다. 깔끔하면서도 편안한 느낌이라 마음에 들었다. 대부분의 테마는 위와 같이 직접 체험이 가능한 데모 페이지를 제공하고 있으므로, 이를 활용하면 테마 선택에 도움이 된다.\r\n\r\n원하는 테마를 선택했다면, `clone` 작업을 진행하자. 거의 모든 테마는 해당하는 Repository URL을 제공한다. `cline` 작업을 위해 테마 Repository의 URL를 알아야 한다. URL은 아래와 같이 확인할 수 있다.\r\n\r\n> clone은 공개된 GitHub Repository를 내 로컬 PC에 복사하는 작업이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90974184-b4704100-e563-11ea-8463-54495387cd70.png\" width=\"820px\" />\r\n</p>\r\n\r\n해당 Repository의 주소나 사진처럼 <span class=\"primary\">Code</span> 버튼을 클릭하여 URL을 확인할 수 있다.\r\n\r\n프로젝트를 복사할 폴더에서 Git Bash를 띄우자. 콘솔에 아래의 명령어를 입력한다.\r\n\r\n`git clone {Theme URL} {username}.github.io`\r\n\r\n위 명령어는 입력한 URL의 소스를 대상 경로의 {username}.github.io 폴더로 복사하는 명령어다. 명령어가 정상적으로 실행되면 대상 경로에 {username}.github.io 폴더가 생기고, 소스를 직접 확인할 수 있다.\r\n\r\n하지만 아직 소스를 받았을 뿐, 내가 만든 Repository와 연동하지 못 했다. 아래의 작업을 통해 연동을 진행하자.\r\n\r\n1. clone된 프로젝트 폴더로 들어가서 Git Bash를 띄운다.\r\n2. `git remote set-url origin https://github.com:{username}/{username}.github.io.git` 명령어를 실행한다.\r\n3. `git push`를 통해 변경사항을 기록한다.\r\n\r\n이 과정을 끝마치고 <span class=\"primary\">GitHub</span>의 Repository를 보면, 텅 비어있던 예전과 달리 테마 소스들이 들어가있음을 확인할 수 있다.\r\n\r\n빌드에 약간의 시간이 걸리므로(~ 1분) 조금 기다렸다가 **https://{username}.github.io** 주소로 접속해보자. 테마가 적용되어있다면 성공이다. 물론 아직 어떠한 커스터마이징도 이루어지지 않았으므로, 데모 페이지와 큰 차이는 없다. 앞으로 여기다가 게시글을 작성하고 블로그를 꾸미면 된다.","url":["2021-06-07-jekyll-blog-jekyll-shopping","2021","06","07","jekyll-blog-jekyll-shopping"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 3. Git 설치하기","excerpt":"GitHub는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 Git을 이용하여 관리할 수 있다. GitHub 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 Git을 활용하는 것이 권장된다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-06T23:42:11","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)","Git"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-06-jekyll-blog-prepare-git.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">GitHub</span>는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 <span class=\"orange-A400\">Git</span>을 이용하여 관리할 수 있다. <span class=\"primary\">GitHub</span> 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 <span class=\"orange-A400\">Git</span>을 활용하는 것이 권장된다.\r\n\r\n# GitHub Repository 생성하기\r\n\r\n이전 장에서 <span class=\"primary\">GitHub</span> 계정을 만들었다. <a href=\"https://github.com\">GitHub 홈페이지</a>로 이동하여 로그인을 해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412420-0b9b8f00-e0e8-11ea-80a5-d28ff329a020.png\" width=\"820px\" />\r\n</p>\r\n\r\n해당 계정에서 관리하는 Repository의 전체 리스트를 보여준다. 아직 별다른 활동을 하지 않았다면 위 사진처럼 심플하게 보여준다. <span class=\"lightBlue-A400\">Create Repository</span> 버튼을 눌러 새로운 Repository를 생성하자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90422505-eada3600-e0f5-11ea-92f1-695a58f7f783.png\" width=\"820px\" />\r\n</p>\r\n\r\n* Owner: 소유주. 본인이 기본으로 지정되어 있다.\r\n* Repository name: Repository 이름. 블로그 호스팅을 위해 **{username}.github.io로 설정**하자.\r\n* Public / Private: Repository의 공개여부. 호스팅용 Repository는 반드시 **Public**이어야 한다.\r\n\r\n이 때, 주의할 점이 한가지 있는데, <span class=\"red-A400\">Repository의 이름을 {username}.github.io</span>으로 지정한다. 만약, username이 <span class=\"teal-A400\">test</span>라면, Repository의 이름은 <span class=\"teal-A400\">test</span>.github.io이 된다. 아이디가 아닌 username임에 주의하자. username은 프로필에서 확인할 수 있다.\r\n\r\n> GitHub Pages는 {username}.github.io 형식의 Repository를 Root(/)로 호스팅해준다. 즉, https://{username}.github.io가 된다. 만약 이와 같은 형식이 아닌 일반적인 Repository의 경우 https://{username}.github.io/{Repository Name}과 같이 하위 경로로 호스팅한다.\r\n\r\n한 계정이 관리하는 Repository의 이름은 중복될 수 없으므로, Root 경로의 호스팅은 계정 당 하나만 가능하다. 계정을 많이 만들어서 운용하면 어느정도 해소할 수 있긴 하다.\r\n\r\n나머지 옵션은 호스팅에 영향을 미치지 않으므로 무시하고 넘어가도 된다. 입력한 내용을 확인한 뒤 <span class=\"lightBlue-A400\">Create Repository</span>를 클릭하여 생성한다. Repository 목록에 생성한 Repository가 추가됐음을 확인할 수 있다.\r\n\r\n앞으로 이 Repository에 Jekyll 블로그 소스를 올릴 것이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90917728-6bfb3b00-e41e-11ea-8313-0251fba0659f.png\" width=\"820px\" />\r\n</p>\r\n\r\n생성된 저장소로 접근하면 위와 같은 화면이 나온다. 위 내용은 <span class=\"orange-A400\">Git</span> 명령어를 이용하여 사용자의 PC에 저장소를 생성하고, 이를 <span class=\"primary\">GitHub</span>의 원격 저장소와 연결하여 소스관리를 하는 절차를 안내하는 내용이다.\r\n\r\n# Git 설치하기\r\n\r\n이제 생성한 Repository를 관리할 <span class=\"orange-A400\">Git</span>을 설치해보자. <span class=\"orange-A400\">Git</span>은 소스코드를 효율적으로 관리할 수 있는 강력한 형상관리 툴로, Linux의 아버지 리누스 토르발스(Linus Benedict Torvalds)가 개발했다. 넓은 의미로 우리가 흔히 하는 복사 및 백업과 동일하지만, <span class=\"orange-A400\">Git</span>은 그것 보다는 더욱 강력하다.\r\n\r\n* 명령어 입력만으로 소스코드 백업이 가능하다.\r\n* <span class=\"orange-A400\">Git</span> 저장소와 통신이 가능한 환경이면 어디서나 저장된 소스코드를 받아오거나, 수정, 반영할 수 있다.\r\n* 커밋 시 해당 내역이 관리되며, 원할 경우 해당 커밋 이전으로 되돌릴 수 있다.\r\n* 커밋 별로 변경점을 비교할 수 있다.\r\n\r\n> Commit(커밋): Git의 변경사항(파일 생성, 수정, 삭제)을 저장소에 기록하는 작업\r\n\r\nJekyll 블로그는 <span class=\"primary\">GitHub</span>를 통해 관리하므로, 이와 연계된 <span class=\"orange-A400\">Git</span>의 사용은 필수다. 물론 <span class=\"orange-A400\">Git</span>을 사용하지 않고 <span class=\"primary\">GitHub</span>의 Repository에서 파일 추가, 삭제, 수정이 가능하다. 그러나 이 방법은 다수의 파일을 관리하는데 매우 비효율적이며, 파일 갱신 즉시 블로그에 내용이 반영되므로 오류가 있을 경우에도 블로그에 그대로 반영된다. 또한, 어찌됐든 Jekyll 사용하면서 코드를 만지게 될텐데, VSCode같은 에디터라도 쓰는게 개발환경에 여러모로 도움이 된다.\r\n\r\n## 설치파일 다운로드\r\n\r\n<a href=\"https://git-scm.com/\">Git 홈페이지</a>에서 Git를 설치하자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90918409-90a3e280-e41f-11ea-846f-68332ffecdbe.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span> 홈페이지는 위와 같다. 놀랍게도 홈페이지에서 자체적으로 **접속한 OS의 정보를 확인하고 해당 OS에 가장 적합한 Git을 추천**한다. 페이지 우측 상단의 모니터 그림에서 적합한 버전을 제공받을 수 있다.\r\n\r\n## 라이센스 동의\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90949816-b0222600-e486-11ea-95d7-7ee7150d4f4f.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span> 사용 라이센스에 동의한다. 당연하게도 동의 안 하면 설치가 불가능하다.\r\n\r\n## 설치경로 선택\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90949836-f6778500-e486-11ea-8568-94fd7e13f358.png\" width=\"820px\" />\r\n</p>\r\n\r\n특별한 문제가 없다면 설치경로는 기본값으로 지정한다.\r\n\r\n## 설치 옵션\r\n\r\n설치 시 적용할 옵션을 선택한다.\r\n\r\n* On the Desktop: 바탕화면 바로가기 생성\r\n* <span class=\"primary\">Git Bash Here</span>: 바탕화면에서 오른쪽 마우스 클릭 시 Git Bash 실행 메뉴 추가\r\n* Git GUI Here: 바탕화면에서 오른쪽 마우스 클릭 시 Git GUI 실행 메뉴 추가\r\n* Git LFS: 대용량 파일 지원\r\n* Associate .git* configuration files with the default text editor: git 설정파일을 기본 텍스트 편집기와 연결\r\n* Associate .sh files to be run with Bash: [.sh] 파일을 Bash로 실행함.\r\n* Use a TrueType font in console windows: 콘솔창의 폰트를 TrueType으로 사용\r\n* Check daily for Git for Windows updates: 매일 Git 업데이트 확인\r\n\r\n원하는 옵션을 추가/제외하고 다음으로 넘어간다. 파란색으로 하이라이팅된 옵션은 반드시 추가하는 것이 좋다.\r\n\r\n## 시작 프로그램 추가\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952465-b6240100-e49e-11ea-9784-cb5a1695ffeb.png\" width=\"820px\" />\r\n</p>\r\n\r\n시작 프로그램에 추가할 이름을 지정한다.\r\n\r\n* Don't create a Start Menu folder: 시작 메뉴를 생성하지 않는다.\r\n\r\n## Git 편집기 선택(Choosing the default editor used by Git)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952499-f97e6f80-e49e-11ea-95a0-818471fd3417.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span>을 사용하기 위한 기본 편집기를 선택한다. 기본 권장옵션은 Vim이며, 원하는 편집기로 변경이 가능하다. 지원하는 편집기는 아래와 같다.\r\n\r\n* Nano Editor\r\n* <span class=\"primary\">Vim</span>\r\n* Notepad++\r\n* Visual Studio Code\r\n* Visual Studio Code Insider\r\n* Sublime\r\n* Atom\r\n* other\r\n\r\n## 환경변수 지정(Adjusting your PATH environment)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952606-f6d04a00-e49f-11ea-85d0-204d305f8f9b.png\" width=\"820px\" />\r\n</p>\r\n\r\n환경변수를 지정하는 옵션을 선택한다.\r\n\r\n* Use Git from Git Bash Only: Bash 환경에서만 Git 사용 가능 (환경변수 미변경)\r\n* <span class=\"primary\">Use Git from Windows Command Prompt</span>: 윈도우 프롬프트에서 Git 사용 가능\r\n* Use Git abnd optional Unix tools from the Windows Command Prompt: 윈도우 프롬프트에 Git 및 Linux 명령어 사용 가능\r\n\r\n## HTTPS 전송 방법 설정(Choosing HTTPS tranport backend)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952734-0e5c0280-e4a1-11ea-8a9f-08a164f05b5e.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span> 사용 시 HTTPS 전송 방법을 선택한다.\r\n\r\n* <span class=\"primary\">Use The OpenSSH library</span>: OpenSSH 라이브러리 사용\r\n* Use The native Windows Secure Channel library: Windows 인증서 저장소 사용\r\n\r\n## 개행문자 처리방식 지정(Configuring the line ending conversions)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90953593-a4932700-e4a7-11ea-95dd-5c6cb50662ea.png\" width=\"820px\" />\r\n</p>\r\n\r\nCheckout, Commit 작업 시 파일의 개행문자 처리 방식을 선택한다.\r\n\r\n* <span class=\"primary\">Checkout Windows-style, commit Unix-style line endings</span>: Checkout 시엔 Windows방식(CRLF), commit 시엔 Unix방식(LF)로 지정\r\n* Checkout as-is, commit Unix-style line endings: Checkout 시엔 변환 없음, commit시엔 Unix방식(LF)로 지정\r\n* Checkout as-is, commit as-is: Checkout, commit 둘 다 변환 없음\r\n\r\n## Git Bash 선택(Configuring the terminal emulator to use with Git Bash)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90953681-ba551c00-e4a8-11ea-9fc4-fe1c43e2ef28.png\" width=\"820px\" />\r\n</p>\r\n\r\nGit Bash 실행 시 사용할 터미널을 선택한다.\r\n\r\n* <span class=\"primary\">Use MinTTY</span>: MinTTY 터미널 사용\r\n* Use Windows default console window: Windows 기본 터미널 사용\r\n\r\n## Pull 기본동작 지정 (Choose the default behavior of 'git pull')\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90953682-bc1edf80-e4a8-11ea-9d0c-d9c0d71afbaf.png\" width=\"820px\" />\r\n</p>\r\n\r\n`git pull` 명령어 실행 시 수행할 동작을 지정한다.\r\n\r\n* <span class=\"primary\">Default (fast-forward or merge)</span>: fast-forward 혹은 merge를 이용한 병합\r\n* Rebase: rebase를 이용항 병합\r\n* Only ever fast-forward: fast-forward를 이용한 병합\r\n\r\n## Credential helper 지정(Choose a credential helper)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90954457-53873100-e4af-11ea-9a98-ef5131c4ab1a.png\" width=\"820px\" />\r\n</p>\r\n\r\nCredential helper를 지정한다.\r\n\r\n> Credential은 데이터 통신에 HTTP 프로토콜을 사용 시, 매번 입력해야하는 인증정보를 저장하고 자동으로 입력해주는 시스템을 제공한다.\r\n\r\n* None: 사용하지 않음\r\n* <span class=\"primary\">Git Credential Manager</span>: Windows 전용 Credential Manager 사용\r\n* Git Credential Manager Core: Cross-Platform을 지원하는 Credential Manager 사용\r\n\r\n## 실험 옵션 지정(Configuring experimental options)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90954553-225b3080-e4b0-11ea-8930-6b461f966b4c.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span>에서 제공하는 실험적인 옵션을 선택한다. 해당 옵션은 업데이트에 따라 정식으로 지원되거나, 제외될 수 있다.\r\n\r\n* Enable experimental support for pseudo consoles: 가상 터미널 지원\r\n\r\n## 설치 완료\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90957778-03b66300-e4cb-11ea-9927-a0efbfc1e921.png\" width=\"820px\" />\r\n</p>\r\n\r\n컴퓨터의 사양에 따라 약간의 시간이 소요될 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90957782-0618bd00-e4cb-11ea-9972-7bd3fe1aa45b.png\" width=\"820px\" />\r\n</p>\r\n\r\n설치가 완료됐다. <span class=\"primary\">Launch Git Bash</span>를 체크하면 Git 명령어를 입력할 수 있는 Git Bash가 즉시 실행된다.\r\n\r\n## Git Bash 실행하기\r\n\r\n설치 후 바탕화면이나 폴더에서 오른쪽 마우스를 클릭해서 컨텍스트 메뉴를 띄우자. [설치 옵션](#설치-옵션)에서 선택했던 내용에 따라 <span class=\"primary\">Git Bash Here</span>, <span class=\"primary\">Git GUI Here</span>가 생성됨을 확인할 수 있다. 해당 메뉴를 클릭하면 Bash 혹은 GUI를 실행할 수 있다. Bash는 콘솔 형태이며, GUI는 UI가 있는 흔한 프로그램이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90957788-0913ad80-e4cb-11ea-8627-6ceba19d58b4.png\" width=\"820px\" />\r\n</p>\r\n\r\n위 사진은 Bash의 사진으로, 본 시리즈에서는 Git Bash를 통한 명령어 입력을 기준으로 서술한다.\r\n\r\n> Git GUI는 Git Desktop으로 인해 잘 쓰이지 않는다.\r\n\r\n# Git 설정하기\r\n\r\nGit Bash를 실행한다. 자신이 만든 Repository와 통신하기 위해서, 내가 나임을 인증할 수 있는 정보를 사전에 입력해야 한다. 아래의 명령어를 통해 인증 정보를 입력하자.\r\n\r\n`git config --global user.name \"사용자 username\"`\r\n`git config --global user.email \"사용자 email\"`\r\n\r\nusername과 email은 회원가입시 입력한 정보로 입력해야한다.","url":["2021-06-06-jekyll-blog-prepare-git","2021","06","06","jekyll-blog-prepare-git"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 2. GitHub와 친해지기","excerpt":"Jekyll은 GitHub를 통해 호스팅한다. 즉, Jekyll로 블로그를 만들기 위해선 GitHub를 조금이나마 알고 있어야 한다. 본문에서는 GitHub의 여러 기능은 제쳐두고, Jekyll 호스팅을 목적을 기준으로 설명한다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-06T23:29:32","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)","GitHub(깃허브)"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-06-jekyll-blog-github.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">Jekyll</span>은 <span class=\"primary\">GitHub</span>를 통해 호스팅한다. 즉, <span class=\"primary\">Jekyll</span>로 블로그를 만들기 위해선 <span class=\"primary\">GitHub</span>를 조금이나마 알고 있어야 한다. 본문에서는 <span class=\"primary\">GitHub</span>의 여러 기능은 제쳐두고, <span class=\"primary\">Jekyll</span> 호스팅을 목적을 기준으로 설명한다.\r\n\r\n# GitHub 속으로!\r\n\r\n<span class=\"primary\">GitHub</span>는 개발자들을 위한 소스코드 형상관리 서비스를 제공해준다. Git을 저장하고 관리하는 대표적인 저장소로, 수 많은 오픈, 개인 소스가 존재한다. Git과 <span class=\"primary\">GitHub</span>는 그 자체만으로도 커다란 주제가 여러개 튀어나오니, 일단은 우리의 목표인 호스팅만을 알아보자.\r\n\r\n<a href=\"https://github.com/\">GitHub 바로가기</a>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90389062-d2512800-e0c3-11ea-8a59-f4980afab7b5.png\" width=\"820px\" />\r\n</p>\r\n\r\n접속하면 위와 같은 화면을 볼 수 있는데, 상단 우측의 <span class=\"lightBlue-A400\">Sign Up</span>을 클릭하여 회원가입을 진행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90411265-777cf800-e0e6-11ea-95d5-372388b32bd2.png\" width=\"820px\" />\r\n</p>\r\n\r\n* username: 닉네임\r\n* Email address: 이메일 주소\r\n* Password: 비밀번호\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412061-96c85500-e0e7-11ea-9a7b-8f71fa52f776.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정을 생성하면 나오는 설문조사. 무시해도 무방하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412232-d42ce280-e0e7-11ea-92e9-dc637cb2c8a9.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정 생성이 완료되면 회원가입 시 작성한 이메일로 인증 코드를 전송하니 메일을 확인한다.\r\n\r\n만약, 이메일이 제대로 오지 않는다면, <span class=\"lightBlue-A400\">Resend verification email</span>을 통해 메일을 재발송할 수 있다. 혹은 이메일 주소를 잘못 입력했다면, <span class=\"lightBlue-A400\">Change your email settings</span>를 클릭하여 인증할 이메일 주소를 변경한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412375-fde60980-e0e7-11ea-805b-7d4c58ab0b4d.png\" width=\"820px\" />\r\n</p>\r\n\r\n인증 이메일을 확인하고 <span class=\"lightBlue-A400\">Verify email address</span>를 클릭하여 인증을 완료한다. 계정 생성 과정이 끝난다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412420-0b9b8f00-e0e8-11ea-80a5-d28ff329a020.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"primary\">GitHub</span>에 접속하여 로그인을한다. 회원가입시 입력한 username이나 email 둘 중 아무거나 사용해도 상관없다. 위 화면이 뜨면 회원가입이 완료된 것이다.","url":["2021-06-06-jekyll-blog-github","2021","06","06","jekyll-blog-github"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 1. Jekyll이란?","excerpt":"대형 포탈이나 크고 작은 플랫폼을 통해 자신만의 블로그를 만들 수 있다. 이러한 플랫폼을 통한 블로그는 연동된 계정과 버튼 클릭 몇 번으로 만들 수 있을 정도로 쉽고 간편하다. 하지만 이와 같은 블로그는 페이지의 기본 프레임이 정해져있고, 자유로운 커스터마이징이 제한된 편이다. 자신만의 색이나 가치관을 담은 블로그를 만들기 위해선 소위 \"기성품\"이 아닌 방법을 찾아야하는데, 이는 곧 자신이 직접 웹 페이지를 제작하고 퍼블리싱, 호스팅까지 전반적인 웹 서비스 자체를 구축해야하는 큰 작업으로 이어진다. 어찌어찌 페이지를 제작한다 하더라도, CSS를 통한 디자인이나 JavaScript같은 부가기능은 프레임 제작 이상으로 어렵다. 여기까지는 어떻게 자력으로 했다고 하더라도, 호스팅은 돈이 든다. DB까지 연동한다면 금액은 더욱 커지게 된다. 내가 원한건 단순한 블로그였는데.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-06T23:18:25","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-06-jekyll-blog-start.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n대형 포탈이나 크고 작은 플랫폼을 통해 자신만의 블로그를 만들 수 있다. 이러한 플랫폼을 통한 블로그는 연동된 계정과 버튼 클릭 몇 번으로 만들 수 있을 정도로 쉽고 간편하다. 하지만 이와 같은 블로그는 페이지의 기본 프레임이 정해져있고, 자유로운 커스터마이징이 제한된 편이다. 자신만의 색이나 가치관을 담은 블로그를 만들기 위해선 소위 \"기성품\"이 아닌 방법을 찾아야하는데, 이는 곧 자신이 직접 <span class=\"green-A400\">웹 페이지를 제작하고 퍼블리싱, 호스팅까지 전반적인 웹 서비스 자체를 구축해야하는 큰 작업</span>으로 이어진다. 어찌어찌 페이지를 제작한다 하더라도, <span class=\"purple-A400\">CSS</span>를 통한 디자인이나 <span class=\"orange-A400\">JavaScript</span>같은 부가기능은 프레임 제작 이상으로 어렵다. 여기까지는 어떻게 자력으로 했다고 하더라도, 호스팅은 돈이 든다. DB까지 연동한다면 금액은 더욱 커지게 된다. 내가 원한건 단순한 블로그였는데.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90330531-5d5cf000-dfe8-11ea-8a25-c5c89fa05a42.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"primary\">GitHub Pages</span>를 활용하면 위와같은 문제의 대부분을 해결할 수 있다. <span class=\"primary\">GitHub</span>는 <span class=\"primary\">GitHub Pages</span> 프로젝트를 통해 특정한 이름을 가진 Repository 내부의 파일들을 <span class=\"primary\">github.io</span> 도메인으로 퍼블리싱해준다. 즉, 무료로 웹 호스팅을 제공받을 수 있는 셈이다. <span class=\"primary\">GitHub Pages</span>가 제시하는 방법에 따라 Repository를 만드는 것만으로도 유일하게 비용이 필요한 호스팅이라는 큰 산이 하나 사라진다.\r\n\r\n> Repository: GitHub에서 관리하는 프로젝트의 단위로, 각 계정마다 여러개의 Repository를 마음대로 생성, 수정, 삭제할 수 있다.\r\n\r\n안타깝게도 이는 호스팅과정을 라이트하게 만들어준 것일 뿐, 실제 페이지를 퍼블리싱하기 위해선 어쩔수 없이 웹 코딩 지식이 필요하다. 이를 위해 <span class=\"primary\">GitHub</span>는 <b class=\"primary\">Jekyll(지킬)</b>이라는 프레임워크를 통해 사용자들이 블로그 테마를 쉽게 만들고 이를 활용할 수 있는 환경을 제공하고 있다.\r\n\r\n필자는 어느정도 웹 관련 지식이 있음에도 불구하고 <span class=\"red-A400\">Ruby</span>와 <span class=\"primary\">Jekyll</span>이라는 다소 생소한 환경때문에 이를 이해하는데 다소 시간이 소요됐다. 이번 주제를 통해 웹에 있어서 나와 비슷하거나, 전무한 지식을 가진 사람들에게 내 블로그 구축기를 공유하고자 한다. 이 글은 <span class=\"primary\">Jekyll</span>이라는 개념을 처음 접하는 이들이 가급적 쉽게 이해함에 초점을 맞춘다.\r\n\r\n# Jekyll(지킬)이란?\r\n\r\n지킬 앤 하이드의 그 지킬 맞다. <span class=\"primary\">Jekyll</span>은 <span class=\"primary\">GitHub</span>의 설립자 중 하나인 Tom Preston-Werner가 <span class=\"red-A400\">Ruby</span>언어를 통해 개발한 프레임워크다. <span class=\"primary\">GitHub</span> 자체적으로 <span class=\"primary\">Jekyll</span> CMS(Contents Management System)을 내장하고 있어서 <span class=\"primary\">Jekyll</span> 호스팅에 매우 적합하다.(물론 굳이 Jekyll 기반이 아니여도 호스팅엔 문제가 없다.)\r\n\r\n웹을 나누는 구분 중에 정적(Static) 웹과 동적(Dynamic) 웹이 있다. <span class=\"primary\">Jekyll</span> 정적(Static) 웹 환경을 위한 프레임워크다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90335406-cdcb3780-e00f-11ea-87e2-b8c8ba8f576c.png\" width=\"820px\" />\r\n</p>\r\n\r\n**정적 웹**\r\n\r\n* 요청에 따라 미리 저장된 페이지를 응답\r\n* 웹 서버가 필요하지 않으므로, 서버 사양에 대한 영향이 적음\r\n* Back-end 코드가 없어 제작이 간편함\r\n* 속도가 빠름\r\n* 복잡한 로직이 필요 없는 소규모 사이트(블로그 등)에 적합함\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90335405-cb68dd80-e00f-11ea-9b08-7a9ec21c5eee.png\" width=\"820px\" />\r\n</p>\r\n\r\n**동적 웹**\r\n\r\n* 요청에 따라 웹 서버가 데이터를 가공하여 전달\r\n* DB연동을 통한 데이터 CRUD가 가능\r\n* 동일한 페이지도 요청에 따라 다양한 내용을 응답\r\n* 웹 서버 사양에 따라 속도 저하의 우려 있음\r\n* 복잡한 로직이 필요한 비즈니스 사이트(쇼핑몰 등)에 적합함\r\n\r\n우리가 사용하는 대부분의 사이트는 동적 웹의 형태가 대부분이다. 자체적인 회원가입 시스템, 간단한 게시판 등이 존재한다면 대부분 동적 웹으로 봐도 무방하다. 회원가입이나 게시판에는 반드시 DB가 필요하고, 이는 곧 DB와 사이트 간의 동작을 제어할 서버가 필요하다는 의미이기 때문. DB의 존재로 인해 실시간 데이터 CRUD가 가능하다. <span class=\"green-A400\">사용자가 페이지에서 무언가 의미있는 컨텐츠 활동을 할 수 있다면 동적 웹</span>이다.\r\n\r\n반대로, 정적 웹은 단순히 저장된 파일을 요청에 맞게 보여만 주므로, 사용자는 단순 사이트 관광객 그 이상 그 이하도 아니다. 블로그의 경우 로그인 같은 사용자 인증이 전혀 필요 없으며, 소유자외의 작성자가 필요하지 않기 때문에 정적 웹 형태로도 얼마든지 서비스를 제공할 수 있다. <span class=\"primary\">Jekyll</span>은 사용자가 작성한 코드를 하나의 웹 프로젝트 형태로 빌드한다. <span class=\"primary\">Jekyll</span>은 이러한 정적 웹 방식을 채택함으로써 빠른 속도를 확보하고 백엔드 코드에 대한 부담감을 없앴다.\r\n\r\n사용하기에 앞서, <span class=\"primary\">Jekyll</span>은 <span class=\"red-A400\">블로그 퍼블리싱의 주체가 자기 자신</span>에게 있다. 즉, 페이지 하나하나를 세세하게 컨트롤 할 수 있으며, 그래야만 한다. 이러한 자유도는 누군가에겐 강력한 장점이지만, 누군가에겐 없는게 나은 단점이 되기도 한다.\r\n\r\n<span class=\"green-A400\">Jekyll은 이런 분들께 적합해요!</span>\r\n\r\n* 판에 찍힌 블로그보다 자신만의 감각이 들어간 블로그를 만들고 싶은 사람\r\n* 웹에 대한 기초적인 지식이나 그에 준하는 센스를 가진 사람\r\n* 다양한 기능을 구현하고 싶은 사람\r\n* 위의 모든 사항을 재미로 느낄 수 있는 사람\r\n\r\n<span class=\"red-A400\">Jekyll은 이런 분들께 나빠요...</span>\r\n\r\n* 어찌됐든 안정적인 블로그를 얻고싶은 사람\r\n* 이런저런 난잡한 일에 시간을 투자하기 어려운 사람\r\n* 지금 당장 블로그를 시작하고 싶은 사람\r\n* 복잡한 것을 지양하는 사람\r\n\r\n<span class=\"primary\">Jekyll</span>은 하나부터 열까지 본인이 직접 구성해야한다. 그 흔한 댓글 기능조차 플러그인을 사용해서 구성해야한다. 즉, 통상 사이트 혹은 블로그라면 응당 존재해야할 기능조차 본인이 스스로 구성하지 않으면 안 된다. 원한다면 내 블로그에 무엇이든 구현할 수 있지만, 반대로 아무것도 구현하지 않은 단순한 페이지조각에 그친다. 기타 카테고리나 태그를 만들 때도 마찬가지. 이런걸 하면서 재미를 느끼지 못 한다면 개인적으로 별로 권하고 싶지 않다.\r\n\r\n물론 아름다운 테마를 적용할 수 있는건 독보적인 강점이지만, 이미 Tistory 정도만 가도 플랫폼 형태이면서 강력한 커스터마이징을 제공하기도 한다. 그럼에도 불구하고 <span class=\"primary\">Jekyll</span>을 선택한다면, <span class=\"primary\">Jekyll</span>은 당신에게 그 어떤 블로그에서도 접해보지 못한 색다른 경험을 제공해줄 것이다.","url":["2021-06-06-jekyll-blog-start","2021","06","06","jekyll-blog-start"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1006번 습격자 초라기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-06T22:42:02","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","PLATINUM","PLATINUM III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-06-a1006.md","content":"\r\n# 습격자 초라기\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/18.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1006번 문제](https://www.acmicpc.net/problem/1006)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)\r\n\r\n![image](https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg)\r\n\r\n초라기는 각각 $W$명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.\r\n\r\n1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.\r\n2. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.\r\n3. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 $W$ 보다 작거나 같아야 한다.\r\n\r\n이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n첫째 줄에는 (구역의 개수)/2 값 $N$과 특수 소대원의 수 $W$가 주어진다. ($1 ≤ N ≤ 10000$, $1 ≤ W ≤ 10000$).\r\n\r\n둘째 줄에는 $1 ~ N$번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 $N + 1 ~ 2N$번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ $W$)\r\n\r\n## 출력\r\n\r\n각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n8 100\r\n70 60 55 43 57 60 44 50\r\n58 40 47 90 45 52 80 40\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n## 힌트\r\n\r\n하나의 특수 소대로 인접한 두 영역을 커버할 수 있는 배치는 (2,10), (9,16), (4,5), (7,8), (13,14) 이다. 그리고 나머지 6개 구역은 각각 하나의 특수 소대로 커버할 수 있다. 그러므로 최소 11개 특수 소대를 침투시켜야 한다.\r\n\r\n# 풀이\r\n\r\n백준 알고리즘을 순서대로 푸는 나 같은 초심자들에게 <span class=\"red-A400\">힘의 차이</span>를 느끼게 해주는 문제라고 한다. [solved.ac](https://solved.ac/)에 의하면 문제 등급이 무려 <span class=\"teal-A400\">PLATINUM III</span> 수준. 지금까지 푼 문제 중 가장 높은 등급이 [ACM Craft](/posts/2021/06/01/a1005) (<span class=\"amber-A400\">GOLD III</span>) 수준임을 감안하면 월등히 높은 수준의 문제. 실제로 풀면서도 혼자서는 도저히 방법이 안 떠오르는데다, 풀이를 봐도 이해가 잘 안 됐다.\r\n\r\n해당 문제에 주어지는 <span class=\"primary\">구역</span>은 원형이다. 문제를 쉽게 접근하기 위해선 이 원형을 임의로 잘라 직사각형 형태로 전개해야 한다. 즉, <span class=\"error\">풀 때는 직사각형 형태지만, 실제로는 원형이므로 직사각형의 잘린 양 끝부분까지 염두하여 계산</span>을 해야한다. 난이도를 상승시키는 요인 중 하나.\r\n\r\n케이스에 제시된 예제를 기준으로 구역을 사각형으로 도식화하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png)\r\n\r\n위 사진과 같이 8x8 배열로 표현할 수 있다. 여기서 여기서 6번째 행까지 특수소대로 채울 수 있는 최소값은 어떻게 구할 수 있을까?\r\n\r\n역으로 한번 생각해보자. 우리 특수소대는 너무나 유능해서 항상 최소의 팀만으로 목표 구역을 점령한다고 해보자. 작전 보고서엔 아래와 같이 점령한 구역을 표시하며, 이를 <span class=\"yellow-a500\">노란색</span> 영역으로 마킹해서 보여준다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120926996-378d0d00-c71a-11eb-9b0f-baacb8da1647.png)\r\n\r\n즉, <span class=\"yellow-a500\">노란색</span> 영역은 최소의 특수소대팀이 투입된 것이며, 우리가 실제로 구현할 알고리즘의 결과물이기도 하다.\r\n\r\n문제의 설정 상, 특수소대는 반드시 한 팀이 온전히 투입되어야 하며, 최소로 투입 가능한 인원 역시 한 팀이다. 그렇다면 위 사진에서 특수소대 한 팀이 커버할 수 있는 영역을 제외해보면 아래와 같이 세 케이스 $a$, $b$, $c$로 나눌 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927024-568b9f00-c71a-11eb-9309-7e4ef2f06ac2.png)\r\n\r\n즉, 우리가 저 세 케이스에 대한 특수소대팀의 최소값을 계산할 수 있다면, 결과적으로 6번째 행 전체를 커버하는 특수소대팀의 수를 구할 수 있다. 이미 최소 인원이 나머지 구역을 점령한 상황에서, 투입할 수 있는 최소 인원인 한 팀만 투입할 수 있기 때문.\r\n\r\n여러 블로그에서 위 세 그림을 많이 봤을 텐데, 뜬금없이 저런 그림이 등장함에는 이와같은 배경이 있는 것이다.\r\n\r\n## 변수\r\n\r\n알고리즘 설계에 사용할 변수는 아래와 같다.\r\n\r\n* $T$: 케이스 수\r\n* $N$: 구역의 행 수\r\n* $e$: 구역별 적의 수\r\n* $a_i$: 첫 번째 케이스의 특수소대 최소 투입 수\r\n* $b_i$: 두 번째 케이스의 특수소대 최소 투입 수\r\n* $c_i$: 세 번째 케이스의 특수소대 최소 투입 수\r\n\r\n## a 공식\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927050-77ec8b00-c71a-11eb-8034-5b02a6c04246.png)\r\n\r\n첫번째 케이스로 $a_5$의 최소값 공식을 설계하자.\r\n\r\n위에서 했던 방식과 마찬가지로 추론하면 $a_5$에서 한팀을 뺀 $a_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927077-90f53c00-c71a-11eb-96cd-38edba684b10.png)\r\n\r\n$a_5 - 1 = c_5$ 이므로 $a_5 = c_5 + 1$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{05} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927092-9c486780-c71a-11eb-91c7-1922f98a1b01.png)\r\n\r\n$a_5 - 1 = b_4$ 이므로 $a_5 = b_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $a_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $a_5 = c_5 + 1$ -> $a_{i+1} = c_{i+1} + 1$\r\n* $a_5 = b_4 + 1$ -> $a_{i+1} = b_i + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## b 공식\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927110-ac604700-c71a-11eb-989a-3d97d8e6a3ca.png)\r\n\r\n$b_5$의 최소값 공식을 설계하자.\r\n\r\n$b_5$에서 한팀을 뺀 $b_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927135-c0a44400-c71a-11eb-9c22-4e1303799b3b.png)\r\n\r\n$b_5 - 1 = c_5$ 이므로 $b_5 = c_5 + 1$\r\n\r\n$a_5$의 식과 동일하다.\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{14} + e_{15} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927154-d285e700-c71a-11eb-8b25-14fd85e1b1b0.png)\r\n\r\n$b_5 - 1 = a_4$ 이므로 $b_5 = a_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $b_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $b_5 = c_5 + 1$ -> $b_{n+1} = c_{n+1} + 1$\r\n* $b_5 = a_4 + 1$ -> $b_{n+1} = a_n + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## c 공식\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927173-e3365d00-c71a-11eb-9c1b-dfb34ab3b444.png)\r\n\r\n$c_5$의 최소값 공식을 설계하자. ($c_5$는 4행까지 채워짐에 유의하자)\r\n\r\n$c_5$에서 한팀을 뺀 $c_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 여러 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927189-f47f6980-c71a-11eb-8c17-2120a82b4b6e.png)\r\n\r\n$c_5 - 1 = a_4$ 이므로 $c_5 = a_4 + 1$\r\n\r\n$c_5 - 1 = b_4$ 이므로 $c_5 = b_4 + 1$\r\n\r\n두 케이스 중 더 작은 케이스가 $c_5$이므로 아래의 식으로 귀결된다.\r\n\r\n$c_5 = min(a_4 + 1, b_4 + 1)$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927199-ff39fe80-c71a-11eb-8b45-bb4f13aadf08.png)\r\n\r\n$c_5 = c_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 한팀이 네개의 구역을 커버할 수 있을 경우\r\n\r\n$c_i$의 경우 한 가지 특이 케이스가 발생한다. $a_i$, $b_i$의 경우 최소 투입인원인 1을 뺀 값만을 계산했다. $c_i$의 경우 직사각형이라는 특징 때문에 최대 4개 구역을 2팀이 점령할 수 있다.\r\n\r\n$e_{03} + e_{04} ≤ W$ 이고 $e_{13} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927226-11b43800-c71b-11eb-8845-7597a3a502b8.png)\r\n\r\n$c_5 = c_3 + 2$\r\n\r\n모든 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $c_{i+1} = min(a_{i} + 1, b_{i} + 1)$\r\n* $c_{i+1} = c_{i} + 1$\r\n* $c_{i+1} = c_{i-1} + 2$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 최종 일반식\r\n\r\n구한 일반식을 정리하면 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 원형 구조 적용을 위한 초기값 지정하기\r\n\r\n위 수식을 코드로 녹여내면 되지만, 완벽한 건 아니다. 왜냐하면 이 구역이 <span class=\"red-A400\">선형이 아닌 원형 구조</span>이기 때문.\r\n\r\n지금까지 우리는 원리 이해 및 수식 도출의 편의를 위해 원타곤을 임의로 잘라 표타곤으로 전개하여 수식을 계산했다. 이러한 <span class=\"green-A700\">선형 구조는 시작점과 도착점이 있지만 원형은 순환 구조</span>이므로 이에 맞춰 조건식을 작성해야 한다. 즉, <span class=\"red-A400\">원형 구조에 호환되도록 일부 케이스에 초기값을 지정</span>해야 최종적으로 원하는 알고리즘을 작성할 수 있다.\r\n\r\n아래의 사진은 원타곤과 표타곤을 비교한 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927246-2b557f80-c71b-11eb-92bf-fe5f92cf5504.png)\r\n\r\n이 처럼, 원형 구조는 $e_{00}, e_{07}$끼리도 연결이 가능하지만, 선형 구조는 구조상 불가능하다. 때문에 이러한 케이스들의 초기값을 지정해줘야한다.\r\n\r\n대충 감이 오겠지만, 걸친 모양에 따라 총 4가지 케이스가 존재한다.\r\n\r\n### 걸치지 않을 경우 (기본)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png)\r\n\r\n$e_{00}, e_{07}$ 혹은 $e_{10}, e_{17}$과 같이 영역이 겹치지 않을 경우. 선형 구조에서도 적용 가능한 기본적인 케이스다. $a_i, b_i, c_i$의 모양과 연관지어 생각하면 아래와 같이 도식이 가능하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927267-4a541180-c71b-11eb-8596-497ba12219e4.png)\r\n\r\n$a_i$는 $i$열의 윗 칸만 채우므로 $e_{00}$만 점령한 상태이므로 1\r\n\r\n$b_i$는 $i$열의 아래 칸만 채우므로 $e_{01}$만 점령한 상태이므로 1\r\n\r\n$c_i$는 $i - 1$열을 채우는데, $c_{-1}$은 논리상 불가능하므로 0\r\n\r\n즉 초기값은 아래와 같다.\r\n\r\n$$\r\na_0 = 1\r\n$$\r\n\r\n$$\r\nb_0 = 1\r\n$$\r\n\r\n$$\r\nc_0 = 0\r\n$$\r\n\r\n$i = 0$일 때의 초기값을 지정한다.\r\n\r\n이 케이스일 경우 $c_N$이 알고리즘의 답이 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_8$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927320-88e9cc00-c71b-11eb-8ae4-3dfb03d4e0f0.png)\r\n\r\n### 윗 행만 걸칠 경우\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927336-9bfc9c00-c71b-11eb-837d-77c000661702.png)\r\n\r\n$e_{00}, e_{07}$을 점령할 경우. 원형 구조에서만 가능한 케이스다. **걸치지 않는 경우**를 제외한 나머지 케이스는 전부 원형 구조에서만 가능한 케이스이니 참고할 것. $i = 0$일 때는 영향을 받지 않아 **걸치지 않는 경우**와 동일하다. 걸치기 위해선 반드시 두 행 이상이 필요하기 때문에, $N > 1$을 충족해야 한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927372-a880f480-c71b-11eb-84cc-689658a3a89c.png)\r\n\r\n연결된 부분을 체크패턴으로 하이라이팅 했다. 이 둘이 서로 연결되기 때문에, 다른 구역의 특수소대가 점령할 수 없다. 따라서 <b class=\"red-A400\">해당 부분은 초기값 계산 시 없는 영역으로 생각하면 된다.</b> 이러한 특징을 감안하면 아래와 같이 초기값을 지정할 수 있다.\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 2\r\n$$\r\n\r\n$$\r\nb_1 = \r\n\\begin{cases}\r\n\t1, & (e_{10} + e_{11} ≤ W)\\\\\r\n\t2, & (e_{10} + e_{11} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $b_{N-1} + 1$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927427-b767a700-c71b-11eb-9306-0931ede25cba.png)\r\n\r\n### 아래 행만 걸칠 경우\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927442-c6e6f000-c71b-11eb-8f51-2fab907fbcc2.png)\r\n\r\n$e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927459-d1a18500-c71b-11eb-9c6c-07919e9f4f8d.png)\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = \r\n\\begin{cases}\r\n\t1, & (e_{00} + e_{01} ≤ W)\\\\\r\n\t2, & (e_{00} + e_{01} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_1 = 2\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $a_{N-1} + 1$이 알고리즘의 답이 된다. $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927475-e120ce00-c71b-11eb-8bd6-c44d4137fae8.png)\r\n\r\n### 두 행 모두 걸칠 경우\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927491-ee3dbd00-c71b-11eb-98b9-f0d4209ec965.png)\r\n\r\n$e_{00}, e_{07}$, $e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927507-fd246f80-c71b-11eb-8e78-f08c15922ad8.png)\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$, $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 1\r\n$$\r\n\r\n$$\r\nb_1 = 1\r\n$$\r\n\r\n$$\r\nc_1 = 0\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $c_{N-1} + 2$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$, $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_{N-1} + 2$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120927519-07df0480-c71c-11eb-9fdf-c8f05858b72d.png)\r\n\r\n### 최종 케이스\r\n\r\n* 기본\r\n  * $a_0 = 1$\r\n  * $b_0 = 1$\r\n  * $c_0 = 0$\r\n\r\n<br />\r\n\r\n* 윗 행만 걸칠 경우 $(e_{00} + e_{0(N-1))} ≤ W)$\r\n  * $a_1 = 2$\r\n  * $b_1 = \\begin{cases} 1, & (e_{10} + e_{11} ≤ W)\\\\ 2, & (e_{10} + e_{11} > W) \\end{cases}$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 아래 행만 걸칠 경우 $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = \\begin{cases} 1, & (e_{00} + e_{01} ≤ W)\\\\ 2, & (e_{00} + e_{01} > W) \\end{cases}$\r\n  * $b_1 = 2$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 두 행 모두 걸칠 경우 $(e_{00} + e_{0(N-1)} ≤ W)$, $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = 1$\r\n  * $b_1 = 1$\r\n  * $c_1 = 0$\r\n\r\n비로소 알고리즘을 구현하기 위한 모든 준비물이 갖춰졌다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1006 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/06/a1006\">1006 풀이</a>\r\n * @since 2021.06.06 Sun 22:44:45\r\n */\r\npublic class Main\r\n{\r\n\tprivate static int N;\r\n\tprivate static int W;\r\n\t\r\n\tprivate static int[][] e;\r\n\t\r\n\tprivate static int[] a;\r\n\tprivate static int[] b;\r\n\tprivate static int[] c;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tint result = 2147483647;\r\n\t\t\t\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 행 수\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\t// 특수소대원 수\r\n\t\t\tW = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 구역별 적 배열\r\n\t\t\te = new int[2][N];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < 2; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tfor (int k = 0; k < N; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\te[j][k] = Integer.parseInt(temp[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ta = new int[N];\r\n\t\t\tb = new int[N];\r\n\t\t\tc = new int[N + 1];\r\n\t\t\t\r\n\t\t\ta[0] = 1;\r\n\t\t\tb[0] = 1;\r\n\t\t\tc[0] = 0;\r\n\t\t\t\r\n\t\t\t// 인덱스 0부터 시작\r\n\t\t\tsolve(0);\r\n\t\t\t\r\n\t\t\tresult = Math.min(result, c[N]);\r\n\t\t\t\r\n\t\t\t// 두 행 이상일 경우\r\n\t\t\tif (N > 1)\r\n\t\t\t{\r\n\t\t\t\t// 두 행 모두 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W && e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 1;\r\n\t\t\t\t\tb[1] = 1;\r\n\t\t\t\t\tc[1] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, c[N - 1] + 2);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 윗 행만 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 2;\r\n\t\t\t\t\tb[1] = e[1][0] + e[1][1] > W ? 2 : 1;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, b[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아래 행만 걸칠 경우\r\n\t\t\t\tif (e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = e[0][0] + e[0][1] > W ? 2 : 1;\r\n\t\t\t\t\tb[1] = 2;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, a[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 함수\r\n\t *\r\n\t * @param num: [int] 시작 인덱스\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\tfor (int i = num; i < N; i++)\r\n\t\t{\r\n\t\t\tc[i + 1] = Math.min(a[i] + 1, b[i] + 1);\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\tif (e[0][i] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i] + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두개의 구역 2개를 점령할 수 있을 경우\r\n\t\t\tif (i > 0 && e[0][i - 1] + e[0][i] <= W && e[1][i - 1] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i - 1] + 2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// a, b팀의 인덱스 보정 (c팀은 인덱스가 하나 더 많음)\r\n\t\t\tif (i < N - 1)\r\n\t\t\t{\r\n\t\t\t\ta[i + 1] = c[i + 1] + 1;\r\n\t\t\t\tb[i + 1] = c[i + 1] + 1;\r\n\t\t\t\t\r\n\t\t\t\t// a팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[0][i] + e[0][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[i + 1] = Math.min(a[i + 1], b[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// b팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[1][i] + e[1][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\tb[i + 1] = Math.min(b[i + 1], a[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n6월 1일부터 풀기 시작해서 이 문제를 완전히 이해하는데 근 일주일 가까이 걸렸다. 나름의 풀이를 작성해야하는데, 남의 풀이가 아닌 내 풀이를 작성하기 위해선 해당 문제를 온전히 이해할 필요가 있었다. 내가 다른 사람들의 풀이를 보면서 이해하지 못해서 내 스스로 생각하고 이해한 걸 나름대로 녹여냈다. 다른 사람이 내 글을 보고 이 어려운 문제를 쉽게 이해할 수 있었으면 좋겠다.\r\n\r\n이해하고 봐도 다소 난해한데, 이걸 원리부터 코드까지 이끌어내어 풀어내는 사람은 정말 대단한 거 같다. 아님 내가 실력이 없는건가.\r\n\r\n## 참고\r\n\r\n* [The Casterian](https://casterian.net/archives/1356)\r\n* [굳건하게](https://travelbeeee.tistory.com/354)\r\n* [테스트 케이스](https://www.acmicpc.net/board/view/11381)","url":["2021-06-06-a1006","2021","06","06","a1006"]},{"header":{"title":"Compiler(컴파일러) & Interpreter(인터프리터)","excerpt":"천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다. 하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 컴퓨터가 알아먹을 수 있어야 실행된다는 얘기다. 글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 컴퓨터는 개발 이래로 초지일관 기계어만을 고집한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.","coverImage":"https://user-images.githubusercontent.com/50317129/120613280-0a79f980-c491-11eb-81a9-15e63062db75.png","date":"2021-06-03T17:25:23","type":"posts","category":"CS","tag":["Compiler(컴파일러)","Interpreter(인터프리터)"],"comment":true,"publish":true},"name":"2021-06-03-compiler-interpreter.md","content":"\r\n# 컴파일러와 인터프리터\r\n\r\n천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다.\r\n\r\n하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 <span class=\"blue-500\">컴퓨터가 알아먹을 수 있어야 실행된다</span>는 얘기다.\r\n\r\n글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 <span class=\"blue-500\">컴퓨터는 개발 이래로 초지일관 기계어만을 고집</span>한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.\r\n\r\n우리가 일상생활에서 외국어를 접할 때, 번역기라는 걸 사용해서 한글로 번역하면 우리가 비교적 쉽게 이해할 수 있다. 그렇다면 이 프로그래밍 언어들을 컴퓨터가 이해할 수 있는 기계어로 번역해준다면, 컴퓨터는 우리가 짠 코드를 이해하고 코드를 실행시킬 수 있을 것이다. 이를 위해 <span class=\"blue-500\">모든 언어는 해당 언어를 기계어로 번역할 수 있는 도구를 사용하여 기계어로 번역</span>한다. 이 번역기들은 방식에 따라 크게 두 가지로 구분할 수 있는데, <span class=\"green-500\">컴파일러</span>와 <span class=\"pink-500\">인터프리터</span>다.\r\n\r\n# Compiler(컴파일러)\r\n\r\n<span class=\"green-500\">컴파일러</span>는 소스코드 전체를 기계어로 번역해주는 도구다. 기계어로 번역된 결과물이 생성되고, 프로그램 실행 시 번역한 결과물을 실행한다. 굳이 기계어가 아니더라도, 원래의 원시코드(소스코드) 전체를 목적코드(기계어 등)로 번역한다면 <span class=\"green-500\">컴파일러</span>라 할 수 있다. 핵심은 전체 원시코드를 다른 코드로 변환함에 있다. <span class=\"green-500\">컴파일러</span> 아래와 같은 특징을 가지고 있다.\r\n\r\n1. <b class=\"primary\">소스코드 전체 번역</b>  \r\n   이러한 특징으로 별도의 컴파일 시간이 요구되며, 코드 한 글짜만 변경하더라도 재컴파일을 수행해야 한다. 코드의 규모가 클 수록 컴파일에 요구되는 시간 또한 늘어난다.\r\n\r\n2. <b class=\"primary\">빠른 속도</b>  \r\n   이미 컴파일을 수행하여 기계어로 번역했기 때문에, 프로그램 실행 시점엔 컴퓨터가 별다른 작업 없이 해당 프로그램을 이해할 수 있다. 즉, 실행 속도가 <span class=\"pink-500\">인터프리터</span>에 비해 대체적으로 빠르다.\r\n\r\n3. <b class=\"primary\">플랫폼 의존성</b>  \r\n   <span class=\"green-500\">컴파일러</span>는 컴파일한 컴퓨터의 CPU, OS에 해당하는 기계어로 번역한다. 즉, CPU나 OS의 구조가 다른 컴퓨터에선 정상적인 동작을 보증할 수 없다. 이와 더불어, 특정 PC에 맞게 컴파일하려면 특정 PC의 CPU와 OS를 가진 컴퓨터가 필요하다.\r\n\r\n4. <b class=\"primary\">강한 보안</b>  \r\n   소스코드의 결과물이 기계어로 번역된 실행 파일이므로 보안이 상대적으로 우수하다. 단, 이는 어디까지나 상대적인 것으로, 실행 파일의 암호화나 소스코드의 난독화가 되어있지 않을 경우, 디컴파일, 해킹같은 분석기법을 통해 코드를 역설계할 수도 있다. 물론 이 자체로도 큰 분야이므로 많은 기술력을 요한다.\r\n\r\n<span class=\"green-500\">컴파일러</span>를 차용하는 언어는 아래와 같다.\r\n\r\n* C계열 (C, C++, C#)\r\n* FORTRAN\r\n* Go\r\n* JAVA (기본적으론 컴파일러 방식)\r\n* Pascal\r\n* Rust\r\n* Visual Basic\r\n\r\n대체적으로 초창기에 출시된, 역사가 깊은 언어가 대부분이다.\r\n\r\n지금의 컴퓨터와 달리, 초창기 컴퓨터들은 사양이 그리 좋지 못 했다. VGA대란을 무시하고 보편적인 하이엔드급 컴퓨터 본체가 대략 200만원 선임을 감안할 때, 동일한 가격으로 90년대 컴퓨터는 CPU가 Intel Pentium 100, RAM은 8MB, HDD는 1GB였다. RAM의 경우 단위를 GB로 바꿔도 다소 부족함을 감안한다면 실로 엄청난 차이.\r\n\r\n이러한 점으로 미루어보아 컴퓨터 자원을 낭비할 수 없었음이 당연할 것이다. 때문에 선처리 과정이 얼마나 걸리든 관계없이, 컴퓨터에서 가능한한 빠르고 가볍게 실행하는 것이 최우선 과제였을 것이다. 이러한 상황에서 초창기 언어들이 <span class=\"green-500\">컴파일러</span>를 차용한 것은 당연한 것이다.\r\n\r\n# Interpreter(인터프리터)\r\n\r\n<span class=\"pink-500\">인터프리터</span>는 실행 시 코드를 한 줄씩 읽어서 기계어로 번역하는 도구다. 한 줄씩 읽어서 실행하므로 별도의 결과물이 생성되지 않아 소스코드 자체가 실행 파일이 된다. 마찬가지로 굳이 기계어가 아니더라도 원래의 코드를 한 줄씩 읽어서 중간코드(기계어 등)으로 변환하여 실행한다면 <span class=\"pink-500\">인터프리터</span>라 할 수 있다. 핵심은 <span class=\"blue-500\">원시코드를 한 줄씩 읽어서 변환함</span>에 있다. <span class=\"pink-500\">인터프리터</span>는 아래와 같은 특징을 가지고 있다.\r\n\r\n1. <b class=\"primary\">소스코드 한줄 씩 변경</b>  \r\n   실행할 때마다 코드를 읽어서 번역하므로 컴파일이라는 작업 자체가 존재하지 않는다. 때문에 생산성이 매우 높다.\r\n\r\n2. <b class=\"primary\">느린 속도</b>  \r\n   컴파일 작업이 없는 대신, 프로그램 실행 시 코드 한 줄마다 작은 컴파일 작업이 이루어진다고 생각하면 된다. 때문에 <span class=\"green-500\">컴파일러</span>에 비해 상대적으로 실행 속도가 느리다.\r\n\r\n3. <b class=\"primary\">플랫폼 독립성</b>  \r\n   소스코드를 통해 프로그램을 실행하므로 컴퓨터의 CPU, OS의 영향을 받지 않는다. 해당 소스코드를 실행할 환경만 구축한다면, 어디서나 동일한 동작을 보증한다.\r\n\r\n4. <b class=\"primary\">약한 보안</b>  \r\n   소스코드 자체가 실행 파일이므로 코드가 유출되기 매우 쉽다. 중요한 동작이나 정보를 다룰 경우 난독화나 암호화를 반드시 해야한다. 이러한 보안작업은 오히려 프로그램의 실행 속도를 더욱 낮추기도 한다.(복호화 등의 작업 추가됨)\r\n\r\n<span class=\"pink-500\">인터프리터</span>를 차용하는 언어는 아래와 같다.\r\n\r\n* HTML\r\n* JavaScript\r\n* PHP\r\n* Python\r\n* Ruby\r\n\r\n<span class=\"green-500\">컴파일러</span>와 달리 비교적 젊은 언어들이 차지하고 있다. 현대에 들어서면서 컴퓨터의 성능이 급격히 좋아짐에 따라 연산 속도도 증가했다. 이와 더불어 시간이 지나면서 인터프리터의 속도 이슈를 해결할 여러 기술들이 개발되기도 했다. 이와 같은 노력들이 <span class=\"pink-500\">인터프리터</span>의 단점을 상쇄시켜줌에 따라 <span class=\"pink-500\">인터프리터</span>의 장점인 높은 생산성이 부각됐다. 이러한 이유로 <span class=\"pink-500\">인터프리터</span>의 언어는 비교적 최신 언어에 많이 적용되어있다.","url":["2021-06-03-compiler-interpreter","2021","06","03","compiler-interpreter"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1005번 ACM Craft","excerpt":"서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-01T01:27:56","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","위상 정렬","GOLD","GOLD III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-01-a1005.md","content":"\r\n# ACM Craft\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/13.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1005번 문제](https://www.acmicpc.net/problem/1005)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다.\r\n\r\n이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219763-b1cf1480-c276-11eb-8131-a3471db1cfc4.png)\r\n\r\n위의 예시를 보자.\r\n\r\n이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할 수 있다. (동시에 진행이 가능하다.) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번 건물의 건설을 시작할 수 있다.\r\n\r\n따라서 4번 건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물와 3번 건물을 동시에 건설하기 시작하면 2번은 1초 뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을 수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.\r\n\r\n프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM Craft 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정 건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정 건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.\r\n\r\n## 입력\r\n\r\n첫째 줄에는 테스트케이스의 갯수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다, 첫째 줄에 건물의 갯수 $N$과 건물 간의 건설순서 규칙의 총 갯수 $K$가 주어진다.(전물의 번호는 1번 부터 $N$번 까지 존재한다.)\r\n\r\n둘째 줄에는 각 건물 당 건설에 걸리는 시간 $D$가 공백을 사이로 주어진다. 셋째 줄부터 $K + 2$줄 까지 건설순서 $X$ $Y$가 주어진다.(이는 건물 X를 지은 다음에 건물 $Y$를 짓는 것이 가능하다는 의미이다.)\r\n\r\n마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 $W$가 주어진다.\r\n\r\n## 출력\r\n\r\n건물 $W$를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.  \r\n건설순서는 모든 건물이 건설 가능하도록 주어진다.\r\n\r\n## 제한\r\n\r\n* $2 ≤ N ≤ 1,000$\r\n* $1 ≤ K ≤ 100,000$\r\n* $1 ≤ X, Y, W ≤ N$\r\n* $0 ≤ D ≤ 100,000)$ $D$는 정수\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4 4\r\n10 1 100 10\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4\r\n8 8\r\n10 20 1 5 8 7 1 43\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n5 7\r\n6 7\r\n7 8\r\n7\r\n```\r\n+ 출력\r\n\r\n``` tc\r\n120\r\n39\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n3 2\r\n1 2 3\r\n3 2\r\n2 1\r\n1\r\n4 3\r\n5 5 5 5\r\n1 2\r\n1 3\r\n2 3\r\n4\r\n5 10\r\n100000 99999 99997 99994 99990\r\n4 5\r\n3 5\r\n3 4\r\n2 5\r\n2 4\r\n2 3\r\n1 5\r\n1 4\r\n1 3\r\n1 2\r\n4\r\n4 3\r\n1 1 1 1\r\n1 2\r\n3 2\r\n1 4\r\n4\r\n7 8\r\n0 0 0 0 0 0 0\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4 5\r\n4 6\r\n5 7\r\n6 7\r\n7\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n6\r\n5\r\n399990\r\n2\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 이해가 되는데, 이를 코딩으로 풀어내기가 어려웠던 알고리즘. <span class=\"primary\">위상정렬</span> 알고리즘에 대한 이해가 있어야한다.  \r\n문제의 경우, 스타크래프트의 건물 테크트리랑 비슷한 개념으로 접근하면 된다. 군수공장을 짓기 위해선 병영을 지어야하는 것처럼, 요구 트리가 있는 건물의 경우 해당 건물을 반드시 완료해야 하며, 하나의 건물이 여러 요구 트리를 가질 경우도 존재한다. 물론 이 경우 요구하는 건물들을 **모두** 건설한 뒤에 건설 가능하다. 요구하는 건물들 중 하나만 건설하면 충족되는게 아니다.\r\n\r\n<span class=\"primary\">위상정렬</span>은 <span class=\"green-A400\">순서가 정해진 작업을 수행할 때, 이 순서를 결정하는 알고리즘</span>이다. <span class=\"primary\">위상정렬</span>은 반드시 DAG(Directed Acyclic Graph, 유향 비순환 그래프) 형태여야 한다. 즉, 순서를 도식화했을 때 반드시 <span class=\"red-A400\">시작/도착점이 존재</span>해야 한다. 시작/도착점이 구분되지 않는 순환 형태일 경우 위상정렬을 적용할 수 없다.\r\n\r\n위상정렬은 순서를 정하는 알고리즘이고, 순서도의 형태에 따라 여러가지의 답이 나올 수 있다. 이 문제는 최적의 답을 도출하기 위해 각 **건물을 건설하는데 필요한 요구 건물**과 **건설 시간**을 적용했다.\r\n\r\n다음 건물을 건설하기 위해선 요구 건물을 모두 건설해야하므로 요구 건물의 건설시간이 가장 많은 건물이 다음 순서가 된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219453-3b321700-c276-11eb-9029-ec105c694854.png)\r\n\r\n예시 1번의 두 번째 케이스를 예시로 하여 위상정렬을 도식화하면 위 사진과 같다.\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   0   |   1   |   1   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n위 표는 도식를 수치화하여 정리한 것이다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">1. 순서의 시작점(진입선이 없는 점)을 찾는다. 시작점이 여러개일 경우 시작점 중 무작위로 하나를 선택해도 무방하다. (위 예시는 시작점이 하나)</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219469-4127f800-c276-11eb-91c8-db36e543c217.png)\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">2. 시작점 1을 큐에 넣고, 시작점에 연결된 진출선을 전부 제거한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219471-438a5200-c276-11eb-9cd3-ca5f31dfb19b.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   0   |   0   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |\r\n| :---: | :---: |\r\n\r\n이 과정에서 2와 3이 새로운 시작점이 된 것을 확인할 수 있다.\r\n\r\n1을 건설하는데 걸리는 시간은 1초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">3. 2에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219484-45ecac00-c276-11eb-8114-a6c4c8b17036.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   0   |   0   |   0   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |\r\n| :---: | :---: | :---: |\r\n\r\n4와 5의 진입선이 0이 된다. 즉, 4와 5를 건설할 수 있게 된다.\r\n\r\n2를 건설하는데는 $10(1) + 20(2)$로 총 30초가 소요된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">4. 3에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219493-48e79c80-c276-11eb-8f48-cf132cab8f5c.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   0   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n\r\n6의 진입선이 0이 된다. 6을 건설할 수 있게 된다.\r\n\r\n3의 건설시간은 $10(1) + 1(3)$으로 총 11초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">5. 4에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219504-4be28d00-c276-11eb-9b40-07c5ea51cbd9.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |\r\n| :---: | :---: | :---: | :---: | :---: |\r\n\r\n4는 진출선이 없으므로 큐에만 추가된다.\r\n\r\n4의 건설시간은 $10(1) + 20(2) + 5(4)$로 총 35초\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">6. 5에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219509-4edd7d80-c276-11eb-9c5f-fc17d373bf50.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   0   |   1   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7이 5와 6에 연결되어 있으므로, 7의 진입선은 1이 된다. 아직 7을 건설할 수 없다.\r\n\r\n5의 건설시간은 $10(1) + 20(2) + 8(5)$로 총 38초\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">7. 6에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219520-53099b00-c276-11eb-9c99-060dcd2039d8.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   0   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7의 진입선이 0이 된다. 7을 건설할 수 있게 된다.\r\n\r\n6의 건설시간은 $10(1) + 1(3) + 7(6)$으로 총 18초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">8. 7에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219527-56048b80-c276-11eb-866b-9b411445b22b.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   0   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n8의 진입선이 0이 된다.\r\n\r\n1 ~ 6까지는 요구 건물이 하나였지만, 7은 두개이다. 앞서 언급했듯이, 5와 6 중 건설시간이 더 긴 것을 기준으로 계산해야한다.\r\n\r\n즉, 7의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7)$로 총 39초\r\n\r\n5번을 기준으로 계산하므로, <span class=\"red-A400\">6번과 중간인 3번은 계산에서 제외</span>된다. 만약, 3의 건설시간을 1초에서 4초로 증가시켜도 결과에 영향을 미치지 않는다. 3의 건설시간을 무시하기 때문이다. 단, 3의 건설시간이 너무 커지게되면 5보다 6의 건설시간이 같이 커지게 되어 결과에 영향을 미치게 된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">9. 8에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219535-58ff7c00-c276-11eb-907c-2a90cc84c596.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n문제는 7에 대한 건설시간을 요구하고 있으므로 8은 무시해도 무방하다. \r\n8의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7) + 43(8)$로 총 82초\r\n\r\n## 전체 소스\r\n\r\n`time`, `matrix`, `link`의 배열 크기가 $N + 1$이다. 별다른 이유는 아니고, 건물은 1번부터 시작하는데 배열은 0번부터 시작한다. 이러한 차이에서 오는 혼란을 방지하기 위해 건물이 총 4개면 배열의 크기를 5로(0, 1, 2, 3, 4, 5)로 지정하여 0을 제외하고 1부터 사용한다.\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1005 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/01/a1005\">1005 풀이</a>\r\n * @since 2021.05.31 Mon 19:11:58\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\t// 케이스 갯수\r\n\t\tint T = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 건물 갯수\r\n\t\t\tint N = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 규칙(건설시간) 갯수\r\n\t\t\tint K = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 건물별 건설시간 배열\r\n\t\t\tint[] time = new int[N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결여부 배열\r\n\t\t\tboolean[][] matrix = new boolean[N + 1][N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결 갯수 배열\r\n\t\t\tint[] link = new int[N + 1];\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j < N + 1; j++)\r\n\t\t\t{\r\n\t\t\t\ttime[j] = scanner.nextInt();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물\r\n\t\t\t\tint X = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\t// 상위 건물\r\n\t\t\t\tint Y = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\tmatrix[X][Y] = true;\r\n\t\t\t\tlink[Y]++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표 건물\r\n\t\t\tint W = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tbuilder.append(calcTopologicalSort(time, matrix, link)[W]).append(\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString());\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위상정렬 결과 반환 함수\r\n\t *\r\n\t * @param time: [int[]] 건물별 건설시간\r\n\t * @param matrix: [boolean[][]] 건물별 연결여부\r\n\t * @param link: [int[]] 건물별 연결 갯수\r\n\t *\r\n\t * @return [int[]] 건물별 종 건설시간 배열\r\n\t */\r\n\tprivate static int[] calcTopologicalSort(int[] time, boolean[][] matrix, int[] link)\r\n\t{\r\n\t\tQueue<Integer> queue = new LinkedList<>();\r\n\t\t\r\n\t\tint[] result = new int[link.length];\r\n\t\t\r\n\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t{\r\n\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\tif (link[i] == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = time[i];\r\n\t\t\t\tqueue.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\t// 하위 건물\r\n\t\t\tint prev = queue.poll();\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물 건설을 요구 하는 건물일 경우\r\n\t\t\t\tif (matrix[prev][i])\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = Math.max(result[i], result[prev] + time[i]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 해당 건물의 요구 건물 갯수 1 감소\r\n\t\t\t\t\t--link[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\t\t\tif (link[i] == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tqueue.add(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 그래프 이론\r\n* 위상 정렬","url":["2021-06-01-a1005","2021","06","01","a1005"]},{"header":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true},"name":"2021-05-30-unsupported-version-error.md","content":"\r\n# Unsupported major.minor version\r\n\r\n간혹 JAVA 프로그램을 실행하다보면 <span class=\"error\">Unsupported major.minor version 52</span>(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다.  \r\n<span class=\"error\">Unsupported major.minor version</span> 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.\r\n\r\n# 원인\r\n\r\nJAVA는 컴파일 언어로, 개발자가 작성한 코드는 `.java` 파일이다. 이를 컴파일하면 JVM(Java Virtual Machine, 자바 가상머신)이 읽을 수 있는 `.class` 파일로 번역한다. 코딩은 사람이 이해할 수 있는 언어로 작성하고, 실제 동작은 컴파일을 통해 컴퓨터가 이해할 수 있는 언어를 사용하는 셈이다.  \r\nJAVA는 작성일 기준으로 16까지 릴리즈됐다. JAVA의 역사가 짧지 않고, 이 시간동안 크고작은 버전 업데이트가 지속적으로 이루어졌다.  \r\n문제는 이 과정에서 생긴 호환성 문제다. 1.5 버전으로 컴파일한 `.class` 파일을 1.8 버전의 환경에서 구동한다거나, 그 반대의 경우가 그 예시다. 다행스럽게도, JAVA는 하위 버전에 대한 호환성을 보장한다. 1.8 버전의 환경에서는 1.8 이하로 컴파일된 `.class` 파일의 실행을 보장한다. 하지만 반대로 상위 버전에 대한 호환성은 제공하지 않는다. 그도 그럴 것이, 호환성을 지키기 위해선, 각 버전 간의 구성을 알맞게 변환해야 하는데, 아직 개발되지 않은 미래 버전의 구성을 알 순 없는 노릇이니...\r\n\r\n| 프로그램 JAVA 버전 | PC JAVA 버전 | Unsupported 오류 발생여부 |              해결책              |\r\n| :----------------: | :----------: | :-----------------------: | :------------------------------: |\r\n|         14         |     1.8      |             O             | JAVA 14 버전 이상으로 업그레이드 |\r\n|        1.6         |     1.7      |             X             |              칼퇴근              |\r\n\r\n즉, <span class=\"green-A400\">Unsupported major.minor version 오류는 내가 실행하려는 JAVA 코드가 내 PC의 JAVA 환경보다 높은 버전에서 컴파일된 경우 발생</span>한다.\r\n\r\n# 해결\r\n\r\n결과적으로, JAVA 버전을 동등 혹은 그 이상의 상위버전으로 업그레이드하면 된다. 크게 두 가지 방법이 있다.\r\n\r\n## 프로그램 코드의 버전 다운그레이드\r\n\r\n만약 본인이 온전한 프로그램 코드를 갖고 있을 경우, 시도해볼 수 있는 방법이다.  \r\n<span class=\"green-A400\">JAVA 버전을 다운그레이드하고 컴파일을 진행</span>하면, 프로그램의 JAVA 버전이 낮아져 기존의 버전보다 훨씬 낮은 버전의 환경에서 구동이 가능하다.\r\n\r\n단, 조건이 있다. JAVA 버전이 업그레이드됨에 따라 여러 신규 패턴, 문법 등이 추가됐다. 만약 <span class=\"red-A400\">1.8 버전부터 새로 생긴 기능을 적극적으로 활용했다면, 1.7 이하의 버전에선 컴파일 오류가 발생</span>한다.  \r\n그도 그럴것이, 1.8 부터 생긴 기능은 1.7에서는 구현되지 않은 기능이기 때문.\r\n\r\n이 경우 프로그램의 코드를 좀더 범용적인 방식으로 리팩토링해야한다.\r\n\r\n## PC의 버전 업그레이드\r\n\r\n만약 본인이 `.class` 파일만 갖고있다거나, 상기한 문제로 다운그레이드가 어려울 경우 혹은 간단한 방법을 찾을 경우 시도해볼 수 있는 방법이다.\r\n<span class=\"green-A400\">PC의 JAVA 버전을 업그레이드하고 프로그램을 실행</span>하면 된다.\r\n\r\nJAVA는 하위 호환성을 지키기 때문에, 별다른 조건이 존재하지 않는다.\r\n\r\n# 아니 버전 맞췄다고 아ㅋㅋ\r\n\r\n톰캣을 사용하다보면, 이 오류가 뜨는 경우가 있다. 그런데 간혹 PC에 설치된 JAVA 버전에 맞게 컴파일을 해줬음에도 오류가 사라지지 않는 현상이 발생하기도 한다.  \r\n이 경우 동반되는 증상이, Servlet Context에 접근할 경우, 첫 접속시 500 에러(Unsupported major.minor version 오류로 인해 발생)가 발생하고, 이후부터는 404 에러만 발생한다. 이러한 현상을 겪어보지 않았거나, 경험이 적은 개발자가 이러한 문제에 부딪히면 십중팔구 고생한다. 원인인 Unsupported major.minor version 오류가 보이지 않아 Servlet 동작의 404 오류와 관련된 정보를 검색하거나 질문하기 때문. 당연히 이러한 사정을 모르는 다른 사람들은 404 오류에 관한 답변을 줄 수 밖에 없다. 이런 경우 정말 난감하기 그지없다. 절대 경험담이라서가 아니다.\r\n\r\n혹시 위 처럼 정상적인 Servlet(서블릿)임에도 불구하고 404 오류가 뜰 경우 아래의 환경변수에서 JRE_HOME이 설정돼있는지 확인해보자.  \r\n간혹 개발 프로그램 중 임의로 JRE_HOME을 설정해버리는 프로그램이 존재한다. 문제는 여기서 발생하는데, JAVA_HOME과 JRE_HOME 환경변수가 둘 다 설정되어있을 경우, <span class=\"red-A400\">톰캣은 JRE_HOME을 우선</span>한다. 즉 JRE의 버전이 적용된다.\r\n\r\n예를 들어, JAVA_HOME이 1.8 버전, JRE_HOME이 1.6 버전이라 가정하자. 컴파일은 반드시 JDK가 필요하므로 JAVA_HOME의 버전인 1.8로 컴파일이 수행된다. 그러나 톰캣 실행 시, JRE_HOME을 우선하는 특징으로 인해 1.6 버전으로 실행된다. 결과적으로 **1.8 버전으로 컴파일된 코드를 1.6으로 실행하는 셈**이니, 버전이 맞지 않아 오류가 발생한다.","url":["2021-05-30-unsupported-version-error","2021","05","30","unsupported-version-error"]},{"header":{"title":"URI? URL? URN? 리소스 식별자 구분하기","excerpt":"우리가 인터넷 상에서 특정한 데이터에 접근할 때 URL이라는 것을 활용하여 접근한다. 원하는 자료의 URL을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 URL을 호출하여 응답을 얻는 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028437-a63ddc80-c02f-11eb-9d41-7c50d7002a42.png","date":"2021-05-29T03:30:17","type":"posts","category":"WEB","tag":["WEB(웹)","URI","URL","URN"],"comment":true,"publish":true},"name":"2021-05-29-uri-url-urn.md","content":"\r\n# URL! URI... URN??\r\n\r\n우리가 인터넷 상에서 **특정한 데이터**에 접근할 때 <span class=\"primary\">URL</span>이라는 것을 활용하여 접근한다.  \r\n원하는 자료의 <span class=\"primary\">URL</span>을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 <span class=\"primary\">URL</span>을 호출하여 응답을 얻는 것이다.\r\n\r\n개발자나, 굳이 개발자가 아니더라도 관련 정보를 찾다보면 심심치않게 <span class=\"primary\">URI</span>라는 용어를 접하게 된다.  \r\nI와 L의 오묘한 유사성 때문에 아예 <span class=\"primary\">URI</span>를 <span class=\"primary\">URL</span>로 오독하는가 하면, 오타라고 생각하는 사람도 더러 있을 것이다.  \r\n하지만 <span class=\"primary\">URL</span>과 <span class=\"primary\">URI</span>는 그 의미가 비슷하면서도 살짝 다르다.\r\n\r\n누구나 알고있는 <span class=\"primary\">URL</span>과 아리까리한 <span class=\"primary\">URI</span>, 생소한 <span class=\"primary\">URN</span>. 이들에 대해 알아보자\r\n\r\n# UR* 톱아보기\r\n\r\n<span class=\"primary\">URI</span>, <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>은 구조상 서로 연관이 있다.\r\n\r\n## URI(Uniform Resource Identifier, 통합 자원 식별자)\r\n\r\n<span class=\"primary\">URI</span>는 우리말로 **통합 자원 식별자**라고 한다. <span class=\"primary\">URI</span>는 앞서 말한 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>을 포함하는 상위 개념으로, <span class=\"orange-400\">인터넷 상에 존재하는 **자원을 구분**하는 식별자</span>라 할 수 있다. 웹 상에서 자원을 식별하는 모든 수단이 곧 <span class=\"primary\">URI</span>이라 할 수 있다.\r\n\r\n## URL(Uniform Resource Locater, 통합 자원 지시자)\r\n\r\n<span class=\"primary\">URL</span>은 굳이 우리말로 하자면 **통합 자원 지시자**라고 할 수 있겠지만, 흔히 인터넷 상에서 **주소**라 함은 99% 이 <span class=\"primary\">URL</span>을 의미한다. 1994년 **RFC-1738**에 정의되어있다.  \r\n<span class=\"primary\">URL</span>은 **Locater**라는 키워드에 걸맞게 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 **위치**를 나타내는 식별자</span>라 할 수 있다. 여기서 **위치**라는 키워드에 주목하자. <span class=\"primary\">URL</span>은 자원의 위치정보를 가지므로, 어떠한 이유로든 자원의 위치가 변경되면 <span class=\"primary\">URL</span>은 자원을 찾을 수 없으며, 변경된 위치를 추적할 수도 없다. 이 때 맞이하게 되는 HTTP 오류가 누구나 알고있는 404 Not Found다.  \r\n당장 내가 이 게시물의 이름을 한 글자만 변경해도, 지금까지의 <span class=\"primary\">URL</span>은 아무 쓸모가 없어지며, 사용자들 또한 해당 <span class=\"primary\">URL</span>로 이 게시물에 접근할 수 없다. 또한, 이 <span class=\"primary\">URL</span>을 통해 원래 있던 게시물의 <span class=\"primary\">URL</span>을 논리적으로 유추할 수도 없다.\r\n\r\n## URN(Uniform Resource Name, 통합 자원 이름)\r\n\r\n<span class=\"primary\">URN</span>은 **통합 자원 이름**이다. 눈치가 빠른 분들은 아시겠지만, <span class=\"primary\">URN</span>은 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 **이름**을 나타내는 식별자</span>다. 자원의 이름은 고유한 값을 가지므로, 인터넷 상의 수 많은 자원들 중 특정 자원을 식별할 수 있는 것이다.  \r\n<span class=\"primary\">URN</span>은 대부분 위에 언급한 두 개념에 비해 생소할 것이다. 그도 그럴 것이, <span class=\"primary\">URN</span>은 위 두 개념보다 훨씬 뒤에 나온 개념이기 때문이다. 1997년 **RFC-2141**에 정의되어있다. <span class=\"primary\">URL</span>보다 3년 뒤에 출범하여 그 역사가 상대적으로 짧다.  \r\n\r\n<span class=\"primary\">URL</span>의 치명적인 단점은 **위치**정보 외에 다른 정보를 저장하지 않는다. 이 상황에서 해당 자원을 찾아야 한다면? 안타깝게도 <span class=\"primary\">URL</span>만으로는 찾아낼 수 없다. 구글링해서 운 좋게 찾아낸다면 모를까.  \r\n반면 <span class=\"primary\">URN</span>을 사용한다면 어떨까? 위치가 아무리 변경된다 하더라도, 자원의 고유한 이름을 통해 찾기 때문에 자원이 웹 상에서 완전히 삭제된 게 아니라면 손쉽게 찾아낼 수 있을 것이다.\r\n\r\n## 정리\r\n\r\n난 어려운 개념을 이해할 때 현실세계와 연관지어 이해하는 걸 좋아한다. 위 세 개념을 현실에서 특정 사람의 신원을 확인하는 과정과 접목해서 정리하면 아래와 같이 정리할 수 있을 것 같다.\r\n\r\n| 구분  |              현실               |         값          |\r\n| :---: | :-----------------------------: | :-----------------: |\r\n| 자원  |             나 자신             |         나          |\r\n|  URI  | 나를 식별할 수 있는 모든 식별자 |          -          |\r\n|  URL  |         내가 사는 주소          | 서울특별시 A구 가동 |\r\n|  URN  |         내 주민등록번호         |   000000-0000000    |\r\n\r\n<span class=\"small red-A400\">※ URN은 모든 자원의 고유값이므로, 사람과 연관지었을 때, 중복 가능성이 있는 이름 보다는 고유값인 주민등록번호가 더 적합하다.</span>\r\n\r\n예를 들어, 내 정보가 위와 같다고 가정해보자. 내가 사는 주소 및 내 주민등록번호 모두 내 신원을 확인할 수 있는 방식(<span class=\"primary\">URI</span>)이므로, 나를 찾기에 적합하다.  \r\n만약 내 주소(<span class=\"primary\">URL</span>)를 통해 확인할 경우, 내가 이사(자원의 이동)를 가게 되면 해당 주소엔 아무것도 없으며, 날 찾을 수도 없다(404 HTTP 에러). 또한, 내가 예전에 살던 주소만으로 내가 이사간 주소를 유추해낼 수도 없을 것이다.\r\n\r\n반면, 내 주민등록번호(<span class=\"primary\">URN</span>)을 통해 확인할 경우, 내 주민등록번호와 매칭되는 사람을 찾는 것으로 나를 식별할 수 있다. 이 과정에서 내가 어디에 있는지는 전혀 중요치 않은 것이다. 주민등록번호 자체가 말소(자원 삭제)되지 않는 한, 내가 어디에서 무엇을 하고있든 내 신원을 확인할 수 있다.\r\n\r\n# 구조\r\n\r\n그렇다면 이들은 어떻게 생겼는지 알아보자. <span class=\"primary\">URI</span>는 자원의 식별자를 포괄하여 지칭하는 개념 그 자체이므로, 구조라고 할 건 없다. 하위 개념인 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>에 대해 알아보자.\r\n\r\n## URL 구조\r\n\r\n<span class=\"primary\">URL</span>은 아래와 같은 구조로 이루어진다. 매우 익숙할 것이다.\r\n\r\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">https</span>://<span class=\"green-400\">rwb0104</span>.<span class=\"yellow-400\">github</span>.<span class=\"pink-400\">com</span>:<span class=\"amber-400\">443</span>/<span class=\"cyan-400\">posts</span><span class=\"teal-400\">?category=WEB&page=1</span></p>\r\n\r\n구조별로 색상을 입혔으며, 순서대로 기술한다.\r\n\r\n### Protocol(프로토콜)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"lightBlue-400\">https</span> 부분.\r\n\r\n통신규약을 의미한다. 작성일 기준으로, 이 규약엔 계층별로 많은 <span class=\"lightBlue-400\">프로토콜</span>이 존재하는데, 웹 통신을 수행할 땐 크게 두 가지로 나뉜다.\r\n\r\n| 구분  |              내용              |\r\n| :---: | :----------------------------: |\r\n| HTTP  | W3 상에서의 HTML 문서 통신규약 |\r\n| HTTPS |    암호화된 HTTP 통신 규약     |\r\n\r\n현재는 포털, 쇼핑몰같은 대형 비즈니스 사이트나 블로그, 카페 등 중소규모의 개인 사이트까지 <span class=\"red-A400\">HTTPS의 사용이 반 강제적으로 권장</span>되어 있다. 특히 전자상거래가 접목된 비즈니스 사이트의 경우 필수로 적용해야 한다. 더군다나 <span class=\"red-A400\">HTTPS가 적용되지 않는 사이트(localhost 제외)에 접근할 경우 브라우저 측에서 보안 관련 경고 메시지</span>를 띄우니, 규모에 관계없이 웹 사이트를 운영할 경우 HTTPS는 필수로 적용하는 편이다.\r\n\r\n### SLD(Second Level Domain, 서브도메인, 호스트)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"green-400\">rwb0104</span> 부분.\r\n\r\n도메인 앞에 붙으며, <span class=\"green-400\">서브도메인</span>을 통해 하나의 <span class=\"yellow-400\">도메인</span>으로 다중 서비스를 제공할 수 있다. 하나의 <span class=\"yellow-400\">도메인</span>에 여러 <span class=\"green-400\">서브도메인</span>을 생성할 수 있으며, 우리가 흔히 아는 `www` 외에도 `dev`, `admin`, `m` 용도에 따라 다양한 문자열을 지정할 수 있다.\r\n\r\n|                  URL                   |                                          내용                                          |\r\n| :------------------------------------: | :------------------------------------------------------------------------------------: |\r\n|     [naver.com](https://naver.com)     | 기본 네이버 홈페이지. 각 플랫폼(데스크탑, 모바일 등)에 가장 적합한 사이트로 리다이렉트 |\r\n| [www.naver.com](https://www.naver.com) |                               데스크탑용 네이버 홈페이지                               |\r\n|   [m.naver.com](https://m.naver.com)   |                                모바일용 네이버 홈페이지                                |\r\n| [map.naver.com](https://map.naver.com) |                                      네이버 지도                                       |\r\n\r\n위는 네이버 서비스의 <span class=\"green-400\">서브도메인</span>으로, `naver.com` <span class=\"yellow-400\">도메인</span>을 중심으로 각기 다른 서비스를 제공하는 것을 확인할 수 있다.\r\n\r\n### Domain(도메인)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"yellow-400\">github</span> 부분.\r\n\r\nURL의 중심이 되는 부분으로, 제공하는 웹 서비스의 아이덴티티 역할을 겸한다. 때문에 <span class=\"yellow-400\">도메인</span>에는 대부분 해당 웹 서비스의 이름이 들어간다.\r\n\r\n|  서비스   |                  URL                   |\r\n| :-------: | :------------------------------------: |\r\n|  네이버   |     [naver.com](https://naver.com)     |\r\n|   다음    |  [www.daum.com](https://www.daum.com)  |\r\n|  GitHub   |    [github.com](https://github.com)    |\r\n| Instagram | [instagram.com](https://instagram.com) |\r\n\r\n대부분의 서비스가 <span class=\"yellow-400\">도메인</span>으로 서비스의 이름을 사용하고 있다.\r\n\r\n### TLD(Top Level Domain, 최상위 도메인)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"pink-400\">com</span> 부분.\r\n\r\n<span class=\"pink-400\">최상위 도메인</span>이란, 앞서 언급한 <span class=\"green-400\">서브도메인</span>, <span class=\"yellow-400\">도메인</span>을 관리하는 업체 혹은 기관이라고 볼 수 있다.  \r\n앞서 언급한 개념의 경우, 중복되지 않는 선에서 사용자가 임의로 지정할 수 있다. 하지만 <span class=\"pink-400\">최상위 도메인</span>의 경우 현재 운영 중인 업체나 기관 중 하나를 **선택**해서 등록해야 한다. <span class=\"pink-400\">최상위 도메인</span>을 선택할 경우, 당신의 도메인은 해당 <span class=\"pink-400\">최상위 도메인</span>을 운영하는 곳에서 관리하게 된다.  \r\n\r\n<span class=\"pink-400\">최상위 도메인</span>은 운영 주체에 따라 두 가지로 나뉜다.\r\n\r\n#### ccTLD(country code TLD, 국가 코드 최상위 도메인)\r\n\r\n국가를 나타내는 <span class=\"pink-400\">최상위 도메인</span>이다.\r\n\r\n| ccTLD |     내용      |\r\n| :---: | :-----------: |\r\n|  .kr  |  한국(KISA)   |\r\n|  .us  |   미국(LLC)   |\r\n|  .jp  |     일본      |\r\n|  .io  | 영국령 인도양 |\r\n\r\n<span class=\"pink-400\">ccTLD</span>는 위 표와 같이 국가 코드 형태이며, 각 국가기관이 직접 관리한다. 즉, `.kr`을 가진 모든 도메인은 **한국의 KISA(한국 인터넷 진흥원)에서 관리**한다.\r\n\r\n#### gTLD(generic TLD, 일반 최상위 도메인)\r\n\r\n사이트 혹은 사이트를 소유한 조직, 기관의 특성에 따라 사용하는 <span class=\"pink-400\">최상위 도메인</span>이다.\r\n\r\n| gTLD  |       내용        |\r\n| :---: | :---------------: |\r\n| .com  | 영리 단체 및 기관 |\r\n| .net  | 네트워크 관리기관 |\r\n| .org  |    비영리 기관    |\r\n| .gov  |     정부 기관     |\r\n\r\n<span class=\"pink-400\">gTLD</span>는 위 표와 같이 다양한 종류가 있으며, 그 중 몇몇은 자주 접했을 것이다. 정부기관이 왜 여기있나 생각할 수도 있는데, <span class=\"pink-400\">ccTLD</span>는 **국가 코드**만 해당된다. 국가 예하의 정부기관, 군사조직 등은 구분 상 <span class=\"pink-400\">gTLD</span>로 분류된다.  \r\n마찬가지로, 각 <span class=\"pink-400\">최상위 도메인</span>은 **해당 <span class=\"pink-400\">최상위 도메인</span>을 소유한 기관 혹은 기업에서 관리**한다.\r\n\r\n> 현재 운영 중인 <span class=\"pink-400\">최상위 도메인</span>은 [IANA](https://www.iana.org/domains/root/db)에서 확인할 수 있다.\r\n\r\n여담으로, <span class=\"pink-400\">최상위 도메인</span>에 중복된 <span class=\"yellow-400\">도메인</span>을 등록할 수 없다. 예를 들어, 내가 `aaa.com` URL을 등록한다고 가정해보자.  \r\n우선 제일 먼저 `.com`을 관리하는 업체에 `aaa`라는 <span class=\"yellow-400\">도메인</span>을 등록해야 한다. 하지만, 이미 누군가가 `aaa.com`을 등록했다면 해당 소유주가 <span class=\"yellow-400\">도메인</span>의 소유권을 포기하기 전까진 `aaa.com` <span class=\"yellow-400\">도메인</span>을 소유할 수 없다.  \r\n물론 `.com`이 아닌 `.kr`이나 `.net`에는 등록할 수 있다. 하지만 `socket.io` 처럼 <span class=\"yellow-400\">도메인</span>과 <span class=\"pink-400\">최상위 도메인</span>까지 의미론적으로 구성했다면, 이러한 상황이 달갑지 않을 것이다. 때문에 일전에 이슈됐던 <span class=\"primary\">덮죽 상표권 선점</span>과 비슷한 일이 일어나기도 한다.\r\n\r\n## Port(포트)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"amber-400\">443</span> 부분. 앞에 반드시 `:`이 붙는다.\r\n\r\n인터넷에 연결된 모든 디바이스는 사용하는 네트워크의 IP를 할당받는다. 할당받은 IP 내에서 해당 디바이스가 수행 중인 모든 프로세스의 통신이 이루어진다. <span class=\"amber-400\">포트</span>는 프로세스의 데이터가 IO되는 통로다. 작업 시, 각 프로세스 별로 고유한 <span class=\"amber-400\">포트</span>를 할당받으며, 하나의 <span class=\"amber-400\">포트</span>는 반드시 하나의 프로세스와 1:1 매칭된다. 반면, 하나의 프로세스는 여러 <span class=\"amber-400\">포트</span>를 할당받을 수 있다.  \r\n**특정 프로세스와 통신하기 위해선 반드시 해당 프로세스가 할당받은 <span class=\"amber-400\">포트</span>에 데이터를 전송**해야 한다. 때문에 <span class=\"amber-400\">포트</span> 통신은 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 크게 중요하지 않으며, 어떤 <span class=\"amber-400\">포트</span>로 보내는지가 중요하다.\r\n\r\n웹 통신에서의 기본<span class=\"amber-400\">포트</span>는 아래와 같다.\r\n\r\n| 포트  |      내용       |\r\n| :---: | :-------------: |\r\n|  80   | HTTP 기본 포트  |\r\n|  443  | HTTPS 기본 포트 |\r\n\r\n아마 이러한 숫자를 처음 볼 수도 있는데, 대부분의 웹 사이트 <span class=\"primary\">URL</span>에는 <span class=\"amber-400\">포트</span>를 확인할 수 없다. 사이트가 **각 프로토콜의 기본 <span class=\"amber-400\">포트</span>로 서비스될 경우, <span class=\"primary\">URL</span>에서 <span class=\"amber-400\">포트</span>를 생략**할 수 있다. 즉, `https://naver.com`의 <span class=\"amber-400\">포트</span>번호는 `443`이지만, `443`은 HTTPS의 기본 <span class=\"amber-400\">포트</span>이므로 생략된다. 만약, `443`이 아닌 `8080`, `9200`과 같은 **임의의 <span class=\"amber-400\">포트</span>로 서비스를 제공할 경우, <span class=\"amber-400\">포트</span>를 반드시 명시해야하므로 생략이 불가능**하다. 이 경우 <span class=\"primary\">URL</span>은 `https://naver.com:8080`이 될 것이다.  \r\n위와 같은 이유로, 대부분의 웹 사이트는 서비스하는 프로토콜에 맞는 기본 <span class=\"amber-400\">포트</span>를 사용한다.\r\n\r\n<span class=\"amber-400\">포트</span>는 **0 ~ 65535**의 범위를 가지며, 크게 세 가지로 구분할 수 있다.\r\n\r\n### 잘 알려진 포트(well-known Port)\r\n\r\n**0 ~ 1023**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터에서 기본적으로 사용되는 주요 프로세스에 기본적으로 할당되는 포트로, ICANN(Internet Corporation for Assigned Names and Numbers, 국제 인터넷주소 관리기구)에 의해 통제된다.\r\n\r\n|  포트  |  기능  |        용도        |\r\n| :----: | :----: | :----------------: |\r\n| 20, 21 |  FTP   |    파일 송수신     |\r\n|   22   |  SFTP  | 파일 암호화 송수신 |\r\n|   23   | Telnet |    터미널 통신     |\r\n|   25   |  SMTP  |     메일 전송      |\r\n|   53   |  DNS   |      DNS 통신      |\r\n|   67   |  DHCP  |     DHCP 통신      |\r\n|   80   |  HTTP  |     HTML 통신      |\r\n|  443   | HTTPS  |  HTML 암호화 통신  |\r\n\r\n어디까지나 초기에 지정되는 <span class=\"amber-400\">포트</span>이므로, 추후 **사용자의 의도에 따라 비어있는 다른 포트로 변경**할 수도 있다. 즉, 초기값일뿐, 강제는 아니다.\r\n\r\n### 등록된 포트(registered Port)\r\n\r\n**1024 ~ 49151**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터의 기본 프로세스는 아니지만, 주요 프로그램들이 기본으로 사용하고자 ICANN에 등록한 <span class=\"amber-400\">포트</span>다. <span class=\"amber-400\">잘 알려진 포트</span>와 마찬가지로 프로그램의 설정을 통해 **사용자의 의도에 따라 비어있는 다른 포트로 변경**할 수 있다.\r\n\r\n| 포트  |         기능         |             용도             |\r\n| :---: | :------------------: | :--------------------------: |\r\n| 1433  |        MSSQL         |        MSSQL DB 통신         |\r\n| 3306  |        MySQL         |        MySQL DB 통신         |\r\n| 3389  |         RDP          | 원격 데스크톱 접근 (Windows) |\r\n| 5432  |      PostgreSQL      |      PostgreSQL DB 통신      |\r\n| 8080  | HTTP 통신(Tomcat 등) |   HTTP 통신 (80포트 대용)    |\r\n| 27017 |       MongoDB        |         MongoDB 통신         |\r\n\r\n주로 <span class=\"primary\">DB</span>같은 개발 관련 프로그램들이 많이 등록돼있다.\r\n\r\n#### 왜? 하필 개발 관련 프로그램들만?\r\n\r\n개발 관련 프로그램들은 그 특성 상 통신의 방식이 **항상 일정**해야 한다. 만약 DB의 <span class=\"amber-400\">포트</span>가 기동할 때마다 수시로 변경된다면 어떨까? 이유를 막론하고 DB가 재기동될 경우, 개발자는 DB가 사용 중인 임의의 <span class=\"amber-400\">포트</span>를 추적하여 프로그램의 DB 통신 코드를 변경해야하는 매우 불합리한 상황이 발생하게 된다.  \r\n\r\n이에 비해 게임이나 IDE 같은 일반적인 프로그램들은 굳이 통신의 방식이 일정할 필요는 없다. 어찌됐든 **서버에 정보를 요청하는 순간, 서버는 자연스레 내 통신 정보를 알게되기 때문**이다. 서버는 요청했던 경로로 다시 데이터를 반환해주면 된다. 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 별로 중요하지 않는 이유가 여기에 있다.\r\n\r\n### 동적 포트(dynamic Port)\r\n\r\n**49152 ~ 65535**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 대다수의 프로그램들은 <span class=\"amber-400\">포트</span> 기본값이 지정되지 않는 경우가 대부분이다. 이러한 프로그램들은 <span class=\"amber-400\">동적 포트</span> 중 사용 가능한 임의의 빈 <span class=\"amber-400\">포트</span>를 자동으로 점유한다. 때문에 ICANN이 관리하지도 않으며, 특정 프로그램이 고유한 <span class=\"amber-400\">포트</span>로 등록되어있지도 않다. 자유석을 생각하면 편하다.\r\n\r\n### Path(경로)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"cyan-400\">posts</span> 부분. 웹 사이트의 하위 경로를 의미한다. <span class=\"cyan-400\">경로</span>는 `/`로 구분하며, 경로 입력을 통해 서버 내의 원하는 자원에 접근할 수 있다.\r\n\r\n* https://blog.itcode.dev\r\n  * posts\r\n    * index.html\r\n    * a1000\r\n      * index.html\r\n    * a1001\r\n      * index.html\r\n    * uri-url-urn\r\n      * index.html\r\n  * project\r\n    * index.html\r\n  * index.html\r\n\r\n위 트리는 이 블로그의 단편적인 디렉토리 예시다. 이 중 해당 게시물에 접근하려면 <span class=\"cyan-400\">경로</span>는 `/posts/uri-url-urn/index.html`와 같이 구성할 수 있다. <span class=\"primary\">index.html은 생략이 가능</span>하므로 `/posts/uri-url-urn`로 접근해도 무방하다.\r\n\r\n> **아시나요?**  \r\n> **index.html** 경로의 기본 HTML을 의미함. 더이상의 하위 경로를 표시하지 않을 경우, 해당 경로의 index.html를 응답한다.\r\n\r\n<span class=\"cyan-400\">경로</span>는 서버의 구조에 따라 결정되므로, 사이트마다 천차만별이다.\r\n\r\n### Query String(쿼리 문자열)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"teal-400\">?category=WEB&page=1</span> 부분. 해당 <span class=\"cyan-400\">경로</span>에 임의의 데이터를 같이 전송할 때 사용한다.  \r\n<span class=\"primary\">key=value</span> 형태로 이루어지며, 각 `key`는 <span class=\"purple-400\">Parameter(파라미터)</span>라 칭한다. 첫 <span class=\"purple-400\">파라미터</span>는 `?`로 시작하며, 이후 각 <span class=\"purple-400\">파라미터</span>들은 `&`으로 구분된다. 즉 `?key1=value1&key2=value2&key3=value3`과 같은 양식으로 전개된다.\r\n\r\n임의의 키워드를 전달하여 페이지의 동작을 제어할 수 있다. <span class=\"primary\">URL</span> 중 **사용자의 니즈가 가장 활발하게 반영**되는 부분. <span class=\"teal-400\">쿼리 문자열</span>은 각각의 `key`에 대한 역할을 정의해야 하므로, 개발자가 각 <span class=\"purple-400\">파라미터</span>의 `key`가 동작하는 로직을 작성했을 때 그 의미가 있다.\r\n\r\n## URN 구조\r\n\r\n지금까지 <span class=\"primary\">URL</span>에 대해선 상당히 장황하게 설명했지만, <span class=\"primary\">URN</span>의 경우 <span class=\"primary\">URL</span>보다 역사가 짧다. 이미 3년이라는 시간 사이에 <span class=\"primary\">URL</span>이 표준으로 자리매김한 탓에, 현재까지도 비주류를 면치 못 해 구현된 예시도 그리 많지 않은게 현실이다.  \r\n<span class=\"primary\">URL</span>이 위치만 바뀌어도 찾을 수 없다는 단점은, 오히려 제공중인 데이터를 은닉하는 측면 등 상황에 따라 오히려 유용하게 사용할 여지도 있다. 즉, <span class=\"primary\">URL</span>의 단점이 마냥 나쁜것만은 아닌 셈이다. 이는 곳 <span class=\"primary\">URN</span>의 장점이 현재 구축된 <span class=\"primary\">URL</span>체계를 갈아 엎을 정도로 매력적이지 않다는 주장을 뒷받침한다.\r\n\r\n<span class=\"primary\">URN</span>은 아래와 같은 구조로 이루어진다. 각 요소는 `:`으로 구분한다.\r\n\r\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">urn</span>:<span class=\"green-400\">isbn</span>:<span class=\"yellow-400\">1234567890</span></p>\r\n\r\n### Protocol(프로토콜)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"lightBlue-400\">urn</span> 부분. `urn`으로 시작하면 <span class=\"primary\">URN</span>체계로 보면 된다.\r\n\r\n### NID(Namespace Identifier, 네임스페이스 지시자)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"green-400\">isbn</span> 부분. **자원이 저장된 저장소**를 표시한다.  \r\n`isbn`은 서지정보유통지원시스템으로 도서 일련번호에 대한 정보를 저장하는 저장소이다. 즉, `isbn`을 <span class=\"green-400\">NID</span>로 지정하면 도서 관련 자원을 식별할 수 있다.\r\n\r\n### NSS(Namespace Specific String, 네임스페이스 특정 문자)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"yellow-400\">1234567890</span> 부분. **자원을 식별할 수 있는 고유값**이다.  \r\n<span class=\"green-400\">NID</span>가 `isbn`으로 지정되어 있으므로, ISBN의 일련번호가 1234567890인 도서를 식별하는 <span class=\"primary\">URN</span>이라 볼 수 있다.","url":["2021-05-29-uri-url-urn","2021","05","29","uri-url-urn"]},{"header":{"title":"Tomcat(톰캣) 현재 콘솔창에서 구동하기","excerpt":"오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-26T16:32:16","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-26-tomcat-current-window.md","content":"\r\n# 왜 자꾸 꺼지는거야!\r\n\r\n오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?\r\n\r\n# 왜?\r\n\r\n톰캣이 콘솔 형태로 실행되는 것은 맞지만, 실행되는 프로세스를 보면 살짝 다르다. `startup.bat`을 실행하면 cmd창이 뜬 뒤 꺼지면서 곧바로 Tomcat 창이 표시된다. <span class=\"primary\">톰캣을 구동하면 항상 새로운 창이 뜨기 때문에, 톰캣이 오류로 인해 동작이 중지되면 창이 곧바로 닫히게 된다.</span>\r\n\r\n# 해결책?\r\n\r\n그렇다고 해결책이 없는 건 아니고, `startup.bat`의 간단한 수정을 통해 톰캣이 <span class=\"primary\">현재 창에서 동작</span>하도록 수정할 수 있다. \r\n\r\n`startup.bat`을 메모장으로 열면, 맨 아래에 `call \"%EXECUTABLE%\" run %CMD_LINE_ARGS%` 구문이 존재한다. 여기서 가운데 `run`을 `start`로 변경한다.\r\n\r\n즉 `call \"%EXECUTABLE%\" start %CMD_LINE_ARGS%`로 구문을 변경하고 저장하면 된다.\r\n\r\n이후 `startup.bat`을 클릭하여 실행하지 말고, `cmd`창 하나를 킨 다음에, 해당 콘솔에서 `startup.bat`을 호출하면 새 창이 뜨지 않고 호출한 콘솔에서 톰캣이 구동된다.  \r\n톰캣이 종료돼도 콘솔창이 꺼지지 않으므로, 편하게 메시지를 확인할 수 있다.","url":["2021-05-26-tomcat-current-window","2021","05","26","tomcat-current-window"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1004번 어린 왕자","excerpt":"어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-22T21:42:23","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","기하학","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-22-a1004.md","content":"\r\n# 어린 왕자\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/8.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1004번 문제](https://www.acmicpc.net/problem/1004)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.\r\n\r\n![image](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfcmhrjj_113gw6bcng2_b.gif)\r\n\r\n빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.\r\n\r\n위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. (행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다고 가정한다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.)\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 $(x_1, y_1)$과 도착점 $(x_2, y_2)$이 주어진다. 두 번째 줄에는 행성계의 개수 $n$이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 $(c_x, c_y, r)$이 주어진다. 입력제한은 다음과 같다. $(-1000 ≤ x_1, y_1, x_2, y_2, c_x, c_y ≤ 1000, 1 ≤ r ≤ 1000, 1 ≤ n ≤ 50)$\r\n\r\n좌표와 반지름은 모두 정수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n-5 1 12 1\r\n7\r\n1 1 8\r\n-3 -1 1\r\n2 2 2\r\n5 5 1\r\n-4 5 1\r\n12 1 1\r\n12 1 2\r\n-5 1 5 1\r\n1\r\n0 0 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n1002번째 알고리즘의 내용을 응용하면 쉽게 풀 수 있는 문제인 것 같다. 실제로 별다른 레퍼런스를 찾지도 않고 풀 수 있었으니.\r\n\r\n문제를 풀기 전에 몇 가지 집고 넘아갈 게 있다.  \r\n숫자들 때문에 입력의 한 세트를 착각하기 쉽다.\r\n\r\n위 예제를 기준으로 설명하면, 첫 번째 숫자는 세트의 갯수. 본문에서는 `2`이므로, 두 세트를 테스트하므로 결과는 두 줄이 출력된다.  \r\n이후 테스트에 필요한 데이터가 출력된다.\r\n\r\n-5 1 12 1 <= $x_1, y_1, x_2, y_2$  \r\n7 <= 행성 갯수  \r\n1 1 8 <= $c_{x1}, c_{y1}, r_1$  \r\n-3 -1 1  \r\n2 2 2  \r\n5 5 1  \r\n-4 5 1  \r\n12 1 1  \r\n12 1 2 <= 행성 갯수만큼 출력됨\r\n\r\n또한, 결과는 행성계의 진입/이탈 횟수를 통틀어서 출력하므로 굳이 진입/이탈을 구분하여 저장할 필요는 없다.\r\n\r\n문제에서 **출발점에서 도착점까지 가는데 통과해야하는 행성계(이하 원, circle)의 최소**를 목적으로 두기 때문에, 반드시 통과해야하는 원만 계산하면 된다.  \r\n출발/도착점이 임의의 원 안에 포함될 경우 반드시 진입/이탈이 일어난다. 따라서, 출발/도착점을 온전히 포함하는 원의 갯수를 계산하면 진입/이탈의 횟수를 구할 수 있다.  \r\n주의할 점이 있는데, **한 원이 출발/도착점을 모두 포함할 경우 계산에서 제외**시켜야 한다.  \r\n하나의 원이 출발/도착점을 전부 포함할 경우, 원 안에서 이동하기 때문에 진입/이탈이 일어나지 않기 때문.  \r\n\r\n![example](https://user-images.githubusercontent.com/50317129/120758690-188d5000-c54d-11eb-917c-f910eb7b3199.png)\r\n\r\n원리는 간단하다. 원점과 점의 거리를 계산한다. 계산한 거리가 원의 반지름보다 짧을 경우, 해당 원은 점을 포함하는 셈이다.  \r\n이를 식으로 정리하면 아래와 같다.\r\n\r\n|     변수     |      의미      |\r\n| :----------: | :------------: |\r\n|   $x$, $y$   |   원점 좌표    |\r\n| $x_o$, $y_o$ | 원의 원점 좌표 |\r\n|     $r$      |  원의 반지름   |\r\n\r\n변수는 위 표와 같이 정의하고 <span class=\"green-A700\">한 원이 원점을 포함하는 식</span>을 전개한다.\r\n\r\n$$\r\n\\sqrt{(x_0 - x)^2 + (y_0 - y)^2} < r\r\n$$\r\n\r\n위 식을 코드로 표현하면 되는 비교적 간단한 알고리즘이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1004 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/05/22/a1004\">1004 풀이</a>\r\n * @since 2021.04.24 Sat 02:15:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint length = scanner.nextInt();\r\n\t\tscanner.nextLine();\r\n\t\t\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tString base = scanner.nextLine();\r\n\t\t\t\r\n\t\t\tint x_start = Integer.parseInt(base.split(\" \")[0]);\r\n\t\t\tint y_start = Integer.parseInt(base.split(\" \")[1]);\r\n\t\t\t\r\n\t\t\tint x_end = Integer.parseInt(base.split(\" \")[2]);\r\n\t\t\tint y_end = Integer.parseInt(base.split(\" \")[3]);\r\n\t\t\t\r\n\t\t\tint through = 0;\r\n\t\t\t\r\n\t\t\tint count = scanner.nextInt();\r\n\t\t\tscanner.nextLine();\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < count; j++)\r\n\t\t\t{\r\n\t\t\t\tString circle = scanner.nextLine();\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(circle.split(\" \")[0]);\r\n\t\t\t\tint y = Integer.parseInt(circle.split(\" \")[1]);\r\n\t\t\t\tint r = Integer.parseInt(circle.split(\" \")[2]);\r\n\t\t\t\t\r\n\t\t\t\tboolean hasStartContain = hasContain(x_start, y_start, x, y, r);\r\n\t\t\t\tboolean hasEndContain = hasContain(x_end, y_end, x, y, r);\r\n\t\t\t\t\r\n\t\t\t\t// 해당 행성이 출발 혹은 도착점 중 하나만을 포함할 경우\r\n\t\t\t\tif (!(hasStartContain && hasEndContain) && (hasStartContain || hasEndContain))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrough++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(through);\r\n\t\t}\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 출발/도착점 포함 여부 반환 함수\r\n\t *\r\n\t * @param xo: [int] 출발/도착점의 x좌표\r\n\t * @param yo: [int] 출발/도착점의 y좌표\r\n\t * @param x: [int] 행성의 x좌표\r\n\t * @param y: [int] 행성의 y좌표\r\n\t * @param r: [int] 행성의 반지름\r\n\t *\r\n\t * @return [boolean] 출발/도착점 포함 여부\r\n\t */\r\n\tprivate static boolean hasContain(int xo, int yo, int x, int y, int r)\r\n\t{\r\n\t\treturn Math.sqrt(Math.pow(xo - x, 2) + Math.pow(yo - y, 2)) < r;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 기하학","url":["2021-05-22-a1004","2021","05","22","a1004"]},{"header":{"title":"Tomcat(톰캣) 콘솔창 한글 인코딩 깨짐 현상 해결하기","excerpt":"톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상. Windows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-22T12:52:51","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-22-tomcat-encoding-euckr.md","content":"\r\n# 와장창!\r\n\r\n![Encoding Broken](https://user-images.githubusercontent.com/50317129/119212087-342a3c80-baf1-11eb-89bc-06829a5f7c16.png)\r\n\r\n톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상.  \r\nWindows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.\r\n\r\n# 도대체 왜?\r\n\r\n실력 좋은 개발자가 아니더라도, 컴퓨터와 친분이 있다면 언어가 깨짐은 곧 인코딩의 불일치라는 걸 개괄적으로 이해하고 있다. 이러한 현상이 일어나는 이유는 아래와 같은데,\r\n\r\n* <span class=\"primary\">Windows Console</span>: Windows OS 설정 언어의 기본 인코딩 (한국어는 **EUC-KR**)\r\n* <span class=\"primary\">Tomcat Console</span>: 설정파일의 인코딩 (**기본 UTF-8**)\r\n\r\n이 처럼, 기본 인코딩이 서로 다르다.\r\n\r\n# 해결책\r\n\r\n이를 해결하는 방법은 크게 두 가지가 존재한다. 개인적으로 <span class=\"red-300\">두 번째 방법을 추천</span>한다.\r\n\r\n### Windows Console 인코딩 변경하기\r\n\r\n첫 번째로, Windows Console의 인코딩을 변경한다. Windows 10 기준으로 OS의 기본 콘솔은 <span class=\"green-500\">cmd</span>와 <span class=\"green-500\">PowerShell</span> 두 가지다. **사용할 콘솔의 기본 인코딩을 EUC-KR에서 UTF-8로 변경**해주면 된다.\r\n\r\n애석하게도, 두 콘솔 모두 인코딩을 변경하는 옵션을 제공하지 않는다. 그렇다고 방법이 없는 건 아니고, 레지스트리 수정을 통해 문제를 해결할 수 있다.\r\n\r\n<br />\r\n\r\n1. 작업표시줄에서 `regedit`을 입력하여 <span class=\"blue-500\">레지스트리 편집기</span>를 띄운다.\r\n2. `HKEY_CURRENT_USER\\Console` 경로에 접근한다. 사용자 계정에 설치된 콘솔들이 출력된다. (cmd, PowerShell, Git 등)\r\n\r\n![Registry](https://user-images.githubusercontent.com/50317129/119212160-83706d00-baf1-11eb-92c8-b41458950f20.png)\r\n\r\n3. 인코딩을 변경하려는 콘솔의 폴더를 클릭한다.\r\n   * **%SystemRoot%_system32_cmd.exe**: cmd\r\n   * **%SystemRoot%_System32_WindowsPowerShell_v1.0_powershell.exe**: 32비트 PowerShell\r\n   * **%SystemRoot%_SysWOW64_WindowsPowerShell_v1.0_powershell.exe**: 64비트 PowerShell\r\n4. `CodePage` 키를 더블클릭하여 편집을 수행한다.\r\n   `CodePage`가 없을 경우, 오른쪽 마우스 버튼을 클릭하여 새 DWORD(32비트) 키를 동일한 이름으로 생성한다.\r\n5. 값 데이터를 10진수 `65001`로 변경한다.\r\n\r\n![Registry](https://user-images.githubusercontent.com/50317129/119212198-ab5fd080-baf1-11eb-981b-82599148c8f8.png)\r\n\r\n6. 앞으로 실행되는 Windows Console은 해당 인코딩이 적용된다.\r\n\r\n이렇게 하면 Windows Console과 Tomcat의 기본 인코딩이 UTF-8로 서로 일치하므로, 한글이 정상적으로 출력된다.  \r\n하지만 이 방법은 Windows Console의 인코딩을 바꾸므로, 차후 해당 <span class=\"red-500\">콘솔을 통해 다른 작업이나 프로그램이 실행될 경우 엉뚱한 프로그램의 한글이 깨질 우려</span>가 있다.  \r\n(대부분은 OS 언어의 기본 인코딩을 따라가도록 설계함)\r\n\r\nWindows Console은 범용적으로 사용되는 프로그램이므로, 다른 작업에 영향을 줄 수 있다. 내가 이 방법을 굳이 추천하지 않는 이유이기도 하다.  \r\n\r\n### Tomcat Console 인코딩 변경하기\r\n\r\n두 번째로, Tomcat Console의 인코딩을 변경한다. 첫 번째 방법보다 이 방법이 나은 이유는, Tomcat이라는 제한적인 용도의 콘솔에만 영향을 미치기 때문. 어차피 Tomcat Console의 인코딩이 불일치해서 생기는 문제이므로, 이쪽을 바꾸는게 상식적으로도 맞다.\r\n\r\n대부분 마찬가지로 위 방법처럼 레지스트리를 수정하라고 안내할텐데, Tomcat은 굳이 그렇게 바꿔줄 필요 없다.\r\n\r\n1. `%TOMCAT_HOME%\\conf\\logging.properties`을 연다.\r\n2. **java.util.logging.ConsoleHandler.encoding**의 값을 **EUC-KR**로 변경한다.\r\n   별다른 설정이 없었다면, UTF-8이 기본으로 설정되어 있다.\r\n3. 앞으로 실행되는 Tomcat은 해당 인코딩이 적용된다.\r\n\r\nTomcat을 실행하면 한글이 정상적으로 출력된다.","url":["2021-05-22-tomcat-encoding-euckr","2021","05","22","tomcat-encoding-euckr"]},{"header":{"title":"도메인이란?","excerpt":"도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다. 인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 고유한 12자리 숫자로 구성된 IP주소를 가진다. IP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다. 유동 IP: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨. 고정 IP: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함. 우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, 특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요하다.","coverImage":"https://user-images.githubusercontent.com/50317129/120056028-b2985880-c074-11eb-8cc3-39f5f10a2c7f.png","date":"2021-05-22T12:52:51","type":"posts","category":"WEB","tag":["WEB(웹)","Domain(도메인)"],"comment":true,"publish":true},"name":"2021-05-22-about-domain.md","content":"\r\n# Domain(도메인)이란?\r\n\r\n도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다.  \r\n인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 <span class=\"blue-500\">고유한 12자리 숫자로 구성된 IP주소</span>를 가진다.  \r\nIP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다.\r\n\r\n* <span class=\"primary\">유동 IP</span>: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨.\r\n* <span class=\"primary\">고정 IP</span>: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함.\r\n\r\n우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, <span class=\"green-500\">특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요</span>하다.  \r\n불행히도, IP는 불규칙적인 숫자로 이루어져있어, 사람이 쉽게 기억하기 다소 어렵다. 이러한 불편함을 해소하기 위한 것이 Domain(도메인)이다.\r\n\r\n도메인은 <span class=\"pink-400\">SLD(서브도메인)</span>, <span class=\"pink-400\">도메인</span>, <span class=\"pink-400\">TLD(최상위 도메인)</span>으로 구분되며, 해당 도메인의 정보는 1차적으로 각 로컬 DNS 서버가 관리하며, 최종적으로는 TLD를 관리하는 Root DNS에서 관리한다.\r\n\r\n> 도메인에 대한 자세한 내용은 이전에 작성된 [URI? URL? URN? 리소스 식별자 구분하기](/posts/uri-url-urn)를 참조한다.\r\n\r\n# 그래서 도메인을 왜 쓰는데?\r\n\r\n우리가 흔히 <span class=\"green-A700\">네이버</span>라고 부르는 사이트의 실제 IP는 [125.209.222.141](http://125.209.222.141)이다. 하지만 우리들 중 그 누구도 저런 IP로 <span class=\"green-A700\">네이버</span>에 접속하지 않는다. 대신 우리는 [https://www.naver.com](https://www.naver.com)이라는 도메인으로 접속한다. 이유는 간단하다. 주소 자체에 <span class=\"green-A700\">naver</span>라는 키워드가 포함되어 있으므로 기억하기 쉽기 때문이다.\r\n\r\n<span class=\"pink-400\">도메인</span>은 숫자가 아닌, 문자 형태로 이루어진 주소다. 문자이므로, 주소에 의미를 부여하기 용이하다. 사용자가 주소를 기억하기 쉬워 주소에 대한 접근성을 높여준다.  \r\n생성한 <span class=\"pink-400\">도메인</span>에 원하는 IP를 연결하면 <span class=\"pink-400\">도메인</span> 주소를 통해서도 해당 IP에 접근할 수 있다.\r\n<span class=\"pink-400\">도메인</span> 제공 업체에 따라, 영숫자 뿐만 아니라 한글과 같은 유니코드 문자도 지원하므로, 딱딱한 IP 대신 개성있는 주소를 사용할 수 있는 것이다.\r\n\r\n# 도메인의 원리\r\n\r\n여기서 의문점이 한 가지 생긴다. IP [125.209.222.141](http://125.209.222.141)와 <span class=\"pink-400\">도메인</span> [https://www.naver.com](https://www.naver.com)가 <span class=\"green-A700\">네이버</span>를 가리키는 주소인건 알겠는데, 인터넷은 과연 두 주소의 연결고리를 어떻게 아는 걸까?\r\n\r\n이는 <span class=\"pink-400\">도메인</span>의 동작 원리를 보면 알 수 있다. `blog.itcode.dev` <span class=\"pink-400\">도메인</span>에 접근하는 과정을 예시로 보자.\r\n\r\n1. HTTP 통신을 통해 `blog.itcode.dev`에 접근을 시도한다.\r\n2. 네트워크에 지정된 로컬 DNS에게 `blog.itcode.dev`의 정보를 요청한다.\r\n   * 만약 로컬 DNS가 해당 도메인의 정보를 보유하고 있을 경우, 즉시 정보를 제공한다.\r\n3. `blog.itcode.dev`에 대한 정보가 없을 경우, 근접한 Root DNS에 해당 도메인의 정보를 요청한다.\r\n4. Root DNS가 `.io` TLD를 관리하는 DNS 서버의 정보를 로컬 DNS에 제공한다.\r\n5. 로컬 DNS가 `blog.itcode.dev`를 관리하는 TLD의 DNS 서버에 해당 정보를 요청한다.\r\n6. TLD DNS 서버가 `blog.itcode.dev`에 대한 정보(IP 등)을 제공한다.\r\n7. 로컬 DNS가 `blog.itcode.dev`의 IP를 알고 있으므로, 이를 통해 해당 사이트에 접근할 수 있다.\r\n\r\n기본적으로 <span class=\"pink-400\">도메인</span>은 반드시 하나의 IP와 연결된다. 이런 특징 덕분에 <span class=\"pink-400\">도메인</span>은 항상 특정한 하나의 IP만을 반환한다.","url":["2021-05-22-about-domain","2021","05","22","about-domain"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1003번 피보나치 함수","excerpt":"다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T23:29:03","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","피보나치 수열","Dynamic Programming(동적 프로그래밍)","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1003.md","content":"\r\n# 피보나치 함수\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/8.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1003번 문제](https://www.acmicpc.net/problem/1003)\r\n\r\n## 조건\r\n\r\n|        시간제한         | 메모리 제한 |\r\n| :---------------------: | :---------: |\r\n| 0.25초 (추가 시간 없음) |    128MB    |\r\n\r\n## 문제\r\n\r\n다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.\r\n\r\n``` cpp\r\nint fibonacci(int n) {\r\n    if (n == 0) {\r\n        printf(\"0\");\r\n        return 0;\r\n    } else if (n == 1) {\r\n        printf(\"1\");\r\n        return 1;\r\n    } else {\r\n        return fibonacci(n‐1) + fibonacci(n‐2);\r\n    }\r\n}\r\n```\r\n\r\n$fibonacci(3)$을 호출하면 다음과 같은 일이 일어난다.\r\n\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$ (첫 번째 호출)을 호출한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$ (두 번째 호출)과 $fibonacci(0)$을 호출한다.\r\n* 두 번째 호출한 $fibonacci(1)$은 1을 출력하고 1을 리턴한다.\r\n* $fibonacci(0)$은 0을 출력하고 0을 리턴한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$과 $fibonacci(0)$의 결과를 얻고, 1을 리턴한다.\r\n* 첫 번째 호출한 $fibonacci(1)$은 1을 출력하고, 1을 리턴한다.\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$의 결과를 얻고, 2를 리턴한다.\r\n\r\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, $fibonacci(N)$을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 적성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.  \r\n각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0\r\n1\r\n3\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 0\r\n0 1\r\n1 2\r\n```\r\n\r\n# 풀이\r\n\r\n알고리즘 풀면서 느끼는 거지만, 문제가 뭘 말하는 지 이해가 안 되는 경우가 많은 것 같다. 내가 멍청해서 그런건가.\r\n\r\n이 문제를 풀기 위해선, 피보나치 수열에 대한 식을 이해하고 있어야 한다.  \r\n피보나치 수열이 $f()$일 때, $n$번째 피보나치 수열의 식은 $f(n) = f(n - 1) + f(n - 2)$로 정의할 수 있다.\r\n\r\n$n = 0, 1$일 때의 초기값이 정해져있다. (식의 특성 상 초기값이 없으면 계산할 수가 없다.)  \r\n$f(0) = 0$  \r\n$f(1) = 1$  \r\n초기값은 위와 같으며, 실질적으로 $n >= 2$ 부터 의미있는 연산이 수행된다.\r\n\r\n다시 문제로 돌아가서, 임의의 수 N이 주어질 경우 $f(N)$을 수행하면서 $f(0)$, $f(1)$이 몇 번 호출되는지를 구하면 된다.  \r\n예를 들어, $N = 4$라고 가정하고 식을 전개하면 아래와 같다.  \r\n$f(4) = f(3) + f(2)$  \r\n위 식에서 $f(3)$은 $f(2) + f(1)$로 치환할 수 있으며, 같은 이유로 $f(2)$ 역시 $f(1) + f(0)$으로 치환 가능하다.  \r\n$f(4) = f(2) + f(1) + f(1) + f(0)$  \r\n$= f(1) + f(0) + f(1) + f(1) + f(0)$\r\n\r\n결과적으로 $f(4) = 2(f0) + 3f(1)$로 정리할 수 있다.  \r\n따라서 이 문제의 알고리즘은 $N = 4$일 경우 `2 3`이 출력되어야 한다.\r\n\r\n우선 식을 정리하여 한 눈에 보면 문제 해결에 도움이 될 것 같다.  \r\n피보나치 수열을 쭉 정리하면 아래와 같다.\r\n\r\n|  $n$  | $f(0)$의 갯수 | $f(1)$의 갯수 | $f(n)$ |\r\n| :---: | :-----------: | :-----------: | :----: |\r\n|   0   |       1       |       0       |   0    |\r\n|   1   |       0       |       1       |   1    |\r\n|   2   |       1       |       1       |   1    |\r\n|   3   |       1       |       2       |   2    |\r\n|   4   |       2       |       3       |   3    |\r\n|   5   |       3       |       5       |   5    |\r\n|   6   |       5       |       8       |   8    |\r\n|   7   |       8       |      13       |   13   |\r\n|   8   |      13       |      21       |   21   |\r\n|   9   |      21       |      34       |   34   |\r\n\r\n표로 정리하니 어느정도 규칙성이 눈에 보이기 시작한다.\r\n\r\n* N의 $f(1)$ 출력 갯수는 $f(N)$과 동일하다.  \r\n* N의 $f(0)$ 출력 갯수는 $f(N - 1)$과 동일하다.\r\n\r\n즉, $N = 4$일 경우 알고리즘은 $f(3)$ $f(4)$가 출력되면 된다.\r\n\r\n여기서 단순하게 생각하면 아래와 같이 코드를 짤 수 있다.\r\n\r\n## 완성....?\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[][] arr = new Integer[41][2];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// N = 0일 때, 0이 호출되는 횟수\r\n\t\tarr[0][0] = 1;\r\n\r\n\t\t// N = 0일 때, 1이 호출되는 횟수\r\n\t\tarr[0][1] = 0;\r\n\r\n\t\t// N = 1일 때, 0이 호출되는 횟수\r\n\t\tarr[1][0] = 0;\r\n\r\n\t\t// N = 1일 때, 1이 호출되는 횟수\r\n\t\tarr[1][1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tint f0 = fibonacci(n - 1);\r\n\t\t\tint f1 = fibonacci(n);\r\n\r\n\t\t\tSystem.out.println(f0 + \" \" + f1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 인덱스가 0일 경우\r\n\t\tif (n == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 1일 경우\r\n\t\telse if (n == 1)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 2 이상일 경우 (연산 가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 코드는 크게 두 가지 문제가 있는데, 우선 $n = 0, 1$일 때의 처리가 정상적으로 이루어지지 않고 있다.  \r\n$f(1) = f(0) + f(-1)$  \r\nN이 문제되기 이전에 이 코드는 런타임 시간 초과로 실패한다. 왜일까?\r\n\r\n위 코드는 **불필요한 연산을 너무 많이 수행한다.** 피보나치 수열의 특성 상 $f(N)$을 계산할 경우, $f(N - 1)$, $f(N - 2)$ ... 등과 같이 N 이하의 피보나치 값까지 전부 계산하게 된다.  \r\n다시 말하면, $f(6)$을 연산할 경우 계산 과정에서 자연스레 $f(4)$, $f(2)$ 등의 피보나치 값을 구할 수 있다.\r\n\r\n위 이론을 알고리즘에 적용하면 아래와 같이 응용할 수 있다.  \r\nN을 총 3번 입력한다고 가정하면 $N_1$, $N_2$, $N_3$으로 구분할 수 있다.\r\n\r\n$N_2 = 8$ -> $f(8)$ 부터 $f(0)$까지의 값을 구할 수 있음.  \r\n$N_3 = 4$ -> $f(4)$ 부터 $f(0)$까지의 값을 구할 수 있음.\r\n\r\n피보나치 연산값을 저장하면 $N_n > N_n+1$일 경우 굳이 **추가적인 연산을 진행하지 않고 이미 저장된 값을 출력**만 함으로써, 런타임 리소스를 줄일 수 있다.\r\n\r\n클래스의 멤버변수로 **Integer 배열을 선언**하여 피보나치 수열값을 저장하고, 알고리즘 연산에 이를 활용하면 될 것 같다.\r\n\r\n> int는 Primitive(자료형) 데이터고, Integer는 Wrapper 클래스다. Wrapper 클래스는 null 입력이 가능하다는 특징이 있으므로, Integer 역시 숫자 이외에 null값을 입력할 수 있다.  \r\nInteger 배열의 초기값은 null로 지정되므로, 배열의 값이 null인 인덱스는 아직 피보나치 수열 계산이 이루어지지 않은 인덱스라고 판단할 수 있다.\r\n\r\n다행히 문제에서 주어진 $N$의 조건은 $0 <= N <= 40$이므로, 배열의 인덱스는 최대 41을 넘지 않음을 알 수 있다.  \r\n(배열은 0부터 시작하므로 40개가 아닌 0을 포함한 41개임에 유의하자)\r\n\r\n이후 피보나치 연산에서 각 과정의 값을 배열에 저장하는 로직을 추가한다.  \r\n배열의 값이 null일 경우, 아직 연산이 진행되지 않았으므로 피보나치 연산을 수행하고 배열에 저장한다.  \r\n반대로, 배열이 특정 숫자값을 가질 경우, 이미 연산이 진행된 인덱스이므로 별도의 연산을 거치지 않고 해당 값을 바로 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/05/21/a1003\">1003 풀이</a>\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[] arr = new Integer[41];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\t// 피보나치 수열 초기값 (N = 0)\r\n\t\tarr[0] = 0;\r\n\t\t\r\n\t\t// 피보나치 수열 초기값 (N = 1)\r\n\t\tarr[1] = 1;\r\n\t\t\r\n\t\tint length = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tfibonacci(n);\r\n\t\t\t\r\n\t\t\t// n이 0일 경우\r\n\t\t\tif (n == 0)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"1 0\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// n이 1일 경우\r\n\t\t\telse if (n == 1)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"0 1\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 초기값이 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(new StringBuffer().append(arr[n - 1]).append(\" \").append(arr[n]).toString());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 해당 인덱스의 피보나치가 아직 연산되지 않았을 경우\r\n\t\tif (arr[n] == null)\r\n\t\t{\r\n\t\t\tarr[n] = fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\t\t\r\n\t\treturn arr[n];\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍","url":["2021-05-21-a1003","2021","05","21","a1003"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1002번 터렛","excerpt":"조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:56:10","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","기하학","SILVER","SILVER IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1002.md","content":"\r\n# 터렛\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/7.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1002번 문제](https://www.acmicpc.net/problem/1002)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.\r\n\r\n![image](https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg)\r\n\r\n이석원은 조규현과 백승환에게 상대편 마린(류재영)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.  \r\n조규현의 좌표 $(x_1, y_1)$와 백승환의 좌표 $(x_2, y_2)$가 주어지고, 조규현이 계산한 류재명과의 거리 $r_1$과 백승환이 계산한 류재명과의 거리 $r_2$가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.  \r\n한 줄에 $x_1$, $y_1$, $r_1$, $x_2$, $y_2$, $r_2$가 주어진다. $x_1$, $y_1$, $x_2$, $y_2$는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 점수이고, $r_1$, $r_2$는 10,000보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0 0 13 40 0 37\r\n0 0 30 0 7 4\r\n1 1 1 1 1 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n2\r\n1\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n예제의 요소를 사람 이름으로 두었으나, 문제 이해에 방해가 되니 간단하게 서술하면 아래와 같다.  \r\n임의의 위치에 있는 점 $A$, $B$, $C$가 존재하며, $A$와 $C$의 거리, $B$와 $C$의 거리가 주어진다.  \r\n이 때, $C$가 실제로 위치할 수 있는 점의 갯수를 구하는 것. 즉, 간단하게 **두 원의 접점을 구하는 문제**라고 정의할 수 있다.  \r\n원이 완벽하게 겹칠 경우, **그 수가 무수히 많으므로 -1로 표현**하라는 조건이 포함된다.\r\n\r\n이를 그림으로 표현하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120757881-14146780-c54c-11eb-94ee-ab79d997000e.png)\r\n\r\n변수는 아래와 같이 정리할 수 있다.\r\n\r\n|  $n$  |   $x_n$   |   $y_n$   |   $r_n$    |\r\n| :---: | :-------: | :-------: | :--------: |\r\n|   1   | A의 x좌표 | A의 y좌표 | A의 반지름 |\r\n|   2   | B의 x좌표 | B의 y좌표 | B의 반지름 |\r\n\r\n케이스를 세분화하면 총 6가지로 나눌 수 있다.\r\n\r\n1. 두 원이 정확히 겹칠 경우 (-1)\r\n2. 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n3. 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n4. 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n5. 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n6. 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\r\n본 풀이에선 $x_1$, $y_1$과 $x_2$, $y_2$의 거리($distance$) 및 $r_1$, $r_2$를 합한 길이($sum$)와 뺀 길이($sub$)의 절대값을 이용하여 진행한다.\r\n\r\n$$\r\ndistance = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\r\n$$\r\n\r\n$$\r\nsum = r_1 + r_2\r\n$$\r\n\r\n$$\r\nsub = \\vert r_1 - r_2 \\vert\r\n$$\r\n\r\n* <b class=\"primary\">case 1 - 두 원이 정확히 겹칠 경우</b>\r\n\r\n\t두 원의 위치 및 반지름이 서로 동일한 상황.  \r\n\t$distance$가 0이며, $r_1$과 $r_2$의 길이가 동일할 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이보다 짧은 상황.  \r\n\t$distance < sub$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합보다 긴 상황.  \r\n\t$distance > sum$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 4 - 두 원이 서로 겹치면서 인접하는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이와 일치하는 상황.  \r\n\t$distance == sub$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합과 일치하는 상황.  \r\n\t$distance == sum$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우</b>\r\n\r\n\t두 원이 서로 적당히 겹치는 상황.  \r\n\t$distance < sum$ $\\&\\&$ $distance > sub$일 경우 성립한다.\r\n\r\n굳이 식으로 표현하지 않아도, 위의 5개 케이스에 부합하지 않는 모든 상황에 적용하면 된다.  \r\n위 케이스들을 `if`문을 사용하여 적절히 표현하면 된다. `switch`문의 경우 하나의 변수를 기준으로 분기를 판단하므로 해당 알고리즘에 적용하기엔 다소 부적절하다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1002 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/05/21/a1002\">1002 풀이</a>\r\n * @since 2021.04.21 Wed 21:56:10\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint length = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint x1 = scanner.nextInt();\r\n\t\t\tint y1 = scanner.nextInt();\r\n\t\t\tint r1 = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tint x2 = scanner.nextInt();\r\n\t\t\tint y2 = scanner.nextInt();\r\n\t\t\tint r2 = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tSystem.out.println(calcPoints(x1, y1, r1, x2, y2, r2));\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접점 갯수 반환 함수\r\n\t *\r\n\t * case 1 - 두 원이 정확히 겹칠 경우 (-1)\r\n\t * case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n\t * case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n\t * case 4 - 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n\t * case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n\t * case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\t *\r\n\t * @param x1: [int] A의 x좌표\r\n\t * @param y1: [int] A의 y좌표\r\n\t * @param r1: [int] A와 C 사이의 거리\r\n\t * @param x2: [int] B의 x좌표\r\n\t * @param y2: [int] B의 y좌표\r\n\t * @param r2: [int] B와 C 사이의 거리\r\n\t *\r\n\t * @return [int] 접점 갯수\r\n\t */\r\n\tprivate static int calcPoints(int x1, int y1, int r1, int x2, int y2, int r2)\r\n\t{\r\n\t\t// 두 점 사이의 거리 계산식\r\n\t\tdouble distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n\t\t\r\n\t\tint sum = r1 + r2;\r\n\t\tint sub = Math.abs(r1 - r2);\r\n\t\t\r\n\t\t// case 1 - 두 원이 정확히 겹칠 경우\r\n\t\tif (distance == 0 && r1 == r2)\r\n\t\t{\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\t// case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse if (distance < sub)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t\t// case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우\r\n\t\telse if (distance > sum)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t\t// case 4 - 두 원이 서로 겹치면서 인접하는 경우\r\n\t\telse if (distance == sub)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t\r\n\t\t// case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우\r\n\t\telse if (distance == sum)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t\r\n\t\t// case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 기하학","url":["2021-05-21-a1002","2021","05","21","a1002"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1001번 A - B","excerpt":"두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:51:19","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1001.md","content":"\r\n# A - B\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/1.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1001번 문제](https://www.acmicpc.net/problem/1001)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 A - B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n```\r\n\r\n# 풀이\r\n\r\n1000번 문제에서 연산만 달라지는 뺄셈 알고리즘\r\nScanner로 두 숫자를 입력받아 뺄셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1001 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/05/21/a1001\">1001 풀이</a>\r\n * @since 2021.04.21 Wed 21:51:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\t\t\r\n\t\tscanner.close();\r\n\t\t\r\n\t\tSystem.out.println(a - b);\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-05-21-a1001","2021","05","21","a1001"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1000번 A + B","excerpt":"두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:38:17","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1000.md","content":"\r\n# A + B\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/1.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1000번 문제](https://www.acmicpc.net/problem/1000)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 A + B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n```\r\n\r\n# 풀이\r\n\r\n알고리즘이라고 하기 뭐한 기초적인 연산 알고리즘\r\nScanner로 두 숫자를 입력받아 덧셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1000 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/05/21/a1000\">1000 풀이</a>\r\n * @since 2021.04.21 Wed 21:38:17\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\t\t\r\n\t\tscanner.close();\r\n\t\t\r\n\t\tSystem.out.println(a + b);\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-05-21-a1000","2021","05","21","a1000"]},{"header":{"title":"백준 알고리즘 시작하기","excerpt":"코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다. 그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다. 풀이의 규칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-start-beakjoon.md","content":"\r\n# 백준 알고리즘\r\n\r\n코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다.\r\n\r\n그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다.\r\n\r\n풀이의 규칙은 아래와 같다.\r\n\r\n1. 가급적 문제번호 순서대로 진행한다.\r\n2. 기본 언어는 <span class=\"orange-A400\">JAVA</span>로 진행한다.\r\n3. 원리는 과하다 싶을 정도로 최대한 자세하게 적는다.\r\n4. 번은 개인주의야\r\n5. 숏코딩을 지양하고, 이해하기 쉽도록 성능이 허락하는 선에서 풀어 쓴다.\r\n6. 주석을 적극 활용한다.\r\n7. 채점결과가 반드시 <b class=\"green-A400\">맞았습니다!!</b>인 코드를 기준으로 한다.\r\n8. 풀이에 제시되는 코드는 그대로 복사해도 알고리즘 풀이가 가능하도록 코딩한다.\r\n9. 신명호는 놔둔다.","url":["2021-05-21-start-beakjoon","2021","05","21","start-beakjoon"]},{"header":{"title":"Jekyll에서 Next.js로","excerpt":"Jekyll에서 Next.js로의 블로그 이동기","coverImage":"https://user-images.githubusercontent.com/50317129/119211732-cf6de280-baee-11eb-8539-f2f5344fecb1.png","date":"2021-05-21T15:09:33","type":"posts","category":"잡담","tag":["React(리액트)","Next.js","개발 블로그","Jekyll"],"comment":true,"publish":true},"name":"2021-05-21-jekyll-to-nextjs.md","content":"\r\n# Bye, Jekyll!\r\n\r\n<div>\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/119211743-e44a7600-baee-11eb-85d0-f21c1f68debc.png\" />\r\n</div>\r\n\r\n기존에 <a href=\"http://jekyllrb-ko.github.io/\" target=\"_blank\" class=\"pink-500\">Jekyll</a>로 운영하던 블로그를 버리고 React 기반의 <span class=\"blue-500\">Next.js</span>를 통해 블로그를 새로 개발했다.\r\n\r\nGithub Pages를 처음 접했을 때, 호스팅을 반드시 <span class=\"pink-500\">Jekyll</span> 기반으로 해야한다고 착각하고있었다. 사실 조금만 생각해보면 상관 없던건데.\r\n\r\n최근에 React를 접했는데, 생각보다 꽤나 매력적인 프레임워크라 소소하게나마 뭔가 만들어보고 싶었다.  \r\n블로그가 적절한 프로젝트(?)가 될 것 같았다. 명색이 개발자인데 블로그 하나 정도는 직접 개발해야 할 것 같기도 하고....\r\n\r\n# 굳이 멀쩡한 블로그 놔두고?\r\n\r\n한동안 안 하긴 했지만, 지금까진 <span class=\"pink-500\">Jekyll</span> 블로그를 운영하고 있었다. [Moon Theme](http://taylantatli.github.io/Moon/)를 적용해서 사용했었는데, 크고작은 불편함이 있었다.\r\n\r\n<br />\r\n\r\n1. <b class=\"green-500\">Jekyll이라는 생소한 환경</b>\r\n\r\n\tGithub의 개발언어는 <span class=\"red-500\">Ruby</span>다. 그래서일까, Github Pages의 기본 배포는 <span class=\"red-500\">Ruby</span> 기반 프레임워크인 <span class=\"pink-500\">Jekyll</span>을 따라간다.  \r\n\t문제는 한국엔 <span class=\"pink-500\">Jekyll</span>은 물론, <span class=\"red-500\">Ruby</span>라는 언어 자체의 수요가 많지 않다. 단순 블로그 하나 운영하기 위해 생판 모르는 언어를 접해야 한다는 점은 무시할 수 없는 디메리트.\r\n\r\n\t물론 <span class=\"red-500\">Ruby</span>를 직접적으로 개발하진 않지만 <span class=\"pink-500\">Jekyll</span> 생태계 또한 그리 친숙한 형태는 아니였다.\r\n\r\n2. <b class=\"green-500\">타인이 개발한 소스의 이해</b>\r\n\r\n\t1번과 같은 문제로, 밑바닥부터 <span class=\"pink-500\">Jekyll</span>을 개발할 수 없었다.  \r\n\t특정 기능에 대한 소요가 발생할 경우, 현재 테마에 어울리도록 \"**잘 디자인**\"하는 것이 중요하다. 하지만 사용자의 입장에서 테마 개발자의 디자인 철학을 이해하는 것은 단순 디자인과는 또 다른 문제. 구조 파악은 덤  \r\n\t더군다나 내 경우 모자란 실력에 이상한 강박증까지 있어서, 내 스타일로 작성되지 않은 코드의 리딩을 못 한다. 또한, 프로젝트의 블랙박스를 싫어한다. 실력은 없는 주제에 프로젝트 내에 내가 모르는 코드 덩어리가 있는 걸 굉장히 싫어한다. 디자인 감각이 좋지도 못 해서 결과물도 기존 테마와 이질적인 무언가가 나온다.\r\n\r\n3. <b class=\"green-500\">편리한 사용자 확장성, 불편한 개발자 확장성</b>\r\n\r\n\t블로그나, 웹 페이지, PPT 같은 환경에서 <span class=\"grenn-500\">테마</span>를 사용하는 이유는 뭘까? 귀찮지만 중요한 디자인에 대한 투자를 과감히 패스하면서도 준수한 디자인 퍼포먼스를 내기 위함이다. 물론 취지는 좋다. 어디까지나 **단순히 해당 테마가 의도한 방향에 맞을 때만.**\r\n\r\n\t다들 비슷한 경험이 있었을 것이다. 테마 혹은 템플릿을 사용하면서 필요에 따라 커스터마이징이 필요할 경우가 그렇다.  \r\n\t대부분의 테마는 결과물이 테마가 추구하는 디자인 철학과 상통할 때 그 빛을 발한다. 다시 말해, 그 의도가 손상될 경우 결과물의 퀄리티는 급락한다.  \r\n\t이 뿐만 아니라, <span class=\"red-500\">필요에 따라 기존의 요소(소스코드, 플러그인 등)을 제거할 경우 그 의존성을 파악하기 힘들어 리스크</span>가 크다.\r\n\r\n\t일례로, 위에서 언급한 <span class=\"lightBlue-500\">Moon Theme</span>의 경우, JQuery에 의존성을 갖고 있다.  \r\n\t근래 웹 개발의 JQuery에 대한 비관적인 평을 생각한다면, 이는 큰 디메리트로 다가온다. 제거 작업으로 인한 공수 또한 무시할 수 없을 것이고.  \r\n\t물론 당시의 개발 트렌드를 무시할 수 없으며, **개발**은 그 중에서도 트렌드의 주기가 매우 빠른 편이다. 이로 미루어 볼 때, 결과론적인 얘기다. 그럼에도 불구하고, **사용자가 의도하지 않은 결함**이라는 사실은 불변하다.\r\n\r\n4. <b class=\"green-500\">개발 욕구</b>\r\n\r\n\t정적 블로그의 경우 백엔드 영역이 거의 전무한데다, 복잡한 비즈니스 로직도 필요 없기 때문에 개발 난이도가 상대적으로 낮다고 판단했다. 즉, 원한다면 내가 직접 개발한 블로그를 사용하는게 그리 어렵지 않다.  \r\n\t위에서 언급했듯이, 직접 개발한 블로그를 사용하는 것이 좀 더 개발자스럽다. 난이도 또한 공부 중인 React를 적용하기도 적합하고.\r\n\r\n# Hello, Next.js!\r\n\r\nReact로 블로그를 만들 땐 주로 <a href=\"https://nextjs.org/\" target=\"_blank\" class=\"blue-500\">Next.js</a> 혹은 <a href=\"https://www.gatsbyjs.com/\" target=\"_blank\" class=\"deepPurple-400\">Gatsby.js</a>를 사용한다. 이번에 개발한 블로그는 <span class=\"blue-500\">Next.js</span>를 활용했다.\r\n\r\n<span class=\"blue-500\">Next.js</span>는 <span class=\"red-500\">Ruby</span>의 <span class=\"pink-500\">Jekyll</span> 프레임워크와 그 결이 비슷하다. <span class=\"pink-500\">Jekyll</span>는 **프레임워크 자체에 구조 스키마를 정함으로써 React의 Component와 유사하게 동작**한다. 그 당시의 난 React라는 걸 접하지도 않은 상황에서, React의 Component 방식으로 블로그를 구성했던 것이다. 말 그대로 낫 놓고 기역자도 모른 셈.\r\n\r\n<span class=\"blue-500\">Next.js</span> 역시 라이브러리 자체에 정적 웹을 구성하고 빌드할 수 있는 환경이 구축되어 있어, 쉽게 사용이 가능하다. 여러 사용자들이 개발한 다수의 플러그인은 덤.  \r\n덕분에 정적 블로그를 밑바닥에서부터 개발할 수 있었다. 나름대로 디자인 한다고 하긴 했는데, 역시 디자인은 어렵다.  \r\n<span class=\"blue-500\">Next.js</span>와 <span class=\"deepPurple-500\">Gatsby.js</span>에 대한 내용은 나중에 따로 다룰 예정이다.\r\n\r\n아직 해야할 것들이 남아있다. sitemap 생성기도 붙여야 하고, 연관 게시물 기능도 필요하다. 아직 다듬어지지 않은 자잘한 요소들도 있고. 역시 규모에 상관없이 무언가를 퍼블리싱하는건 정말 힘든 것 같다.  \r\n적어도 이번 블로그는 내 노력으로 내가 개발한 거니, 꾸준히 운영할 수 있었음 한다.","url":["2021-05-21-jekyll-to-nextjs","2021","05","21","jekyll-to-nextjs"]}],"categories":{"All":{"count":64,"flag":true},"RaspberryPi":{"count":3,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"page":1,"hash":"3240f7a90e7"},"__N_SSG":true}