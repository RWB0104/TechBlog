{"pageProps":{"page":{"type":"posts","prev":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true,"slug":"2021-05-30-unsupported-version-error","content":"\r\n# Unsupported major.minor version\r\n\r\n간혹 JAVA 프로그램을 실행하다보면 <span class=\"error\">Unsupported major.minor version 52</span>(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다.  \r\n<span class=\"error\">Unsupported major.minor version</span> 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.\r\n\r\n# 원인\r\n\r\nJAVA는 컴파일 언어로, 개발자가 작성한 코드는 `.java` 파일이다. 이를 컴파일하면 JVM(Java Virtual Machine, 자바 가상머신)이 읽을 수 있는 `.class` 파일로 번역한다. 코딩은 사람이 이해할 수 있는 언어로 작성하고, 실제 동작은 컴파일을 통해 컴퓨터가 이해할 수 있는 언어를 사용하는 셈이다.  \r\nJAVA는 작성일 기준으로 16까지 릴리즈됐다. JAVA의 역사가 짧지 않고, 이 시간동안 크고작은 버전 업데이트가 지속적으로 이루어졌다.  \r\n문제는 이 과정에서 생긴 호환성 문제다. 1.5 버전으로 컴파일한 `.class` 파일을 1.8 버전의 환경에서 구동한다거나, 그 반대의 경우가 그 예시다. 다행스럽게도, JAVA는 하위 버전에 대한 호환성을 보장한다. 1.8 버전의 환경에서는 1.8 이하로 컴파일된 `.class` 파일의 실행을 보장한다. 하지만 반대로 상위 버전에 대한 호환성은 제공하지 않는다. 그도 그럴 것이, 호환성을 지키기 위해선, 각 버전 간의 구성을 알맞게 변환해야 하는데, 아직 개발되지 않은 미래 버전의 구성을 알 순 없는 노릇이니...\r\n\r\n| 프로그램 JAVA 버전 | PC JAVA 버전 | Unsupported 오류 발생여부 |              해결책              |\r\n| :----------------: | :----------: | :-----------------------: | :------------------------------: |\r\n|         14         |     1.8      |             O             | JAVA 14 버전 이상으로 업그레이드 |\r\n|        1.6         |     1.7      |             X             |              칼퇴근              |\r\n\r\n즉, <span class=\"green-A400\">Unsupported major.minor version 오류는 내가 실행하려는 JAVA 코드가 내 PC의 JAVA 환경보다 높은 버전에서 컴파일된 경우 발생</span>한다.\r\n\r\n# 해결\r\n\r\n결과적으로, JAVA 버전을 동등 혹은 그 이상의 상위버전으로 업그레이드하면 된다. 크게 두 가지 방법이 있다.\r\n\r\n## 프로그램 코드의 버전 다운그레이드\r\n\r\n만약 본인이 온전한 프로그램 코드를 갖고 있을 경우, 시도해볼 수 있는 방법이다.  \r\n<span class=\"green-A400\">JAVA 버전을 다운그레이드하고 컴파일을 진행</span>하면, 프로그램의 JAVA 버전이 낮아져 기존의 버전보다 훨씬 낮은 버전의 환경에서 구동이 가능하다.\r\n\r\n단, 조건이 있다. JAVA 버전이 업그레이드됨에 따라 여러 신규 패턴, 문법 등이 추가됐다. 만약 <span class=\"red-A400\">1.8 버전부터 새로 생긴 기능을 적극적으로 활용했다면, 1.7 이하의 버전에선 컴파일 오류가 발생</span>한다.  \r\n그도 그럴것이, 1.8 부터 생긴 기능은 1.7에서는 구현되지 않은 기능이기 때문.\r\n\r\n이 경우 프로그램의 코드를 좀더 범용적인 방식으로 리팩토링해야한다.\r\n\r\n## PC의 버전 업그레이드\r\n\r\n만약 본인이 `.class` 파일만 갖고있다거나, 상기한 문제로 다운그레이드가 어려울 경우 혹은 간단한 방법을 찾을 경우 시도해볼 수 있는 방법이다.\r\n<span class=\"green-A400\">PC의 JAVA 버전을 업그레이드하고 프로그램을 실행</span>하면 된다.\r\n\r\nJAVA는 하위 호환성을 지키기 때문에, 별다른 조건이 존재하지 않는다.\r\n\r\n# 아니 버전 맞췄다고 아ㅋㅋ\r\n\r\n톰캣을 사용하다보면, 이 오류가 뜨는 경우가 있다. 그런데 간혹 PC에 설치된 JAVA 버전에 맞게 컴파일을 해줬음에도 오류가 사라지지 않는 현상이 발생하기도 한다.  \r\n이 경우 동반되는 증상이, Servlet Context에 접근할 경우, 첫 접속시 500 에러(Unsupported major.minor version 오류로 인해 발생)가 발생하고, 이후부터는 404 에러만 발생한다. 이러한 현상을 겪어보지 않았거나, 경험이 적은 개발자가 이러한 문제에 부딪히면 십중팔구 고생한다. 원인인 Unsupported major.minor version 오류가 보이지 않아 Servlet 동작의 404 오류와 관련된 정보를 검색하거나 질문하기 때문. 당연히 이러한 사정을 모르는 다른 사람들은 404 오류에 관한 답변을 줄 수 밖에 없다. 이런 경우 정말 난감하기 그지없다. 절대 경험담이라서가 아니다.\r\n\r\n혹시 위 처럼 정상적인 Servlet(서블릿)임에도 불구하고 404 오류가 뜰 경우 아래의 환경변수에서 JRE_HOME이 설정돼있는지 확인해보자.  \r\n간혹 개발 프로그램 중 임의로 JRE_HOME을 설정해버리는 프로그램이 존재한다. 문제는 여기서 발생하는데, JAVA_HOME과 JRE_HOME 환경변수가 둘 다 설정되어있을 경우, <span class=\"red-A400\">톰캣은 JRE_HOME을 우선</span>한다. 즉 JRE의 버전이 적용된다.\r\n\r\n예를 들어, JAVA_HOME이 1.8 버전, JRE_HOME이 1.6 버전이라 가정하자. 컴파일은 반드시 JDK가 필요하므로 JAVA_HOME의 버전인 1.8로 컴파일이 수행된다. 그러나 톰캣 실행 시, JRE_HOME을 우선하는 특징으로 인해 1.6 버전으로 실행된다. 결과적으로 **1.8 버전으로 컴파일된 코드를 1.6으로 실행하는 셈**이니, 버전이 맞지 않아 오류가 발생한다."},"next":-1},"group":[{"title":"[JAVA] 백준 알고리즘 1004번 어린 왕자","excerpt":"어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-22T21:42:23","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-05-22-A1004","content":"\r\n# 어린 왕자\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1004번 문제](https://www.acmicpc.net/problem/1004)\r\n\r\n# 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfcmhrjj_113gw6bcng2_b.gif\" width=\"512px\" />\r\n</p>\r\n\r\n빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.\r\n\r\n위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. (행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다고 가정한다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.)\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 (x<sub>1</sub>, y<sub>1</sub>)과 도착점 `(x<sub>2</sub>, y<sub>2</sub>)이 주어진다. 두 번째 줄에는 행성계의 개수 n이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 (c<sub>x</sub>, c<sub>y</sub>, r)이 주어진다. 입력제한은 다음과 같다. (-1000 ≤ x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, c<sub>x</sub>, c<sub>y</sub> ≤ 1000, 1 ≤ r ≤ 1000, 1 ≤ n ≤ 50)\r\n\r\n좌표와 반지름은 모두 정수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n\t2  \r\n\t-5 1 12 1  \r\n\t7  \r\n\t1 1 8  \r\n\t-3 -1 1  \r\n\t2 2 2  \r\n\t5 5 1  \r\n\t-4 5 1  \r\n\t12 1 1  \r\n\t12 1 2  \r\n\t-5 1 5 1  \r\n\t1  \r\n\t0 0 2\r\n\r\n+ 출력\r\n\r\n\t3  \r\n\t0\r\n\r\n# 풀이\r\n\r\n1002번째 알고리즘의 내용을 응용하면 쉽게 풀 수 있는 문제인 것 같다. 실제로 별다른 레퍼런스를 찾지도 않고 풀 수 있었으니.\r\n\r\n문제를 풀기 전에 몇 가지 집고 넘아갈 게 있다.  \r\n숫자들 때문에 입력의 한 세트를 착각하기 쉽다.\r\n\r\n위 예제를 기준으로 설명하면, 첫 번째 숫자는 세트의 갯수. 본문에서는 `2`이므로, 두 세트를 테스트하므로 결과는 두 줄이 출력된다.  \r\n이후 테스트에 필요한 데이터가 출력된다.\r\n\r\n-5 1 12 1 <= x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>  \r\n7 <= 행성 갯수  \r\n1 1 8 <= c<sub>x1</sub>, c<sub>y1</sub>, r<sub>1</sub>  \r\n-3 -1 1  \r\n2 2 2  \r\n5 5 1  \r\n-4 5 1  \r\n12 1 1  \r\n12 1 2 <= 행성 갯수만큼 출력됨\r\n\r\n또한, 결과는 행성계의 진입/이탈 횟수를 통틀어서 출력하므로 굳이 진입/이탈을 구분하여 저장할 필요는 없다.\r\n\r\n문제에서 **출발점에서 도착점까지 가는데 통과해야하는 행성계(이하 원, circle)의 최소**를 목적으로 두기 때문에, 반드시 통과해야하는 원만 계산하면 된다.  \r\n출발/도착점이 임의의 원 안에 포함될 경우 반드시 진입/이탈이 일어난다. 따라서, 출발/도착점을 온전히 포함하는 원의 갯수를 계산하면 진입/이탈의 횟수를 구할 수 있다.  \r\n주의할 점이 있는데, **한 원이 출발/도착점을 모두 포함할 경우 계산에서 제외**시켜야 한다.  \r\n하나의 원이 출발/도착점을 전부 포함할 경우, 원 안에서 이동하기 때문에 진입/이탈이 일어나지 않기 때문.  \r\n\r\n-그림-\r\n\r\n원리는 간단하다. 원점과 점의 거리를 계산한다. 계산한 거리가 원의 반지름보다 짧을 경우, 해당 원은 점을 포함하는 셈이다.  \r\n이를 식으로 정리하면 아래와 같다.\r\n\r\n|    변수    |      의미      |\r\n| :--------: | :------------: |\r\n|  `x`, `y`  |   원점 좌표    |\r\n| `xo`, `yo` | 원의 원점 좌표 |\r\n|    `r`     |  원의 반지름   |\r\n\r\n변수는 위 표와 같이 정의하고 식을 전개한다.\r\n\r\n-식-\r\n\r\n위 식을 코드로 표현하면 되는 비교적 간단한 알고리즘이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1004 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.24 Sat 02:15:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint length = scanner.nextInt();\r\n\t\tscanner.nextLine();\r\n\t\t\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tString base = scanner.nextLine();\r\n\t\t\t\r\n\t\t\tint x_start = Integer.parseInt(base.split(\" \")[0]);\r\n\t\t\tint y_start = Integer.parseInt(base.split(\" \")[1]);\r\n\t\t\t\r\n\t\t\tint x_end = Integer.parseInt(base.split(\" \")[2]);\r\n\t\t\tint y_end = Integer.parseInt(base.split(\" \")[3]);\r\n\t\t\t\r\n\t\t\tint through = 0;\r\n\t\t\t\r\n\t\t\tint count = scanner.nextInt();\r\n\t\t\tscanner.nextLine();\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < count; j++)\r\n\t\t\t{\r\n\t\t\t\tString circle = scanner.nextLine();\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(circle.split(\" \")[0]);\r\n\t\t\t\tint y = Integer.parseInt(circle.split(\" \")[1]);\r\n\t\t\t\tint r = Integer.parseInt(circle.split(\" \")[2]);\r\n\t\t\t\t\r\n\t\t\t\tboolean hasStartContain = hasContain(x_start, y_start, x, y, r);\r\n\t\t\t\tboolean hasEndContain = hasContain(x_end, y_end, x, y, r);\r\n\t\t\t\t\r\n\t\t\t\t// 해당 행성이 출발 혹은 도착점 중 하나만을 포함할 경우\r\n\t\t\t\tif (!(hasStartContain && hasEndContain) && (hasStartContain || hasEndContain))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrough++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(through);\r\n\t\t}\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 출발/도착점 포함 여부 반환 함수\r\n\t *\r\n\t * @param xo: [int] 출발/도착점의 x좌표\r\n\t * @param yo: [int] 출발/도착점의 y좌표\r\n\t * @param x: [int] 행성의 x좌표\r\n\t * @param y: [int] 행성의 y좌표\r\n\t * @param r: [int] 행성의 반지름\r\n\t *\r\n\t * @return [boolean] 출발/도착점 포함 여부\r\n\t */\r\n\tprivate static boolean hasContain(int xo, int yo, int x, int y, int r)\r\n\t{\r\n\t\treturn Math.sqrt(Math.pow(xo - x, 2) + Math.pow(yo - y, 2)) < r;\r\n\t}\r\n}\r\n```"},{"title":"[JAVA] 백준 알고리즘 1003번 피보나치 함수","excerpt":"다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T23:29:03","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-05-21-A1003","content":"\r\n# 피보나치 함수\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1003번 문제](https://www.acmicpc.net/problem/1003)\r\n\r\n## 조건\r\n\r\n|        시간제한         | 메모리 제한 |\r\n| :---------------------: | :---------: |\r\n| 0.25초 (추가 시간 없음) |    128MB    |\r\n\r\n## 문제\r\n\r\n다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.\r\n\r\n``` cpp\r\nint fibonacci(int n) {\r\n    if (n == 0) {\r\n        printf(\"0\");\r\n        return 0;\r\n    } else if (n == 1) {\r\n        printf(\"1\");\r\n        return 1;\r\n    } else {\r\n        return fibonacci(n‐1) + fibonacci(n‐2);\r\n    }\r\n}\r\n```\r\n\r\n`fibonacci(3)`을 호출하면 다음과 같은 일이 일어난다.\r\n\r\n* `fibonacci(3)`은 `fibonacci(2)`와 `fibonacci(1)` (첫 번째 호출)을 호출한다.\r\n* `fibonacci(2)`는 `fibonacci(1)` (두 번째 호출)과 `fibonacci(0)`을 호출한다.\r\n* 두 번째 호출한 `fibonacci(1)`은 1을 출력하고 1을 리턴한다.\r\n* `fibonacci(0)`은 0을 출력하고 0을 리턴한다.\r\n* `fibonacci(2)`는 `fibonacci(1)`과 `fibonacci(0)`의 결과를 얻고, 1을 리턴한다.\r\n* 첫 번째 호출한 `fibonacci(1)`은 1을 출력하고, 1을 리턴한다.\r\n* `fibonacci(3)`은 `fibonacci(2)`와 `fibonacci(1)`의 결과를 얻고, 2를 리턴한다.\r\n\r\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, `fibonacci(N)`을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 적성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.  \r\n각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n\t3  \r\n\t0  \r\n\t1  \r\n\t3\r\n\r\n+ 출력\r\n\r\n\t1 0  \r\n\t0 1  \r\n\t1 2\r\n\r\n# 풀이\r\n\r\n알고리즘 풀면서 느끼는 거지만, 문제가 뭘 말하는 지 이해가 안 되는 경우가 많은 것 같다. 내가 멍청해서 그런건가.\r\n\r\n이 문제를 풀기 위해선, 피보나치 수열에 대한 식을 이해하고 있어야 한다.  \r\n피보나치 수열이 `f()`일 때, `n`번째 피보나치 수열의 식은 `f(n) = f(n - 1) + f(n - 2)`로 정의할 수 있다.\r\n\r\n`n = 0, 1`일 때의 초기값이 정해져있다. (식의 특성 상 초기값이 없으면 계산할 수가 없다.)  \r\n`f(0) = 0`  \r\n`f(1) = 1`  \r\n초기값은 위와 같으며, 실질적으로 `n >= 2` 부터 의미있는 연산이 수행된다.\r\n\r\n다시 문제로 돌아가서, 임의의 수 N이 주어질 경우 `f(N)`을 수행하면서 `f(0)`, `f(1)`이 몇 번 호출되는지를 구하면 된다.  \r\n예를 들어, `N = 4`라고 가정하고 식을 전개하면 아래와 같다.  \r\n`f(4) = f(3) + f(2)`  \r\n위 식에서 `f(3)`은 `f(2) + f(1)`로 치환할 수 있으며, 같은 이유로 `f(2)` 역시 `f(1) + f(0)`으로 치환 가능하다.  \r\n`f(4) = f(2) + f(1) + f(1) + f(0)`  \r\n`= f(1) + f(0) + f(1) + f(1) + f(0)`\r\n\r\n결과적으로 `f(4) = 2(f0) + 3f(1)`로 정리할 수 있다.  \r\n따라서 이 문제의 알고리즘은 `N = 4`일 경우 `2 3`이 출력되어야 한다.\r\n\r\n우선 식을 정리하여 한 눈에 보면 문제 해결에 도움이 될 것 같다.  \r\n피보나치 수열을 쭉 정리하면 아래와 같다.\r\n\r\n|   n   | f(0)의 갯수 | f(1)의 갯수 | f(n)  |\r\n| :---: | :---------: | :---------: | :---: |\r\n|   0   |      1      |      0      |   0   |\r\n|   1   |      0      |      1      |   1   |\r\n|   2   |      1      |      1      |   1   |\r\n|   3   |      1      |      2      |   2   |\r\n|   4   |      2      |      3      |   3   |\r\n|   5   |      3      |      5      |   5   |\r\n|   6   |      5      |      8      |   8   |\r\n|   7   |      8      |     13      |  13   |\r\n|   8   |     13      |     21      |  21   |\r\n|   9   |     21      |     34      |  34   |\r\n\r\n표로 정리하니 어느정도 규칙성이 눈에 보이기 시작한다.\r\n\r\n* N의 `f(1)` 출력 갯수는 `f(N)`과 동일하다.  \r\n* N의 `f(0)` 출력 갯수는 `f(N - 1)`과 동일하다.\r\n\r\n즉, `N = 4`일 경우 알고리즘은 `f(3) f(4)`가 출력되면 된다.\r\n\r\n여기서 단순하게 생각하면 아래와 같이 코드를 짤 수 있다.\r\n\r\n## 완성....?\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[][] arr = new Integer[41][2];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// N = 0일 때, 0이 호출되는 횟수\r\n\t\tarr[0][0] = 1;\r\n\r\n\t\t// N = 0일 때, 1이 호출되는 횟수\r\n\t\tarr[0][1] = 0;\r\n\r\n\t\t// N = 1일 때, 0이 호출되는 횟수\r\n\t\tarr[1][0] = 0;\r\n\r\n\t\t// N = 1일 때, 1이 호출되는 횟수\r\n\t\tarr[1][1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tint f0 = fibonacci(n - 1);\r\n\t\t\tint f1 = fibonacci(n);\r\n\r\n\t\t\tSystem.out.println(f0 + \" \" + f1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 인덱스가 0일 경우\r\n\t\tif (n == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 1일 경우\r\n\t\telse if (n == 1)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 2 이상일 경우 (연산 가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 코드는 크게 두 가지 문제가 있는데, 우선 `n = 0, 1`일 때의 처리가 정상적으로 이루어지지 않고 있다.  \r\n`f(1) = f(0) + f(-1)`  \r\nN이 문제되기 이전에 이 코드는 런타임 시간 초과로 실패한다. 왜일까?\r\n\r\n위 코드는 **불필요한 연산을 너무 많이 수행한다.** 피보나치 수열의 특성 상 `f(N)`을 계산할 경우, `f(N - 1)`, `f(N - 2)` ... 등과 같이 N 이하의 피보나치 값까지 전부 계산하게 된다.  \r\n다시 말하면, `f(6)`을 연산할 경우 계산 과정에서 자연스레 `f(4)`, `f(2)` 등의 피보나치 값을 구할 수 있다.\r\n\r\n위 이론을 알고리즘에 적용하면 아래와 같이 응용할 수 있다.  \r\nN을 총 3번 입력한다고 가정하면 N<sub>1</sub>, N<sub>2</sub>, N<sub>3</sub>으로 구분할 수 있다.\r\n\r\nN<sub>2</sub> = 8 -> `f(8)` 부터 `f(0)`까지의 값을 구할 수 있음.  \r\nN<sub>3</sub> = 4 -> `f(4)` 부터 `f(0)`까지의 값을 구할 수 있음.\r\n\r\n피보나치 연산값을 저장하면 N<sub>n</sub> > N<sub>n+1</sub>일 경우 굳이 **추가적인 연산을 진행하지 않고 이미 저장된 값을 출력**만 함으로써, 런타임 리소스를 줄일 수 있다.\r\n\r\n클래스의 멤버변수로 **Integer 배열을 선언**하여 피보나치 수열값을 저장하고, 알고리즘 연산에 이를 활용하면 될 것 같다.\r\n\r\n> int는 Primitive(자료형) 데이터고, Integer는 Wrapper 클래스다. Wrapper 클래스는 null 입력이 가능하다는 특징이 있으므로, Integer 역시 숫자 이외에 null값을 입력할 수 있다.  \r\nInteger 배열의 초기값은 null로 지정되므로, 배열의 값이 null인 인덱스는 아직 피보나치 수열 계산이 이루어지지 않은 인덱스라고 판단할 수 있다.\r\n\r\n다행히 문제에서 주어진 `N`의 조건은 `0 <= N <= 40`이므로, 배열의 인덱스는 최대 41을 넘지 않음을 알 수 있다.  \r\n(배열은 0부터 시작하므로 40개가 아닌 0을 포함한 41개임에 유의하자)\r\n\r\n이후 피보나치 연산에서 각 과정의 값을 배열에 저장하는 로직을 추가한다.  \r\n배열의 값이 null일 경우, 아직 연산이 진행되지 않았으므로 피보나치 연산을 수행하고 배열에 저장한다.  \r\n반대로, 배열이 특정 숫자값을 가질 경우, 이미 연산이 진행된 인덱스이므로 별도의 연산을 거치지 않고 해당 값을 바로 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\npackage all.a1003;\r\n\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[] arr = new Integer[41];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 0)\r\n\t\tarr[0] = 0;\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 1)\r\n\t\tarr[1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tfibonacci(n);\r\n\r\n\t\t\t// n이 0일 경우\r\n\t\t\tif (n == 0)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"1 0\");\r\n\t\t\t}\r\n\r\n\t\t\t// n이 1일 경우\r\n\t\t\telse if (n == 1)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"0 1\");\r\n\t\t\t}\r\n\r\n\t\t\t// 초기값이 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(new StringBuffer().append(arr[n - 1]).append(\" \").append(arr[n]).toString());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscanner.close();\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 해당 인덱스의 피보나치가 아직 연산되지 않았을 경우\r\n\t\tif (arr[n] == null)\r\n\t\t{\r\n\t\t\tarr[n] = fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\r\n\t\treturn arr[n];\r\n\t}\r\n}\r\n```"},{"title":"[JAVA] 백준 알고리즘 1002번 터렛","excerpt":"조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:56:10","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-05-21-A1002","content":"\r\n# 터렛\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1002번 문제](https://www.acmicpc.net/problem/1002)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg\" width=\"128px\" />\r\n</p>\r\n\r\n이석원은 조규현과 백승환에게 상대편 마린(류재영)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.  \r\n조규현의 좌표 (x<sub>1</sub>, y<sub>2</sub>)와 백승환의 좌표 (x<sub>2</sub>, y<sub>2</sub>)가 주어지고, 조규현이 계산한 류재명과의 거리 r<sub>1</sub>과 백승환이 계산한 류재명과의 거리 r<sub>2</sub>가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.  \r\n한 줄에 x<sub>1</sub>, y<sub>1</sub>, r<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, r<sub>2</sub>가 주어진다. x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 점수이고, r<sub>1</sub>, r<sub>2</sub>는 10,000보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n\t3  \r\n\t0 0 13 40 0 37  \r\n\t0 0 30 0 7 4  \r\n\t1 1 1 1 1 5\r\n\r\n+ 출력\r\n\r\n\t2  \r\n\t1  \r\n\t0\r\n\r\n# 풀이\r\n\r\n예제의 요소를 사람 이름으로 두었으나, 문제 이해에 방해가 되니 간단하게 서술하면 아래와 같다.  \r\n임의의 위치에 있는 점 A, B, C가 존재하며, A와 C의 거리, B와 C의 거리가 주어진다.  \r\n이 때, C가 실제로 위치할 수 있는 점의 갯수를 구하는 것. 즉, 간단하게 **두 원의 접점을 구하는 문제**라고 정의할 수 있다.  \r\n원이 완벽하게 겹칠 경우, **그 수가 무수히 많으므로 -1로 표현**하라는 조건이 포함된다.\r\n\r\n이를 그림으로 표현하면 아래와 같다.  \r\n[대충 원 그림]\r\n\r\n변수는 아래와 같이 정리할 수 있다.\r\n\r\n|   n   | x<sub>n</sub> | y<sub>n</sub> | r<sub>n</sub> |\r\n| :---: | :-----------: | :-----------: | :-----------: |\r\n|   1   |   A의 x좌표   |   A의 y좌표   |  A의 반지름   |\r\n|   2   |   B의 x좌표   |   B의 y좌표   |  B의 반지름   |\r\n\r\n케이스를 세분화하면 총 6가지로 나눌 수 있다.\r\n\r\n1. 두 원이 정확히 겹칠 경우 (-1)\r\n2. 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n3. 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n4. 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n5. 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n6. 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\r\n본 풀이에선 x<sub>1</sub>, y<sub>1</sub>과 x<sub>2</sub>, y<sub>2</sub>의 거리(`distance`) 및 r<sub>1</sub>, r<sub>2</sub>를 합한 길이(`sum`)와 뺀 길이(`sub`)의 절대값을 이용하여 진행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://latex.codecogs.com/svg.latex?%5Cfn_phv%20%7B%5Ccolor%7BWhite%7D%20distance%20=%20%5Csqrt%7B%28x_%7B1%7D%20-%20x_%7B2%7D%29%5E%7B2%7D%20&plus;%20%28y_%7B1%7D%20-%20y_%7B2%7D%29%5E%7B2%7D%7D%7D\" />\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://latex.codecogs.com/svg.latex?%5Cfn_phv%20%7B%5Ccolor%7BWhite%7D%20sum%20%3D%20r_%7B1%7D%20&plus;%20r_%7B2%7D%7D\" />\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://latex.codecogs.com/svg.latex?%5Cfn_phv%20%7B%5Ccolor%7BWhite%7D%20sub%20%3D%20%5Cleft%20%7C%20r_%7B1%7D%20-%20r_%7B2%7D%20%5Cright%20%7C%7D\" />\r\n</p>\r\n\r\n* case 1 - 두 원이 정확히 겹칠 경우\r\n\r\n\t두 원의 위치 및 반지름이 서로 동일한 상황.  \r\n\t`distance`가 0이며, r<sub>1</sub>과 r<sub>2</sub>의 길이가 동일할 경우 성립한다.\r\n\r\n* case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이보다 짧은 상황.  \r\n\t`distance < sub`일 경우 성립한다.\r\n\r\n* case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합보다 긴 상황.  \r\n\t`distance > sum`일 경우 성립한다.\r\n\r\n* case 4 - 두 원이 서로 겹치면서 인접하는 경우\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이와 일치하는 상황.  \r\n\t`distance == sub`일 경우 성립한다.\r\n\r\n* case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합과 일치하는 상황.  \r\n\t`distance == sum`일 경우 성립한다.\r\n\r\n* case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\r\n\t두 원이 서로 적당히 겹치는 상황.  \r\n\t`distance < sum && distance > sub`일 경우 성립한다.\r\n\r\n굳이 식으로 표현하지 않아도, 위의 5개 케이스에 부합하지 않는 모든 상황에 적용하면 된다.  \r\n위 케이스들을 `if`문을 사용하여 적절히 표현하면 된다. `switch`문의 경우 하나의 변수를 기준으로 분기를 판단하므로 해당 알고리즘에 적용하기엔 다소 부적절하다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1002 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:56:10\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint x1 = scanner.nextInt();\r\n\t\t\tint y1 = scanner.nextInt();\r\n\t\t\tint r1 = scanner.nextInt();\r\n\r\n\t\t\tint x2 = scanner.nextInt();\r\n\t\t\tint y2 = scanner.nextInt();\r\n\t\t\tint r2 = scanner.nextInt();\r\n\r\n\t\t\tSystem.out.println(calcPoints(x1, y1, r1, x2, y2, r2));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 접점 갯수 반환 함수\r\n\t *\r\n\t * case 1 - 두 원이 정확히 겹칠 경우 (-1)\r\n\t * case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n\t * case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n\t * case 4 - 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n\t * case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n\t * case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\t *\r\n\t * @param x1: [int] A의 x좌표\r\n\t * @param y1: [int] A의 y좌표\r\n\t * @param r1: [int] A와 C 사이의 거리\r\n\t * @param x2: [int] B의 x좌표\r\n\t * @param y2: [int] B의 y좌표\r\n\t * @param r2: [int] B와 C 사이의 거리\r\n\t *\r\n\t * @return [int] 접점 갯수\r\n\t */\r\n\tprivate static int calcPoints(int x1, int y1, int r1, int x2, int y2, int r2)\r\n\t{\r\n\t\t// 두 점 사이의 거리 계산식\r\n\t\tdouble distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n\r\n\t\tint sum = r1 + r2;\r\n\t\tint sub = Math.abs(r1 - r2);\r\n\r\n\t\t// case 1 - 두 원이 정확히 겹칠 경우\r\n\t\tif (distance == 0 && r1 == r2)\r\n\t\t{\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse if (distance < sub)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우\r\n\t\telse if (distance > sum)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// case 4 - 두 원이 서로 겹치면서 인접하는 경우\r\n\t\telse if (distance == sub)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우\r\n\t\telse if (distance == sum)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t}\r\n}\r\n```"},{"title":"[JAVA] 백준 알고리즘 1001번 A - B","excerpt":"두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:51:19","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-05-21-A1001","content":"\r\n# A - B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1001번 문제](https://www.acmicpc.net/problem/1001)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)\r\n\r\n## 출력\r\n\r\n첫째 줄에 A - B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n\t3 2\r\n\r\n+ 출력\r\n\r\n\t1\r\n\r\n# 풀이\r\n\r\n1000번 문제에서 연산만 달라지는 뺄셈 알고리즘\r\nScanner로 두 숫자를 입력받아 뺄셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1001 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:51:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\r\n\t\tscanner.close();\r\n\r\n\t\tSystem.out.println(a - b);\r\n\t}\r\n}\r\n```"},{"title":"[JAVA] 백준 알고리즘 1000번 A + B","excerpt":"두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:38:17","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-05-21-A1000","content":"\r\n# A + B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1000번 문제](https://www.acmicpc.net/problem/1000)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. `(0 < A, B < 10)`\r\n\r\n## 출력\r\n\r\n첫째 줄에 A + B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n\t1 2\r\n\r\n+ 출력\r\n\r\n\t3\r\n\r\n# 풀이\r\n\r\n알고리즘이라고 하기 뭐한 기초적인 연산 알고리즘\r\nScanner로 두 숫자를 입력받아 덧셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1000 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:38:17\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\r\n\t\tscanner.close();\r\n\r\n\t\tSystem.out.println(a + b);\r\n\t}\r\n}\r\n```"},{"title":"백준 알고리즘 시작하기","excerpt":"코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다. 그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다. 풀이의 규칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-05-21-start-beakjoon","content":"\r\n# 백준 알고리즘\r\n\r\n코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다.\r\n\r\n그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다.\r\n\r\n풀이의 규칙은 아래와 같다.\r\n\r\n1. 가급적 문제번호 순서대로 진행한다.\r\n2. 기본 언어는 <span class=\"orange-A400\">JAVA</span>로 진행한다.\r\n3. 원리는 과하다 싶을 정도로 최대한 자세하게 적는다.\r\n4. 번은 개인주의야\r\n5. 숏코딩을 지양하고, 이해하기 쉽도록 성능이 허락하는 선에서 풀어 쓴다.\r\n6. 주석을 적극 활용한다.\r\n7. 채점결과가 반드시 <b class=\"green-A400\">맞았습니다!!</b>인 코드를 기준으로 한다.\r\n8. 풀이에 제시되는 코드는 그대로 복사해도 알고리즘 풀이가 가능하도록 코딩한다.\r\n9. 신명호는 놔둔다."}],"post":{"title":"[JAVA] 백준 알고리즘 1005번 ACM Craft","excerpt":"서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-01T01:27:56","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","위상정렬"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-06-01-A1005","content":"<h1 id=\"acm-craft\"><a href=\"#acm-craft\" class=\"head-link\"><span>🔗</span></a>ACM Craft</h1>\n<p><img src=\"https://shields.io/badge/java-JDK%2014-lightgray?logo=java&#x26;style=plastic&#x26;logoColor=white&#x26;labelColor=orange\" alt=\"JAVA\"></p>\n<p>🔗 <a href=\"https://www.acmicpc.net/problem/1005\">전체 1005번 문제</a></p>\n<h1 id=\"조건\"><a href=\"#%EC%A1%B0%EA%B1%B4\" class=\"head-link\"><span>🔗</span></a>조건</h1>\n<table>\n<thead>\n<tr>\n<th align=\"center\">시간제한</th>\n<th align=\"center\">메모리 제한</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1초</td>\n<td align=\"center\">512MB</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"문제\"><a href=\"#%EB%AC%B8%EC%A0%9C\" class=\"head-link\"><span>🔗</span></a>문제</h2>\n<p>서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다.</p>\n<p>이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.</p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219763-b1cf1480-c276-11eb-8131-a3471db1cfc4.png\" width=\"1024px\" />\r\n</p>\n<p>위의 예시를 보자.</p>\n<p>이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할 수 있다. (동시에 진행이 가능하다.) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번 건물의 건설을 시작할 수 있다.</p>\n<p>따라서 4번 건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물와 3번 건물을 동시에 건설하기 시작하면 2번은 1초 뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을 수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.</p>\n<p>프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM Craft 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정 건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정 건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.</p>\n<h2 id=\"입력\"><a href=\"#%EC%9E%85%EB%A0%A5\" class=\"head-link\"><span>🔗</span></a>입력</h2>\n<p>첫째 줄에는 테스트케이스의 갯수 <code>T</code>가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다, 첫째 줄에 건물의 갯수 <code>N</code>과 건물 간의 건설순서 규칙의 총 갯수 <code>K</code>가 주어진다.(전물의 번호는 1번 부터 N번 까지 존재한다.)</p>\n<p>둘째 줄에는 각 건물 당 건설에 걸리는 시간 D가 공백을 사이로 주어진다. 셋째 줄부터 <code>K + 2</code>줄 까지 건설순서 <code>X</code> <code>Y</code>가 주어진다.(이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다.)</p>\n<p>마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.</p>\n<h2 id=\"출력\"><a href=\"#%EC%B6%9C%EB%A0%A5\" class=\"head-link\"><span>🔗</span></a>출력</h2>\n<p>건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.<br>\n건설순서는 모든 건물이 건설 가능하도록 주어진다.</p>\n<h2 id=\"제한\"><a href=\"#%EC%A0%9C%ED%95%9C\" class=\"head-link\"><span>🔗</span></a>제한</h2>\n<ul>\n<li><code>2 ≤ N ≤ 1,000</code></li>\n<li><code>1 ≤ K ≤ 100,000</code></li>\n<li><code>1 ≤ X, Y, W ≤ N</code></li>\n<li><code>0 ≤ D ≤ 100,000)</code> D는 정수</li>\n</ul>\n<h2 id=\"케이스\"><a href=\"#%EC%BC%80%EC%9D%B4%EC%8A%A4\" class=\"head-link\"><span>🔗</span></a>케이스</h2>\n<h3 id=\"예제-1\"><a href=\"#%EC%98%88%EC%A0%9C-1\" class=\"head-link\"><span>🔗</span></a>예제 1</h3>\n<ul>\n<li>\n<p>입력</p>\n<p>2<br>\n4 4<br>\n10 1 100 10<br>\n1 2<br>\n1 3<br>\n2 4<br>\n3 4<br>\n4<br>\n8 8<br>\n10 20 1 5 8 7 1 43<br>\n1 2<br>\n1 3<br>\n2 4<br>\n2 5<br>\n3 6<br>\n5 7<br>\n6 7<br>\n7 8<br>\n7</p>\n</li>\n<li>\n<p>출력</p>\n<p>120<br>\n39</p>\n</li>\n</ul>\n<h3 id=\"예제-2\"><a href=\"#%EC%98%88%EC%A0%9C-2\" class=\"head-link\"><span>🔗</span></a>예제 2</h3>\n<ul>\n<li>\n<p>입력</p>\n<p>5<br>\n3 2<br>\n1 2 3<br>\n3 2<br>\n2 1<br>\n1<br>\n4 3<br>\n5 5 5 5<br>\n1 2<br>\n1 3<br>\n2 3<br>\n4<br>\n5 10<br>\n100000 99999 99997 99994 99990<br>\n4 5<br>\n3 5<br>\n3 4<br>\n2 5<br>\n2 4<br>\n2 3<br>\n1 5<br>\n1 4<br>\n1 3<br>\n1 2<br>\n4<br>\n4 3<br>\n1 1 1 1<br>\n1 2<br>\n3 2<br>\n1 4<br>\n4<br>\n7 8<br>\n0 0 0 0 0 0 0<br>\n1 2<br>\n1 3<br>\n2 4<br>\n3 4<br>\n4 5<br>\n4 6<br>\n5 7<br>\n6 7<br>\n7</p>\n</li>\n<li>\n<p>출력</p>\n<p>6<br>\n5<br>\n399990<br>\n2<br>\n0</p>\n</li>\n</ul>\n<h1 id=\"풀이\"><a href=\"#%ED%92%80%EC%9D%B4\" class=\"head-link\"><span>🔗</span></a>풀이</h1>\n<p>문제는 이해가 되는데, 이를 코딩으로 풀어내기가 어려웠던 알고리즘. <span class=\"primary\">위상정렬</span> 알고리즘에 대한 이해가 있어야한다.<br>\n문제의 경우, 스타크래프트의 건물 테크트리랑 비슷한 개념으로 접근하면 된다. 군수공장을 짓기 위해선 병영을 지어야하는 것처럼, 요구 트리가 있는 건물의 경우 해당 건물을 반드시 완료해야 하며, 하나의 건물이 여러 요구 트리를 가질 경우도 존재한다. 물론 이 경우 요구하는 건물들을 <strong>모두</strong> 건설한 뒤에 건설 가능하다. 요구하는 건물들 중 하나만 건설하면 충족되는게 아니다.</p>\n<p><span class=\"primary\">위상정렬</span>은 <span class=\"green-A400\">순서가 정해진 작업을 수행할 때, 이 순서를 결정하는 알고리즘</span>이다. <span class=\"primary\">위상정렬</span>은 반드시 DAG(Directed Acyclic Graph, 유향 비순환 그래프) 형태여야 한다. 즉, 순서를 도식화했을 때 반드시 <span class=\"red-A400\">시작/도착점이 존재</span>해야 한다. 시작/도착점이 구분되지 않는 순환 형태일 경우 위상정렬을 적용할 수 없다.</p>\n<p>위상정렬은 순서를 정하는 알고리즘이고, 순서도의 형태에 따라 여러가지의 답이 나올 수 있다. 이 문제는 최적의 답을 도출하기 위해 각 <strong>건물을 건설하는데 필요한 요구 건물</strong>과 <strong>건설 시간</strong>을 적용했다.</p>\n<p>다음 건물을 건설하기 위해선 요구 건물을 모두 건설해야하므로 요구 건물의 건설시간이 가장 많은 건물이 다음 순서가 된다.</p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219453-3b321700-c276-11eb-9029-ec105c694854.png\" width=\"1024px\" />\r\n</p>\n<p>예시 1번의 두 번째 케이스를 예시로 하여 위상정렬을 도식화하면 위 사진과 같다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<p>위 표는 도식를 수치화하여 정리한 것이다.</p>\n<br />\n<p><span class=\"large orange-A400\">1. 순서의 시작점(진입선이 없는 점)을 찾는다. 시작점이 여러개일 경우 시작점 중 무작위로 하나를 선택해도 무방하다. (위 예시는 시작점이 하나)</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219469-4127f800-c276-11eb-91c8-db36e543c217.png\" width=\"1024px\" />\r\n</p>\n<br />\n<p><span class=\"large orange-A400\">2. 시작점 1을 큐에 넣고, 시작점에 연결된 진출선을 전부 제거한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219471-438a5200-c276-11eb-9cd3-ca5f31dfb19b.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n</tr>\n</thead>\n</table>\n<p>이 과정에서 2와 3이 새로운 시작점이 된 것을 확인할 수 있다.</p>\n<p>1을 건설하는데 걸리는 시간은 1초.</p>\n<br />\n<p><span class=\"large orange-A400\">3. 2에 대해 2번 과정을 적용한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219484-45ecac00-c276-11eb-8114-a6c4c8b17036.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n</tr>\n</thead>\n</table>\n<p>4와 5의 진입선이 0이 된다. 즉, 4와 5를 건설할 수 있게 된다.</p>\n<p>2를 건설하는데는 <code>10(1) + 20(2)</code>로 총 30초가 소요된다.</p>\n<br />\n<p><span class=\"large orange-A400\">4. 3에 대해 2번 과정을 적용한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219493-48e79c80-c276-11eb-8f48-cf132cab8f5c.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n</tr>\n</thead>\n</table>\n<p>6의 진입선이 0이 된다. 6을 건설할 수 있게 된다.</p>\n<p>3의 건설시간은 <code>10(1) + 1(3)</code>으로 총 11초.</p>\n<br />\n<p><span class=\"large orange-A400\">5. 4에 대해 2번 과정을 적용한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219504-4be28d00-c276-11eb-9b40-07c5ea51cbd9.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n</tr>\n</thead>\n</table>\n<p>4는 진출선이 없으므로 큐에만 추가된다.</p>\n<p>4의 건설시간은 <code>10(1) + 20(2) + 5(4)</code>로 총 35초</p>\n<br />\n<p><span class=\"large orange-A400\">6. 5에 대해 2번 과정을 적용한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219509-4edd7d80-c276-11eb-9c5f-fc17d373bf50.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n</tr>\n</thead>\n</table>\n<p>7이 5와 6에 연결되어 있으므로, 7의 진입선은 1이 된다. 아직 7을 건설할 수 없다.</p>\n<p>5의 건설시간은 <code>10(1) + 20(2) + 8(5)</code>로 총 38초</p>\n<br />\n<p><span class=\"large orange-A400\">7. 6에 대해 2번 과정을 적용한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219520-53099b00-c276-11eb-9c99-060dcd2039d8.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n</tr>\n</thead>\n</table>\n<p>7의 진입선이 0이 된다. 7을 건설할 수 있게 된다.</p>\n<p>6의 건설시간은 <code>10(1) + 1(3) + 7(6)</code>으로 총 18초.</p>\n<br />\n<p><span class=\"large orange-A400\">8. 7에 대해 2번 과정을 적용한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219527-56048b80-c276-11eb-866b-9b411445b22b.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n</tr>\n</thead>\n</table>\n<p>8의 진입선이 0이 된다.</p>\n<p>1 ~ 6까지는 요구 건물이 하나였지만, 7은 두개이다. 앞서 언급했듯이, 5와 6 중 건설시간이 더 긴 것을 기준으로 계산해야한다.</p>\n<p>즉, 7의 건설시간은 <code>10(1) + 20(2) + 8(5) + 1(7)</code>로 총 39초</p>\n<p>5번을 기준으로 계산하므로, <span class=\"red-A400\">6번과 중간인 3번은 계산에서 제외</span>된다. 만약, 3의 건설시간을 1초에서 4초로 증가시켜도 결과에 영향을 미치지 않는다. 3의 건설시간을 무시하기 때문이다. 단, 3의 건설시간이 너무 커지게되면 5보다 6의 건설시간이 같이 커지게 되어 결과에 영향을 미치게 된다.</p>\n<br />\n<p><span class=\"large orange-A400\">9. 8에 대해 2번 과정을 적용한다.</span></p>\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219535-58ff7c00-c276-11eb-907c-2a90cc84c596.png\" width=\"1024px\" />\r\n</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">노드</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">진입선</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n</tr>\n<tr>\n<td align=\"center\">시간</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">43</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">큐</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n</tr>\n</thead>\n</table>\n<p>문제는 7에 대한 건설시간을 요구하고 있으므로 8은 무시해도 무방하다.\r\n8의 건설시간은 <code>10(1) + 20(2) + 8(5) + 1(7) + 43(8)</code>로 총 82초</p>\n<h2 id=\"전체-소스\"><a href=\"#%EC%A0%84%EC%B2%B4-%EC%86%8C%EC%8A%A4\" class=\"head-link\"><span>🔗</span></a>전체 소스</h2>\n<p><code>time</code>, <code>matrix</code>, <code>link</code>의 배열 크기가 <code>N + 1</code>이다. 별다른 이유는 아니고, 건물은 1번부터 시작하는데 배열은 0번부터 시작한다. 이러한 차이에서 오는 혼란을 방지하기 위해 건물이 총 4개면 배열의 크기를 5로(0, 1, 2, 3, 4, 5)로 지정하여 0을 제외하고 1부터 사용한다.</p>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">LinkedList</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Queue</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Scanner</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 백준 전체 1005 문제 알고리즘 클래스\n *\n * <span class=\"token keyword\">@author</span> RWB\n * <span class=\"token keyword\">@since</span> 2021.05.31 Mon 19:11:58\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token doc-comment comment\">/**\n\t * 메인 함수\n\t *\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">args</span>: [String[]] 매개변수\n\t */</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Scanner</span> scanner <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Scanner</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token class-name\">StringBuilder</span> builder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 케이스 갯수</span>\n\t\t<span class=\"token keyword\">int</span> <span class=\"token class-name\">T</span> <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">// 건물 갯수</span>\n\t\t\t<span class=\"token keyword\">int</span> <span class=\"token class-name\">N</span> <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 규칙(건설시간) 갯수</span>\n\t\t\t<span class=\"token keyword\">int</span> <span class=\"token class-name\">K</span> <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 건물별 건설시간 배열</span>\n\t\t\t<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> time <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 건물별 연결여부 배열</span>\n\t\t\t<span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> maxtrix <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 건물별 연결 갯수 배열</span>\n\t\t\t<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> link <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&#x3C;</span> <span class=\"token class-name\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\ttime<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&#x3C;</span> <span class=\"token class-name\">K</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token comment\">// 하위 건물</span>\n\t\t\t\t<span class=\"token keyword\">int</span> <span class=\"token class-name\">X</span> <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\t<span class=\"token comment\">// 상위 건물</span>\n\t\t\t\t<span class=\"token keyword\">int</span> <span class=\"token class-name\">Y</span> <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\tmaxtrix<span class=\"token punctuation\">[</span><span class=\"token class-name\">X</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">Y</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t\t\tlink<span class=\"token punctuation\">[</span><span class=\"token class-name\">Y</span><span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 목표 건물</span>\n\t\t\t<span class=\"token keyword\">int</span> <span class=\"token class-name\">W</span> <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\tbuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token function\">calcTopologicalSort</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">,</span> maxtrix<span class=\"token punctuation\">,</span> link<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">W</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>builder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\tscanner<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token doc-comment comment\">/**\n\t * 위상정렬 결과 반환 함수\n\t *\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">time</span>: [int[]] 건물별 건설시간\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">matrix</span>: [boolean[][]] 건물별 연결여부\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">link</span>: [int[]] 건물별 연결 갯수\n\t *\n\t * <span class=\"token keyword\">@return</span> [int[]] 건물별 종 건설시간 배열\n\t */</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">calcTopologicalSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> time<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> matrix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> link<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Queue</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> queue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>link<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> link<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">// 요구 건물이 없는 건물일 경우</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>link<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\tresult<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> time<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\tqueue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>queue<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">// 하위 건물</span>\n\t\t\t<span class=\"token keyword\">int</span> prev <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> link<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token comment\">// 하위 건물 건설을 요구 하는 건물일 경우</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t\tresult<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> time<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t\n\t\t\t\t\t<span class=\"token comment\">// 해당 건물의 요구 건물 갯수 1 감소</span>\n\t\t\t\t\t<span class=\"token operator\">--</span>link<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t\n\t\t\t\t\t<span class=\"token comment\">// 요구 건물이 없는 건물일 경우</span>\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>link<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t\t\tqueue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n"}},"__N_SSG":true}