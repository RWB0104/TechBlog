{"pageProps":{"posts":[{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1011번 Fly me to the Alpha Centauri","excerpt":"우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다. 그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k - 1 , k 혹은 k + 1 광년만을 다시 이동할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-11T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-11-a1011.md","content":"\r\n# 다리 놓기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1011번 문제](https://www.acmicpc.net/problem/1011)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.\r\n\r\n그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 $k$광년을 이동하였을 때는 $k - 1$ , $k$ 혹은 $k + 1$ 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/rlaehdgur.JPG\" width=\"600px\" />\r\n</p>\r\n\r\n김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 $x$지점에서 $y$지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 $y$지점에 도착해서도 공간 이동장치의 안전성을 위하여 $y$지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.\r\n\r\n김우현을 위해 $x$지점부터 정확히 $y$지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $T$가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 $x$와 목표 위치 $y$가 정수로 주어지며, $x$는 항상 $y$보다 작은 값을 갖는다. $(0 ≤ x < y < 2^31)$\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 $x$지점으로부터 $y$지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0 3\r\n1 5\r\n45 50\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n3\r\n4\r\n```\r\n\r\n# 풀이\r\n\r\nFrank Sinatra의 [Fly me to the moon](https://www.youtube.com/embed/ZEcqHA7dbwM)을 오마주한 제목인 거 같다.\r\n\r\n<p align=\"center\">\r\n\t<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZEcqHA7dbwM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\r\n</p>\r\n\r\n시나트라를 Fallout NV의 Blue Moon으로 처음 접했었는데, 그 후에 Come fly with me나 Theme from Newyork Newyork 같이 좋은 곡들이 너무 많아서 자주 듣는 편이다.\r\n\r\n문제로 돌아와서, 러프하게 보면 \"무작정 빨리가면 되지 않나?\"라고 생각할 수 있다. 하지만 아래 두 조건이 발목을 잡는다.\r\n\r\n1. 처음, 끝 구간은 반드시 <span class=\"primary\">한 칸만 워프</span>할 수 있다.\r\n2. $k$만큼 이동할 경우, <span class=\"primary\">$k - 1$ ~ $k + 1$만큼만 이동 가능</span>함\r\n3. 반드시 <span class=\"primary\">정확한 지점에 도착</span>해야함 (통과 X)\r\n\r\n위 조건들 때문에 새벽 2시 강남의 \"과학\"마냥 쏘다니면 안 된다.\r\n\r\n경우의 수는 아니고, 정해진 규칙이 있으니 이를 계산하여 순서대로 나열하면 단서를 발견할 수 있을 것 같다.\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   2   | 1 1           |     2     |\r\n|   3   | 1 1 1         |     3     |\r\n|   4   | 1 2 1         |     3     |\r\n|   5   | 1 2 1 1       |     4     |\r\n|   6   | 1 2 2 1       |     4     |\r\n|   7   | 1 2 2 1 1     |     5     |\r\n|   8   | 1 2 2 2 1     |     5     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  10   | 1 2 3 2 1 1   |     6     |\r\n|  11   | 1 2 3 2 2 1   |     6     |\r\n|  12   | 1 2 3 3 2 1   |     6     |\r\n|  13   | 1 2 3 3 2 1 1 |     7     |\r\n|  14   | 1 2 3 3 2 2 1 |     7     |\r\n|  15   | 1 2 3 3 3 2 1 |     7     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n잘 안 보일 수도 있으나, 규칙성 찾을 때 가장 만만한 제곱수(1, 4, 9...)를 기준으로 규칙을 정의할 수 있다. 특징은 아래와 같다.\r\n\r\n* 제곱수 이후로 가동 횟수가 1 증가한다.\r\n* 현재 제곱수와 다음 제곱수의 중간에서 가동 횟수가 1 증가한다.\r\n\r\n즉, 제곱수 이후로 가시적인 변화가 있으며, 제곱수를 기준으로 구간의 중간에서 가동률이 1 증가한다.\r\n\r\n### 제곱수의 가동 횟수 일반식\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   4   | 1 2 1         |     3     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n제곱수의 가동률은 아래와 같다. 제곱수 $n$의 가동 횟수 일반식은 아래와 같다.\r\n\r\n$$\r\n2\\sqrt{n} - 1\r\n$$\r\n\r\n9의 경우 $2 * 3 - 1 = 5$이므로 식이 성립함을 알 수 있다.\r\n\r\n### 제곱수가 아닌 수의 가동 횟수 일반식\r\n\r\n제곱수 사이의 중간에서 가동 횟수가 바뀌므로, 이 중간값을 계산하면 된다. 제곱수가 아닌 일반적인 숫자 $k$가 있다고 가정하자. 이 규칙은 제곱수를 중심으로 돌아가므로, $k$를 통해 제곱수를 구해야 한다. 구해야 할 요소는 아래와 같다.\r\n\r\n* $k$보다 크면서 가장 가까운 제곱수\r\n* $k$가 속한 제곱수 구간의 중간값\r\n\r\n1. $k$에 제곱근 연산을 수행하고 이를 반올림한다. $k$보다 크면서 $k$와 가장 가까운 제곱수의 제곱근 $\\sqrt{n}$이 계산된다.\r\n2. $\\sqrt{n}$을 제곱하여 가장 근접한 제곱수 $n$을 계산한다.\r\n3. $n - \\sqrt{n}$의 식으로 $k$가 속한 제곱수 구간의 중간값$t$을 계산한다.\r\n4. $k > t$일 경우, $n$의 가동 횟수와 동일한 $2\\sqrt{n} - 1$식을 적용한다.\r\n5. $k <= t$일 경우, $n$의 가동 횟수에서 1을 뺀 $2\\sqrt{n} - 2$식을 적용한다.\r\n\r\n위 방법을 토대로 7의 가동 횟수를 계산해보자.\r\n\r\n$\\sqrt{7} \\fallingdotseq 2.646$이므로, 이를 반올림하면 3이 계산된다. 즉, 7보다 크면서 가장 가까운 제곱수는 $3^2 = 9$다.\r\n\r\n$9 - \\sqrt{9} = 9 - 3 = 6$이므로, $k$가 속한 제곱수 구간의 중간값은 6이다. 숫자가 6보다 클 경우 9와 가동 횟수가 동일하다. 주어진 숫자는 7이므로 9의 가동 횟수와 동일하다.\r\n\r\n9의 가동횟수는 $2\\sqrt{9} - 1 = 6 - 1 = 5$이므로 7의 가동 횟수 역시 5가 된다.\r\n\r\n위 절차를 코드로 녹여내면 된다. 코드 구현 난이도는 낮다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1011 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/11/a1011\">1011 풀이</a>\r\n * @since 2021.06.11 Fri 09:06:34\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 현재 위치\r\n\t\t\tdouble x = Double.parseDouble(temp[0]);\r\n\t\t\t\r\n\t\t\t// 목표 위치\r\n\t\t\tdouble y = Double.parseDouble(temp[1]);\r\n\t\t\t\r\n\t\t\t// x, y 사이의 거리\r\n\t\t\tdouble distance = y - x;\r\n\t\t\t\r\n\t\t\tSystem.out.println(solve(distance));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가동횟수 반환 함수\r\n\t *\r\n\t * @param distance: [double] 거리\r\n\t *\r\n\t * @return [int] 가동횟수\r\n\t */\r\n\tprivate static int solve(double distance)\r\n\t{\r\n\t\tint result;\r\n\t\t\r\n\t\tdouble ref = Math.sqrt(distance);\r\n\t\t\r\n\t\t// 제곱수일 경우\r\n\t\tif (ref % 1 == 0)\r\n\t\t{\r\n\t\t\tresult = (int) (2 * ref - 1);\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tdouble next = Math.ceil(ref);\r\n\t\t\t\r\n\t\t\t// 이전 제곱수와 다음 제곱수의 중간보다 큰 수일 경우\r\n\t\t\tif (distance > Math.pow(next, 2) - next)\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 2);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n주의할 점이 하나 있는데, $x$와 $y$의 최대값이 $2^31$이다. int의 최대값은 2,147,483,647이지만, $2^31$은 2,147,483,64<span class=\"red-A200\">8</span>이므로 $x$, $y$의 거리 계산 시 int를 사용하면 안 된다. 결과만 int형으로 출력해야 한다.\r\n\r\n메모이제이션을 적용할까 했지만, 배열을 $2^31$ 크기만큼 초기화해야 하므로 오히려 오버헤드가 더 심하게 발생할 것 같다. 재귀함수도 아니니 메모이제이션을 적용해도 별차이 없을 것 같다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-11-a1011","2021","06","11","a1011"]}],"categories":{"WEB":{"count":3,"flag":true},"CS":{"count":10,"flag":true},"알고리즘":{"count":30,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false},"잡담":{"count":1,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"SILVER I","page":1},"__N_SSG":true}