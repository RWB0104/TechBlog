{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 의존성 역전 원칙 (Dependency Inversion Principle)","excerpt":"의존성 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다. 말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가? 고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, 객체는 객체보다 인터페이스에 의존해야한다로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-17T03:06:35","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-17-dependency-inversion-principle.md","content":"\r\n# 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n<span class=\"orange-400\">의존성 역전 원칙</span>이란 <span class=\"red-600\">객체는 저수준 모듈보다 고수준 모듈에 의존해야한다</span>는 원칙이다.\r\n\r\n말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가?\r\n\r\n* <span class=\"primary\">고수준 모듈</span>: 인터페이스와 같은 객체의 형태나 추상적 개념\r\n* <span class=\"primary\">저수준 모듈</span>: 구현된 객체\r\n\r\n고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, <span class=\"red-600\">객체는 객체보다 인터페이스에 의존해야한다</span>로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.\r\n\r\n# 코드로 보는 의존성 역전 원칙\r\n\r\n예시를 통해 의존성 역전 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 의존성 역전 원칙을 준수하지 않은 코드\r\n\r\n어렸을 적 누구나 한 번씩 단풍에 대한 이야기를 다룬 게임을 해본적이 있을 것이다. 비록 이젠 죽어버렸지만 필자도 매우 좋아했었고, 성인이 된 후에도 방학시즌 이벤트만 되면 으레 복귀해서 게임을 즐기곤 했었다.\r\n\r\n그 게임은 RPG 장르로, RPG가 그렇듯 다양한 직업군과 그에 맞는 스킬/무기 시스템이 갖춰져있다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n수 많은 무기 가운데 하나인 한손검을 구현한 `OneHandSword` 객체가 있다. 캐릭터는 위와 같은 무기를 장비할 수 있을 것이다. 인스턴스 생성 시 무기의 이름과 데미지를 입력하여 생성한다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate OneHandSword weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic Character(String name, int health, OneHandSword weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic void chageWeapon(OneHandSword weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터를 구현한 `Character` 객체다. 게임 캐릭터가 취할 수 있는 기본적인 행동 일부가 구현되어있으며, 인스턴스 생성 시 캐릭터 이름, 체력, 무기를 입력하여 생성한다.\r\n\r\n하지만 다들 알다시피, 무기엔 한손검만 있는 게 아니다. 근접계열 무기만 하더라도 두손검, 단검, 창, 도끼, 둔기 등 다양한 종류가 존재할 수 있다. 그러나 이 `Character` 객체. 애초에 한손검 외엔 쓸 수가 없는 구조다. `Character`의 인스턴스 생성 시 `OneHandSword`에 의존성을 가지기 때문. \t공격 동작을 담당하는 `attack()` 메소드 역시 `OneHandSword`에 의존성을 가진다.\r\n\r\n이 상황에서 한손검을 제외한 다른 무기를 사용하려면 `Character`의 코드를 바꿔야한다. 즉, 이전에 다뤘던 [개방-폐쇄 원칙](/posts/2021/08/14/open-closed-principle)을 위배한다. 더 큰 문제는 무기가 바뀔 때마다 이 짓을 해줘야한다. \r\n\r\n## 의존성 역전 원칙을 준수한 코드\r\n\r\n만약 위 코드가 의존성 역전 원칙을 잘 지켰다면 고민할 필요가 없는 문제다. 위 코드의 <span class=\"red-400\">가장 큰 문제는 이미 완전하게 구현된 저수준 모듈을 의존하고 있다는 점</span>이다. 즉, 추상적인 고수준 모듈을 의존하도록 리팩토링해야한다.\r\n\r\n``` java\r\n/**\r\n * 공격 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 02:07:19\r\n */\r\npublic interface Attackable\r\n{\r\n\t/**\r\n\t * 공격 추상 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tint attack();\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 추상 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tString toString();\r\n}\r\n```\r\n\r\n우선 고수준 모듈인 `Weapon` 인터페이스를 생성한다. 공격 데미지를 반환하는 추상 함수 `attack()`과 무기 이름을 반환하는 추상 함수 `toString()`가 선언되어있다. 앞으로 모든 공격 가능한 무기 객체는 이 인터페이스를 상속받게 될 것이다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword implements Attackable\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\t@Override\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n`Attackable`를 상속받은 한손검 객체 `OneHandSword` 객체다. 상속받은 점 외에 크게 달라진 점은 없다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate Attackable weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic Character(String name, int health, Attackable weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic void chageWeapon(Attackable weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터 `Character` 객체다. 기존의 `OneHandSword`를 파라미터에서 좀 더 고수준 모듈인 `Attackable`을 파라미터로 받는 걸 확인할 수 있다. 그 밖의 무기와 관련된 메소드 전부가 그렇다.\r\n\r\n하나의 객체였던 저수준 모듈에서 고수준 모듈로 의존성이 바뀌게 되니, `Attackable`을 상속하는 모든 객체를 다룰 수 있다. 게임 시스템 내부적으로 모든 공격 가능한 무기는 `Attackable`을 상속받기로 가정했으므로, 공격 가능한 모든 무기를 사용할 수 있는 셈이다.\r\n\r\n이러한 변경으로 무기의 변경에 따라 `Character`의 <span class=\"green-600\">코드를 변경할 필요가 없으므로, 개방-폐쇄 원칙 또한 준수</span>할 수 있다.\r\n\r\n# 정리\r\n\r\n의존성 역전 원칙은 코드의 확장성 및 재사용성을 추구하기 위한 원칙이다. 경직된 객체보다 구현되지 않아 유연한 인터페이스가 더욱 확장 가능성이 높을 것이다.\r\n\r\n다른 원칙에 비해 <span class=\"orange-400\">의존성 역전 원칙은 중요도가 좀 떨어지는데, 그 이유는 타 원칙의 하위호환 격이기 때문</span>이다. 당장 위에서도 언급했듯이, 의존성 역전 원칙은 개방-폐쇄 원칙을 준수할 경우 자연스레 준수하기이다. 뿐만 아니라 1객체 = 1책임인 단일 책임 원칙, 기능별 인터페이스화를 추구하는 인터페이스 분리 원칙을 준수할 경우 역시 마찬가지다.\r\n\r\n객체 생성 시 객체로 구현해야할 것과 인터페이스로 구현해야할 것을 적절히 구분하여 올바른 의존 관계를 가지도록 구현하자. 이왕이면 방금 언급한 원칙들을 준수하여 두 마리 토끼를 잡는 것도 매우 좋은 방법일 것이다.\r\n\r\n# 마치며\r\n\r\n이 장을 끝으로 객체지향에 대한 글을 마무리한다. 지금껏 JAVA라는 객체지향 언어를 사용하고 있었음에도, 정작 객체지향에 대해 너무 몰랐다는 것을 새삼 느낀다. 내가 얼마나 비객체지향적으로 코딩했는지도....\r\n\r\n객체지향에서의 가장 큰 특징이라면 바로 <span class=\"primary\">상속</span>일 것이다. 객체지향의 5원칙 중 대부분이 상속과 직/간접적으로 연관된 것만 봐도, 객체지향의 아이덴티티는 상속이라고 할 수 있을 것이다. 그 만큼 객체지향에서 상속은 중요하면서 동시에 이해하기 어려운 개념이다. 잘 쓰기는 더더욱 어렵다.\r\n\r\n물론 객체지향의 의의를 온전히 구현하고, 수립된 원칙들을 전부 지키는 것은 시니어급 개발자라도 매우 어려운 일일 것이다. 당장 나 같아도 \"이 많은 걸 다 지켜가며 설계하라고?\"라는 생각이 들고, 대부분의 개발은 구현 과정보단 동작 결과에 치중하기 때문이다.\r\n\r\n탄탄한 기획과 이에 동반되는 고민은 견고한 설계가 가능하지만, 언제까지나 시간을 낭비할 수 없는 노릇이다. 아무리 탄탄하게 설계 중인 프로젝트라도 개발 기간을 준수하지 못 하면 결과물은 물론, 이 결과물을 내기까지 했던 모든 고민들이 시간낭비로 치부되는 것을 뻔하다.\r\n\r\n이러한 원칙을 정해진 시간 내에 구현해야 하므로, 객체지향을 잘 다루기 위해선 많은 노력이 필요할 것이다.","url":["2021-08-17-dependency-inversion-principle","2021","08","17","dependency-inversion-principle"]},"next":null},"group":[],"data":{"header":{"title":"[SSL] SSL이란?","excerpt":"웹을 배포해본 적이 있다면 SSL에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 https://로 시작하며, http://와 달리 보안(Secure)을 의미하는 s가 붙는다. 지금 이 사이트의 주소도 https://rwb0104.github.io로 SSL이 적용된 걸 확인할 수 있다. NAVER나 Google도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T00:26:08","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","TLS"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl.md","content":"<h1 id=\"개요\">개요 <a href=\"#개요\">🔗</a></h1><p>웹을 배포해본 적이 있다면 <span class=\"pink-600\">SSL</span>에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 <code class=\"inline-code\">https://</code>로 시작하며, <code class=\"inline-code\">http://</code>와 달리 <span class=\"blue-400\">보안(Secure)</span>을 의미하는 <code class=\"inline-code\">s</code>가 붙는다. 지금 이 사이트의 주소도 <a href=\"https://rwb0104.github.io\">https://rwb0104.github.io</a>로 SSL이 적용된 걸 확인할 수 있다. <a href=\"https://naver.com\">NAVER</a>나 <a href=\"https://google.com\">Google</a>도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.</p>\n<h1 id=\"SSL(Secure-Socket Layer)\">SSL(Secure Socket Layer) <a href=\"#SSL(Secure-Socket Layer)\">🔗</a></h1><p>그렇다면 이 <span class=\"pink-600\">SSL</span>이란 놈은 뭘까? SSL은 Secure Socket Layer의 약자로, 직역하면 암호화 소켓층이다. 1994년 Netscape사에서 처음 개발되어 3.0 버전까지 존재한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129691442-090810ed-30c5-4245-aa9d-9dd785f621a6.png\" alt=\"image\"></p>\n<p>SSL이란, <span class=\"amber-400\">웹 서버와 클라이언트의 통신 암호화 프로토콜</span>이다.</p>\n<p>SSL이 적용되지 않은 통신의 경우, 위 그림과 같이 평문(Plain Text)가 그대로 전송된다. 만약 제 3자가 어떠한 방식으로든 통신 패킷을 탈취할 경우, 그 내용을 쉽게 확인할 수 있다.</p>\n<p>통신 내용에 시덥잖은 것만 있다면 다행이겠지만, 사용자의 개인 정보나, 결제 정보와 같은 민감한 정보의 통신이라면 얘기가 달라진다.</p>\n<p>SSL을 적용한다면 이러한 문제를 기술적으로 해결할 수 있다. 요청을 암호화해서 보내므로 통신 패킷이 탈취되도 복호화 키가 없으면 원래 내용을 알 수 없기 때문이다.</p>\n<h2 id=\"TLS(Transport-Layer Security)\">TLS(Transport Layer Security) <a href=\"#TLS(Transport-Layer Security)\">🔗</a></h2><p>SSL을 접하다보면 <span class=\"pink-600\">TLS</span>라는 개념도 접하게 된다. 찾다보면 SSL이랑 TLS랑 혼재되어있기도 하고.</p>\n<p>SSL은 1996년에 3.0 버전이 출시되었으며, 보안취약점으로 인해 현재는 퇴출된 상태다.</p>\n<p>TLS는 국제 인터넷 표준화 기구(IETF)에서 개발한 것으로, SSL 3.0의 보안취약점을 보완한 통신 보안 프로토콜이다. 현재 TLS는 2018년 1.3 버전이 출시됏다.</p>\n<p>SSL을 보완한 것이 TLS지만, 인터넷에 적용되는 통신 보안 프로토콜을 전부 통틀어서 SSL이라 부른다.</p>\n<p>실상은 2015년에 SSL의 마지막 버전인 3.0 마저 금지됐다. 현재 사용 중인 프로토콜은 모두 TLS다.</p>\n<h1 id=\"SSL의-특징\">SSL의 특징 <a href=\"#SSL의-특징\">🔗</a></h1><ol>\n<li>URL 프로토콜은 <code class=\"inline-code\">https</code>이며, 기본 포트는 <code class=\"inline-code\">443</code>이다.</li>\n<li>통신 데이터가 암호화되어, 패킷이 탈취되는 사고가 발생해도 데이터를 지킬 수 있다.</li>\n<li>SSL 인증서를 통해 도메인의 신뢰성을 검증할 수 있다.</li>\n<li>데이터 송/수신 과정에서 암/복호화가 발생하므로 속도가 느리다.</li>\n</ol>\n<h1 id=\"SSL의-원리\">SSL의 원리 <a href=\"#SSL의-원리\">🔗</a></h1><p>SSL의 통신하는 원리는 아래와 같으며, 이러한 일련의 과정을 HandShake라 한다. 클라이언트와 서버 간의 요청/응답을 반복하며 통신에 필요한 사전 작업을 하는게 마치 악수 같아 붙여졌다고 한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129752108-1423e7cf-3c4c-4e4c-a77a-7a76d208d7f8.png\" alt=\"image\"></p>\n<br />\n<br />\n\n<p class=\"large amber-600\">1. ClientHello 요청</p>\n\n<p>클라이언트가 특정 주소에 접근하면, 해당하는 서버에 요청을 보낸다. <a href=\"https://naver.com\">NAVER</a>에 접근하면 네이버 서버에 요청을 보내게 된다.</p>\n<ul>\n<li>난수 데이터</li>\n<li>암호화 프로토콜 정보 (프로토콜, 버전 등)</li>\n<li>클라이언트가 사용 가능한 암호화 기법</li>\n<li>세션 아이디</li>\n<li>기타 확장 정보</li>\n</ul>\n<p>이 요청에는 위와 같은 정보들이 포함되어있다. 클라이언트의 주요 정보를 서버에 전송하여, 해당 클라이언트를 식별하고, 어떤 암호화를 사용할 수 있는 지 등의 정보를 서버가 인지하도록 한다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">2. ServerHello 응답</p>\n\n<p>서버가 ClientHello 요청을 받으면, 위의 정보를 담아 클라이언트에게 일종의 화답을 보낸다.</p>\n<ul>\n<li>난수 데이터 (ClientHello의 데이터와 다름)</li>\n<li>서버가 사용할 암호화 기법</li>\n<li>인증서<ul>\n<li>CA</li>\n<li>도메인</li>\n<li>공개키</li>\n</ul>\n</li>\n</ul>\n<p>난수 데이터는 ClientHello에서 보낸 데이터과 아무런 상관관계가 없는 별개의 데이터다.</p>\n<p>클라이언트가 사용 가능하다고 통보한 암호화 기법 중 서버에서 활용할 암호화 기법을 전달하여 동일한 암호화 기법으로 송수신할 수 있도록 선언한다.</p>\n<p>인증서 정보와 함께, 서버와의 암호화 통신을 위한 서버 공개키가 전달된다. 서버의 공개키로 데이터를 암호화하면 서버는 이를 받아 개인키로 복호화하여 요청을 분석할 수 있다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">3. 인증서 검토</p>\n\n<p>서버가 전달한 인증서가, 실제 해당 서버의 인증서인지, 신뢰할 수 있는 CA에서 발급된 것인지, 실제 해당 CA에서 발급받았는지 등 인증서를 검토한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129752361-4831de06-e99b-4f0c-9862-fe1f8ab5642a.png\" alt=\"image\"></p>\n<p>인증서에 이상이 없다면 주소창에 위와 같이 표시된다. (Microsoft Chromium Edge 기준)</p>\n<p>만약 문제가 있다면 아래와 같은 창을 보게 될 것이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129752602-f9967221-3b82-487f-91c4-7fefc1cf3e94.png\" alt=\"image\"></p>\n<p>이는 브라우저가 사용자에게 보내는 경고문으로, 해당 사이트의 인증서가 올바르지 않으므로 신뢰할 수 없다고 경고하는 것이다.</p>\n<p>물론 사이트 관리자의 실수로 인증서가 만료됐거나, 잘못된 인증서를 교체해서 발생한 사소한 이유일 수도 있다. 하지만 낮선 사이트를 접속하는데 이와 같은 경고가 뜬다면, 정상적인 방법으로 인증서를 발급받을 수 없는 사이트일 가능성이 있으므로 접근을 자제하자.</p>\n<p>악의가 없는 사이트일지라도, 사용자의 데이터는 보호해주지 못 하니 주의할 것.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">4. Premaster Secret 송수신</p>\n\n<p>ClientHello, ServerHello에서 송수신한 난수 데이터를 조합하여 Premaster Secret을 생성한다.</p>\n<p>이를 ServerHello에서 전달받았던 공개키로 암호화한다. 이 데이터는 서버가 가진 개인키로만 복호화가 가능하다. 즉, 이 데이터는 탈취된다 하더라도 그 내용이 보호된다.</p>\n<p>서버는 수신된 데이터를 복호화하여 클라이언트와 동일한 Premaster Secret을 저장할 수 있다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">5. 통신 키 생성</p>\n\n<p>보유한 Premaster Secret을 토대로 Master Secret, Session Key를 생성한다. 이를 통해 클라이언트와 서버가 동일한 키를 보유하게 되므로 자신들끼리의 암호화 통신이 가능하다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">6. 데이터 송수신</p>\n\n<p>필요한 데이터는 저장된 Session Key를 통한 대칭키 암호화 방식으로 암/복호화하여 통신한다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">7. 세션 종료</p>\n\n<p>클라이언트와의 연결이 끊겼을 경우 사용했던 Session Key는 폐기한다.</p>\n<h1 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h1><p>SSL은 통신 패킷을 암호화하여 패킷 탈취, 정보 누출 등을 방지하기 위한 보안 프로토콜이다.</p>\n<p>현재는 모두 TLS로 교체되었지만, SSL 자체가 고유명사되어 넓은 의미의 통신 보안 프로토콜을 명칭하는 의미로 쓰인다.</p>\n<p>현대에 이르러서는 웹 배포에 있어서 필수적인 사항이므로, 내용을 잘 이해하자.</p>\n<p>다음 장에서는 SSL 인증서에 대해 다룬다.</p>\n","url":["2021-08-18-about-ssl","2021","08","18","about-ssl"],"toc":[{"text":"개요","tag":"개요","depth":1},{"text":"SSL(Secure Socket Layer)","tag":"SSL(Secure-Socket Layer)","depth":1},{"text":"TLS(Transport Layer Security)","tag":"TLS(Transport-Layer Security)","depth":2},{"text":"SSL의 특징","tag":"SSL의-특징","depth":1},{"text":"SSL의 원리","tag":"SSL의-원리","depth":1},{"text":"정리","tag":"정리","depth":1}]}},"__N_SSG":true}