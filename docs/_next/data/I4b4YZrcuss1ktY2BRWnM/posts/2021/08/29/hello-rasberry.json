{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1021번 회전하는 큐","excerpt":"지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다. 지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-08-26T01:39:29","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","덱","SILVER","SILVER IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-08-26-a1021.md","content":"\r\n# 회전하는 큐\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/7.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1021번 문제](https://www.acmicpc.net/problem/1021)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 $N$개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.\r\n\r\n지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다.\r\n\r\n1. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 $a_1, \\dotsb, a_k$였던 것이 $a_2, \\dotsb, a_k$가 된다.\r\n2. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면 $a_1, \\dotsb, a_k$가 $a_2, \\dotsb, a_k, a_1$이 된다.\r\n3. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면 $a_1, \\dotsb, a_k$가 $a_k, a_1, \\dotsb, a_{k - 1}$이 된다.\r\n\r\n큐에 처음에 포함되어 있던 수 $N$이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 큐의 크기 $N$과 뽑아내려고 하는 수의 개수 $M$이 주어진다. $N$은 50보다 작거나 같은 자연수이고, $M$은 $N$보다 작거나 같은 자연수이다. 둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다. 위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 문제의 정답을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n``` input\r\n10 3\r\n1 2 3\r\n```\r\n\r\n``` output\r\n0\r\n```\r\n\r\n### 예제 2\r\n\r\n``` input\r\n10 3\r\n2 9 5\r\n```\r\n\r\n``` output\r\n8\r\n```\r\n\r\n### 예제 3\r\n\r\n``` input\r\n32 6\r\n27 16 30 11 6 23\r\n```\r\n\r\n``` output\r\n59\r\n```\r\n\r\n### 예제 4\r\n\r\n``` input\r\n10 10\r\n1 6 3 2 7 9 8 4 10 5\r\n```\r\n\r\n``` output\r\n14\r\n```\r\n\r\n# 풀이\r\n\r\n<span class=\"teal-600\">큐</span>의 특성을 알고 있다면 이해하기 쉬운 문제다.\r\n\r\n큐는 배열의 형태로, 한쪽 입구에서 요소의 삽입이 일어나며, 다른 한쪽에서 요소의 삭제가 일어나는 자료구조다. 컨테이너 벨트처럼 순차적으로 데이터를 처리하는 선입선출(FIFO) 방식을 차용하고 있어 순차적인 데이터를 처리하는데 유용하다.\r\n\r\n> 큐의 특성은 해당 블로그에 작성된 [게시글](/posts/2021/07/31/about-algorithm-chapter08#8-3.-%ED%81%90)에서 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130629741-6b9dc89d-86fa-4c84-a06e-05950c86a489.png)\r\n\r\n\r\n하지만 단순한 큐가 아니라, 아래의 특징을 갖는 자료구조를 설계해야한다.\r\n\r\n1. 첫 번째 원소를 뽑아내는 연산\r\n2. 데이터의 좌우 이동 연산 (각 끝의 요소는 반대편으로 이동하는 방식으로 순환)\r\n\r\n위 자료구조를 토대로 알고리즘이 원하는 동작을 구현하면 된다.\r\n\r\n문제에서 제시하는 데이터를 순서대로 뽑아내되, 최소한의 데이터 이동이 이루어져야한다.\r\n\r\n1번 연산을 수행하면, 단순히 첫 번째 칸의 원소만 지우는 게 아니라, 칸 자체를 제거한다.\r\n\r\n즉, <span class=\"red-500\">10개의 칸을 가진 큐에서 1번 연산을 수행하면 칸이 9개로 감소</span>한다.\r\n\r\n## 예제 풀이\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130823251-4d6f5300-4363-49b6-ad76-7168d484dff8.png)\r\n\r\n예제 2를 기준으로 풀이를 진행한다. 큐의 길이는 총 10으로, 위와 같을 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130823281-5ed5b772-66ce-494a-9189-2366cd7ad45c.png)\r\n\r\n뽑을 원소의 순서는 위와 같다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">1. 2의 위치 계산</b>\r\n\r\n첫 번째로 뽑을 원소인 2와 데이터의 삭제 연산이 일어나는 첫 번째 칸까지의 위치를 계산한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130824338-20a0e7da-d8c3-4e00-a691-0ea103fd3cce.png)\r\n\r\n* 오른쪽: 9칸\r\n* 왼쪽: 1칸\r\n\r\n왼쪽이 더 빠르므로, 방향을 왼쪽으로 정한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">2. 요소 왼쪽으로 이동</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130824549-67551e2a-3d14-4581-8161-743bb46469fc.png)\r\n\r\n* 누적 이동횟수: 1\r\n\r\n요소 2를 첫 번째 칸까지 왼쪽으로 1칸 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">3. 요소 삭제</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130824982-ae2575aa-dfff-4424-affe-15e9a92ddbb9.png)\r\n\r\n요소 2를 삭제한다. 아예 칸 자체가 사라짐에 유의하자.\r\n\r\n삭제는 이동횟수에 포함되지 않는다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">4. 9의 위치 계산</b>\r\n\r\n두 번째로 뽑을 원소인 9와 데이터의 삭제 연산이 일어나는 첫 번째 칸까지의 위치를 계산한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130825673-9af78509-8918-4638-84cc-0ffcfa30a95b.png)\r\n\r\n* 오른쪽: 3칸\r\n* 왼쪽: 6칸\r\n\r\n오른쪽이 더 빠르므로, 방향을 오른쪽으로 정한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">5. 요소 오른쪽으로 이동</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130826195-b7a12a3f-0fed-4e46-bcb0-46936bfd130f.png)\r\n\r\n* 누적 이동횟수: 4\r\n\r\n요소 9를 첫 번째 칸까지 오른쪽으로 3칸 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">6. 요소 삭제</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130826601-776f4bc8-944e-4d5f-a05d-73116334e229.png)\r\n\r\n요소 9를 삭제한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">7. 5의 위치 계산</b>\r\n\r\n마지막으로 뽑을 원소인 5와 데이터의 삭제 연산이 일어나는 첫 번째 칸까지의 위치를 계산한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130827731-deda3121-792f-4664-b851-8e21d2a0a1a9.png)\r\n\r\n* 오른쪽: 4칸\r\n* 왼쪽: 4칸\r\n\r\n거리가 서로 동등한 케이스다. 이 경우 알고리즘 역시 별도의 제약조건을 걸지 않았으므로, 아무 방향으로 이동해도 상관없다.\r\n\r\n본 문서에선 왼쪽을 기준으로 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">8. 요소 왼쪽으로 이동</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130828678-790bc1ee-7c7d-43d9-912f-ee7ecc41c1f8.png)\r\n\r\n* 누적 이동횟수: 8\r\n\r\n요소 9를 첫 번째 칸까지 오른쪽으로 4칸 이동한다.\r\n\r\n<br />\r\n<br />\r\n\r\n<b class=\"large deepPurple-300\">9. 요소 삭제</b>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130828805-3a216247-5361-47be-8c13-c41081b594dd.png)\r\n\r\n요소 9를 삭제한다.\r\n\r\n<b class=\"large deepPurple-300\">10. 결과 도출</b>\r\n\r\n총 이동횟수는 8회이므로, 알고리즘의 결과는 8이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\n\r\n/**\r\n * 백준 전체 1021 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/08/26/a1021\">1021 풀이</a>\r\n * @since 2021.08.26 00:48:27\r\n */\r\npublic class Main\r\n{\r\n\t// 방향 Enum\r\n\tprivate enum DIRECTION\r\n\t{\r\n\t\tLEFT, RIGHT\r\n\t}\r\n\t\r\n\t// 뽑을 수의 갯수\r\n\tprivate static int M;\r\n\t\r\n\t// 큐\r\n\tprivate static final LinkedList<Integer> QUEUE = new LinkedList<>();\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// N과 M\r\n\t\tint[] meta = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 수의 위치\r\n\t\tint[] position = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 큐의 크기\r\n\t\tint N = meta[0];\r\n\t\t\r\n\t\tM = meta[1];\r\n\t\t\r\n\t\t// 큐의 크기만큼 큐 초기화\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tQUEUE.add(i + 1);\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(String.valueOf(solve(position)));\r\n\t\twriter.newLine();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 큐 연산 갯수 반환 함수\r\n\t *\r\n\t * @param position: [int[]] 수의 위치 배열\r\n\t *\r\n\t * @return [int] 연산 갯수\r\n\t */\r\n\tprivate static int solve(int[] position)\r\n\t{\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < M; i++)\r\n\t\t{\r\n\t\t\t// 뽑을 요소의 인덱스\r\n\t\t\tint target = QUEUE.indexOf(position[i]);\r\n\t\t\t\r\n\t\t\t// 요소의 중간\r\n\t\t\tint mid = QUEUE.size() / 2;\r\n\t\t\t\r\n\t\t\t// 인덱스가 요소의 중간값을 넘을 경우 오른쪽이 더 빠름\r\n\t\t\tDIRECTION direction = target > mid ? DIRECTION.RIGHT : DIRECTION.LEFT;\r\n\t\t\t\r\n\t\t\t// 오른쪽으로 갈 경우 큐의 길이에서 인덱스를 빼서 역계산\r\n\t\t\tint distance = direction == DIRECTION.RIGHT ? QUEUE.size() - target : target;\r\n\t\t\t\r\n\t\t\tmove(direction, distance);\r\n\t\t\tpop();\r\n\t\t\t\r\n\t\t\t// 이동 길이 누적\r\n\t\t\tcount += distance;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이동 함수\r\n\t *\r\n\t * @param direction: [DIRECTION] 방향 Enum\r\n\t * @param distance: [int] 거리\r\n\t */\r\n\tprivate static void move(DIRECTION direction, int distance)\r\n\t{\r\n\t\t// 왼쪽으로 이동할 경우\r\n\t\tif (DIRECTION.LEFT == direction)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < distance; i++)\r\n\t\t\t{\r\n\t\t\t\tQUEUE.addLast(QUEUE.removeFirst());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 오른쪽으로 이동할 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < distance; i++)\r\n\t\t\t{\r\n\t\t\t\tQUEUE.addFirst(QUEUE.removeLast());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 삭제 함수\r\n\t */\r\n\tprivate static void pop()\r\n\t{\r\n\t\tQUEUE.removeFirst();\r\n\t}\r\n}\r\n```\r\n\r\n회전하는 큐의 주요 동작은 양방향 이동, 삭제다. 해당 동작은 각각 `move()`, `pop()` 메소드로 구현된다.\r\n\r\n``` java\r\n/**\r\n * 이동 함수\r\n *\r\n * @param direction: [DIRECTION] 방향 Enum\r\n * @param distance: [int] 거리\r\n */\r\nprivate static void move(DIRECTION direction, int distance)\r\n{\r\n\t// 왼쪽으로 이동할 경우\r\n\tif (DIRECTION.LEFT == direction)\r\n\t{\r\n\t\tfor (int i = 0; i < distance; i++)\r\n\t\t{\r\n\t\t\tQUEUE.addLast(QUEUE.removeFirst());\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 오른쪽으로 이동할 경우\r\n\telse\r\n\t{\r\n\t\tfor (int i = 0; i < distance; i++)\r\n\t\t{\r\n\t\t\tQUEUE.addFirst(QUEUE.removeLast());\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n`move()` 수행 시 방향은 `enum` 객체인 `DIRECTION`으로 구분하며, 입력한 횟수만큼 이동한다.\r\n\r\n``` java\r\n/**\r\n * 삭제 함수\r\n */\r\nprivate static void pop()\r\n{\r\n\tQUEUE.removeFirst();\r\n}\r\n```\r\n\r\n`pop()` 수행 시 큐의 첫 번째 요소를 삭제한다.\r\n\r\n<br />\r\n\r\n핵심 알고리즘 함수는 아래와 같다.\r\n\r\n``` java\r\n/**\r\n * 큐 연산 갯수 반환 함수\r\n *\r\n * @param position: [int[]] 수의 위치 배열\r\n *\r\n * @return [int] 연산 갯수\r\n */\r\nprivate static int solve(int[] position)\r\n{\r\n\tint count = 0;\r\n\t\r\n\tfor (int i = 0; i < M; i++)\r\n\t{\r\n\t\t// 뽑을 요소의 인덱스\r\n\t\tint target = QUEUE.indexOf(position[i]);\r\n\t\t\r\n\t\t// 요소의 중간\r\n\t\tint mid = QUEUE.size() / 2;\r\n\t\t\r\n\t\t// 인덱스가 요소의 중간값을 넘을 경우 오른쪽이 더 빠름\r\n\t\tDIRECTION direction = target > mid ? DIRECTION.RIGHT : DIRECTION.LEFT;\r\n\t\t\r\n\t\t// 오른쪽으로 갈 경우 큐의 길이에서 인덱스를 빼서 역계산\r\n\t\tint distance = direction == DIRECTION.RIGHT ? QUEUE.size() - target : target;\r\n\t\t\r\n\t\tmove(direction, distance);\r\n\t\tpop();\r\n\t\t\r\n\t\t// 이동 길이 누적\r\n\t\tcount += distance;\r\n\t}\r\n\t\r\n\treturn count;\r\n}\r\n```\r\n\r\n`target`으로 뽑을 요소의 인덱스를 구한다.\r\n\r\n`mid` 큐의 중간값으로, `target`이 중간값보다 클 경우 오른쪽으로, 아닐 경우 왼쪽으로 이동하도록 `direction`을 지정한다.\r\n\r\n`distance`는 거리로, 오른쪽으로 이동할 경우 큐의 사이즈에서 거리를 빼고, 왼쪽으로 이동할 경우 거리를 그대로 사용한다.\r\n\r\n이후 계산한 방향, 거리만큼 이동하고 데이터를 삭제한다. 이동거리는 `count`에 누적된다.\r\n\r\n## 분류\r\n\r\n* 자료구조\r\n* 덱","url":["2021-08-26-a1021","2021","08","26","a1021"]},"next":null},"group":[],"data":{"header":{"title":"[라즈베리파이 4] Hello Rasberry!","excerpt":"개발자의 적지않은 수가 클라우드든, 디바이스든 자신만의 서버를 구축하여 다양하게 활용하고 있다. 개발을 하다보면 필연적으로 24시간 언제나 가동되는 서버 비스무리한 것이 필요할 때가 있다. 일례로 GitHub Pages의 경우 정적 페이지만 호스팅해줄 뿐, 백엔드나 DB는 사용할 수가 없어 동적 페이지 호스팅은 불가능하다. 그러나 개인 API 혹은 DB 서버가 존재한다면, 해당 서버와의 통신을 통해 더욱 동적 페이지 호스팅이 가능하다. 웹에서 백엔드가 갖는 역할을 생각해본다면, 개인이 활용 가능한 서버가 있고 없고의 차이는 천지차이가 난다. 나 역시도 개발하는 입장에서 제약없이 사용할 수 있는 서버의 소요가 이전부터 있어왔고, 개인 서버를 구축하기 위한 방안을 모색했다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-08-29T13:41:41","type":"posts","category":"알고리즘","tag":["라즈베리파이"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-08-29-hello-rasberry.md","content":"<h1 id=\"서버가-필요해!\">서버가 필요해! <a href=\"#서버가-필요해!\">🔗</a></h1><p>개발자의 적지않은 수가 클라우드든, 디바이스든 자신만의 서버를 구축하여 다양하게 활용하고 있다.</p>\n<p>개발을 하다보면 필연적으로 24시간 언제나 가동되는 서버 비스무리한 것이 필요할 때가 있다. 일례로 GitHub Pages의 경우 정적 페이지만 호스팅해줄 뿐, 백엔드나 DB는 사용할 수가 없어 동적 페이지 호스팅은 불가능하다.</p>\n<p>그러나 개인 API 혹은 DB 서버가 존재한다면, 해당 서버와의 통신을 통해 더욱 동적 페이지 호스팅이 가능하다. 웹에서 백엔드가 갖는 역할을 생각해본다면, 개인이 활용 가능한 서버가 있고 없고의 차이는 천지차이가 난다.</p>\n<p>나 역시도 개발하는 입장에서 제약없이 사용할 수 있는 서버의 소요가 이전부터 있어왔고, 개인 서버를 구축하기 위한 방안을 모색했다.</p>\n<h1 id=\"Hello,-Rasberry Pi\">Hello, Rasberry Pi <a href=\"#Hello,-Rasberry Pi\">🔗</a></h1><p><img src=\"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png\" alt=\"image\"></p>\n<p>많은 선택지가 있었지만, 내가 선택한 방안은 <span class=\"pink-700\">Rasberry Pi</span>를 통해 서버환경을 구축하는 것이였다.</p>\n<p>한창 트렌디한 <span class=\"orange-500\">Cloud</span> 플랫폼, 서버 호스팅 서비스도 있었지만, 여러 요인을 비교해본 결과 라즈베이 파이가 적절하다고 생각했다.</p>\n<h1 id=\"왜-하필?\">왜 하필? <a href=\"#왜-하필?\">🔗</a></h1><p>근래 들어 AWS를 필두로 클라우드 시장이 크게 활성화됐다. 덕분에 국/내외를 막론하고 여러 양질의 클라우드 서비스 제공처가 생겼다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/131238859-18b9cccd-4d6b-4e38-b279-c0faa66d4815.png\" alt=\"image\"></p>\n<p>클라우드 서비스를 활용하면 개인 서버를 쉽게 구축할 수 있겠지만, 그럼에도 불구하고 난 라즈베리 파이를 선택했다.</p>\n<p>크게 비용적 측면, 학구적 측면에서 생각했다.</p>\n<h2 id=\"비용적-측면\">비용적 측면 <a href=\"#비용적-측면\">🔗</a></h2><p>라즈베리 파이를 선택한 가장 큰 이유.</p>\n<p>몇 번 테스트삼아 쓸 것도 아니고, WAS, DB 등 각종 개발 관련 툴을 구동하려는 나로써는 서버의 사양 또한 쉽사리 무시할 수 없는 요소 중 하나다.</p>\n<p>높은 사양은 당연하게도 높은 비용으로 직결된다. 하지만 난 돈이 없다. 그렇다고 마냥 아낄 건 아니다만, 최대한 합리적인 선택지를 취할 필요가 있었다.</p>\n<p>내가 원하는 조건은 아래와 같았다.</p>\n<ul>\n<li>하나 이상의 Tomcat을 구동하는데 무리가 없을 것.</li>\n<li>하나 이상의 DBMS를 구동하는데 무리가 없을 것.</li>\n<li>최소 100GB 이상의 데이터를 보관할 수 있을 것.</li>\n<li>최대한 적은 유지비를 요구할 것.</li>\n</ul>\n<p>위 조건을 충족하기 위해선 많은 RAM, 디스크 용량이 필요했다. SSD일 경우 가격은 가격은 더욱 상승할 것이고. 서버에서 컴파일같은 연산 작업의 소요는 거의 없을 것 같아 CPU는 크게 신경쓰지 않았다.</p>\n<p><span class=\"orange-500\">AWS</span>와 <span class=\"pink-700\">Rasberry Pi</span>를 비교하면 아래와 같이 정리할 수 있다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">구분</th>\n<th align=\"center\"><span class=\"orange-500\">AWS LightSail</span></th>\n<th align=\"center\"><span class=\"pink-700\">Rasberry Pi 4</span> Model B</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">CPU</td>\n<td align=\"center\">2Core</td>\n<td align=\"center\">4Core</td>\n</tr>\n<tr>\n<td align=\"center\">RAM</td>\n<td align=\"center\">8GB</td>\n<td align=\"center\">8GB</td>\n</tr>\n<tr>\n<td align=\"center\">VGA</td>\n<td align=\"center\">X</td>\n<td align=\"center\">O (Support 4K)</td>\n</tr>\n<tr>\n<td align=\"center\">SSD</td>\n<td align=\"center\">320GB</td>\n<td align=\"center\">256GB (별도)</td>\n</tr>\n<tr>\n<td align=\"center\">Pricing</td>\n<td align=\"center\">40$ / per month</td>\n<td align=\"center\">160,000 (영구적)</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>CPU와 VGA는 위 조건의 영향을 적게 받으므로 제외하고 본다면 AWS가 우수해보인다. 하지만 AWS는 40$라는 적지않은 돈이 <strong>매 달</strong> 과금된다는 게 문제. 라즈베리 파이가 16만원에 영구적인 소장이 가능함을 감안하면 4개월 이후부터 AWS의 비용이 지속적으로 늘어난다. 환율을 천 원으로 감안했음에도 이 정도다.</p>\n<p>AWS에서 가성비로 호평받는 LightSail이 이정도면 EC2는 볼 필요도 없는 셈.</p>\n<p>장기적인 측면에서 볼 때 비용적으론 라즈베리 파이가 우수하다.</p>\n<h2 id=\"학구적-측면\">학구적 측면 <a href=\"#학구적-측면\">🔗</a></h2><p>서버를 다루고, 새로운 OS를 접한다는 것 자체도 개발자에겐 하나의 스펙으로 작용할 수 있다.</p>\n<p>AWS 역시 클라우드 업계의 대표로, 최근의 회사들은 AWS를 다루는 능력 또한 중요하게 보고있다.</p>\n<p>스펙적인 면을 감안하면 AWS가 훨씬 우세하지만, AWS나 라즈베리파이나 결국 서버의 범주에 들어가므로 서버를 학습하는덴 크게 무리는 없을 것이다.</p>\n<p>라즈베리파이는 처음부터 끝까지 사용자가 직접 구축해야하지만, 이 점이 오히려 학구적으로는 장점으로 작용할 것이다.</p>\n<h1 id=\"목표\">목표 <a href=\"#목표\">🔗</a></h1><p>라즈베리파이 서버의 최종 목표는 아래와 같다.</p>\n<ul>\n<li>라즈베리파이에 Ubuntu 서버를 구축한다.</li>\n<li>도메인을 입힌다.</li>\n<li>SSH, RDP 등의 원격 통신환경을 구축한다.</li>\n<li>Tomcat을 구동하여 페이지를 호스팅한다</li>\n<li>MariaDB를 설치하여 DB 통신을 수행한다.</li>\n</ul>\n","url":["2021-08-29-hello-rasberry","2021","08","29","hello-rasberry"],"toc":[{"text":"서버가 필요해!","tag":"서버가-필요해!","depth":1},{"text":"Hello, Rasberry Pi","tag":"Hello,-Rasberry Pi","depth":1},{"text":"왜 하필?","tag":"왜-하필?","depth":1},{"text":"비용적 측면","tag":"비용적-측면","depth":2},{"text":"학구적 측면","tag":"학구적-측면","depth":2},{"text":"목표","tag":"목표","depth":1}]}},"__N_SSG":true}