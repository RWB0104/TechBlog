{"pageProps":{"page":{"type":"posts","prev":{"title":"[JAVA] 백준 알고리즘 1006번 습격자 초라기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-06T22:42:02","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","DP(동적 계획법)","PLATINUM","PLATINUM III"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-06-06-A1006","content":"\r\n# 습격자 초라기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1006번 문제](https://www.acmicpc.net/problem/1006)\r\n\r\n# 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg\" width=\"400px\" />\r\n</p>\r\n\r\n초라기는 각각 $W$명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.\r\n\r\n1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.\r\n2. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.\r\n3. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 $W$ 보다 작거나 같아야 한다.\r\n\r\n이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n첫째 줄에는 (구역의 개수)/2 값 $N$과 특수 소대원의 수 $W$가 주어진다. ($1 ≤ N ≤ 10000$, $1 ≤ W ≤ 10000$).\r\n\r\n둘째 줄에는 $1 ~ N$번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 $N + 1 ~ 2N$번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ $W$)\r\n\r\n## 출력\r\n\r\n각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n8 100\r\n70 60 55 43 57 60 44 50\r\n58 40 47 90 45 52 80 40\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n## 힌트\r\n\r\n하나의 특수 소대로 인접한 두 영역을 커버할 수 있는 배치는 (2,10), (9,16), (4,5), (7,8), (13,14) 이다. 그리고 나머지 6개 구역은 각각 하나의 특수 소대로 커버할 수 있다. 그러므로 최소 11개 특수 소대를 침투시켜야 한다.\r\n\r\n# 풀이\r\n\r\n백준 알고리즘을 순서대로 푸는 나 같은 초심자들에게 <span class=\"red-A400\">힘의 차이</span>를 느끼게 해주는 문제라고 한다. [solved.ac](https://solved.ac/)에 의하면 문제 등급이 무려 <span class=\"teal-A400\">PLATINUM III</span> 수준. 지금까지 푼 문제 중 가장 높은 등급이 [ACM Craft](/posts/2021/06/01/A1005/) (<span class=\"amber-A400\">GOLD III</span>) 수준임을 감안하면 월등히 높은 수준의 문제. 실제로 풀면서도 혼자서는 도저히 방법이 안 떠오르는데다, 풀이를 봐도 이해가 잘 안 됐다.\r\n\r\n해당 문제에 주어지는 <span class=\"primary\">구역</span>은 원형이다. 문제를 쉽게 접근하기 위해선 이 원형을 임의로 잘라 직사각형 형태로 전개해야 한다. 즉, <span class=\"error\">풀 때는 직사각형 형태지만, 실제로는 원형이므로 직사각형의 잘린 양 끝부분까지 염두하여 계산</span>을 해야한다. 난이도를 상승시키는 요인 중 하나.\r\n\r\n케이스에 제시된 예제를 기준으로 구역을 사각형으로 도식화하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n위 사진과 같이 8x8 배열로 표현할 수 있다. 여기서 여기서 6번째 행까지 특수소대로 채울 수 있는 최소값은 어떻게 구할 수 있을까?\r\n\r\n역으로 한번 생각해보자. 우리 특수소대는 너무나 유능해서 항상 최소의 팀만으로 목표 구역을 점령한다고 해보자. 작전 보고서엔 아래와 같이 점령한 구역을 표시하며, 이를 <span class=\"yellow-a500\">노란색</span> 영역으로 마킹해서 보여준다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926996-378d0d00-c71a-11eb-9b0f-baacb8da1647.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, <span class=\"yellow-a500\">노란색</span> 영역은 최소의 특수소대팀이 투입된 것이며, 우리가 실제로 구현할 알고리즘의 결과물이기도 하다.\r\n\r\n문제의 설정 상, 특수소대는 반드시 한 팀이 온전히 투입되어야 하며, 최소로 투입 가능한 인원 역시 한 팀이다. 그렇다면 위 사진에서 특수소대 한 팀이 커버할 수 있는 영역을 제외해보면 아래와 같이 세 케이스 $a$, $b$, $c$로 나눌 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927024-568b9f00-c71a-11eb-9309-7e4ef2f06ac2.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, 우리가 저 세 케이스에 대한 특수소대팀의 최소값을 계산할 수 있다면, 결과적으로 6번째 행 전체를 커버하는 특수소대팀의 수를 구할 수 있다. 이미 최소 인원이 나머지 구역을 점령한 상황에서, 투입할 수 있는 최소 인원인 한 팀만 투입할 수 있기 때문.\r\n\r\n여러 블로그에서 위 세 그림을 많이 봤을 텐데, 뜬금없이 저런 그림이 등장함에는 이와같은 배경이 있는 것이다.\r\n\r\n## 변수\r\n\r\n알고리즘 설계에 사용할 변수는 아래와 같다.\r\n\r\n* $T$: 케이스 수\r\n* $N$: 구역의 행 수\r\n* $e$: 구역별 적의 수\r\n* $a_i$: 첫 번째 케이스의 특수소대 최소 투입 수\r\n* $b_i$: 두 번째 케이스의 특수소대 최소 투입 수\r\n* $c_i$: 세 번째 케이스의 특수소대 최소 투입 수\r\n\r\n## a 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927050-77ec8b00-c71a-11eb-8034-5b02a6c04246.png\" width=\"512px\" />\r\n</p>\r\n\r\n첫번째 케이스로 $a_5$의 최소값 공식을 설계하자.\r\n\r\n위에서 했던 방식과 마찬가지로 추론하면 $a_5$에서 한팀을 뺀 $a_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927077-90f53c00-c71a-11eb-96cd-38edba684b10.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = c_5$ 이므로 $a_5 = c_5 + 1$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{05} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927092-9c486780-c71a-11eb-91c7-1922f98a1b01.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = b_4$ 이므로 $a_5 = b_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $a_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $a_5 = c_5 + 1$ -> $a_{i+1} = c_{i+1} + 1$\r\n* $a_5 = b_4 + 1$ -> $a_{i+1} = b_i + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## b 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927110-ac604700-c71a-11eb-989a-3d97d8e6a3ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5$의 최소값 공식을 설계하자.\r\n\r\n$b_5$에서 한팀을 뺀 $b_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927135-c0a44400-c71a-11eb-9c22-4e1303799b3b.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = c_5$ 이므로 $b_5 = c_5 + 1$\r\n\r\n$a_5$의 식과 동일하다.\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{14} + e_{15} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927154-d285e700-c71a-11eb-8b25-14fd85e1b1b0.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = a_4$ 이므로 $b_5 = a_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $b_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $b_5 = c_5 + 1$ -> $b_{n+1} = c_{n+1} + 1$\r\n* $b_5 = a_4 + 1$ -> $b_{n+1} = a_n + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## c 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927173-e3365d00-c71a-11eb-9c1b-dfb34ab3b444.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5$의 최소값 공식을 설계하자. ($c_5$는 4행까지 채워짐에 유의하자)\r\n\r\n$c_5$에서 한팀을 뺀 $c_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 여러 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927189-f47f6980-c71a-11eb-8c17-2120a82b4b6e.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 - 1 = a_4$ 이므로 $c_5 = a_4 + 1$\r\n\r\n$c_5 - 1 = b_4$ 이므로 $c_5 = b_4 + 1$\r\n\r\n두 케이스 중 더 작은 케이스가 $c_5$이므로 아래의 식으로 귀결된다.\r\n\r\n$c_5 = min(a_4 + 1, b_4 + 1)$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927199-ff39fe80-c71a-11eb-8b45-bb4f13aadf08.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 한팀이 네개의 구역을 커버할 수 있을 경우\r\n\r\n$c_i$의 경우 한 가지 특이 케이스가 발생한다. $a_i$, $b_i$의 경우 최소 투입인원인 1을 뺀 값만을 계산했다. $c_i$의 경우 직사각형이라는 특징 때문에 최대 4개 구역을 2팀이 점령할 수 있다.\r\n\r\n$e_{03} + e_{04} ≤ W$ 이고 $e_{13} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927226-11b43800-c71b-11eb-8845-7597a3a502b8.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_3 + 2$\r\n\r\n모든 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $c_{i+1} = min(a_{i} + 1, b_{i} + 1)$\r\n* $c_{i+1} = c_{i} + 1$\r\n* $c_{i+1} = c_{i-1} + 2$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 최종 일반식\r\n\r\n구한 일반식을 정리하면 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 원형 구조 적용을 위한 초기값 지정하기\r\n\r\n위 수식을 코드로 녹여내면 되지만, 완벽한 건 아니다. 왜냐하면 이 구역이 <span class=\"red-A400\">선형이 아닌 원형 구조</span>이기 때문.\r\n\r\n지금까지 우리는 원리 이해 및 수식 도출의 편의를 위해 원타곤을 임의로 잘라 표타곤으로 전개하여 수식을 계산했다. 이러한 <span class=\"green-A700\">선형 구조는 시작점과 도착점이 있지만 원형은 순환 구조</span>이므로 이에 맞춰 조건식을 작성해야 한다. 즉, <span class=\"red-A400\">원형 구조에 호환되도록 일부 케이스에 초기값을 지정</span>해야 최종적으로 원하는 알고리즘을 작성할 수 있다.\r\n\r\n아래의 사진은 원타곤과 표타곤을 비교한 것이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927246-2b557f80-c71b-11eb-92bf-fe5f92cf5504.png\" width=\"512px\" />\r\n</p>\r\n\r\n이 처럼, 원형 구조는 $e_{00}, e_{07}$끼리도 연결이 가능하지만, 선형 구조는 구조상 불가능하다. 때문에 이러한 케이스들의 초기값을 지정해줘야한다.\r\n\r\n대충 감이 오겠지만, 걸친 모양에 따라 총 4가지 케이스가 존재한다.\r\n\r\n### 걸치지 않을 경우 (기본)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$ 혹은 $e_{10}, e_{17}$과 같이 영역이 겹치지 않을 경우. 선형 구조에서도 적용 가능한 기본적인 케이스다. $a_i, b_i, c_i$의 모양과 연관지어 생각하면 아래와 같이 도식이 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927267-4a541180-c71b-11eb-8596-497ba12219e4.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_i$는 $i$열의 윗 칸만 채우므로 $e_{00}$만 점령한 상태이므로 1\r\n\r\n$b_i$는 $i$열의 아래 칸만 채우므로 $e_{01}$만 점령한 상태이므로 1\r\n\r\n$c_i$는 $i - 1$열을 채우는데, $c_{-1}$은 논리상 불가능하므로 0\r\n\r\n즉 초기값은 아래와 같다.\r\n\r\n$$\r\na_0 = 1\r\n$$\r\n\r\n$$\r\nb_0 = 1\r\n$$\r\n\r\n$$\r\nc_0 = 0\r\n$$\r\n\r\n$i = 0$일 때의 초기값을 지정한다.\r\n\r\n이 케이스일 경우 $c_N$이 알고리즘의 답이 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_8$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927320-88e9cc00-c71b-11eb-8ae4-3dfb03d4e0f0.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 윗 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927336-9bfc9c00-c71b-11eb-837d-77c000661702.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$을 점령할 경우. 원형 구조에서만 가능한 케이스다. **걸치지 않는 경우**를 제외한 나머지 케이스는 전부 원형 구조에서만 가능한 케이스이니 참고할 것. $i = 0$일 때는 영향을 받지 않아 **걸치지 않는 경우**와 동일하다. 걸치기 위해선 반드시 두 행 이상이 필요하기 때문에, $N > 1$을 충족해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927372-a880f480-c71b-11eb-84cc-689658a3a89c.png\" width=\"512px\" />\r\n</p>\r\n\r\n연결된 부분을 체크패턴으로 하이라이팅 했다. 이 둘이 서로 연결되기 때문에, 다른 구역의 특수소대가 점령할 수 없다. 따라서 <b class=\"red-A400\">해당 부분은 초기값 계산 시 없는 영역으로 생각하면 된다.</b> 이러한 특징을 감안하면 아래와 같이 초기값을 지정할 수 있다.\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 2\r\n$$\r\n\r\n$$\r\nb_1 = \r\n\\begin{cases}\r\n\t1, & (e_{10} + e_{11} ≤ W)\\\\\r\n\t2, & (e_{10} + e_{11} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $b_{N-1} + 1$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927427-b767a700-c71b-11eb-9306-0931ede25cba.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 아래 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927442-c6e6f000-c71b-11eb-8f51-2fab907fbcc2.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927459-d1a18500-c71b-11eb-9c6c-07919e9f4f8d.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = \r\n\\begin{cases}\r\n\t1, & (e_{00} + e_{01} ≤ W)\\\\\r\n\t2, & (e_{00} + e_{01} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_1 = 2\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $a_{N-1} + 1$이 알고리즘의 답이 된다. $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927475-e120ce00-c71b-11eb-8bd6-c44d4137fae8.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 두 행 모두 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927491-ee3dbd00-c71b-11eb-98b9-f0d4209ec965.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$, $e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927507-fd246f80-c71b-11eb-8e78-f08c15922ad8.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$, $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 1\r\n$$\r\n\r\n$$\r\nb_1 = 1\r\n$$\r\n\r\n$$\r\nc_1 = 0\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $c_{N-1} + 2$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$, $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_{N-1} + 2$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927519-07df0480-c71c-11eb-9fdf-c8f05858b72d.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 최종 케이스\r\n\r\n* 기본\r\n  * $a_0 = 1$\r\n  * $b_0 = 1$\r\n  * $c_0 = 0$\r\n\r\n<br />\r\n\r\n* 윗 행만 걸칠 경우 $(e_{00} + e_{0(N-1))} ≤ W)$\r\n  * $a_1 = 2$\r\n  * $b_1 = \\begin{cases} 1, & (e_{10} + e_{11} ≤ W)\\\\ 2, & (e_{10} + e_{11} > W) \\end{cases}$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 아래 행만 걸칠 경우 $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = \\begin{cases} 1, & (e_{00} + e_{01} ≤ W)\\\\ 2, & (e_{00} + e_{01} > W) \\end{cases}$\r\n  * $b_1 = 2$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 두 행 모두 걸칠 경우 $(e_{00} + e_{0(N-1)} ≤ W)$, $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = 1$\r\n  * $b_1 = 1$\r\n  * $c_1 = 0$\r\n\r\n비로소 알고리즘을 구현하기 위한 모든 준비물이 갖춰졌다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\npackage beakjoon.all.a1006;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1006 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/02/A1006/\">1006 풀이</a>\r\n * @since 2021.06.06 Sun 22:44:45\r\n */\r\npublic class Main\r\n{\r\n\tprivate static int N;\r\n\tprivate static int W;\r\n\t\r\n\tprivate static int[][] e;\r\n\t\r\n\tprivate static int[] a;\r\n\tprivate static int[] b;\r\n\tprivate static int[] c;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tint result = 2147483647;\r\n\t\t\t\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 행 수\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\t// 특수소대원 수\r\n\t\t\tW = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 구역별 적 배열\r\n\t\t\te = new int[2][N];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < 2; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tfor (int k = 0; k < N; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\te[j][k] = Integer.parseInt(temp[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ta = new int[N];\r\n\t\t\tb = new int[N];\r\n\t\t\tc = new int[N + 1];\r\n\t\t\t\r\n\t\t\ta[0] = 1;\r\n\t\t\tb[0] = 1;\r\n\t\t\tc[0] = 0;\r\n\t\t\t\r\n\t\t\t// 인덱스 0부터 시작\r\n\t\t\tsolve(0);\r\n\t\t\t\r\n\t\t\tresult = Math.min(result, c[N]);\r\n\t\t\t\r\n\t\t\t// 두 행 이상일 경우\r\n\t\t\tif (N > 1)\r\n\t\t\t{\r\n\t\t\t\t// 두 행 모두 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W && e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 1;\r\n\t\t\t\t\tb[1] = 1;\r\n\t\t\t\t\tc[1] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, c[N - 1] + 2);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 윗 행만 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 2;\r\n\t\t\t\t\tb[1] = e[1][0] + e[1][1] > W ? 2 : 1;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, b[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아래 행만 걸칠 경우\r\n\t\t\t\tif (e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = e[0][0] + e[0][1] > W ? 2 : 1;\r\n\t\t\t\t\tb[1] = 2;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, a[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 함수\r\n\t *\r\n\t * @param num: [int] 시작 인덱스\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\tfor (int i = num; i < N; i++)\r\n\t\t{\r\n\t\t\tc[i + 1] = Math.min(a[i] + 1, b[i] + 1);\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\tif (e[0][i] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i] + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두개의 구역 2개를 점령할 수 있을 경우\r\n\t\t\tif (i > 0 && e[0][i - 1] + e[0][i] <= W && e[1][i - 1] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i - 1] + 2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// a, b팀의 인덱스 보정 (c팀은 인덱스가 하나 더 많음)\r\n\t\t\tif (i < N - 1)\r\n\t\t\t{\r\n\t\t\t\ta[i + 1] = c[i + 1] + 1;\r\n\t\t\t\tb[i + 1] = c[i + 1] + 1;\r\n\t\t\t\t\r\n\t\t\t\t// a팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[0][i] + e[0][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[i + 1] = Math.min(a[i + 1], b[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// b팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[1][i] + e[1][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\tb[i + 1] = Math.min(b[i + 1], a[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n# 여담\r\n\r\n6월 1일부터 풀기 시작해서 이 문제를 완전히 이해하는데 근 일주일 가까이 걸렸다. 나름의 풀이를 작성해야하는데, 남의 풀이가 아닌 내 풀이를 작성하기 위해선 해당 문제를 온전히 이해할 필요가 있었다. 내가 다른 사람들의 풀이를 보면서 이해하지 못해서 내 스스로 생각하고 이해한 걸 나름대로 녹여냈다. 다른 사람이 내 글을 보고 이 어려운 문제를 쉽게 이해할 수 있었으면 좋겠다.\r\n\r\n이해하고 봐도 다소 난해한데, 이걸 원리부터 코드까지 이끌어내어 풀어내는 사람은 정말 대단한 거 같다. 아님 내가 실력이 없는건가.\r\n\r\n## 참고\r\n\r\n* [The Casterian](https://casterian.net/archives/1356)\r\n* [굳건하게](https://travelbeeee.tistory.com/354)\r\n* [테스트 케이스](https://www.acmicpc.net/board/view/11381)"},"next":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 2. GitHub와 친해지기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-07T22:42:02","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)","GitHub(깃허브)"],"group":"Jekyll Blog","comment":true,"publish":true,"slug":"2021-06-07-jekyll-blog-github","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">Jekyll</span>은 <span class=\"primary\">GitHub</span>를 통해 호스팅한다. 즉, <span class=\"primary\">Jekyll</span>로 블로그를 만들기 위해선 <span class=\"primary\">GitHub</span>를 조금이나마 알고 있어야 한다. 본문에서는 <span class=\"primary\">GitHub</span>의 여러 기능은 제쳐두고, <span class=\"primary\">Jekyll</span> 호스팅을 목적을 기준으로 설명한다.\r\n\r\n# GitHub 속으로!\r\n\r\n<span class=\"primary\">GitHub</span>는 개발자들을 위한 소스코드 형상관리 서비스를 제공해준다. Git을 저장하고 관리하는 대표적인 저장소로, 수 많은 오픈, 개인 소스가 존재한다. Git과 <span class=\"primary\">GitHub</span>는 그 자체만으로도 커다란 주제가 여러개 튀어나오니, 일단은 우리의 목표인 호스팅만을 알아보자.\r\n\r\n<a href=\"https://github.com/\">GitHub 바로가기</a>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90389062-d2512800-e0c3-11ea-8a59-f4980afab7b5.png\" width=\"820px\" />\r\n</p>\r\n\r\n접속하면 위와 같은 화면을 볼 수 있는데, 상단 우측의 <span class=\"lightBlue-A400\">Sign Up</span>을 클릭하여 회원가입을 진행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90411265-777cf800-e0e6-11ea-95d5-372388b32bd2.png\" width=\"820px\" />\r\n</p>\r\n\r\n* username: 닉네임\r\n* Email address: 이메일 주소\r\n* Password: 비밀번호\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412061-96c85500-e0e7-11ea-9a7b-8f71fa52f776.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정을 생성하면 나오는 설문조사. 무시해도 무방하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412232-d42ce280-e0e7-11ea-92e9-dc637cb2c8a9.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정 생성이 완료되면 회원가입 시 작성한 이메일로 인증 코드를 전송하니 메일을 확인한다.\r\n\r\n만약, 이메일이 제대로 오지 않는다면, <span class=\"lightBlue-A400\">Resend verification email</span>을 통해 메일을 재발송할 수 있다. 혹은 이메일 주소를 잘못 입력했다면, <span class=\"lightBlue-A400\">Change your email settings</span>를 클릭하여 인증할 이메일 주소를 변경한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412375-fde60980-e0e7-11ea-805b-7d4c58ab0b4d.png\" width=\"820px\" />\r\n</p>\r\n\r\n인증 이메일을 확인하고 <span class=\"lightBlue-A400\">Verify email address</span>를 클릭하여 인증을 완료한다. 계정 생성 과정이 끝난다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412420-0b9b8f00-e0e8-11ea-80a5-d28ff329a020.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"primary\">GitHub</span>에 접속하여 로그인을한다. 회원가입시 입력한 username이나 email 둘 중 아무거나 사용해도 상관없다. 위 화면이 뜨면 회원가입이 완료된 것이다."}},"group":[{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 2. GitHub와 친해지기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-07T22:42:02","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)","GitHub(깃허브)"],"group":"Jekyll Blog","comment":true,"publish":true,"slug":"2021-06-07-jekyll-blog-github","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">Jekyll</span>은 <span class=\"primary\">GitHub</span>를 통해 호스팅한다. 즉, <span class=\"primary\">Jekyll</span>로 블로그를 만들기 위해선 <span class=\"primary\">GitHub</span>를 조금이나마 알고 있어야 한다. 본문에서는 <span class=\"primary\">GitHub</span>의 여러 기능은 제쳐두고, <span class=\"primary\">Jekyll</span> 호스팅을 목적을 기준으로 설명한다.\r\n\r\n# GitHub 속으로!\r\n\r\n<span class=\"primary\">GitHub</span>는 개발자들을 위한 소스코드 형상관리 서비스를 제공해준다. Git을 저장하고 관리하는 대표적인 저장소로, 수 많은 오픈, 개인 소스가 존재한다. Git과 <span class=\"primary\">GitHub</span>는 그 자체만으로도 커다란 주제가 여러개 튀어나오니, 일단은 우리의 목표인 호스팅만을 알아보자.\r\n\r\n<a href=\"https://github.com/\">GitHub 바로가기</a>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90389062-d2512800-e0c3-11ea-8a59-f4980afab7b5.png\" width=\"820px\" />\r\n</p>\r\n\r\n접속하면 위와 같은 화면을 볼 수 있는데, 상단 우측의 <span class=\"lightBlue-A400\">Sign Up</span>을 클릭하여 회원가입을 진행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90411265-777cf800-e0e6-11ea-95d5-372388b32bd2.png\" width=\"820px\" />\r\n</p>\r\n\r\n* username: 닉네임\r\n* Email address: 이메일 주소\r\n* Password: 비밀번호\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412061-96c85500-e0e7-11ea-9a7b-8f71fa52f776.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정을 생성하면 나오는 설문조사. 무시해도 무방하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412232-d42ce280-e0e7-11ea-92e9-dc637cb2c8a9.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정 생성이 완료되면 회원가입 시 작성한 이메일로 인증 코드를 전송하니 메일을 확인한다.\r\n\r\n만약, 이메일이 제대로 오지 않는다면, <span class=\"lightBlue-A400\">Resend verification email</span>을 통해 메일을 재발송할 수 있다. 혹은 이메일 주소를 잘못 입력했다면, <span class=\"lightBlue-A400\">Change your email settings</span>를 클릭하여 인증할 이메일 주소를 변경한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412375-fde60980-e0e7-11ea-805b-7d4c58ab0b4d.png\" width=\"820px\" />\r\n</p>\r\n\r\n인증 이메일을 확인하고 <span class=\"lightBlue-A400\">Verify email address</span>를 클릭하여 인증을 완료한다. 계정 생성 과정이 끝난다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412420-0b9b8f00-e0e8-11ea-80a5-d28ff329a020.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"primary\">GitHub</span>에 접속하여 로그인을한다. 회원가입시 입력한 username이나 email 둘 중 아무거나 사용해도 상관없다. 위 화면이 뜨면 회원가입이 완료된 것이다."}],"post":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 1. Jekyll이란?","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-07T22:42:02","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)"],"group":"Jekyll Blog","comment":true,"publish":true,"slug":"2021-06-07-jekyll-blog-start","content":"<nav class=\"toc-wrap\"><ol class=\"toc-level toc-level-1\"><li class=\"toc-item toc-item-h1\"><a class=\"toc-link toc-link-h1\" href=\"#개요\">개요</a></li><li class=\"toc-item toc-item-h1\"><a class=\"toc-link toc-link-h1\" href=\"#jekyll지킬이란\">Jekyll(지킬)이란?</a></li></ol></nav><p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\n<h1 id=\"개요\"><a class=\"head-link\" href=\"#개요\"><span>🔗</span></a>개요</h1>\n<p>대형 포탈이나 크고 작은 플랫폼을 통해 자신만의 블로그를 만들 수 있다. 이러한 플랫폼을 통한 블로그는 연동된 계정과 버튼 클릭 몇 번으로 만들 수 있을 정도로 쉽고 간편하다. 하지만 이와 같은 블로그는 페이지의 기본 프레임이 정해져있고, 자유로운 커스터마이징이 제한된 편이다. 자신만의 색이나 가치관을 담은 블로그를 만들기 위해선 소위 \"기성품\"이 아닌 방법을 찾아야하는데, 이는 곧 자신이 직접 <span class=\"green-A400\">웹 페이지를 제작하고 퍼블리싱, 호스팅까지 전반적인 웹 서비스 자체를 구축해야하는 큰 작업</span>으로 이어진다. 어찌어찌 페이지를 제작한다 하더라도, <span class=\"purple-A400\">CSS</span>를 통한 디자인이나 <span class=\"orange-A400\">JavaScript</span>같은 부가기능은 프레임 제작 이상으로 어렵다. 여기까지는 어떻게 자력으로 했다고 하더라도, 호스팅은 돈이 든다. DB까지 연동한다면 금액은 더욱 커지게 된다. 내가 원한건 단순한 블로그였는데.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90330531-5d5cf000-dfe8-11ea-8a25-c5c89fa05a42.png\" width=\"820px\">\n</p>\n<p><span class=\"primary\">GitHub Pages</span>를 활용하면 위와같은 문제의 대부분을 해결할 수 있다. <span class=\"primary\">GitHub</span>는 <span class=\"primary\">GitHub Pages</span> 프로젝트를 통해 특정한 이름을 가진 Repository 내부의 파일들을 <span class=\"primary\">github.io</span> 도메인으로 퍼블리싱해준다. 즉, 무료로 웹 호스팅을 제공받을 수 있는 셈이다. <span class=\"primary\">GitHub Pages</span>가 제시하는 방법에 따라 Repository를 만드는 것만으로도 유일하게 비용이 필요한 호스팅이라는 큰 산이 하나 사라진다.</p>\n<blockquote>\n<p>Repository: GitHub에서 관리하는 프로젝트의 단위로, 각 계정마다 여러개의 Repository를 마음대로 생성, 수정, 삭제할 수 있다.</p>\n</blockquote>\n<p>안타깝게도 이는 호스팅과정을 라이트하게 만들어준 것일 뿐, 실제 페이지를 퍼블리싱하기 위해선 어쩔수 없이 웹 코딩 지식이 필요하다. 이를 위해 <span class=\"primary\">GitHub</span>는 <b class=\"primary\">Jekyll(지킬)</b>이라는 프레임워크를 통해 사용자들이 블로그 테마를 쉽게 만들고 이를 활용할 수 있는 환경을 제공하고 있다.</p>\n<p>필자는 어느정도 웹 관련 지식이 있음에도 불구하고 <span class=\"red-A400\">Ruby</span>와 <span class=\"primary\">Jekyll</span>이라는 다소 생소한 환경때문에 이를 이해하는데 다소 시간이 소요됐다. 이번 주제를 통해 웹에 있어서 나와 비슷하거나, 전무한 지식을 가진 사람들에게 내 블로그 구축기를 공유하고자 한다. 이 글은 <span class=\"primary\">Jekyll</span>이라는 개념을 처음 접하는 이들이 가급적 쉽게 이해함에 초점을 맞춘다.</p>\n<h1 id=\"jekyll지킬이란\"><a class=\"head-link\" href=\"#jekyll지킬이란\"><span>🔗</span></a>Jekyll(지킬)이란?</h1>\n<p>지킬 앤 하이드의 그 지킬 맞다. <span class=\"primary\">Jekyll</span>은 <span class=\"primary\">GitHub</span>의 설립자 중 하나인 Tom Preston-Werner가 <span class=\"red-A400\">Ruby</span>언어를 통해 개발한 프레임워크다. <span class=\"primary\">GitHub</span> 자체적으로 <span class=\"primary\">Jekyll</span> CMS(Contents Management System)을 내장하고 있어서 <span class=\"primary\">Jekyll</span> 호스팅에 매우 적합하다.(물론 굳이 Jekyll 기반이 아니여도 호스팅엔 문제가 없다.)</p>\n<p>웹을 나누는 구분 중에 정적(Static) 웹과 동적(Dynamic) 웹이 있다. <span class=\"primary\">Jekyll</span> 정적(Static) 웹 환경을 위한 프레임워크다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90335406-cdcb3780-e00f-11ea-87e2-b8c8ba8f576c.png\" width=\"820px\">\n</p>\n<p><strong>정적 웹</strong></p>\n<ul>\n<li>요청에 따라 미리 저장된 페이지를 응답</li>\n<li>웹 서버가 필요하지 않으므로, 서버 사양에 대한 영향이 적음</li>\n<li>Back-end 코드가 없어 제작이 간편함</li>\n<li>속도가 빠름</li>\n<li>복잡한 로직이 필요 없는 소규모 사이트(블로그 등)에 적합함</li>\n</ul>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90335405-cb68dd80-e00f-11ea-9b08-7a9ec21c5eee.png\" width=\"820px\">\n</p>\n<p><strong>동적 웹</strong></p>\n<ul>\n<li>요청에 따라 웹 서버가 데이터를 가공하여 전달</li>\n<li>DB연동을 통한 데이터 CRUD가 가능</li>\n<li>동일한 페이지도 요청에 따라 다양한 내용을 응답</li>\n<li>웹 서버 사양에 따라 속도 저하의 우려 있음</li>\n<li>복잡한 로직이 필요한 비즈니스 사이트(쇼핑몰 등)에 적합함</li>\n</ul>\n<p>우리가 사용하는 대부분의 사이트는 동적 웹의 형태가 대부분이다. 자체적인 회원가입 시스템, 간단한 게시판 등이 존재한다면 대부분 동적 웹으로 봐도 무방하다. 회원가입이나 게시판에는 반드시 DB가 필요하고, 이는 곧 DB와 사이트 간의 동작을 제어할 서버가 필요하다는 의미이기 때문. DB의 존재로 인해 실시간 데이터 CRUD가 가능하다. <span class=\"green-A400\">사용자가 페이지에서 무언가 의미있는 컨텐츠 활동을 할 수 있다면 동적 웹</span>이다.</p>\n<p>반대로, 정적 웹은 단순히 저장된 파일을 요청에 맞게 보여만 주므로, 사용자는 단순 사이트 관광객 그 이상 그 이하도 아니다. 블로그의 경우 로그인 같은 사용자 인증이 전혀 필요 없으며, 소유자외의 작성자가 필요하지 않기 때문에 정적 웹 형태로도 얼마든지 서비스를 제공할 수 있다. <span class=\"primary\">Jekyll</span>은 사용자가 작성한 코드를 하나의 웹 프로젝트 형태로 빌드한다. <span class=\"primary\">Jekyll</span>은 이러한 정적 웹 방식을 채택함으로써 빠른 속도를 확보하고 백엔드 코드에 대한 부담감을 없앴다.</p>\n<p>사용하기에 앞서, <span class=\"primary\">Jekyll</span>은 <span class=\"red-A400\">블로그 퍼블리싱의 주체가 자기 자신</span>에게 있다. 즉, 페이지 하나하나를 세세하게 컨트롤 할 수 있으며, 그래야만 한다. 이러한 자유도는 누군가에겐 강력한 장점이지만, 누군가에겐 없는게 나은 단점이 되기도 한다.</p>\n<p><span class=\"green-A400\">Jekyll은 이런 분들께 적합해요!</span></p>\n<ul>\n<li>판에 찍힌 블로그보다 자신만의 감각이 들어간 블로그를 만들고 싶은 사람</li>\n<li>웹에 대한 기초적인 지식이나 그에 준하는 센스를 가진 사람</li>\n<li>다양한 기능을 구현하고 싶은 사람</li>\n<li>위의 모든 사항을 재미로 느낄 수 있는 사람</li>\n</ul>\n<p><span class=\"red-A400\">Jekyll은 이런 분들께 나빠요...</span></p>\n<ul>\n<li>어찌됐든 안정적인 블로그를 얻고싶은 사람</li>\n<li>이런저런 난잡한 일에 시간을 투자하기 어려운 사람</li>\n<li>지금 당장 블로그를 시작하고 싶은 사람</li>\n<li>복잡한 것을 지양하는 사람</li>\n</ul>\n<p><span class=\"primary\">Jekyll</span>은 하나부터 열까지 본인이 직접 구성해야한다. 그 흔한 댓글 기능조차 플러그인을 사용해서 구성해야한다. 즉, 통상 사이트 혹은 블로그라면 응당 존재해야할 기능조차 본인이 스스로 구성하지 않으면 안 된다. 원한다면 내 블로그에 무엇이든 구현할 수 있지만, 반대로 아무것도 구현하지 않은 단순한 페이지조각에 그친다. 기타 카테고리나 태그를 만들 때도 마찬가지. 이런걸 하면서 재미를 느끼지 못 한다면 개인적으로 별로 권하고 싶지 않다.</p>\n<p>물론 아름다운 테마를 적용할 수 있는건 독보적인 강점이지만, 이미 Tistory 정도만 가도 플랫폼 형태이면서 강력한 커스터마이징을 제공하기도 한다. 그럼에도 불구하고 <span class=\"primary\">Jekyll</span>을 선택한다면, <span class=\"primary\">Jekyll</span>은 당신에게 그 어떤 블로그에서도 접해보지 못한 색다른 경험을 제공해줄 것이다.</p>"}},"__N_SSG":true}