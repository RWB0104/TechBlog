{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"URI? URL? URN? 리소스 식별자 구분하기","excerpt":"우리가 인터넷 상에서 특정한 데이터에 접근할 때 URL이라는 것을 활용하여 접근한다. 원하는 자료의 URL을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 URL을 호출하여 응답을 얻는 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028437-a63ddc80-c02f-11eb-9d41-7c50d7002a42.png","date":"2021-05-29T03:30:17","type":"posts","category":"WEB","tag":["WEB(웹)","URI","URL","URN"],"comment":true,"publish":true},"name":"2021-05-29-uri-url-urn.md","content":"\r\n# URL! URI... URN??\r\n\r\n우리가 인터넷 상에서 **특정한 데이터**에 접근할 때 <span class=\"primary\">URL</span>이라는 것을 활용하여 접근한다.  \r\n원하는 자료의 <span class=\"primary\">URL</span>을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 <span class=\"primary\">URL</span>을 호출하여 응답을 얻는 것이다.\r\n\r\n개발자나, 굳이 개발자가 아니더라도 관련 정보를 찾다보면 심심치않게 <span class=\"primary\">URI</span>라는 용어를 접하게 된다.  \r\nI와 L의 오묘한 유사성 때문에 아예 <span class=\"primary\">URI</span>를 <span class=\"primary\">URL</span>로 오독하는가 하면, 오타라고 생각하는 사람도 더러 있을 것이다.  \r\n하지만 <span class=\"primary\">URL</span>과 <span class=\"primary\">URI</span>는 그 의미가 비슷하면서도 살짝 다르다.\r\n\r\n누구나 알고있는 <span class=\"primary\">URL</span>과 아리까리한 <span class=\"primary\">URI</span>, 생소한 <span class=\"primary\">URN</span>. 이들에 대해 알아보자\r\n\r\n# UR* 톱아보기\r\n\r\n<span class=\"primary\">URI</span>, <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>은 구조상 서로 연관이 있다.\r\n\r\n## URI(Uniform Resource Identifier, 통합 자원 식별자)\r\n\r\n<span class=\"primary\">URI</span>는 우리말로 **통합 자원 식별자**라고 한다. <span class=\"primary\">URI</span>는 앞서 말한 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>을 포함하는 상위 개념으로, <span class=\"orange-400\">인터넷 상에 존재하는 **자원을 구분**하는 식별자</span>라 할 수 있다. 웹 상에서 자원을 식별하는 모든 수단이 곧 <span class=\"primary\">URI</span>이라 할 수 있다.\r\n\r\n## URL(Uniform Resource Locater, 통합 자원 지시자)\r\n\r\n<span class=\"primary\">URL</span>은 굳이 우리말로 하자면 **통합 자원 지시자**라고 할 수 있겠지만, 흔히 인터넷 상에서 **주소**라 함은 99% 이 <span class=\"primary\">URL</span>을 의미한다. 1994년 **RFC-1738**에 정의되어있다.  \r\n<span class=\"primary\">URL</span>은 **Locater**라는 키워드에 걸맞게 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 **위치**를 나타내는 식별자</span>라 할 수 있다. 여기서 **위치**라는 키워드에 주목하자. <span class=\"primary\">URL</span>은 자원의 위치정보를 가지므로, 어떠한 이유로든 자원의 위치가 변경되면 <span class=\"primary\">URL</span>은 자원을 찾을 수 없으며, 변경된 위치를 추적할 수도 없다. 이 때 맞이하게 되는 HTTP 오류가 누구나 알고있는 404 Not Found다.  \r\n당장 내가 이 게시물의 이름을 한 글자만 변경해도, 지금까지의 <span class=\"primary\">URL</span>은 아무 쓸모가 없어지며, 사용자들 또한 해당 <span class=\"primary\">URL</span>로 이 게시물에 접근할 수 없다. 또한, 이 <span class=\"primary\">URL</span>을 통해 원래 있던 게시물의 <span class=\"primary\">URL</span>을 논리적으로 유추할 수도 없다.\r\n\r\n## URN(Uniform Resource Name, 통합 자원 이름)\r\n\r\n<span class=\"primary\">URN</span>은 **통합 자원 이름**이다. 눈치가 빠른 분들은 아시겠지만, <span class=\"primary\">URN</span>은 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 **이름**을 나타내는 식별자</span>다. 자원의 이름은 고유한 값을 가지므로, 인터넷 상의 수 많은 자원들 중 특정 자원을 식별할 수 있는 것이다.  \r\n<span class=\"primary\">URN</span>은 대부분 위에 언급한 두 개념에 비해 생소할 것이다. 그도 그럴 것이, <span class=\"primary\">URN</span>은 위 두 개념보다 훨씬 뒤에 나온 개념이기 때문이다. 1997년 **RFC-2141**에 정의되어있다. <span class=\"primary\">URL</span>보다 3년 뒤에 출범하여 그 역사가 상대적으로 짧다.  \r\n\r\n<span class=\"primary\">URL</span>의 치명적인 단점은 **위치**정보 외에 다른 정보를 저장하지 않는다. 이 상황에서 해당 자원을 찾아야 한다면? 안타깝게도 <span class=\"primary\">URL</span>만으로는 찾아낼 수 없다. 구글링해서 운 좋게 찾아낸다면 모를까.  \r\n반면 <span class=\"primary\">URN</span>을 사용한다면 어떨까? 위치가 아무리 변경된다 하더라도, 자원의 고유한 이름을 통해 찾기 때문에 자원이 웹 상에서 완전히 삭제된 게 아니라면 손쉽게 찾아낼 수 있을 것이다.\r\n\r\n## 정리\r\n\r\n난 어려운 개념을 이해할 때 현실세계와 연관지어 이해하는 걸 좋아한다. 위 세 개념을 현실에서 특정 사람의 신원을 확인하는 과정과 접목해서 정리하면 아래와 같이 정리할 수 있을 것 같다.\r\n\r\n| 구분  |              현실               |         값          |\r\n| :---: | :-----------------------------: | :-----------------: |\r\n| 자원  |             나 자신             |         나          |\r\n|  URI  | 나를 식별할 수 있는 모든 식별자 |          -          |\r\n|  URL  |         내가 사는 주소          | 서울특별시 A구 가동 |\r\n|  URN  |         내 주민등록번호         |   000000-0000000    |\r\n\r\n<span class=\"small red-A400\">※ URN은 모든 자원의 고유값이므로, 사람과 연관지었을 때, 중복 가능성이 있는 이름 보다는 고유값인 주민등록번호가 더 적합하다.</span>\r\n\r\n예를 들어, 내 정보가 위와 같다고 가정해보자. 내가 사는 주소 및 내 주민등록번호 모두 내 신원을 확인할 수 있는 방식(<span class=\"primary\">URI</span>)이므로, 나를 찾기에 적합하다.  \r\n만약 내 주소(<span class=\"primary\">URL</span>)를 통해 확인할 경우, 내가 이사(자원의 이동)를 가게 되면 해당 주소엔 아무것도 없으며, 날 찾을 수도 없다(404 HTTP 에러). 또한, 내가 예전에 살던 주소만으로 내가 이사간 주소를 유추해낼 수도 없을 것이다.\r\n\r\n반면, 내 주민등록번호(<span class=\"primary\">URN</span>)을 통해 확인할 경우, 내 주민등록번호와 매칭되는 사람을 찾는 것으로 나를 식별할 수 있다. 이 과정에서 내가 어디에 있는지는 전혀 중요치 않은 것이다. 주민등록번호 자체가 말소(자원 삭제)되지 않는 한, 내가 어디에서 무엇을 하고있든 내 신원을 확인할 수 있다.\r\n\r\n# 구조\r\n\r\n그렇다면 이들은 어떻게 생겼는지 알아보자. <span class=\"primary\">URI</span>는 자원의 식별자를 포괄하여 지칭하는 개념 그 자체이므로, 구조라고 할 건 없다. 하위 개념인 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>에 대해 알아보자.\r\n\r\n## URL 구조\r\n\r\n<span class=\"primary\">URL</span>은 아래와 같은 구조로 이루어진다. 매우 익숙할 것이다.\r\n\r\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">https</span>://<span class=\"green-400\">rwb0104</span>.<span class=\"yellow-400\">github</span>.<span class=\"pink-400\">com</span>:<span class=\"amber-400\">443</span>/<span class=\"cyan-400\">posts</span><span class=\"teal-400\">?category=WEB&page=1</span></p>\r\n\r\n구조별로 색상을 입혔으며, 순서대로 기술한다.\r\n\r\n### Protocol(프로토콜)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"lightBlue-400\">https</span> 부분.\r\n\r\n통신규약을 의미한다. 작성일 기준으로, 이 규약엔 계층별로 많은 <span class=\"lightBlue-400\">프로토콜</span>이 존재하는데, 웹 통신을 수행할 땐 크게 두 가지로 나뉜다.\r\n\r\n| 구분  |              내용              |\r\n| :---: | :----------------------------: |\r\n| HTTP  | W3 상에서의 HTML 문서 통신규약 |\r\n| HTTPS |    암호화된 HTTP 통신 규약     |\r\n\r\n현재는 포털, 쇼핑몰같은 대형 비즈니스 사이트나 블로그, 카페 등 중소규모의 개인 사이트까지 <span class=\"red-A400\">HTTPS의 사용이 반 강제적으로 권장</span>되어 있다. 특히 전자상거래가 접목된 비즈니스 사이트의 경우 필수로 적용해야 한다. 더군다나 <span class=\"red-A400\">HTTPS가 적용되지 않는 사이트(localhost 제외)에 접근할 경우 브라우저 측에서 보안 관련 경고 메시지</span>를 띄우니, 규모에 관계없이 웹 사이트를 운영할 경우 HTTPS는 필수로 적용하는 편이다.\r\n\r\n### SLD(Second Level Domain, 서브도메인, 호스트)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"green-400\">rwb0104</span> 부분.\r\n\r\n도메인 앞에 붙으며, <span class=\"green-400\">서브도메인</span>을 통해 하나의 <span class=\"yellow-400\">도메인</span>으로 다중 서비스를 제공할 수 있다. 하나의 <span class=\"yellow-400\">도메인</span>에 여러 <span class=\"green-400\">서브도메인</span>을 생성할 수 있으며, 우리가 흔히 아는 `www` 외에도 `dev`, `admin`, `m` 용도에 따라 다양한 문자열을 지정할 수 있다.\r\n\r\n|                  URL                   |                                          내용                                          |\r\n| :------------------------------------: | :------------------------------------------------------------------------------------: |\r\n|     [naver.com](https://naver.com)     | 기본 네이버 홈페이지. 각 플랫폼(데스크탑, 모바일 등)에 가장 적합한 사이트로 리다이렉트 |\r\n| [www.naver.com](https://www.naver.com) |                               데스크탑용 네이버 홈페이지                               |\r\n|   [m.naver.com](https://m.naver.com)   |                                모바일용 네이버 홈페이지                                |\r\n| [map.naver.com](https://map.naver.com) |                                      네이버 지도                                       |\r\n\r\n위는 네이버 서비스의 <span class=\"green-400\">서브도메인</span>으로, `naver.com` <span class=\"yellow-400\">도메인</span>을 중심으로 각기 다른 서비스를 제공하는 것을 확인할 수 있다.\r\n\r\n### Domain(도메인)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"yellow-400\">github</span> 부분.\r\n\r\nURL의 중심이 되는 부분으로, 제공하는 웹 서비스의 아이덴티티 역할을 겸한다. 때문에 <span class=\"yellow-400\">도메인</span>에는 대부분 해당 웹 서비스의 이름이 들어간다.\r\n\r\n|  서비스   |                  URL                   |\r\n| :-------: | :------------------------------------: |\r\n|  네이버   |     [naver.com](https://naver.com)     |\r\n|   다음    |  [www.daum.com](https://www.daum.com)  |\r\n|  GitHub   |    [github.com](https://github.com)    |\r\n| Instagram | [instagram.com](https://instagram.com) |\r\n\r\n대부분의 서비스가 <span class=\"yellow-400\">도메인</span>으로 서비스의 이름을 사용하고 있다.\r\n\r\n### TLD(Top Level Domain, 최상위 도메인)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"pink-400\">com</span> 부분.\r\n\r\n<span class=\"pink-400\">최상위 도메인</span>이란, 앞서 언급한 <span class=\"green-400\">서브도메인</span>, <span class=\"yellow-400\">도메인</span>을 관리하는 업체 혹은 기관이라고 볼 수 있다.  \r\n앞서 언급한 개념의 경우, 중복되지 않는 선에서 사용자가 임의로 지정할 수 있다. 하지만 <span class=\"pink-400\">최상위 도메인</span>의 경우 현재 운영 중인 업체나 기관 중 하나를 **선택**해서 등록해야 한다. <span class=\"pink-400\">최상위 도메인</span>을 선택할 경우, 당신의 도메인은 해당 <span class=\"pink-400\">최상위 도메인</span>을 운영하는 곳에서 관리하게 된다.  \r\n\r\n<span class=\"pink-400\">최상위 도메인</span>은 운영 주체에 따라 두 가지로 나뉜다.\r\n\r\n#### ccTLD(country code TLD, 국가 코드 최상위 도메인)\r\n\r\n국가를 나타내는 <span class=\"pink-400\">최상위 도메인</span>이다.\r\n\r\n| ccTLD |     내용      |\r\n| :---: | :-----------: |\r\n|  .kr  |  한국(KISA)   |\r\n|  .us  |   미국(LLC)   |\r\n|  .jp  |     일본      |\r\n|  .io  | 영국령 인도양 |\r\n\r\n<span class=\"pink-400\">ccTLD</span>는 위 표와 같이 국가 코드 형태이며, 각 국가기관이 직접 관리한다. 즉, `.kr`을 가진 모든 도메인은 **한국의 KISA(한국 인터넷 진흥원)에서 관리**한다.\r\n\r\n#### gTLD(generic TLD, 일반 최상위 도메인)\r\n\r\n사이트 혹은 사이트를 소유한 조직, 기관의 특성에 따라 사용하는 <span class=\"pink-400\">최상위 도메인</span>이다.\r\n\r\n| gTLD  |       내용        |\r\n| :---: | :---------------: |\r\n| .com  | 영리 단체 및 기관 |\r\n| .net  | 네트워크 관리기관 |\r\n| .org  |    비영리 기관    |\r\n| .gov  |     정부 기관     |\r\n\r\n<span class=\"pink-400\">gTLD</span>는 위 표와 같이 다양한 종류가 있으며, 그 중 몇몇은 자주 접했을 것이다. 정부기관이 왜 여기있나 생각할 수도 있는데, <span class=\"pink-400\">ccTLD</span>는 **국가 코드**만 해당된다. 국가 예하의 정부기관, 군사조직 등은 구분 상 <span class=\"pink-400\">gTLD</span>로 분류된다.  \r\n마찬가지로, 각 <span class=\"pink-400\">최상위 도메인</span>은 **해당 <span class=\"pink-400\">최상위 도메인</span>을 소유한 기관 혹은 기업에서 관리**한다.\r\n\r\n> 현재 운영 중인 <span class=\"pink-400\">최상위 도메인</span>은 [IANA](https://www.iana.org/domains/root/db)에서 확인할 수 있다.\r\n\r\n여담으로, <span class=\"pink-400\">최상위 도메인</span>에 중복된 <span class=\"yellow-400\">도메인</span>을 등록할 수 없다. 예를 들어, 내가 `aaa.com` URL을 등록한다고 가정해보자.  \r\n우선 제일 먼저 `.com`을 관리하는 업체에 `aaa`라는 <span class=\"yellow-400\">도메인</span>을 등록해야 한다. 하지만, 이미 누군가가 `aaa.com`을 등록했다면 해당 소유주가 <span class=\"yellow-400\">도메인</span>의 소유권을 포기하기 전까진 `aaa.com` <span class=\"yellow-400\">도메인</span>을 소유할 수 없다.  \r\n물론 `.com`이 아닌 `.kr`이나 `.net`에는 등록할 수 있다. 하지만 `socket.io` 처럼 <span class=\"yellow-400\">도메인</span>과 <span class=\"pink-400\">최상위 도메인</span>까지 의미론적으로 구성했다면, 이러한 상황이 달갑지 않을 것이다. 때문에 일전에 이슈됐던 <span class=\"primary\">덮죽 상표권 선점</span>과 비슷한 일이 일어나기도 한다.\r\n\r\n## Port(포트)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"amber-400\">443</span> 부분. 앞에 반드시 `:`이 붙는다.\r\n\r\n인터넷에 연결된 모든 디바이스는 사용하는 네트워크의 IP를 할당받는다. 할당받은 IP 내에서 해당 디바이스가 수행 중인 모든 프로세스의 통신이 이루어진다. <span class=\"amber-400\">포트</span>는 프로세스의 데이터가 IO되는 통로다. 작업 시, 각 프로세스 별로 고유한 <span class=\"amber-400\">포트</span>를 할당받으며, 하나의 <span class=\"amber-400\">포트</span>는 반드시 하나의 프로세스와 1:1 매칭된다. 반면, 하나의 프로세스는 여러 <span class=\"amber-400\">포트</span>를 할당받을 수 있다.  \r\n**특정 프로세스와 통신하기 위해선 반드시 해당 프로세스가 할당받은 <span class=\"amber-400\">포트</span>에 데이터를 전송**해야 한다. 때문에 <span class=\"amber-400\">포트</span> 통신은 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 크게 중요하지 않으며, 어떤 <span class=\"amber-400\">포트</span>로 보내는지가 중요하다.\r\n\r\n웹 통신에서의 기본<span class=\"amber-400\">포트</span>는 아래와 같다.\r\n\r\n| 포트  |      내용       |\r\n| :---: | :-------------: |\r\n|  80   | HTTP 기본 포트  |\r\n|  443  | HTTPS 기본 포트 |\r\n\r\n아마 이러한 숫자를 처음 볼 수도 있는데, 대부분의 웹 사이트 <span class=\"primary\">URL</span>에는 <span class=\"amber-400\">포트</span>를 확인할 수 없다. 사이트가 **각 프로토콜의 기본 <span class=\"amber-400\">포트</span>로 서비스될 경우, <span class=\"primary\">URL</span>에서 <span class=\"amber-400\">포트</span>를 생략**할 수 있다. 즉, `https://naver.com`의 <span class=\"amber-400\">포트</span>번호는 `443`이지만, `443`은 HTTPS의 기본 <span class=\"amber-400\">포트</span>이므로 생략된다. 만약, `443`이 아닌 `8080`, `9200`과 같은 **임의의 <span class=\"amber-400\">포트</span>로 서비스를 제공할 경우, <span class=\"amber-400\">포트</span>를 반드시 명시해야하므로 생략이 불가능**하다. 이 경우 <span class=\"primary\">URL</span>은 `https://naver.com:8080`이 될 것이다.  \r\n위와 같은 이유로, 대부분의 웹 사이트는 서비스하는 프로토콜에 맞는 기본 <span class=\"amber-400\">포트</span>를 사용한다.\r\n\r\n<span class=\"amber-400\">포트</span>는 **0 ~ 65535**의 범위를 가지며, 크게 세 가지로 구분할 수 있다.\r\n\r\n### 잘 알려진 포트(well-known Port)\r\n\r\n**0 ~ 1023**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터에서 기본적으로 사용되는 주요 프로세스에 기본적으로 할당되는 포트로, ICANN(Internet Corporation for Assigned Names and Numbers, 국제 인터넷주소 관리기구)에 의해 통제된다.\r\n\r\n|  포트  |  기능  |        용도        |\r\n| :----: | :----: | :----------------: |\r\n| 20, 21 |  FTP   |    파일 송수신     |\r\n|   22   |  SFTP  | 파일 암호화 송수신 |\r\n|   23   | Telnet |    터미널 통신     |\r\n|   25   |  SMTP  |     메일 전송      |\r\n|   53   |  DNS   |      DNS 통신      |\r\n|   67   |  DHCP  |     DHCP 통신      |\r\n|   80   |  HTTP  |     HTML 통신      |\r\n|  443   | HTTPS  |  HTML 암호화 통신  |\r\n\r\n어디까지나 초기에 지정되는 <span class=\"amber-400\">포트</span>이므로, 추후 **사용자의 의도에 따라 비어있는 다른 포트로 변경**할 수도 있다. 즉, 초기값일뿐, 강제는 아니다.\r\n\r\n### 등록된 포트(registered Port)\r\n\r\n**1024 ~ 49151**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터의 기본 프로세스는 아니지만, 주요 프로그램들이 기본으로 사용하고자 ICANN에 등록한 <span class=\"amber-400\">포트</span>다. <span class=\"amber-400\">잘 알려진 포트</span>와 마찬가지로 프로그램의 설정을 통해 **사용자의 의도에 따라 비어있는 다른 포트로 변경**할 수 있다.\r\n\r\n| 포트  |         기능         |             용도             |\r\n| :---: | :------------------: | :--------------------------: |\r\n| 1433  |        MSSQL         |        MSSQL DB 통신         |\r\n| 3306  |        MySQL         |        MySQL DB 통신         |\r\n| 3389  |         RDP          | 원격 데스크톱 접근 (Windows) |\r\n| 5432  |      PostgreSQL      |      PostgreSQL DB 통신      |\r\n| 8080  | HTTP 통신(Tomcat 등) |   HTTP 통신 (80포트 대용)    |\r\n| 27017 |       MongoDB        |         MongoDB 통신         |\r\n\r\n주로 <span class=\"primary\">DB</span>같은 개발 관련 프로그램들이 많이 등록돼있다.\r\n\r\n#### 왜? 하필 개발 관련 프로그램들만?\r\n\r\n개발 관련 프로그램들은 그 특성 상 통신의 방식이 **항상 일정**해야 한다. 만약 DB의 <span class=\"amber-400\">포트</span>가 기동할 때마다 수시로 변경된다면 어떨까? 이유를 막론하고 DB가 재기동될 경우, 개발자는 DB가 사용 중인 임의의 <span class=\"amber-400\">포트</span>를 추적하여 프로그램의 DB 통신 코드를 변경해야하는 매우 불합리한 상황이 발생하게 된다.  \r\n\r\n이에 비해 게임이나 IDE 같은 일반적인 프로그램들은 굳이 통신의 방식이 일정할 필요는 없다. 어찌됐든 **서버에 정보를 요청하는 순간, 서버는 자연스레 내 통신 정보를 알게되기 때문**이다. 서버는 요청했던 경로로 다시 데이터를 반환해주면 된다. 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 별로 중요하지 않는 이유가 여기에 있다.\r\n\r\n### 동적 포트(dynamic Port)\r\n\r\n**49152 ~ 65535**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 대다수의 프로그램들은 <span class=\"amber-400\">포트</span> 기본값이 지정되지 않는 경우가 대부분이다. 이러한 프로그램들은 <span class=\"amber-400\">동적 포트</span> 중 사용 가능한 임의의 빈 <span class=\"amber-400\">포트</span>를 자동으로 점유한다. 때문에 ICANN이 관리하지도 않으며, 특정 프로그램이 고유한 <span class=\"amber-400\">포트</span>로 등록되어있지도 않다. 자유석을 생각하면 편하다.\r\n\r\n### Path(경로)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"cyan-400\">posts</span> 부분. 웹 사이트의 하위 경로를 의미한다. <span class=\"cyan-400\">경로</span>는 `/`로 구분하며, 경로 입력을 통해 서버 내의 원하는 자원에 접근할 수 있다.\r\n\r\n* https://blog.itcode.dev\r\n  * posts\r\n    * index.html\r\n    * a1000\r\n      * index.html\r\n    * a1001\r\n      * index.html\r\n    * uri-url-urn\r\n      * index.html\r\n  * project\r\n    * index.html\r\n  * index.html\r\n\r\n위 트리는 이 블로그의 단편적인 디렉토리 예시다. 이 중 해당 게시물에 접근하려면 <span class=\"cyan-400\">경로</span>는 `/posts/uri-url-urn/index.html`와 같이 구성할 수 있다. <span class=\"primary\">index.html은 생략이 가능</span>하므로 `/posts/uri-url-urn`로 접근해도 무방하다.\r\n\r\n> **아시나요?**  \r\n> **index.html** 경로의 기본 HTML을 의미함. 더이상의 하위 경로를 표시하지 않을 경우, 해당 경로의 index.html를 응답한다.\r\n\r\n<span class=\"cyan-400\">경로</span>는 서버의 구조에 따라 결정되므로, 사이트마다 천차만별이다.\r\n\r\n### Query String(쿼리 문자열)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"teal-400\">?category=WEB&page=1</span> 부분. 해당 <span class=\"cyan-400\">경로</span>에 임의의 데이터를 같이 전송할 때 사용한다.  \r\n<span class=\"primary\">key=value</span> 형태로 이루어지며, 각 `key`는 <span class=\"purple-400\">Parameter(파라미터)</span>라 칭한다. 첫 <span class=\"purple-400\">파라미터</span>는 `?`로 시작하며, 이후 각 <span class=\"purple-400\">파라미터</span>들은 `&`으로 구분된다. 즉 `?key1=value1&key2=value2&key3=value3`과 같은 양식으로 전개된다.\r\n\r\n임의의 키워드를 전달하여 페이지의 동작을 제어할 수 있다. <span class=\"primary\">URL</span> 중 **사용자의 니즈가 가장 활발하게 반영**되는 부분. <span class=\"teal-400\">쿼리 문자열</span>은 각각의 `key`에 대한 역할을 정의해야 하므로, 개발자가 각 <span class=\"purple-400\">파라미터</span>의 `key`가 동작하는 로직을 작성했을 때 그 의미가 있다.\r\n\r\n## URN 구조\r\n\r\n지금까지 <span class=\"primary\">URL</span>에 대해선 상당히 장황하게 설명했지만, <span class=\"primary\">URN</span>의 경우 <span class=\"primary\">URL</span>보다 역사가 짧다. 이미 3년이라는 시간 사이에 <span class=\"primary\">URL</span>이 표준으로 자리매김한 탓에, 현재까지도 비주류를 면치 못 해 구현된 예시도 그리 많지 않은게 현실이다.  \r\n<span class=\"primary\">URL</span>이 위치만 바뀌어도 찾을 수 없다는 단점은, 오히려 제공중인 데이터를 은닉하는 측면 등 상황에 따라 오히려 유용하게 사용할 여지도 있다. 즉, <span class=\"primary\">URL</span>의 단점이 마냥 나쁜것만은 아닌 셈이다. 이는 곳 <span class=\"primary\">URN</span>의 장점이 현재 구축된 <span class=\"primary\">URL</span>체계를 갈아 엎을 정도로 매력적이지 않다는 주장을 뒷받침한다.\r\n\r\n<span class=\"primary\">URN</span>은 아래와 같은 구조로 이루어진다. 각 요소는 `:`으로 구분한다.\r\n\r\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">urn</span>:<span class=\"green-400\">isbn</span>:<span class=\"yellow-400\">1234567890</span></p>\r\n\r\n### Protocol(프로토콜)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"lightBlue-400\">urn</span> 부분. `urn`으로 시작하면 <span class=\"primary\">URN</span>체계로 보면 된다.\r\n\r\n### NID(Namespace Identifier, 네임스페이스 지시자)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"green-400\">isbn</span> 부분. **자원이 저장된 저장소**를 표시한다.  \r\n`isbn`은 서지정보유통지원시스템으로 도서 일련번호에 대한 정보를 저장하는 저장소이다. 즉, `isbn`을 <span class=\"green-400\">NID</span>로 지정하면 도서 관련 자원을 식별할 수 있다.\r\n\r\n### NSS(Namespace Specific String, 네임스페이스 특정 문자)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"yellow-400\">1234567890</span> 부분. **자원을 식별할 수 있는 고유값**이다.  \r\n<span class=\"green-400\">NID</span>가 `isbn`으로 지정되어 있으므로, ISBN의 일련번호가 1234567890인 도서를 식별하는 <span class=\"primary\">URN</span>이라 볼 수 있다.","url":["2021-05-29-uri-url-urn","2021","05","29","uri-url-urn"]},"next":{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1005번 ACM Craft","excerpt":"서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-01T01:27:56","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","위상 정렬","GOLD","GOLD III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-01-a1005.md","content":"\r\n# ACM Craft\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/13.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1005번 문제](https://www.acmicpc.net/problem/1005)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다.\r\n\r\n이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219763-b1cf1480-c276-11eb-8131-a3471db1cfc4.png)\r\n\r\n위의 예시를 보자.\r\n\r\n이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할 수 있다. (동시에 진행이 가능하다.) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번 건물의 건설을 시작할 수 있다.\r\n\r\n따라서 4번 건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물와 3번 건물을 동시에 건설하기 시작하면 2번은 1초 뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을 수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.\r\n\r\n프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM Craft 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정 건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정 건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.\r\n\r\n## 입력\r\n\r\n첫째 줄에는 테스트케이스의 갯수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다, 첫째 줄에 건물의 갯수 $N$과 건물 간의 건설순서 규칙의 총 갯수 $K$가 주어진다.(전물의 번호는 1번 부터 $N$번 까지 존재한다.)\r\n\r\n둘째 줄에는 각 건물 당 건설에 걸리는 시간 $D$가 공백을 사이로 주어진다. 셋째 줄부터 $K + 2$줄 까지 건설순서 $X$ $Y$가 주어진다.(이는 건물 X를 지은 다음에 건물 $Y$를 짓는 것이 가능하다는 의미이다.)\r\n\r\n마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 $W$가 주어진다.\r\n\r\n## 출력\r\n\r\n건물 $W$를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.  \r\n건설순서는 모든 건물이 건설 가능하도록 주어진다.\r\n\r\n## 제한\r\n\r\n* $2 ≤ N ≤ 1,000$\r\n* $1 ≤ K ≤ 100,000$\r\n* $1 ≤ X, Y, W ≤ N$\r\n* $0 ≤ D ≤ 100,000)$ $D$는 정수\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4 4\r\n10 1 100 10\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4\r\n8 8\r\n10 20 1 5 8 7 1 43\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n5 7\r\n6 7\r\n7 8\r\n7\r\n```\r\n+ 출력\r\n\r\n``` tc\r\n120\r\n39\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n3 2\r\n1 2 3\r\n3 2\r\n2 1\r\n1\r\n4 3\r\n5 5 5 5\r\n1 2\r\n1 3\r\n2 3\r\n4\r\n5 10\r\n100000 99999 99997 99994 99990\r\n4 5\r\n3 5\r\n3 4\r\n2 5\r\n2 4\r\n2 3\r\n1 5\r\n1 4\r\n1 3\r\n1 2\r\n4\r\n4 3\r\n1 1 1 1\r\n1 2\r\n3 2\r\n1 4\r\n4\r\n7 8\r\n0 0 0 0 0 0 0\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4 5\r\n4 6\r\n5 7\r\n6 7\r\n7\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n6\r\n5\r\n399990\r\n2\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 이해가 되는데, 이를 코딩으로 풀어내기가 어려웠던 알고리즘. <span class=\"primary\">위상정렬</span> 알고리즘에 대한 이해가 있어야한다.  \r\n문제의 경우, 스타크래프트의 건물 테크트리랑 비슷한 개념으로 접근하면 된다. 군수공장을 짓기 위해선 병영을 지어야하는 것처럼, 요구 트리가 있는 건물의 경우 해당 건물을 반드시 완료해야 하며, 하나의 건물이 여러 요구 트리를 가질 경우도 존재한다. 물론 이 경우 요구하는 건물들을 **모두** 건설한 뒤에 건설 가능하다. 요구하는 건물들 중 하나만 건설하면 충족되는게 아니다.\r\n\r\n<span class=\"primary\">위상정렬</span>은 <span class=\"green-A400\">순서가 정해진 작업을 수행할 때, 이 순서를 결정하는 알고리즘</span>이다. <span class=\"primary\">위상정렬</span>은 반드시 DAG(Directed Acyclic Graph, 유향 비순환 그래프) 형태여야 한다. 즉, 순서를 도식화했을 때 반드시 <span class=\"red-A400\">시작/도착점이 존재</span>해야 한다. 시작/도착점이 구분되지 않는 순환 형태일 경우 위상정렬을 적용할 수 없다.\r\n\r\n위상정렬은 순서를 정하는 알고리즘이고, 순서도의 형태에 따라 여러가지의 답이 나올 수 있다. 이 문제는 최적의 답을 도출하기 위해 각 **건물을 건설하는데 필요한 요구 건물**과 **건설 시간**을 적용했다.\r\n\r\n다음 건물을 건설하기 위해선 요구 건물을 모두 건설해야하므로 요구 건물의 건설시간이 가장 많은 건물이 다음 순서가 된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219453-3b321700-c276-11eb-9029-ec105c694854.png)\r\n\r\n예시 1번의 두 번째 케이스를 예시로 하여 위상정렬을 도식화하면 위 사진과 같다.\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   0   |   1   |   1   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n위 표는 도식를 수치화하여 정리한 것이다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">1. 순서의 시작점(진입선이 없는 점)을 찾는다. 시작점이 여러개일 경우 시작점 중 무작위로 하나를 선택해도 무방하다. (위 예시는 시작점이 하나)</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219469-4127f800-c276-11eb-91c8-db36e543c217.png)\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">2. 시작점 1을 큐에 넣고, 시작점에 연결된 진출선을 전부 제거한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219471-438a5200-c276-11eb-9cd3-ca5f31dfb19b.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   0   |   0   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |\r\n| :---: | :---: |\r\n\r\n이 과정에서 2와 3이 새로운 시작점이 된 것을 확인할 수 있다.\r\n\r\n1을 건설하는데 걸리는 시간은 1초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">3. 2에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219484-45ecac00-c276-11eb-8114-a6c4c8b17036.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   0   |   0   |   0   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |\r\n| :---: | :---: | :---: |\r\n\r\n4와 5의 진입선이 0이 된다. 즉, 4와 5를 건설할 수 있게 된다.\r\n\r\n2를 건설하는데는 $10(1) + 20(2)$로 총 30초가 소요된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">4. 3에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219493-48e79c80-c276-11eb-8f48-cf132cab8f5c.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   0   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n\r\n6의 진입선이 0이 된다. 6을 건설할 수 있게 된다.\r\n\r\n3의 건설시간은 $10(1) + 1(3)$으로 총 11초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">5. 4에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219504-4be28d00-c276-11eb-9b40-07c5ea51cbd9.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |\r\n| :---: | :---: | :---: | :---: | :---: |\r\n\r\n4는 진출선이 없으므로 큐에만 추가된다.\r\n\r\n4의 건설시간은 $10(1) + 20(2) + 5(4)$로 총 35초\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">6. 5에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219509-4edd7d80-c276-11eb-9c5f-fc17d373bf50.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   0   |   1   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7이 5와 6에 연결되어 있으므로, 7의 진입선은 1이 된다. 아직 7을 건설할 수 없다.\r\n\r\n5의 건설시간은 $10(1) + 20(2) + 8(5)$로 총 38초\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">7. 6에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219520-53099b00-c276-11eb-9c99-060dcd2039d8.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   0   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7의 진입선이 0이 된다. 7을 건설할 수 있게 된다.\r\n\r\n6의 건설시간은 $10(1) + 1(3) + 7(6)$으로 총 18초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">8. 7에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219527-56048b80-c276-11eb-866b-9b411445b22b.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   0   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n8의 진입선이 0이 된다.\r\n\r\n1 ~ 6까지는 요구 건물이 하나였지만, 7은 두개이다. 앞서 언급했듯이, 5와 6 중 건설시간이 더 긴 것을 기준으로 계산해야한다.\r\n\r\n즉, 7의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7)$로 총 39초\r\n\r\n5번을 기준으로 계산하므로, <span class=\"red-A400\">6번과 중간인 3번은 계산에서 제외</span>된다. 만약, 3의 건설시간을 1초에서 4초로 증가시켜도 결과에 영향을 미치지 않는다. 3의 건설시간을 무시하기 때문이다. 단, 3의 건설시간이 너무 커지게되면 5보다 6의 건설시간이 같이 커지게 되어 결과에 영향을 미치게 된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">9. 8에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219535-58ff7c00-c276-11eb-907c-2a90cc84c596.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n문제는 7에 대한 건설시간을 요구하고 있으므로 8은 무시해도 무방하다. \r\n8의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7) + 43(8)$로 총 82초\r\n\r\n## 전체 소스\r\n\r\n`time`, `matrix`, `link`의 배열 크기가 $N + 1$이다. 별다른 이유는 아니고, 건물은 1번부터 시작하는데 배열은 0번부터 시작한다. 이러한 차이에서 오는 혼란을 방지하기 위해 건물이 총 4개면 배열의 크기를 5로(0, 1, 2, 3, 4, 5)로 지정하여 0을 제외하고 1부터 사용한다.\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1005 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/01/a1005\">1005 풀이</a>\r\n * @since 2021.05.31 Mon 19:11:58\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\t// 케이스 갯수\r\n\t\tint T = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 건물 갯수\r\n\t\t\tint N = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 규칙(건설시간) 갯수\r\n\t\t\tint K = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 건물별 건설시간 배열\r\n\t\t\tint[] time = new int[N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결여부 배열\r\n\t\t\tboolean[][] matrix = new boolean[N + 1][N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결 갯수 배열\r\n\t\t\tint[] link = new int[N + 1];\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j < N + 1; j++)\r\n\t\t\t{\r\n\t\t\t\ttime[j] = scanner.nextInt();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물\r\n\t\t\t\tint X = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\t// 상위 건물\r\n\t\t\t\tint Y = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\tmatrix[X][Y] = true;\r\n\t\t\t\tlink[Y]++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표 건물\r\n\t\t\tint W = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tbuilder.append(calcTopologicalSort(time, matrix, link)[W]).append(\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString());\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위상정렬 결과 반환 함수\r\n\t *\r\n\t * @param time: [int[]] 건물별 건설시간\r\n\t * @param matrix: [boolean[][]] 건물별 연결여부\r\n\t * @param link: [int[]] 건물별 연결 갯수\r\n\t *\r\n\t * @return [int[]] 건물별 종 건설시간 배열\r\n\t */\r\n\tprivate static int[] calcTopologicalSort(int[] time, boolean[][] matrix, int[] link)\r\n\t{\r\n\t\tQueue<Integer> queue = new LinkedList<>();\r\n\t\t\r\n\t\tint[] result = new int[link.length];\r\n\t\t\r\n\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t{\r\n\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\tif (link[i] == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = time[i];\r\n\t\t\t\tqueue.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\t// 하위 건물\r\n\t\t\tint prev = queue.poll();\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물 건설을 요구 하는 건물일 경우\r\n\t\t\t\tif (matrix[prev][i])\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = Math.max(result[i], result[prev] + time[i]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 해당 건물의 요구 건물 갯수 1 감소\r\n\t\t\t\t\t--link[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\t\t\tif (link[i] == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tqueue.add(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 그래프 이론\r\n* 위상 정렬","url":["2021-06-01-a1005","2021","06","01","a1005"]}},"group":[],"data":{"header":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true},"name":"2021-05-30-unsupported-version-error.md","content":"<h1 id=\"Unsupported-major.minor version\">Unsupported major.minor version <a href=\"#Unsupported-major.minor version\">🔗</a></h1><p>간혹 JAVA 프로그램을 실행하다보면 <span class=\"error\">Unsupported major.minor version 52</span>(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다.<br><span class=\"error\">Unsupported major.minor version</span> 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.</p>\n<h1 id=\"원인\">원인 <a href=\"#원인\">🔗</a></h1><p>JAVA는 컴파일 언어로, 개발자가 작성한 코드는 <code class=\"inline-code\">.java</code> 파일이다. 이를 컴파일하면 JVM(Java Virtual Machine, 자바 가상머신)이 읽을 수 있는 <code class=\"inline-code\">.class</code> 파일로 번역한다. 코딩은 사람이 이해할 수 있는 언어로 작성하고, 실제 동작은 컴파일을 통해 컴퓨터가 이해할 수 있는 언어를 사용하는 셈이다.<br>JAVA는 작성일 기준으로 16까지 릴리즈됐다. JAVA의 역사가 짧지 않고, 이 시간동안 크고작은 버전 업데이트가 지속적으로 이루어졌다.<br>문제는 이 과정에서 생긴 호환성 문제다. 1.5 버전으로 컴파일한 <code class=\"inline-code\">.class</code> 파일을 1.8 버전의 환경에서 구동한다거나, 그 반대의 경우가 그 예시다. 다행스럽게도, JAVA는 하위 버전에 대한 호환성을 보장한다. 1.8 버전의 환경에서는 1.8 이하로 컴파일된 <code class=\"inline-code\">.class</code> 파일의 실행을 보장한다. 하지만 반대로 상위 버전에 대한 호환성은 제공하지 않는다. 그도 그럴 것이, 호환성을 지키기 위해선, 각 버전 간의 구성을 알맞게 변환해야 하는데, 아직 개발되지 않은 미래 버전의 구성을 알 순 없는 노릇이니...</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">프로그램 JAVA 버전</th>\n<th align=\"center\">PC JAVA 버전</th>\n<th align=\"center\">Unsupported 오류 발생여부</th>\n<th align=\"center\">해결책</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">14</td>\n<td align=\"center\">1.8</td>\n<td align=\"center\">O</td>\n<td align=\"center\">JAVA 14 버전 이상으로 업그레이드</td>\n</tr>\n<tr>\n<td align=\"center\">1.6</td>\n<td align=\"center\">1.7</td>\n<td align=\"center\">X</td>\n<td align=\"center\">칼퇴근</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>즉, <span class=\"green-A400\">Unsupported major.minor version 오류는 내가 실행하려는 JAVA 코드가 내 PC의 JAVA 환경보다 높은 버전에서 컴파일된 경우 발생</span>한다.</p>\n<h1 id=\"해결\">해결 <a href=\"#해결\">🔗</a></h1><p>결과적으로, JAVA 버전을 동등 혹은 그 이상의 상위버전으로 업그레이드하면 된다. 크게 두 가지 방법이 있다.</p>\n<h2 id=\"프로그램-코드의 버전 다운그레이드\">프로그램 코드의 버전 다운그레이드 <a href=\"#프로그램-코드의 버전 다운그레이드\">🔗</a></h2><p>만약 본인이 온전한 프로그램 코드를 갖고 있을 경우, 시도해볼 수 있는 방법이다.<br><span class=\"green-A400\">JAVA 버전을 다운그레이드하고 컴파일을 진행</span>하면, 프로그램의 JAVA 버전이 낮아져 기존의 버전보다 훨씬 낮은 버전의 환경에서 구동이 가능하다.</p>\n<p>단, 조건이 있다. JAVA 버전이 업그레이드됨에 따라 여러 신규 패턴, 문법 등이 추가됐다. 만약 <span class=\"red-A400\">1.8 버전부터 새로 생긴 기능을 적극적으로 활용했다면, 1.7 이하의 버전에선 컴파일 오류가 발생</span>한다.<br>그도 그럴것이, 1.8 부터 생긴 기능은 1.7에서는 구현되지 않은 기능이기 때문.</p>\n<p>이 경우 프로그램의 코드를 좀더 범용적인 방식으로 리팩토링해야한다.</p>\n<h2 id=\"PC의-버전 업그레이드\">PC의 버전 업그레이드 <a href=\"#PC의-버전 업그레이드\">🔗</a></h2><p>만약 본인이 <code class=\"inline-code\">.class</code> 파일만 갖고있다거나, 상기한 문제로 다운그레이드가 어려울 경우 혹은 간단한 방법을 찾을 경우 시도해볼 수 있는 방법이다.\n<span class=\"green-A400\">PC의 JAVA 버전을 업그레이드하고 프로그램을 실행</span>하면 된다.</p>\n<p>JAVA는 하위 호환성을 지키기 때문에, 별다른 조건이 존재하지 않는다.</p>\n<h1 id=\"아니-버전 맞췄다고 아ㅋㅋ\">아니 버전 맞췄다고 아ㅋㅋ <a href=\"#아니-버전 맞췄다고 아ㅋㅋ\">🔗</a></h1><p>톰캣을 사용하다보면, 이 오류가 뜨는 경우가 있다. 그런데 간혹 PC에 설치된 JAVA 버전에 맞게 컴파일을 해줬음에도 오류가 사라지지 않는 현상이 발생하기도 한다.<br>이 경우 동반되는 증상이, Servlet Context에 접근할 경우, 첫 접속시 500 에러(Unsupported major.minor version 오류로 인해 발생)가 발생하고, 이후부터는 404 에러만 발생한다. 이러한 현상을 겪어보지 않았거나, 경험이 적은 개발자가 이러한 문제에 부딪히면 십중팔구 고생한다. 원인인 Unsupported major.minor version 오류가 보이지 않아 Servlet 동작의 404 오류와 관련된 정보를 검색하거나 질문하기 때문. 당연히 이러한 사정을 모르는 다른 사람들은 404 오류에 관한 답변을 줄 수 밖에 없다. 이런 경우 정말 난감하기 그지없다. 절대 경험담이라서가 아니다.</p>\n<p>혹시 위 처럼 정상적인 Servlet(서블릿)임에도 불구하고 404 오류가 뜰 경우 아래의 환경변수에서 JRE_HOME이 설정돼있는지 확인해보자.<br>간혹 개발 프로그램 중 임의로 JRE_HOME을 설정해버리는 프로그램이 존재한다. 문제는 여기서 발생하는데, JAVA_HOME과 JRE_HOME 환경변수가 둘 다 설정되어있을 경우, <span class=\"red-A400\">톰캣은 JRE_HOME을 우선</span>한다. 즉 JRE의 버전이 적용된다.</p>\n<p>예를 들어, JAVA_HOME이 1.8 버전, JRE_HOME이 1.6 버전이라 가정하자. 컴파일은 반드시 JDK가 필요하므로 JAVA_HOME의 버전인 1.8로 컴파일이 수행된다. 그러나 톰캣 실행 시, JRE_HOME을 우선하는 특징으로 인해 1.6 버전으로 실행된다. 결과적으로 <strong>1.8 버전으로 컴파일된 코드를 1.6으로 실행하는 셈</strong>이니, 버전이 맞지 않아 오류가 발생한다.</p>\n","url":["2021-05-30-unsupported-version-error","2021","05","30","unsupported-version-error"],"toc":[{"text":"Unsupported major.minor version","tag":"Unsupported-major.minor version","depth":1},{"text":"원인","tag":"원인","depth":1},{"text":"해결","tag":"해결","depth":1},{"text":"프로그램 코드의 버전 다운그레이드","tag":"프로그램-코드의 버전 다운그레이드","depth":2},{"text":"PC의 버전 업그레이드","tag":"PC의-버전 업그레이드","depth":2},{"text":"아니 버전 맞췄다고 아ㅋㅋ","tag":"아니-버전 맞췄다고 아ㅋㅋ","depth":1}]},"hash":"68edc3bd614"},"__N_SSG":true}