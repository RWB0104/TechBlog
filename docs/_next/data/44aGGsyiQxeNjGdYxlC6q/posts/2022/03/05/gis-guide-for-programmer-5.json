{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 4. QGIS 체험하기","excerpt":"이전에 대부분의 공간정보 데이터는 SHP를 기본으로 제공한다고 언급했었다. 그런데 문제는 이 SHP. 어떻게 여는지 모르겠다. GeoJSON이나 CSV 같은 텍스트 기반 데이터는 어찌됐든 열어서 검증을 해볼 수 있지만, SHP는 그게 안 된다는 말이다. 때문에 SHP를 열어서 조작할 수 있는 일종의 툴이 필요한데, 이미 여러 툴이 있으니 크게 문제되진 않는다. 가장 대표적인 툴은 두 가지가 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-05T03:05:25+09:00","type":"posts","category":"GIS","tag":["GIS","QGIS"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-05-gis-guide-for-programmer-4.md","content":"\r\n# QGIS\r\n\r\n이전에 대부분의 공간정보 데이터는 SHP를 기본으로 제공한다고 언급했었다. 그런데 문제는 이 SHP. 어떻게 여는지 모르겠다. GeoJSON이나 CSV 같은 텍스트 기반 데이터는 어찌됐든 열어서 검증을 해볼 수 있지만, SHP는 그게 안 된다는 말이다.\r\n\r\n때문에 SHP를 열어서 조작할 수 있는 일종의 툴이 필요한데, 이미 여러 툴이 있으니 크게 문제되진 않는다. 가장 대표적인 툴은 두 가지가 있다.\r\n\r\n* ArcGIS: 강력한 퍼포먼스를 가진 상용 프로그램. 비싸다.\r\n* QGIS: ESRI에서 만든 오픈소스 프로그램. 무료지만, 대용량 처리 시 좀 버벅인다.\r\n\r\n타일맵 제작이나 초대용량 데이터 처리가 아니라면, 대부분은 QGIS로 충분히 커버할 수 있다. 두 프로그램 모두 Python으로 개발되었으며, 덕분에 Python을 활용한 다양한 플러그인을 사용할 수 있다. 본인이 Python에 조예가 있다면, 직접 스크립트를 입력하여 복잡한 동작을 수행할 수도 있다. 하지만 QGIS로 이 정도 수준의 업무를 수행한다면, 개발자라기보단 데이터 관련 직무에 더 가깝다.\r\n\r\n공간정보 데이터에 대한 충분한 이해 없이 OpenLayers를 다뤄봤자, 혼란만 가중된다. 때문에 OpenLayers에 대해 설명하기 이전에, QGIS를 통해 SHP를 다루는 방법을 먼저 다루고 넘어간다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 설치하기\r\n\r\nQGIS는 [공식 홈페이지](https://qgis.org/ko/site/)에서 다운로드 받을 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## SHP 열어보기\r\n\r\nQGIS를 실행하고, SHP를 드래그해보자. 정상적인 공간정보 파일이라면, 관련 데이터가 창에 표시된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156781770-e5540bed-d1c3-4fde-be69-e3dac0e08c8c.png)\r\n\r\n위 데이터는 도로명주소에서 제공하는 세종시 건물 데이터다. 처음 해보는 사람도, 일단 뭔가 유효한 데이터가 출력됐다 정도는 인식할 수 있다.\r\n\r\n건물은 면(Polygon) 형태를 띈다. 각 도형은 건물을 의미한다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## Open Street Map 띄워서 비교하기\r\n\r\n데이터가 나왔다는 건 알겠는데, 저 건물이 실제로 어떤 위치에 있는지 확인하기 매우 어렵다. 즉, 위치를 비교할 수 있는 완전한 지도를 같이 띄워놓고 비교하는 것이 편하다.\r\n\r\nQGIS는 Open Street Map(이하 OSM) 레이어를 기본으로 제공한다.\r\n\r\nOSM이란, 전세계 지도 종사자들이 자율적으로 관리하는 세계지도다. 각국의 지도는 해당 국가의 개발자들이 기여하므로, 로컬라이징은 물론, 세계화도 잘 되어있어 당장 간편하게 쓰기 좋은 지도다. 단, 네이버나 카카오처럼 국내에 특화된 지도는 아니라서, 국내 한정 서비스에 적용하기는 다소 아쉽다.\r\n\r\n<br />\r\n\r\n물론 이건 어디까지나 서비스할 때 얘기고, 당장 데이터 놓고 위치 비교하기엔 이만한 게 없다.\r\n\r\n좌측 사이드바에서 [XYZ Tiles - OpenStreetMap]을 더블 클릭하여 레이어에 추가하자.\r\n\r\n레이어 순서에 따라 표시되는 우선순위가 달라지니, 가급적 OpenLayers를 제일 밑에 두도록 하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156783705-707ce5d6-c6ce-4d7f-9b49-ce13d824f9e6.png)\r\n\r\n더욱 비교하기 쉬워졌다. 데이터를 보면 얼추 세종시의 지형에 맞게 데이터가 배치된 것을 확인할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 데이터 확인하기\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156788688-ce4efff3-9648-45a9-8f19-fed8fc81ee21.png)\r\n\r\n데이터를 클릭해서 정보를 확인할 수 있다. 상단 메뉴에서 [객체 식별 (Ctrl + Shift + I)] 버튼을 클릭하고 객체를 누르면 정보를 확인할 수 있다.\r\n\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156793866-a6d13e58-fc2b-4b63-aabc-5e16112b07b2.png)\r\n\r\n레이어를 오른쪽 마우스로 클릭하면 사용 가능한 메뉴를 볼 수 있다. [속성 테이블 열기]를 클릭하면 모든 데이터의 속성을 볼 수 있다. DB의 형태와 매우 유사하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156789125-2c96cf14-43d8-4202-bfbf-752aacad0bcb.png)\r\n\r\n데이터를 찾거나, 선택한 데이터를 지도에 표시하는 것은 물론, 데이터의 수정, 삭제 또한 가능하다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 좌표계 설정하기\r\n\r\nQGIS는 각 레이어의 좌표계를 확인하고 주 좌표계로 변환하여 QGIS에 표시한다.\r\n\r\n예를 들어, 아래와 같다고 해보자.\r\n\r\n* 주 좌표계: EPSG:4326\r\n* A 레이어 좌표계: EPSG:5179\r\n* B 레이어 좌표계: EPSG:3857\r\n\r\n주 좌표계가 `EPSG:4326`이므로, A, B 좌표를 `EPSG:4326`으로 변환하여 QGIS에 표시한다. 최종적으로 사용자는 `EPSG:4326`으로 표현된 지도를 볼 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156792339-013c91ae-0762-44f0-a03d-fe76144271b2.png)\r\n\r\n주 좌표계는 QGIS 우측 하단에서 설정할 수 있다. 원하는 EPSG 코드를 찾아 지정하면, 해당 좌표계로 데이터가 자동 변환되어 표시된다.\r\n\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156792509-a23d95b7-0a64-4e2e-a483-0cfd0f553d93.png)\r\n\r\n각 레이어의 좌표계는 해당 메뉴를 통해 변환할 수 있다. 반드시 해당 레이어에 맞는 좌표계를 지정해야한다.\r\n\r\n예를 들어, `EPSG:5181` 좌표계로 정의된 레이어를 `EPSG:4326`으로 잘 못 지정하면 전혀 엉뚱한 위치로 계산된다.\r\n\r\n쉽게 설명하자면, 번역기에 이탈리아어를 영어로 인식하고 번역하는 것과 같은 이치다. 영어가 아닌 것을 영어라고 번역하니 전혀 의미없는 단어가 번역되기 때문. 마찬가지로, 레이어 좌표계를 잘 못 지정하면 전혀 엉뚱한 위치로 변환되므로 주의해야한다. 만약 이 현상이 나타났다면, 레이어의 좌표계를 다시 확인하기 바란다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 레이어 저장하기\r\n\r\nQGIS에서 데이터의 내용이나, 좌표계를 변경했을 경우, 이 데이터를 SHP 혹은 그에 준하는 공간정보 데이터로 출력해서 사용할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156793756-eb05a60b-be4f-4554-a309-610b0a61ab4b.png)\r\n\r\n[내보내기 - 객체를 다른 이름으로 저장]을 클릭하여 저장 메뉴를 호출한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156800667-0ef7c428-c905-4fa3-94a9-2cdda89193e3.png)\r\n\r\n원하는 데이터 형식과 설정을 입력하면, 데이터를 저장할 수 있다.","url":["2022-03-05-gis-guide-for-programmer-4","2022","03","05","gis-guide-for-programmer-4"]},"next":{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 6. 공간정보의 DB화","excerpt":"데이터의 CRUD 소요가 있는 서비스는 DB를 사용한다. 서비스 운영에 필요한 데이터를 DB에 저장하고, 이를 적절히 관리, 조작함으로써 서비스의 기능을 제공한다. GIS의 경우, 그 특성상 대용량 데이터를 자주 접하게 된다. 일례로, 전국의 건물 수는 몇백만을 우습게 상회하기 때문. 단순 row가 백만 단위인 것도 문제지만, 건물 정보의 특성 상 column의 갯수 또한 수십 개 정도다. 때문의 데이터의 용량이 매우 커진다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-05T04:35:41+09:00","type":"posts","category":"GIS","tag":["GIS","MariaDB","QGIS"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-05-gis-guide-for-programmer-6.md","content":"\r\n# 공간정보 데이터 관리하기\r\n\r\n데이터의 CRUD 소요가 있는 서비스는 DB를 사용한다. 서비스 운영에 필요한 데이터를 DB에 저장하고, 이를 적절히 관리, 조작함으로써 서비스의 기능을 제공한다.\r\n\r\nGIS의 경우, 그 특성상 대용량 데이터를 자주 접하게 된다. 일례로, 전국의 건물 수는 몇백만을 우습게 상회하기 때문. 단순 row가 백만 단위인 것도 문제지만, 건물 정보의 특성 상 column의 갯수 또한 수십 개 정도다. 때문의 데이터의 용량이 매우 커진다.\r\n\r\n때문에 공간정보 역시 DB에 저장하여 관리할 필요성이 생긴다. 하지만 문제는 공간정보는 DB에 저장하기 꽤나 까다롭다. 다른 데이터야 문자열이든 정수형이든 대충 삽입하면 되지만, 좌표값에서 문제가 발생한다. 점의 경우 $(x, y)$로 비교적 간단하지만, 선과 면의 경우 $xy$좌표가 무수히 나올 수 있으므로 문제가 커진다.\r\n\r\n그 뿐만 아니라, 별도로 언급하지 않은 복잡한 형태의 도형(도넛처럼 가운데가 빈 면 등)을 저장할때도 많은 문제가 생긴다. 때문에 적절한 툴을 활용하여 DB에 SHP를 삽입하는 것이 가장 효과적이다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## ogr2ogr로 MariaDB에 SHP 삽입하기\r\n\r\n이 장에서는 DB에 SHP를 삽입하는 방법으로 `ogr2ogr`을 사용한다. 이 툴은 공간정보를 다루는 라이브러리로, QGIS를 설치하면 자동으로 같이 설치된다.\r\n\r\n`ogr2ogr`만 따로 설치하는 것보다 QGIS 설치해서 딸려나오는 걸 사용하는 게 훨씬 편하므로, 여기선 이 방법을 통해 기술한다.\r\n\r\nQGIS 3.16 기준으로 일반적인 설치 경로는 `C:\\Program Files\\QGIS 3.16`이다. 물론 버전에 따라 경로는 조금씩 차이가 발생할 수 있으니 참고만 할 것.\r\n\r\n`C:\\Program Files\\QGIS 3.16\\bin`에서 `ogr2ogr`을 찾을 수 있다. 해당 경로에서 `cmd`를 통해 `ogr2ogr`에 명령어를 날려 SHP를 삽입해보자.\r\n\r\n<br />\r\n\r\n``` batch\r\nogr2ogr -f MySQL MySQL:{DB명}, host={DB 호스트}, user={DB 계정명}, password={DB 비밀번호} {SHP 경로} -nln {생성할 테이블 이름} -a_srs {SHP의 EPSG 코드} -lco engine=MYISAM\r\n```\r\n\r\n위 명령어를 입력하여 SHP를 MariaDB에 삽입할 수 있다. `-nln` 옵션을 지정하지 않을 경우, SHP의 이름을 그대로 따라간다.\r\n\r\n삽입 시, SHP의 테이블 외에도 공간정보의 메타데이터를 관리하는 테이블이 2개 생성되며, 각각 아래와 같다.\r\n\r\n* `geometry_columns`: 각 레이어의 좌표 정보에 대한 메타데이터\r\n* `spatial_ref_sys`: 사용된 좌표계의 메타데이터\r\n\r\n위 두 테이블은 개발자가 직접 사용할 일은 거의 없으니 그냥 이런 게 있다고 알고만 있으면 된다. 이 점을 모를 경우, 내가 의도한 테이블 외에 다른 테이블이 생김에 혼란을 일으킬 수 있기 때문.\r\n\r\n> <b class=\"yellow-500\">🙋‍♂️ DB는 꼭 MariaDB가 아니여도 상관없어요!</b>  \r\n> 이 문서에서는 MariaDB를 기준으로 설명했지만, 이건 어디까지나 내 서버에 MariaDB를 운용하고 있기 때문이지, 다른 이유가 있는 건 아니다.  \r\n> GIS를 전문으로 취급하는 데이터베이스를 구축할 심산이라면, PostgreSQL이 훨씬 나은 선택지다. PostgreSQL은 GIS 관련 기능이 매우 강력하기 때문에, DB 자체적으로 많은 편의기능을 제공한다.  \r\n> 많은 GIS 툴에서 PostgreSQL과의 직접적인 Connection Pool을 기본으로 제공한다.\r\n\r\n<br />\r\n\r\nSHP 데이터를 입력하다보면, 잘못된 도형으로 인해 삽입이 되지 않는 현상을 종종 목격한다. 명령어 마지막에 `--skipfailure` 옵션을 붙여주면 오류가 난 행은 제외하고 삽입하니 참고할 것.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156867178-87770a5a-e24f-4beb-b21b-fc081d67e5aa.png)\r\n\r\nSHP를 MariaDB에 삽입한 예시. DBeaver로 데이터베이스를 확인하면 무려 OSM을 기반으로 데이터의 형태까지 보여준다. 하단의 메뉴에서 EPSG 코드를 설정할 수 있으니 참고할 것.","url":["2022-03-05-gis-guide-for-programmer-6","2022","03","05","gis-guide-for-programmer-6"]}},"group":[{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 9. 데이터 필터링하기","excerpt":"WFS나 WMS를 호출할 때, 좀 더 다채로운 필터링이 필요한 경우가 존재할 수 있다. 특정 영역 밖의 객체를 호출한다거나, 특정 영역에 걸치는 데이터만 호출하는 것, 혹은 다양한 조건을 조합하여 데이터를 조회해야 할 수도 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-15T01:11:19+09:00","type":"posts","category":"GIS","tag":["GIS","GeoServer"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-15-gis-guide-for-programmer-9.md","content":"\r\n# OGC Filter\r\n\r\nWFS나 WMS를 호출할 때, 좀 더 다채로운 필터링이 필요한 경우가 존재할 수 있다. 특정 영역 밖의 객체를 호출한다거나, 특정 영역에 걸치는 데이터만 호출하는 것, 혹은 다양한 조건을 조합하여 데이터를 조회해야 할 수도 있다.\r\n\r\n이 때 요긴하게 사용할 수 있는 것이 OGC Filter다. OGC Filter는 XML의 형태를 가지며, 요청에 포함되어 좀 더 다양한 공간정보 데이터의 필터링을 가능케 한다.\r\n\r\nOGC Filter의 요청 URL에 `filter` 파라미터로 값을 지정하여 사용할 수 있다. 또한 `Transaction` 명령에서도 사용할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 이항 비교 연산자\r\n\r\n이항 비교 연산자는 아래와 같다.\r\n\r\n* `PropertyIsEqualTo`: 일치하는 데이터\r\n* `PropertyIsNotEqualTo`: 불일치하는 데이터\r\n* `PropertyIsLessThan`: 미만인 데이터\r\n* `PropertyIsLessThanOrEqualTo`: 이하인 데이터\r\n* `PropertyIsGreaterThan`: 초과인 데이터\r\n* `PropertyIsGreaterThanOrEqualTo`: 이상인 데이터\r\n\r\n|     Name     | Required | value  |\r\n| :----------: | :------: | :----: |\r\n| PropertyName |    Y     | 컬럼명 |\r\n|   Literal    |    Y     |   값   |\r\n\r\n``` xml\r\n<!-- CITY 컬럼이 서울인 데이터만을 필터링 -->\r\n<PropertyIsEqualTo>\r\n\t<PropertyName>CITY</PropertyName>\r\n\t<Literal>서울</Literal>\r\n</PropertyIsEqualTo>\r\n\r\n<!-- AREA 컬럼이 350 이하인 데이터만을 필터링 -->\r\n<PropertyIsLessThanOrEqualTo>\r\n\t<PropertyName>AREA</PropertyName>\r\n\t<Literal>350</Literal>\r\n</PropertyIsLessThanOrEqualTo>\r\n```\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 값 비교 연산자\r\n\r\n값 비교 연산자는 아래와 같다.\r\n\r\n* `PropertyIsLike`: 값을 포함하는 데이터\r\n* `PropertyIsNull`: 값이 NULL인 데이터\r\n* `PropertyIsBetween`: 값이 지정값 사이인 데이터\r\n\r\n연산자별로 양식이 조금씩 다르다.\r\n\r\n* `PropertyIsLike`\r\n\r\n|     Name     | Required | value  |\r\n| :----------: | :------: | :----: |\r\n| PropertyName |    Y     | 컬럼명 |\r\n|   Literal    |    Y     |   값   |\r\n\r\nPropertyName 태그에서 아래의 3가지 속성을 사용할 수 있다.\r\n\r\n* wildCard: 와일드카드\r\n* singleChar: 문자열 하나\r\n* escapeChar: 개행문자\r\n\r\n위 속성에 문자열을 할당하면, 해당 문자열은 위와 동일한 의미를 가지게 된다.\r\n\r\n속성은 여러개를 동시에 사용할 수도 있다.\r\n\r\n``` xml\r\n<!-- CITY 컬럼이 서울이란 단어를 포함한 데이터만을 필터링 -->\r\n<PropertyIsLike>\r\n\t<PropertyName>CITY</PropertyName>\r\n\t<Literal>서울</Literal>\r\n</PropertyIsLike>\r\n\r\n<!-- CITY 컬럼이 서울로 시작하는 3글자 단어를 포함한 데이터만을 필터링 -->\r\n<PropertyIsLike>\r\n\t<PropertyName>CITY</PropertyName>\r\n\t<Literal singleChar=\"_\">서울_</Literal>\r\n</PropertyIsLike>\r\n\r\n<!-- CITY 컬럼이 서로 시작해서 울로 끝나는 단어를 포함한 데이터만을 필터링 -->\r\n<PropertyIsLike>\r\n\t<PropertyName>CITY</PropertyName>\r\n\t<Literal wildCard=\"%\">서%울</Literal>\r\n</PropertyIsLike>\r\n\r\n<!-- CITY 컬럼이 서울로 시작하는 3글자 단어가 개행된 데이터만을 필터링 -->\r\n<PropertyIsLike>\r\n\t<PropertyName>CITY</PropertyName>\r\n\t<Literal singleChar=\"_\" escapeChar=\"-\">서울_-</Literal>\r\n</PropertyIsLike>\r\n```\r\n\r\n<br />\r\n\r\n* `PropertyIsNull`\r\n\r\n|     Name     | Required | value  |\r\n| :----------: | :------: | :----: |\r\n| PropertyName |    Y     | 컬럼명 |\r\n\r\n컬럼값이 NULL인지만 비교하므로, Literal은 필요 없는 게 특징이다.\r\n\r\n``` xml\r\n<!-- CITY 컬럼이 NULL인 데이터만을 필터링 -->\r\n<PropertyIsNull>\r\n\t<PropertyName>CITY</PropertyName>\r\n</PropertyIsNull>\r\n```\r\n\r\n<br />\r\n\r\n* `PropertyIsBetween`\r\n\r\n|     Name      | Required |       value        |\r\n| :-----------: | :------: | :----------------: |\r\n| PropertyName  |    Y     |       컬럼명       |\r\n| UpperBoundary |    Y     |        최대        |\r\n| LowerBoundary |    Y     |        최소        |\r\n|    Literal    |    Y     | 값 (Boundary 하위) |\r\n\r\n``` xml\r\n<!-- COUNT 컬럼이 500 ~ 1000인 데이터만을 필터링 -->\r\n<PropertyIsBetween>\r\n\t<PropertyName>COUNT</PropertyName>\r\n\t<UpperBoundary>\r\n\t\t<Literal>1000</Literal>\r\n\t</UpperBoundary>\r\n\t<LowerBoundary>\r\n\t\t<Literal>500</Literal>\r\n\t</LowerBoundary>\r\n</PropertyIsBetween>\r\n```\r\n\r\nBoundary 태그 안에 Literal 태그가 들어감을 주의하자.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 공간 연산자\r\n\r\n좌표, 영역 등의 공간을 기반으로 필터를 구성할 수 있다.\r\n\r\n* `Intersects`: 해당 공간에 포함되거나 걸치는 데이터\r\n* `Disjoint`: 해당 공간에 포함되지 않는 데이터\r\n* `Contains`: 해당 공간에 포함되는 데이터\r\n* `Within`: 해당 공간 내부의 데이터\r\n* `Touches`: 해당 공간에 닿는 데이터\r\n* `Crosses`: 해당 공간을 교차하는 데이터\r\n* `Overlaps`: 해당 공간에 겹쳐지는 데이터\r\n* `Equlas`: 해당 공간과 동일한 데이터\r\n\r\n글로 보면 좀 모호할 수 있는데, 이해를 돕기 위해 아래 그림을 보자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/158647372-0e75b6ba-2f93-46bd-9425-eba12f0335cf.png)\r\n\r\n이와 같은 차이가 존재한다.\r\n\r\n|     Name     | Required |      value      |\r\n| :----------: | :------: | :-------------: |\r\n| PropertyName |    Y     | 공간정보 컬럼명 |\r\n|     gml      |    Y     |  공간정보 XML   |\r\n\r\n공간정보 XML은 이전 장에서 확인할 수 있다.\r\n\r\n``` xml\r\n<!-- 해당 영역에 포함되거나 걸치는 데이터만을 필터링 -->\r\n<Intersects>\r\n\t<PropertyName>GEOM</PropertyName>\r\n\t<gml:Polygon srsName=\"EPSG:0000\">\r\n\t\t<gml:outerBoundaryIs>\r\n\t\t\t<gml:LinearRing>\r\n\t\t\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4 x1,y1</gml:coordinates>\r\n\t\t\t</gml:LinearRing>\r\n\t\t</gml:outerBoundaryIs>\r\n\t</gml:Polygon>\r\n</Intersects>\r\n\r\n<!-- 해당 라인을 교차하는 데이터만을 필터링 -->\r\n<Crosses>\r\n\t<PropertyName>GEOM</PropertyName>\r\n\t<gml:LineString srsName=\"EPSG:0000\">\r\n\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4</gml:coordinates>\r\n\t</gml:LineString>\r\n</Crosses>\r\n```\r\n\r\n공간 연산의 특성 상, 점 데이터는 활용 가능성이 낮다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 거리 연산자\r\n\r\n데이터의 거리를 기반으로 필터를 구성한다.\r\n\r\n* `DWithin`: 해당 거리 이내의 데이터\r\n* `Beyond`: 해당 거리 너머의 데이터\r\n\r\n|     Name     | Required |      value      |\r\n| :----------: | :------: | :-------------: |\r\n| PropertyName |    Y     | 공간정보 컬럼명 |\r\n|     gml      |    Y     |  공간정보 XML   |\r\n|   Distance   |    Y     |      거리       |\r\n\r\nDistance의 속성으로 units를 사용할 수 있으며, 거리의 단위를 표기한다.\r\n\r\n``` xml\r\n<!-- 해당 점과 100m 이내의 데이터만을 필터링 -->\r\n<DWithin>\r\n\t<PropertyName>GEOM</PropertyName>\r\n\t<gml:Point srsName=\"EPSG:0000\">\r\n\t\t<gml:coordinates>x,y</gml:coordinates>\r\n\t</gml:Point>\r\n\t<Distance units=\"m\">100</Distance>\r\n</DWithin>\r\n```\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 영역 연산자\r\n\r\n데이터의 영역을 기반으로 필터를 구성한다.\r\n\r\n* `BBOX`: 해당 공간에 포함되거나 걸치는 데이터 (Intersects와 동일)\r\n\r\n|     Name     | Required |      value      |\r\n| :----------: | :------: | :-------------: |\r\n| PropertyName |    Y     | 공간정보 컬럼명 |\r\n|   Literal    |    Y     |       값        |\r\n|     gml      |    Y     |  공간정보 XML   |\r\n\r\n``` xml\r\n<!-- 해당 영역에 포함되거나 걸치는 데이터만을 필터링 -->\r\n<BBOX>\r\n\t<PropertyName>GEOM</PropertyName>\r\n\t<Literal>\r\n\t\t<gml:Polygon srsName=\"EPSG:0000\">\r\n\t\t\t<gml:outerBoundaryIs>\r\n\t\t\t\t<gml:LinearRing>\r\n\t\t\t\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4 x1,y1</gml:coordinates>\r\n\t\t\t\t</gml:LinearRing>\r\n\t\t\t</gml:outerBoundaryIs>\r\n\t\t</gml:Polygon>\r\n\t</Literal>\r\n</BBOX>\r\n```\r\n\r\n사실상 공간 연산자의 Intersects와 동일한 결과.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 논리 연산자\r\n\r\n여러 조건을 결합하여 필터를 구성한다.\r\n\r\n* `And`: 조건을 모두 충족하는 데이터\r\n* `Or`: 조건을 하나 이상 충족하는 데이터\r\n* `Not`: 조건을 충족하지 않는 데이터\r\n\r\n``` xml\r\n<!-- 해당 영역에 포함되거나 걸치면서, AREA가 350 이하인 데이터 -->\r\n<And>\r\n\t<BBOX>\r\n\t\t<PropertyName>GEOM</PropertyName>\r\n\t\t<Literal>\r\n\t\t\t<gml:Polygon srsName=\"EPSG:0000\">\r\n\t\t\t\t<gml:outerBoundaryIs>\r\n\t\t\t\t\t<gml:LinearRing>\r\n\t\t\t\t\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4 x1,y1</gml:coordinates>\r\n\t\t\t\t\t</gml:LinearRing>\r\n\t\t\t\t</gml:outerBoundaryIs>\r\n\t\t\t</gml:Polygon>\r\n\t\t</Literal>\r\n\t</BBOX>\r\n\r\n\t<PropertyIsLessThanOrEqualTo>\r\n\t\t<PropertyName>AREA</PropertyName>\r\n\t\t<Literal>350</Literal>\r\n\t</PropertyIsLessThanOrEqualTo>\r\n</And>\r\n```\r\n\r\n논리 연산자를 적절히 중첩하여 복잡한 필터를 구성할 수 있다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# CQL Filter\r\n\r\nOGC Filter 이외에도 CQL Filter라는 것 또한 존재한다. 잠깐 짚고 넘어가보자.\r\n\r\nCQL Filter는 사용자에 따라 OGC Filter 보다 더 쉬울 수 있다. SQL의 형태와 매우 유사하기 때문.\r\n\r\nCQL Filter는 요청 URL에 `cql_filter` 파라미터로 값을 지정하여 사용할 수 있다.\r\n\r\n<br />\r\n\r\n예를 들어, 아래와 같이 사용할 수 있다.\r\n\r\n* `PropertyIsLike`\r\n\r\n``` xml\r\n<!-- CITY 컬럼이 서울이란 단어를 포함한 데이터만을 필터링 -->\r\n<PropertyIsLike>\r\n\t<PropertyName>CITY</PropertyName>\r\n\t<Literal>서울</Literal>\r\n</PropertyIsLike>\r\n```\r\n\r\n``` txt\r\nCITY LIKE '%서울%'\r\n```\r\n\r\n<br />\r\n\r\n* `Intersects`\r\n\r\n``` xml\r\n<!-- 해당 영역에 포함되거나 걸치는 데이터만을 필터링 -->\r\n<Intersects>\r\n\t<PropertyName>GEOM</PropertyName>\r\n\t<gml:Polygon srsName=\"EPSG:0000\">\r\n\t\t<gml:outerBoundaryIs>\r\n\t\t\t<gml:LinearRing>\r\n\t\t\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4 x1,y1</gml:coordinates>\r\n\t\t\t</gml:LinearRing>\r\n\t\t</gml:outerBoundaryIs>\r\n\t</gml:Polygon>\r\n</Intersects>\r\n```\r\n\r\n``` txt\r\nINTERSECTS(GEOM, POLYGON((x1 y1, x2 y2, x3 y3, x4 y4, x1 y1)))\r\n```\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 마치며\r\n\r\nOGC Filter와 CQL Filter에 대해서 알아봤다.\r\n\r\n데이터의 필터링을 구체적으로 수행할 경우, 요긴하게 사용할 것이다.\r\n\r\n<br />\r\n\r\nOGC, CQL Filter에 더 많은 정보가 필요하다면 각각 아래의 사이트를 확인하자.\r\n\r\n* [OGC Filter](https://docs.geoserver.org/latest/en/user/filter/filter_reference.html)\r\n* [CQL Filter](https://docs.geoserver.org/stable/en/user/tutorials/cql/cql_tutorial.html)","url":["2022-03-15-gis-guide-for-programmer-9","2022","03","15","gis-guide-for-programmer-9"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 8. 공간정보 데이터를 주문하는 법. OGC","excerpt":"OpenLayers는 웹 브라우저에서 지도나 GIS 서비스를 제공하기 위한 JavaScript Library다. GIS 라이브러리 중 진입 장벽은 가장 높지만, 그에 상응하는 강력한 기능을 제공한다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-14T23:37:32+09:00","type":"posts","category":"GIS","tag":["GIS","GeoServer"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-14-gis-guide-for-programmer-8.md","content":"\r\n# OGC 표준\r\n\r\n이전 장에서 GeoServer를 통해 공간정보 데이터 관리 시스템을 구축했다. 이제 이 데이터를 적절히 호출만 하면 될텐데, 이를 어떻게 해야할까?\r\n\r\n만약 소프트웨어나 서비스 제공 기관별로 호출방법을 제각각으로 둘 경우 많은 혼란이 야기될 것이다. 어떤 서비스에선 이런 기능이 제공되는데, 어떤 서비스에선 이 기능이 전무한 상황이 빈번할 것이다. 즉, 서비스의 일관성을 해치게 된다. 공간정보라는 복잡한 데이터의 특성 상 일관성의 훼손이 주는 의미는 더욱 크다.\r\n\r\n이를 해결하기 위해 적절한 표준을 제정한 것이 OGC 표준이다. OGC(Open Geospatial Consortium)는 공간정보 관련 기술의 개방형 표준화를 개발하고 구현하는 국제 표준화 기구다.\r\n\r\nOGC에서 공간정보 질의 표준을 정의한 것이 OGC 표준이다. 공간정보와 관련된 소프트웨어, 웹, 앱 등이 OGC 표준을 준수한다면, 어떤 형태든 동일한 요청 방식으로 데이터를 제공받을 수 있다. 즉, OGC 표준을 준수하는 시스템을 활용한다면, 서비스의 일관성을 지킬 수 있다. 한 번 잘 알아두면 OGC 표준을 준수하는 모든 서비스에서 동일하게 활용이 가능하다. 이러한 편의성으로 인해 정상적인 GIS 솔루션이라면 OGC 표준을 반드시 준수한다.\r\n\r\n당연히 OGC 표준 준수는 그냥 막 가져다 붙일 수 있는 건 전혀 아니고, 심사를 통해 OGC 표준을 정상적으로 구현했는지 검증하는 과정을 거쳐야 비로소 OGC 표준을 준수한다고 할 수 있다.\r\n\r\n<br />\r\n\r\n아래는 웹 환경에서의 OGC 표준 주요 항목이다.\r\n\r\n* WFS (Web Feature Service): 벡터 데이터의 속성 및 공간 정보\r\n* WMS (Web Map Service): 배경지도 및 시각화\r\n* WCS (Web Coverage Service): 래스터 데이터 추출\r\n* WPS (Web Processing Service): 공간분석 처리\r\n\r\n가장 사용 빈도가 높은 건 WFS, WMS다. 서비스의 대부분은 단순 공간정보를 질의하거나 배경지도를 호출하는 수준에 그치기 때문.\r\n\r\n이 두 스펙 정도만 알아놔도 OpenLayers로 지도를 표현하는 데 아무런 문제가 없다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## WFS\r\n\r\nWFS의 주요 명령어를 기술한다.\r\n\r\n* GetFeature\r\n* Transaction\r\n\r\n기본 URL은 `http://localhost:8080/geoserver/wfs`와 같다.\r\n\r\n<br />\r\n\r\n\r\n\r\n### 1. GetFeature\r\n\r\n레이어의 속성정보를 호출한다. DB로 따지자면 테이블의 데이터를 호출하는 것과 동일하다.\r\n\r\n지도의 속성 정보가 필요할 때 사용한다.\r\n\r\nGeoServer의 `GetFeature`에 필요한 파라미터는 아래와 같다.\r\n\r\n``` txt\r\nGET http://localhost:8080/geoserver/wfs?service=WFS&version=2.0.0&request=GetFeature&typename=test:building&srsName=EPSG:3857&outputFormat=application/json&bbox=14168809.936013725,4366042.924151548,14170735.193663657,4367768.7289308,EPSG:3857\r\n```\r\n\r\n|  Parameter   |                   Example                   | Require |                     Description                     |\r\n| :----------: | :-----------------------------------------: | :-----: | :-------------------------------------------------: |\r\n|   service    |                 WFS (고정)                  |    Y    |                      서비스명                       |\r\n|   version    |         2.0.0 (기본), 1.1.0, 1.0.0          |    Y    |                        버전                         |\r\n|   request    |              GetFeature (고정)              |    Y    |                       요청명                        |\r\n|   typename   |            repo_name:layer_name             |    Y    |            레이어명 (다수는 쉼표로 구분)            |\r\n|   srsName    |                  EPSG:4326                  |         | 기준 좌표계 (비울 경우 레이어의 기본 좌표계로 표시) |\r\n| outputFormat |      application/vnd.ogc.se_xml (기본)      |         |                      응답 형식                      |\r\n|  exceptions  |      application/vnd.ogc.se_xml (기본)      |         |                   예외 응답 형식                    |\r\n| propertyName |                  전체 컬럼                  |         |   응답에 포함할 컬럼명 (다수의 경우 쉼표로 구분)    |\r\n|     bbox     | $x_{min},y_{min},x_{max},y_{max}$,EPSG:0000 |         |                     제한할 범위                     |\r\n|  featureID   |                    {id}                     |         |                     Feature ID                      |\r\n\r\n필수 파라미터만 입력하면 해당 레이어의 모든 데이터에 대한 속성정보를 불러온다.\r\n\r\n<br />\r\n\r\n`srsName`에 원하는 EPSG 코드를 입력하면, 그에 맞게 좌표변환을 수행하여 결과를 출력해준다. 클라이언트나 서버에서의 좌표변환을 전혀 신경쓰지 않아도 된다.\r\n\r\nJSON 방식을 원할 경우, `application/json`을 `outputFormat`에 지정하면 된다.\r\n\r\n<br />\r\n\r\n`propertyName`에 컬럼명을 입력하면, 해당 데이터만을 불러온다. 이를 적절히 활용해 필요한 데이터만을 호출하여 응답 속도 및 크기를 최적화할 수 있다.\r\n\r\n<br />\r\n\r\n`bbox`나 `featureID`는 둘 중 하나만 사용 가능하다. 별다른 제한 없이 WFS를 그냥 호출해버리면 레이어의 모든 데이터를 연산하여 응답해주기 때문에 시간은 물론, 서버에 부하도 많이 간다. 때문에 대부분 현재 영역에 해당하는 데이터만을 반환하도록 제한한다. 이 때 사용하는 영역 제한값이 `bbox`.\r\n\r\n`bbox`의 마지막 EPSG 코드는 생략할 수 있으며, 생략할 경우 레이어의 기본 EPSG 좌표계로 인식하고 계산한다.\r\n\r\n<br />\r\n\r\n`featureID`는 특정 아이디를 가진 데이터 하나만을 타깃하여 반환해준다. 기본적으로 모든 데이터에는 ID가 붙는데, `{layer}.{number}`와 같은 식이다. 예를 들어, 레이어 이름이 `test_layer`라면, `test_layer.354`와 같은 식.\r\n\r\n`featureID=354`을 포함하여 요청하면 해당 데이터 하나만을 반환한다.\r\n\r\n``` txt\r\n/geoserver/wfs?service=WFS&version=2.0.0&request=GetFeature&typename=TEST:buld_sejong&srsName=EPSG:3857&outputFormat=application/json&exceptions=application/json&featureID=11645\r\n```\r\n\r\n``` json\r\n{\r\n    \"type\": \"FeatureCollection\",\r\n    \"features\": [\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"id\": \"buld_sejong.11645\",\r\n            \"geometry\": {\r\n                \"type\": \"Polygon\",\r\n                \"coordinates\": [\r\n                    [\r\n                        [\r\n                            1.418136757571567E7,\r\n                            4370012.19281353\r\n                        ],\r\n                        [\r\n                            1.418136633370244E7,\r\n                            4370021.40639941\r\n                        ],\r\n                        [\r\n                            1.418138830051506E7,\r\n                            4370022.60152291\r\n                        ],\r\n                        [\r\n                            1.418138868963238E7,\r\n                            4370013.39142052\r\n                        ],\r\n                        [\r\n                            1.418136757571567E7,\r\n                            4370012.19281353\r\n                        ]\r\n                    ]\r\n                ]\r\n            },\r\n            \"geometry_name\": \"SHAPE\",\r\n            \"properties\": {\r\n                \"bdtyp_cd\": \"17005\",\r\n                \"bd_mgt_sn\": \"3611033027102590003000005\",\r\n                \"bsi_int_sn\": 67897,\r\n                \"bsi_zon_no\": \"30078\",\r\n                \"buld_mnnm\": 35,\r\n                \"buld_nm\": null,\r\n                \"buld_nm_dc\": \"4동\",\r\n                \"buld_se_cd\": \"0\",\r\n                \"buld_slno\": 35,\r\n                \"bul_dpn_se\": \"M\",\r\n                \"bul_eng_nm\": null,\r\n                \"bul_man_no\": 55809,\r\n                \"emd_cd\": \"330\",\r\n                \"eqb_man_sn\": 0,\r\n                \"gro_flo_co\": 1,\r\n                \"li_cd\": \"27\",\r\n                \"lnbr_mnnm\": 259,\r\n                \"lnbr_slno\": 6,\r\n                \"mntn_yn\": \"0\",\r\n                \"mvmn_de\": \"20210308\",\r\n                \"mvmn_resn\": \"건물번호 변경신청(노호리 259-6)에 따른 건물군 분리\",\r\n                \"mvm_res_cd\": \"35\",\r\n                \"ntfc_de\": \"20210308\",\r\n                \"opert_de\": \"20210308130538\",\r\n                \"pos_bul_nm\": null,\r\n                \"rds_man_no\": 3020,\r\n                \"rds_sig_cd\": \"36110\",\r\n                \"rn_cd\": \"3258065\",\r\n                \"sig_cd\": \"36110\",\r\n                \"und_flo_co\": 0\r\n            }\r\n        }\r\n    ],\r\n    \"totalFeatures\": 1,\r\n    \"numberMatched\": 1,\r\n    \"numberReturned\": 1,\r\n    \"timeStamp\": \"2022-03-10T16:05:54.511Z\",\r\n    \"crs\": {\r\n        \"type\": \"name\",\r\n        \"properties\": {\r\n            \"name\": \"urn:ogc:def:crs:EPSG::3857\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n위 응답은 세종시 건물 중 아이디가 `11645`인 데이터를 `GetFeature`로 호출한 결과이다. `outputFormat`을 `application/json`으로 지정하여 GeoJSON이 응답된다. 만약 응답 형식을 따로 지정하지 않는다면 XML 형태로 응답한다.\r\n\r\n만약 `propertyName=bdtyp_cd,bd_mgt_sn` 파라미터를 추가했다면, `properties`에서 `bdtyp_cd`, `bd_mgt_sn`만 포함될 것이다.\r\n\r\n> <b>공간정보를 가진 XML. GML</b>  \r\n> 공간정보를 가진 JSON을 GeoJSON이라고 부르듯이, XML 또한 GML이라는 별도의 명칭으로 부르기도 한다.  \r\n> GeoServer는 별도의 응답 형식을 지정하지 않으면, 대부분의 응답을 GML이나 XML로 처리하니, API 통신에서의 원활한 사용을 위해 가급적 JSON으로 지정해주자.\r\n\r\n<br />\r\n\r\n\r\n\r\n### 2. Transaction\r\n\r\n레이어의 데이터에 대한 삽입, 갱신, 삭제 기능을 제공한다.\r\n\r\n요청의 메소드는 `POST`로 공통이다. 삽입, 갱신, 삭제 모두 `POST`를 사용한다.\r\n\r\nbody에 동작을 XML로 구성하여 요청한다. OGC 표준이 워낙 옛날부터 제정되다보니, 대부분의 요청은 XML을 기본으로 한다.\r\n\r\n<br />\r\n\r\n공간정보의 좌표값은 정해진 XML 양식을 통해 죄표값을 기술하여 정의할 수 있다. 각 데이터 형식에 해당하는 XML은 아래와 같다.\r\n\r\n해당 XML은 Transaction Insert, Update에 사용된다.\r\n\r\n* Polygon\r\n\r\n``` xml\r\n<gml:Polygon srsName=\"EPSG:0000\">\r\n\t<gml:outerBoundaryIs>\r\n\t\t<gml:LinearRing>\r\n\t\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4 x1,y1</gml:coordinates>\r\n\t\t</gml:LinearRing>\r\n\t</gml:outerBoundaryIs>\r\n</gml:Polygon>\r\n```\r\n\r\n`gml:Polygon`의 속성 `srsName`에 좌표계를 기술한다. 생략할 경우, 대상 레이어의 기본 좌표계로 인식한다.\r\n\r\n`gml:coordinates`의 내부에 좌표를 기술한다. 하나의 좌표 $x, y$는 쉼표로 구분하고, 각 좌표끼리는 공백으로 구분한다.\r\n\r\nPolygon은 반드시 첫 좌표와 마지막 좌표가 동일해야한다는 점을 잊지 말자.\r\n\r\n* Line\r\n\r\n``` xml\r\n<gml:LineString srsName=\"EPSG:0000\">\r\n\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4</gml:coordinates>\r\n</gml:LineString>\r\n```\r\n\r\n`gml:LineString`의 속성 `srsName`에 좌표계를 기술한다. 생략할 경우, 대상 레이어의 기본 좌표계로 인식한다.\r\n\r\n`gml:coordinates`의 내부에 좌표를 기술한다. 하나의 좌표 $x, y$는 쉼표로 구분하고, 각 좌표끼리는 공백으로 구분한다.\r\n\r\nLine은 반드시 첫 좌표와 마지막 좌표가 다르다는 점을 잊지 말자.\r\n\r\n* Point\r\n\r\n``` xml\r\n<gml:Point srsName=\"EPSG:0000\">\r\n\t<gml:coordinates>x,y</gml:coordinates>\r\n</gml:Point>\r\n```\r\n\r\n`gml:Point`의 속성 `srsName`에 좌표계를 기술한다. 생략할 경우, 대상 레이어의 기본 좌표계로 인식한다.\r\n\r\n`gml:coordinates`의 내부에 좌표를 기술한다. 점이므로 $x, y$만 존재하며 이 둘은 쉼표로 구분한다.\r\n\r\n<br />\r\n\r\n\r\n\r\n#### 2-1. Transaction Insert\r\n\r\n레이어 데이터에 대한 삽입 기능이다.\r\n\r\n``` txt\r\nPOST http://localhost:8080/geoserver/wfs\r\n```\r\n\r\n``` xml\r\n<wfs:Transaction\r\n\txmlns:wfs=\"http://www.opengis.net/wfs\"\r\n\txmlns:gml=\"http://www.opengis.net/gml\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\tservice=\"WFS\"\r\n\tversion=\"1.0.0\"\r\n\txsi:schemaLocation=\"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd\">\r\n\t<wfs:Insert>\r\n\t\t<layer_name>\r\n\t\t\t<column1>value1</column1>\r\n\t\t\t<column2>value2</column2>\r\n\t\t\t<column3>value3</column3>\r\n\t\t\t<geo_column>\r\n\t\t\t\t<gml:Polygon srsName=\"EPSG:4326\">\r\n\t\t\t\t\t<gml:outerBoundaryIs>\r\n\t\t\t\t\t\t<gml:LinearRing>\r\n\t\t\t\t\t\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4 x1,y1</gml:coordinates>\r\n\t\t\t\t\t\t</gml:LinearRing>\r\n\t\t\t\t\t</gml:outerBoundaryIs>\r\n\t\t\t\t</gml:Polygon>\r\n\t\t\t</geo_column>\r\n\t\t</layer_name>\r\n\t</wfs:Insert>\r\n</wfs:Transaction>\r\n```\r\n\r\n위 XML은 Polygon을 추가하는 XML이다. 이 XML을 해석하면 아래와 같다.\r\n\r\n* 대상 테이블은 `layer_name`이다.\r\n* 컬럼 `column1`, `column2`, `column3`에 각각 `value1`, `value2`, `value3`을 삽입한다.\r\n  * Schema엔 있으나, 삽입 시 컬럼을 명시하지 않았을 경우, 해당 컬럼은 `null`로 삽입된다.\r\n* 공간정보 컬럼명은 `geo_column`이다.\r\n* 좌표 `x1,y1 x2,y2 x3,y3 x4,y4 x1,y1`의 폴리곤이다.\r\n  * 좌표계는 `EPSG:4326`이다.\r\n\r\n용도에 맞게 테이블명, 컬럼 등을 변경하면 된다.\r\n\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<wfs:WFS_TransactionResponse\r\n\txmlns:wfs=\"http://www.opengis.net/wfs\"\r\n\txmlns:ogc=\"http://www.opengis.net/ogc\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\tversion=\"1.0.0\"\r\n\txsi:schemaLocation=\"http://www.opengis.net/wfs https://api.itcode.dev/geoserver/schemas/wfs/1.0.0/WFS-transaction.xsd\">\r\n\t<wfs:InsertResult>\r\n\t\t<ogc:FeatureId fid=\"buld_test.71\"/>\r\n\t</wfs:InsertResult>\r\n\t<wfs:TransactionResult>\r\n\t\t<wfs:Status>\r\n\t\t\t<wfs:SUCCESS/>\r\n\t\t</wfs:Status>\r\n\t</wfs:TransactionResult>\r\n</wfs:WFS_TransactionResponse>\r\n```\r\n\r\n정상응답은 위와 같다. `Transaction`의 응답은 아쉽게도 XML만 지원한다.\r\n\r\n위 응답에서 얻을 수 있는 정보는 아래와 같다.\r\n\r\n* 데이터를 삽입함\r\n* 응답 결과가 `SUCCESS`로 정상\r\n* 생성된 객체의 아이디는 `buld_test.71`\r\n\r\n<br />\r\n\r\n\r\n\r\n#### 2-2. Transaction Update\r\n\r\n레이어 데이터에 대한 수정 기능이다.\r\n\r\n``` txt\r\nPOST http://localhost:8080/geoserver/wfs\r\n```\r\n\r\n``` xml\r\n<wfs:Transaction\r\n\txmlns:wfs=\"http://www.opengis.net/wfs\"\r\n\txmlns:gml=\"http://www.opengis.net/gml\"\r\n\txmlns:ogc=\"http://www.opengis.net/ogc\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\tservice=\"WFS\"\r\n\tversion=\"1.0.0\"\r\n\txsi:schemaLocation=\"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd\">\r\n\t<wfs:Update typeName=\"layer_name\">\r\n\t\t<wfs:Property>\r\n\t\t\t<wfs:Name>column1</wfs:Name>\r\n\t\t\t<wfs:Value>value1</wfs:Value>\r\n\t\t</wfs:Property>\r\n\r\n\t\t<wfs:Property>\r\n\t\t\t<wfs:Name>column2</wfs:Name>\r\n\t\t\t<wfs:Value>value2</wfs:Value>\r\n\t\t</wfs:Property>\r\n\r\n\t\t<wfs:Property>\r\n\t\t\t<wfs:Name>geo_column</wfs:Name>\r\n\t\t\t<wfs:Value>\r\n\t\t\t\t<gml:Polygon srsName=\"EPSG:0000\">\r\n\t\t\t\t\t<gml:outerBoundaryIs>\r\n\t\t\t\t\t\t<gml:LinearRing>\r\n\t\t\t\t\t\t\t<gml:coordinates>x1,y1 x2,y2 x3,y3 x4,y4 x1,y1</gml:coordinates>\r\n\t\t\t\t\t\t</gml:LinearRing>\r\n\t\t\t\t\t</gml:outerBoundaryIs>\r\n\t\t\t\t</gml:Polygon>\r\n\t\t\t</wfs:Value>\r\n\t\t</wfs:Property>\r\n\r\n\t\t<ogc:Filter>\r\n\t\t\t<ogc:FeatureId fid=\"layer_name.32\" />\r\n\t\t</ogc:Filter>\r\n\t</wfs:Update>\r\n</wfs:Transaction>\r\n```\r\n\r\n위 XML은 Polygon을 수정하는 XML이다. 이 XML을 해석하면 아래와 같다.\r\n\r\n* 대상 테이블은 `layer_name`이다.\r\n* 컬럼 `column1`, `column2`에 각각 `value1`, `value2`으로 변경한다.\r\n  * 각 컬럼은 `wfs:Property`로 묶인다.\r\n  * 명시된 컬럼만 변경한다.\r\n* 공간정보 컬럼명은 `geo_column`이다.\r\n* 좌표 `x1,y1 x2,y2 x3,y3 x4,y4 x1,y1`의 폴리곤으로 변경한다.\r\n  * 좌표계는 `EPSG:4326`이다.\r\n* 변경 대상 객체는 아이디가 `layer_name.32`인 객체다.\r\n\r\n용도에 맞게 테이블명, 컬럼 등을 변경하면 된다.\r\n\r\n`ogc:Filter`는 OGC Filter의 양식을 따른다.\r\n\r\n위 XML은 아이디가 `layer_name.32`인 데이터 하나만을 대상으로 변경했지만, 필터의 구성에 따라 다수의 데이터를 전부 변경할 수도 있다.\r\n\r\n이와 관련된 OGC 필터는 후술.\r\n\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<wfs:WFS_TransactionResponse\r\n\txmlns:wfs=\"http://www.opengis.net/wfs\"\r\n\txmlns:ogc=\"http://www.opengis.net/ogc\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\tversion=\"1.0.0\"\r\n\txsi:schemaLocation=\"http://www.opengis.net/wfs https://api.itcode.dev/geoserver/schemas/wfs/1.0.0/WFS-transaction.xsd\">\r\n\t<wfs:InsertResult>\r\n\t\t<ogc:FeatureId fid=\"none\"/>\r\n\t</wfs:InsertResult>\r\n\t<wfs:TransactionResult>\r\n\t\t<wfs:Status>\r\n\t\t\t<wfs:SUCCESS/>\r\n\t\t</wfs:Status>\r\n\t</wfs:TransactionResult>\r\n</wfs:WFS_TransactionResponse>\r\n```\r\n\r\n정상응답은 위와 같다. 위 응답에서 얻을 수 있는 정보는 아래와 같다.\r\n\r\n* 데이터를 갱신함\r\n  * `InsertResult`로 삽입과 형태가 동일하지만, 새로 생성된게 없으므로 아이디가 `none`이다.\r\n* 응답 결과가 `SUCCESS`로 정상\r\n\r\n<br />\r\n\r\n\r\n\r\n#### 2-3. Transaction Delete\r\n\r\n레이어 데이터에 대한 삭제 기능이다.\r\n\r\n단순 삭제만 수행하면 되므로, XML이 훨씬 간단하다.\r\n\r\n``` txt\r\nPOST http://localhost:8080/geoserver/wfs\r\n```\r\n\r\n``` xml\r\n<wfs:Transaction\r\n\txmlns:wfs=\"http://www.opengis.net/wfs\"\r\n\txmlns:ogc=\"http://www.opengis.net/ogc\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\tservice=\"WFS\"\r\n\tversion=\"1.0.0\"\r\n\txsi:schemaLocation=\"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd\">\r\n\t<wfs:Delete typeName=\"layer_name\">\r\n\t\t<ogc:Filter>\r\n\t\t\t<ogc:FeatureId fid=\"layer_name.66\" />\r\n\t\t</ogc:Filter>\r\n\t</wfs:Delete>\r\n</wfs:Transaction>\r\n```\r\n\r\n위 XML은 Polygon을 삭제하는 XML이다. 이 XML을 해석하면 아래와 같다.\r\n\r\n* 대상 테이블은 `layer_name`이다.\r\n* 삭제 대상 객체는 아이디가 `layer_name.66`인 객체다.\r\n\r\n데이터를 삭제하기만 하면 되므로, XML이 다른 API보다 훨씬 간단하다. 삭제할 객체가 어떤 객체인지 타깃만 하면 되기 때문.+\r\n\r\n마찬가지로, 필터의 구성에 따라 다수의 데이터를 전부 삭제할 수도 있다.\r\n\r\n이와 관련된 OGC 필터는 후술.\r\n\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<wfs:WFS_TransactionResponse\r\n\txmlns:wfs=\"http://www.opengis.net/wfs\"\r\n\txmlns:ogc=\"http://www.opengis.net/ogc\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\tversion=\"1.0.0\"\r\n\txsi:schemaLocation=\"http://www.opengis.net/wfs https://api.itcode.dev/geoserver/schemas/wfs/1.0.0/WFS-transaction.xsd\">\r\n\t<wfs:InsertResult>\r\n\t\t<ogc:FeatureId fid=\"none\"/>\r\n\t</wfs:InsertResult>\r\n\t<wfs:TransactionResult>\r\n\t\t<wfs:Status>\r\n\t\t\t<wfs:SUCCESS/>\r\n\t\t</wfs:Status>\r\n\t</wfs:TransactionResult>\r\n</wfs:WFS_TransactionResponse>\r\n```\r\n\r\n정상응답은 위와 같다. 위 응답에서 얻을 수 있는 정보는 아래와 같다.\r\n\r\n* 데이터를 삭제함\r\n  * `InsertResult`로 삽입과 형태가 동일하지만, 새로 삭제된게 없으므로 아이디가 `none`이다.\r\n  * 갱신과 삭제는 구분하기 어렵다.\r\n* 응답 결과가 `SUCCESS`로 정상\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## WMS\r\n\r\nWMS의 주요 명령어를 기술한다.\r\n\r\n* GetMap\r\n* GetFeatureInfo\r\n\r\n기본 URL은 `http://localhost:8080/geoserver/wms`와 같다.\r\n\r\n<br />\r\n\r\n\r\n\r\n### 1. GetMap\r\n\r\n레이어의 데이터 및 선언된 스타일을 토대로 렌더링된 지도를 제공한다. 즉, JSON 같은 텍스트 기반 데이터가 아닌, PNG 같은 이미지를 제공한다.\r\n\r\n보유한 데이터를 토대로, 자신이 직접 디자인한 지도를 제공할 수도 있다.\r\n\r\nGeoServer의 `GetMap`에 필요한 파라미터는 아래와 같다.\r\n\r\n``` txt\r\nGET http://localhost:8080/geoserver/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&FORMAT=image%2Fpng&TRANSPARENT=true&layers=buld_sejong&exceptions=application%2Fjson&WIDTH=256&HEIGHT=256&CRS=EPSG%3A3857&STYLES=&BBOX=14167144.570487704%2C4365471.559422987%2C14167756.066713985%2C4366083.055649268\r\n```\r\n\r\n|  Parameter  |              Example              | Require |                                      Description                                      |\r\n| :---------: | :-------------------------------: | :-----: | :-----------------------------------------------------------------------------------: |\r\n|   service   |            WMS (고정)             |    Y    |                                       서비스명                                        |\r\n|   version   | 1.3.0 (고정), 1.1.1, 1.1.0, 1.0.0 |    Y    |                                         버전                                          |\r\n|   request   |           GetMap (고정)           |    Y    |                                        요청명                                         |\r\n|   layers    |       repo_name:layer_name        |    Y    |                             레이어명 (다수는 쉼표로 구분)                             |\r\n|   styles    |              style1               |         | 적용할 스타일명 (비울 경우 GeoServer에서 설정한 기본 스타일 적용, 다수는 쉼표로 구분) |\r\n| srs(or crs) |             EPSG:4326             |         |                  기준 좌표계 (비울 경우 레이어의 기본 좌표계로 인식)                  |\r\n|    bbox     | $x_{min},y_{min},x_{max},y_{max}$ |    Y    |                                   이미지 영역 좌표                                    |\r\n|    width    |                256                |    Y    |                                      이미지 넓이                                      |\r\n|   height    |                256                |    Y    |                                      이미지 높이                                      |\r\n|   format    |             image/png             |    Y    |                                        요청명                                         |\r\n| transparent |           false (기본)            |         |                                    배경 투명 여부                                     |\r\n|   bgcolor   |           FFFFFF (기본)           |         |                                RRGGBB 형태의 배경 색상                                |\r\n| exceptions  | application/vnd.ogc.se_xml (기본) |         |                                    예외 응답 형식                                     |\r\n|    time     |   2022-03-14T22:30.27.520+09:00   |         |                 시계열 데이터를 위한 시간 (yyyy-MM-ddThh:mm:ss.SSSZ)                  |\r\n|     sld     |    https://example.com/sld.xml    |         |                                     XML 파일 경로                                     |\r\n|  sld_body   |            <sld></sld>            |         |                                        SLD XML                                        |\r\n\r\nWMS는 OGC 표준 명령어 중에서 특이하게 이미지를 반환하는 명령어다. `format` 역시 이미지 MIME 타입인 것을 확인할 수 있다. 이를 통해서 자신이 직접 디자인한 지도를 서비스할 수도 있다.\r\n\r\n단, 레이어가 너무 많거나, SLD가 복잡해질수록 렌더링 시간이 길어질 수 있다.\r\n\r\n<br />\r\n\r\n`srs`는 기준 좌표계다. `bbox`의 EPSG 코드를 입력하면 되며, 비울 경우 레이어의 기본 EPSG 코드로 인식한다.\r\n\r\n`version`이 1.3.0일 경우, `crs`로 사용한다.\r\n\r\n<br />\r\n\r\nWMS는 반드시 `bbox`를 통해 영역을 입력해야한다.\r\n\r\n<br />\r\n\r\n`styles`는 사용할 SLD의 이름이다. GeoServer에서 해당 레이어에 사용할 SLD를 지정할 수 있는데, 이 때 지정한 SLD의 이름을 입력하는 것이다.\r\n\r\n쉼표로 구분하여 하나 이상의 SLD를 입력할 수 있으며, 비울 경우 기본으로 지정한 SLD가 자동으로 선택된다.\r\n\r\n<br />\r\n\r\n`time`은 시계열 데이터를 위한 파라미터. 시간별로 구분된 데이터가 있다면, 해당 파라미터를 통해 호출할 수 있다.\r\n\r\n<br />\r\n\r\n`sld`는 외부 SLD를 지정하기 위한 파라미터로, URL을 입력한다.\r\n\r\n`sld_body`는 SLD XML을 직접 파라미터에 입력하는 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/158647221-814d9d12-a03e-47fd-acb9-487ca6c5da8d.png)\r\n\r\n`GetMap`의 응답 예시다.\r\n\r\n<br />\r\n\r\n\r\n\r\n### 2. GetFeatureInfo\r\n\r\nGetMap으로 출력된 지도는 모든 객체들이 이미지로 바뀌므로, 객체를 선택하거나 판별하는 것이 불가능해보인다.\r\n\r\n하지만, `GetFeatureInfo`를 사용하면, 이미지를 클릭했을 때 해당 객체의 정보를 확인할 수 있다.\r\n\r\nGeoServer의 `GetFeatureInfo`에 필요한 파라미터는 아래와 같다.\r\n\r\n``` txt\r\nGET http://localhost:8080/geoserver/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&FORMAT=image%2Fpng&TRANSPARENT=true&QUERY_LAYERS=buld_sejong&layers=buld_sejong&exceptions=application%2Fjson&INFO_FORMAT=application%2Fjson&I=221&J=178&WIDTH=256&HEIGHT=256&CRS=EPSG%3A3857&STYLES=&BBOX=14169590.555392835%2C4366694.551875548%2C14169896.303505976%2C4367000.299988689\r\n```\r\n\r\n|   Parameter   |              Example              | Require |                     Description                     |\r\n| :-----------: | :-------------------------------: | :-----: | :-------------------------------------------------: |\r\n|    service    |            WMS (고정)             |    Y    |                      서비스명                       |\r\n|    version    | 1.3.0 (고정), 1.1.1, 1.1.0, 1.0.0 |    Y    |                        버전                         |\r\n|    request    |       GetFeatureInfo (고정)       |    Y    |                       요청명                        |\r\n|    layers     |       repo_name:layer_name        |    Y    |            레이어명 (다수는 쉼표로 구분)            |\r\n|    styles     |              style1               |         |  적용할 스타일명 (`GetFeatureInfo`에선 의미 없음)   |\r\n|  crs(or srs)  |             EPSG:4326             |         | 기준 좌표계 (비울 경우 레이어의 기본 좌표계로 인식) |\r\n|     bbox      | $x_{min},y_{min},x_{max},y_{max}$ |    Y    |                  이미지 영역 좌표                   |\r\n|     width     |                256                |    Y    |                     이미지 넓이                     |\r\n|    height     |                256                |    Y    |                     이미지 높이                     |\r\n| query_layers  |       repo_name:layer_name        |    Y    |       추가 요청 레이어명 (다수는 쉼표로 구분)       |\r\n|  info_format  | application/vnd.ogc.se_xml (기본) |         |                      응답 형식                      |\r\n| feature_count |             1 (기본)              |         |                  최대 객체 호출 수                  |\r\n|    x(or i)    |                225                |    Y    |                   지도의 x 픽셀값                   |\r\n|    y(or j)    |                156                |    Y    |                   지도의 y 픽셀값                   |\r\n|  exceptions   | application/vnd.ogc.se_xml (기본) |         |                   예외 응답 형식                    |\r\n\r\n`layers`와 `query_layers`가 비슷해서 헷갈릴 수 있는데, 이는 `GetMap`에서의 확장을 염두에 두었기 때문이다.\r\n\r\n`GetMap`의 요청에 `GetFeatureInfo`가 추가로 요구하는 몇몇 파라미터만 이어붙여 사용하기 위해 별도로 둔 것이다. `layers`와 `query_layers`의 차이는 아래와 같다.\r\n\r\n* `layers`: `GetMap`시 해당 레이어가 지도에 출력됨\r\n* `query_layers`: `GetMap`에는 출력되지 않으나, `GetFeatureInfo`에선 포함되어 검색됨\r\n\r\n지금까지 소개한 명령어들의 응답 형식이 `format`인데 비해, `GetFeatureInfo`만 `info_format`으로 상이한 이유 또한 여기에 있다.\r\n\r\n<br />\r\n\r\n`GetFeatureInfo`은 클릭한 위치를 계산하여 해당하는 객체의 정보를 출력하는 명령어이므로, `info_format`에 입력하는 값은 `GetFeature`와 같이 텍스트 MIME를 사용한다.\r\n\r\n<br />\r\n\r\n`x`, `y`는 지도 상에서 마우스가 클릭한 픽셀 값이다. 좌표가 아님에 주의하자. 좌표는 `bbox`에 입력한다.\r\n\r\n`version`이 1.3.0일 경우, `x`, `y`가 아닌 `i`, `j`로 사용해야한다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 마치며\r\n\r\n위에서 소개한 명령어는 OGC 표준 중 가장 빈번하게 사용하는 명령어로, 이외에도 당신에게 꼭 필요할 수도 있는 다채로운 명령어들이 존재한다.\r\n\r\n앞으로 설명할 예제들도 그렇고, 기본적인 기능의 지도는 위 기능들만 적절히 활용해도 충분히 서비스할 수 있다.\r\n\r\n더 많은 내용이 궁금하다면, 여기를 확인하길 바란다.","url":["2022-03-14-gis-guide-for-programmer-8","2022","03","14","gis-guide-for-programmer-8"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 7. 공간정보 데이터를 관리하는 법. GeoServer","excerpt":"이전 장에서 공간정보 데이터를 DB에 넣어봤다. 이제 데이터를 적절한 방법으로 통신할 방법만 마련한다면, DB에 저장한 공간정보 데이터를 웹에서든 앱에서든 자유롭게 활용할 수 있을 것이다. 하지만 누누히 언급했듯이, 공간정보 데이터는 다른 데이터와 엄연한 차별점이 존재한다. 바로 공간 데이터라는 점이다. 공간정보 데이터는 일반적인 텍스트 기반의 데이터가 아니다보니, CRUD에 있어서 굉장히 취약하다. 좀 더 자유로운 통신을 위해 DB에 넣었음에도 CRUD에 전혀 강점이 없는 것. 즉, MyBatis든, JPA든, 일반적인 DB 통신으로는 공간정보 데이터를 온전히 받기가 어렵다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-07T01:12:33+09:00","type":"posts","category":"GIS","tag":["GIS","GeoServer"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-07-gis-guide-for-programmer-7.md","content":"\r\n# Without GeoServer\r\n\r\n이전 장에서 공간정보 데이터를 DB에 넣어봤다. 이제 데이터를 적절한 방법으로 통신할 방법만 마련한다면, DB에 저장한 공간정보 데이터를 웹에서든 앱에서든 자유롭게 활용할 수 있을 것이다.\r\n\r\n하지만 누누히 언급했듯이, 공간정보 데이터는 다른 데이터와 엄연한 차별점이 존재한다. 바로 공간 데이터라는 점이다. 공간정보 데이터는 일반적인 텍스트 기반의 데이터가 아니다보니, CRUD에 있어서 굉장히 취약하다. 좀 더 자유로운 통신을 위해 DB에 넣었음에도 CRUD에 전혀 강점이 없는 것.\r\n\r\n즉, MyBatis든, JPA든, 일반적인 DB 통신으로는 공간정보 데이터를 온전히 받기가 어렵다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# GeoServer\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157473965-c0bdfa0c-8915-4053-a1f0-eff73fc3e719.png)\r\n\r\n이 쯤에서 등장하는 게 <span class=\"primary\">GeoServer</span>다. GeoServer는 GIS 데이터를 공유, 편집할 수 있는 웹 서버다. JAVA로 개발된 오픈 소프트웨어다.\r\n\r\nAPI 형태로 원하는 GIS 데이터를 다양한 형태로 통신할 수 있으며, 엔진 단계에서 좌표계 변환, 타일 렌더링 등을 제공하기 때문에 개발자가 구현해야할 GIS 연산 로직이 대폭 감소한다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## GeoServer 설치하기\r\n\r\n설치는 [GeoServer 공식 홈페이지](http://geoserver.org/release/stable/)에서 확인 가능하다. GeoServer의 파일은 두 가지 형태로 제공한다.\r\n\r\n* Stand-Alone: 단독 설치버전. WAS가 자체적으로 포함되어있음.\r\n  * Platform Independent Binary: OS에 범용적인 바이너리 파일\r\n  * Windows Installer: Windows 전용 exe 파일\r\n* Web Archive: WAR 버전. Tomcat같은 JavaEE를 구현한 WAS에서 구동 가능.\r\n\r\n둘 중 원하는 방식을 사용하면 된다.\r\n\r\n만약 별도로 Tomcat을 운용하는데, GeoServer 스탠드얼론 버전을 사용할 경우, 포트가 8080으로 서로 겹친다. GeoServer 스탠드얼론 버전의 기본 포트도 8080이기 때문. `start.ini`의 `jetty.port=8080`을 원하는 포트로 변경해주면 된다.\r\n\r\n기본 설정 기준으로 [https://localhost:8080/geoserver](https://localhost:8080/geoserver)로 접속하면 GeoServer에 접속할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157474361-20317947-87f0-4695-86a5-2c3517ad7991.png)\r\n\r\n위 페이지가 뜬다면 정상적으로 설치가 완료된 것.\r\n\r\nGeoServer의 모든 설정은 웹에서 관리하므로, 여기에서 원하는 설정을 관리하면 된다.\r\n\r\n기본 계정의 아이디/비밀번호는 `admin/geoserver`다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 계정 관리\r\n\r\n기본 계정을 그대로 사용할 경우, 보안 상의 위협을 받을 수 있다. 따라서 비밀번호를 변경하거나, 아예 새로운 계정을 만들어 관리하는 것이 안전하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157474677-97f37c75-f4b3-495a-9c72-55f640d5ad99.png)\r\n\r\n사이드 메뉴의 [사용자, 그룹, 역할] 메뉴를 클릭한다. 상단의 탭에서 [사용자/그룹] 탭을 클릭하여 계정을 관리할 수 있다. `admin` 계정은 가장 기본적으로 제공하는 계정이므로, 노출도가 심하다. 비밀번호를 적절히 변경해주거나, 아니면 아예 다른 계정을 사용하는 것이 안전하다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n### 새로운 계정 생성하기\r\n\r\n상단의 버튼 중 [새로운 사용자 추가] 버튼을 클릭한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157474979-a427e2c4-83c7-4e5c-9b37-a161d030f867.png)\r\n\r\n원하는 계정명, 비밀번호를 입력한다. 맨 하단의 역할에서 [ADMIN]을 활성화하면, 기존의 `admin` 계정과 동일한 권한을 부여받는다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n### admin 계정 비활성화\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157475238-d434d927-6527-4bda-b556-3b8ac6608ca9.png)\r\n\r\n사용하지 않는 계정은 비활성화하는 것이 안전하다. 아까와 동일한 메뉴에서 `admin` 계정을 클릭하여 들어간다.\r\n\r\n계정명 하단의 [비활성화] 체크박스를 활성화하고 저정하면 계정이 비활성화된다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 레이어 추가하기\r\n\r\nGeoServer를 설치했으니, GeoServer에게 어떤 데이터를 서비스할 것인지 알려주는 과정이 필요하다. 이 과정을 \"레이어를 추가한다\"고 한다.\r\n\r\n레이어는 아래의 분류를 가진다.\r\n\r\n* 레이어: 데이터의 주체가 되는 소분류. DB의 테이블이 여기에 해당한다.\r\n* 레이어 그룹: 다수의 레이어를 그룹화한 것. 한꺼번에 여러개의 레이어를 호출해야할 경우, 그룹화하여 호출 레이어를 간략화할 수 있다.\r\n* 저장소: 데이터 저장소가 되는 중분류. DB, SHP가 여기에 해당한다. 다수의 레이어 및 그룹을 하위에 포함하고 있다.\r\n* 작업공간: GeoServer에서 레이어를 관리하기 위한 대분류. 다수의 저장소를 하위에 포함하고 있다.\r\n\r\n작업공간은 저장소를 포함하고, 저장소는 레이어 그룹 및 레이어를 포함한다. 즉, 레이어를 추가하기 위해선 먼저 작업공간을 만들고, 저장소를 추가한 뒤 레이어를 생성하는 순서로 진행된다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n### 1. 작업공간 추가하기\r\n\r\n레이어의 가장 대분류가 되는 작업공간을 추가하자. 좌측 사이드 메뉴에서 [작업공간] 메뉴를 클릭하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157476460-04787661-7156-470d-ab6e-c8d828efb364.png)\r\n\r\n[새로운 작업공간 추가하기]를 클릭하여 작업공간을 추가한다.\r\n\r\n이름과 URI를 지정한다. URI는 추후 레이어 호출 시 같이 입력해야 하므로, 적절한 걸 입력해주자.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n### 2. 저장소 생성하기\r\n\r\n레이어를 담고있는 저장소를 생성하자. SHP 혹은 DB를 연결할 수 있다.\r\n\r\nDB의 경우, 기본적으로 PostgreSQL을 지원하며, 별도의 플러그인을 통해 다른 DB와의 연결을 추가할 수도 있다. 이 장에서 사용할 MariaDB(MySQL)의 경우도 별도의 플러그인을 추가하여 진행하게 된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157476582-8ea73590-6a25-456e-9d87-5ebd059325a2.png)\r\n\r\n[새로운 저장소 생성하기]를 클릭하여 저장소를 생성한다.\r\n\r\n원하는 연결 방법을 선택하자. 파일 시스템의 SHP를 지정할 수도, DB를 연결할 수도 있다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n#### 플러그인 추가하기\r\n\r\n[GeoServer 다운로드 페이지](http://geoserver.org/release/stable/)에서 각 버전에 해당하는 플러그인을 다운로드 받을 수 있다.\r\n\r\n링크의 사이트를 Stable 버전으로, 자신이 설치한 버전에 맞는 플러그인을 받는 것이 좋으므로 버전을 꼭 확인하자.\r\n\r\nMariaDB(MySQL) 플러그인의 경우, 하단의 [Vector Formats - MySQL]을 클릭해서 다운로드 받을 수 있다.\r\n\r\n이 밖에도 Oracle, MongoDB 등 타 DB의 플러그인도 있는 걸 확인할 수 있으니, 필요하다면 참고할 것. [Extensions - Extensions]를 클릭하여 제공하는 플러그인 일체를 확인할 수 있다.\r\n\r\n<br />\r\n\r\n받은 플러그인의 압축을 해제하면 `jar` 파일이 나오는데, 이 `jar` 라이브러리를 GeoServer의 라이브러리에 넣으면 된다. 아래의 경로 중 하나에 넣자.\r\n\r\nTomcat의 설치경로를 `$CATALINA_HOME`으로 표기한다.\r\n\r\n* Tomcat 전역 라이브러리: `$CATALINA_HOME/lib`\r\n* GeoServer 라이브러리 `$CATALINA_HOME/webapps/geoserver/WEB-INF/lib`\r\n\r\n이후 재기동을 해주면 반영된다. MySQL 플러그인을 설치하면, 이후 [저장소 생성하기] 메뉴의 저장소 목록에서 MySQL 관련 항목이 추가된 것을 확인할 수 있다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n#### SHP 추가하기\r\n\r\nDB를 따로 구축하기 싫다면, 파일 기반의 SHP를 통해 레이어를 구성할 수도 있다.\r\n\r\n[Directory of Spatial files]를 클릭한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157479933-7f1ef829-8a0b-47f7-8b5e-fbe337638207.png)\r\n\r\n1. 할당할 저장공간을 선택한다.\r\n2. 데이터 저장소의 이름을 선택한다.\r\n3. SHP 경로를 지정한다.\r\n4. 데이터의 문자셋을 지정한다.\r\n\r\n이후 저장을 누르면 SHP 기반의 저장소가 생성된다.\r\n\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n#### MariaDB(MySQL) 추가하기\r\n\r\nGIS 데이터를 관리하는 DB가 있다면, GeoServer와 연동하여 레이어를 구성할 수 있다.\r\n\r\n진행 전에 아래 두 사항을 진행했는지 확인하자.\r\n\r\n* GIS 데이터가 DB에 이미 삽입되어 있어야한다.\r\n* MySQL 플러그인이 설치되어 있어야한다.\r\n\r\n[MySQL]을 클릭한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157480077-057964b7-c818-4bec-a365-e9b2a38e8ecc.png)\r\n\r\n1. 할당할 저장공간을 선택한다.\r\n2. 데이터 저장소의 이름을 선택한다.\r\n3. host를 입력한다. (IP 혹은 도메인)\r\n4. 포트를 입력한다.\r\n5. 데이터베이스의 이름을 입력한다.\r\n6. 계정명, 비밀번호를 입력한다.\r\n\r\n이 정도가 필수 사항이고, 나머지 하단의 옵션은 Connection Pool에 대한 설정이므로 원한다면 별도로 수정해주면 된다.\r\n\r\n이후 저장을 누르면 MySQL 기반의 저장소가 생성된다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n### 3. 레이어 추가하기\r\n\r\nGIS 데이터의 기본이 되는 레이어를 추가하자. 기존에 유효한 저장소가 추가되어 있어야, 정상적으로 레이어를 추가할 수 있다.\r\n\r\n[새로운 레이어 추가하기]를 클릭한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/157480381-7a4e548e-7d3a-4c52-a7d5-2f45e85aef99.png)\r\n\r\n1. 대상 저장소를 선택한다. 추가 가능한 레이어 목록이 표시된다.\r\n2. 원하는 레이어의 우측 [발행하기] 버튼을 클릭한다.\r\n3. 좌표계를 지정한다. 원하는 좌표계를 검색하여 선택할 수 있다.\r\n4. 레이어 영역을 지정한다. [데이터로부터 계산하기], [원본 영역으로부터 계산하기]를 각각 눌러주면 알아서 계산된다.\r\n5. 상단 탭의 [발행]을 클릭한다.\r\n6. [WMS 설정]의 [기본 스타일]을 지정한다.\r\n   1. 해당 스타일은 WMS 요청 시 기본으로 지정되여 렌더링된다. (자세한건 추후 별도 문서에서 후술)\r\n\r\n이후 저장을 누르면 레이어가 추가된다. 여기까지 진행해야 GeoServer에서 레이어를 호출할 수 있다.\r\n\r\n레이어 호출 시 `{저장공간 URI명}:{레이어명}`으로 레이어를 특정할 수 있다. 만약, 저장공간의 URI를 `storage`라 지정하고, 레이어명은 `polygon`으로 지정했다면, `storage:polygon`이라는 형식으로 해당 레이어를 특정할 수 있는 것이다.\r\n\r\n그 밖에도 지도 서비스와 관련해서 여러 설정을 할 수 있으니, 확인해보자.","url":["2022-03-07-gis-guide-for-programmer-7","2022","03","07","gis-guide-for-programmer-7"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 6. 공간정보의 DB화","excerpt":"데이터의 CRUD 소요가 있는 서비스는 DB를 사용한다. 서비스 운영에 필요한 데이터를 DB에 저장하고, 이를 적절히 관리, 조작함으로써 서비스의 기능을 제공한다. GIS의 경우, 그 특성상 대용량 데이터를 자주 접하게 된다. 일례로, 전국의 건물 수는 몇백만을 우습게 상회하기 때문. 단순 row가 백만 단위인 것도 문제지만, 건물 정보의 특성 상 column의 갯수 또한 수십 개 정도다. 때문의 데이터의 용량이 매우 커진다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-05T04:35:41+09:00","type":"posts","category":"GIS","tag":["GIS","MariaDB","QGIS"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-05-gis-guide-for-programmer-6.md","content":"\r\n# 공간정보 데이터 관리하기\r\n\r\n데이터의 CRUD 소요가 있는 서비스는 DB를 사용한다. 서비스 운영에 필요한 데이터를 DB에 저장하고, 이를 적절히 관리, 조작함으로써 서비스의 기능을 제공한다.\r\n\r\nGIS의 경우, 그 특성상 대용량 데이터를 자주 접하게 된다. 일례로, 전국의 건물 수는 몇백만을 우습게 상회하기 때문. 단순 row가 백만 단위인 것도 문제지만, 건물 정보의 특성 상 column의 갯수 또한 수십 개 정도다. 때문의 데이터의 용량이 매우 커진다.\r\n\r\n때문에 공간정보 역시 DB에 저장하여 관리할 필요성이 생긴다. 하지만 문제는 공간정보는 DB에 저장하기 꽤나 까다롭다. 다른 데이터야 문자열이든 정수형이든 대충 삽입하면 되지만, 좌표값에서 문제가 발생한다. 점의 경우 $(x, y)$로 비교적 간단하지만, 선과 면의 경우 $xy$좌표가 무수히 나올 수 있으므로 문제가 커진다.\r\n\r\n그 뿐만 아니라, 별도로 언급하지 않은 복잡한 형태의 도형(도넛처럼 가운데가 빈 면 등)을 저장할때도 많은 문제가 생긴다. 때문에 적절한 툴을 활용하여 DB에 SHP를 삽입하는 것이 가장 효과적이다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## ogr2ogr로 MariaDB에 SHP 삽입하기\r\n\r\n이 장에서는 DB에 SHP를 삽입하는 방법으로 `ogr2ogr`을 사용한다. 이 툴은 공간정보를 다루는 라이브러리로, QGIS를 설치하면 자동으로 같이 설치된다.\r\n\r\n`ogr2ogr`만 따로 설치하는 것보다 QGIS 설치해서 딸려나오는 걸 사용하는 게 훨씬 편하므로, 여기선 이 방법을 통해 기술한다.\r\n\r\nQGIS 3.16 기준으로 일반적인 설치 경로는 `C:\\Program Files\\QGIS 3.16`이다. 물론 버전에 따라 경로는 조금씩 차이가 발생할 수 있으니 참고만 할 것.\r\n\r\n`C:\\Program Files\\QGIS 3.16\\bin`에서 `ogr2ogr`을 찾을 수 있다. 해당 경로에서 `cmd`를 통해 `ogr2ogr`에 명령어를 날려 SHP를 삽입해보자.\r\n\r\n<br />\r\n\r\n``` batch\r\nogr2ogr -f MySQL MySQL:{DB명}, host={DB 호스트}, user={DB 계정명}, password={DB 비밀번호} {SHP 경로} -nln {생성할 테이블 이름} -a_srs {SHP의 EPSG 코드} -lco engine=MYISAM\r\n```\r\n\r\n위 명령어를 입력하여 SHP를 MariaDB에 삽입할 수 있다. `-nln` 옵션을 지정하지 않을 경우, SHP의 이름을 그대로 따라간다.\r\n\r\n삽입 시, SHP의 테이블 외에도 공간정보의 메타데이터를 관리하는 테이블이 2개 생성되며, 각각 아래와 같다.\r\n\r\n* `geometry_columns`: 각 레이어의 좌표 정보에 대한 메타데이터\r\n* `spatial_ref_sys`: 사용된 좌표계의 메타데이터\r\n\r\n위 두 테이블은 개발자가 직접 사용할 일은 거의 없으니 그냥 이런 게 있다고 알고만 있으면 된다. 이 점을 모를 경우, 내가 의도한 테이블 외에 다른 테이블이 생김에 혼란을 일으킬 수 있기 때문.\r\n\r\n> <b class=\"yellow-500\">🙋‍♂️ DB는 꼭 MariaDB가 아니여도 상관없어요!</b>  \r\n> 이 문서에서는 MariaDB를 기준으로 설명했지만, 이건 어디까지나 내 서버에 MariaDB를 운용하고 있기 때문이지, 다른 이유가 있는 건 아니다.  \r\n> GIS를 전문으로 취급하는 데이터베이스를 구축할 심산이라면, PostgreSQL이 훨씬 나은 선택지다. PostgreSQL은 GIS 관련 기능이 매우 강력하기 때문에, DB 자체적으로 많은 편의기능을 제공한다.  \r\n> 많은 GIS 툴에서 PostgreSQL과의 직접적인 Connection Pool을 기본으로 제공한다.\r\n\r\n<br />\r\n\r\nSHP 데이터를 입력하다보면, 잘못된 도형으로 인해 삽입이 되지 않는 현상을 종종 목격한다. 명령어 마지막에 `--skipfailure` 옵션을 붙여주면 오류가 난 행은 제외하고 삽입하니 참고할 것.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156867178-87770a5a-e24f-4beb-b21b-fc081d67e5aa.png)\r\n\r\nSHP를 MariaDB에 삽입한 예시. DBeaver로 데이터베이스를 확인하면 무려 OSM을 기반으로 데이터의 형태까지 보여준다. 하단의 메뉴에서 EPSG 코드를 설정할 수 있으니 참고할 것.","url":["2022-03-05-gis-guide-for-programmer-6","2022","03","05","gis-guide-for-programmer-6"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 4. QGIS 체험하기","excerpt":"이전에 대부분의 공간정보 데이터는 SHP를 기본으로 제공한다고 언급했었다. 그런데 문제는 이 SHP. 어떻게 여는지 모르겠다. GeoJSON이나 CSV 같은 텍스트 기반 데이터는 어찌됐든 열어서 검증을 해볼 수 있지만, SHP는 그게 안 된다는 말이다. 때문에 SHP를 열어서 조작할 수 있는 일종의 툴이 필요한데, 이미 여러 툴이 있으니 크게 문제되진 않는다. 가장 대표적인 툴은 두 가지가 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-05T03:05:25+09:00","type":"posts","category":"GIS","tag":["GIS","QGIS"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-05-gis-guide-for-programmer-4.md","content":"\r\n# QGIS\r\n\r\n이전에 대부분의 공간정보 데이터는 SHP를 기본으로 제공한다고 언급했었다. 그런데 문제는 이 SHP. 어떻게 여는지 모르겠다. GeoJSON이나 CSV 같은 텍스트 기반 데이터는 어찌됐든 열어서 검증을 해볼 수 있지만, SHP는 그게 안 된다는 말이다.\r\n\r\n때문에 SHP를 열어서 조작할 수 있는 일종의 툴이 필요한데, 이미 여러 툴이 있으니 크게 문제되진 않는다. 가장 대표적인 툴은 두 가지가 있다.\r\n\r\n* ArcGIS: 강력한 퍼포먼스를 가진 상용 프로그램. 비싸다.\r\n* QGIS: ESRI에서 만든 오픈소스 프로그램. 무료지만, 대용량 처리 시 좀 버벅인다.\r\n\r\n타일맵 제작이나 초대용량 데이터 처리가 아니라면, 대부분은 QGIS로 충분히 커버할 수 있다. 두 프로그램 모두 Python으로 개발되었으며, 덕분에 Python을 활용한 다양한 플러그인을 사용할 수 있다. 본인이 Python에 조예가 있다면, 직접 스크립트를 입력하여 복잡한 동작을 수행할 수도 있다. 하지만 QGIS로 이 정도 수준의 업무를 수행한다면, 개발자라기보단 데이터 관련 직무에 더 가깝다.\r\n\r\n공간정보 데이터에 대한 충분한 이해 없이 OpenLayers를 다뤄봤자, 혼란만 가중된다. 때문에 OpenLayers에 대해 설명하기 이전에, QGIS를 통해 SHP를 다루는 방법을 먼저 다루고 넘어간다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 설치하기\r\n\r\nQGIS는 [공식 홈페이지](https://qgis.org/ko/site/)에서 다운로드 받을 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## SHP 열어보기\r\n\r\nQGIS를 실행하고, SHP를 드래그해보자. 정상적인 공간정보 파일이라면, 관련 데이터가 창에 표시된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156781770-e5540bed-d1c3-4fde-be69-e3dac0e08c8c.png)\r\n\r\n위 데이터는 도로명주소에서 제공하는 세종시 건물 데이터다. 처음 해보는 사람도, 일단 뭔가 유효한 데이터가 출력됐다 정도는 인식할 수 있다.\r\n\r\n건물은 면(Polygon) 형태를 띈다. 각 도형은 건물을 의미한다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## Open Street Map 띄워서 비교하기\r\n\r\n데이터가 나왔다는 건 알겠는데, 저 건물이 실제로 어떤 위치에 있는지 확인하기 매우 어렵다. 즉, 위치를 비교할 수 있는 완전한 지도를 같이 띄워놓고 비교하는 것이 편하다.\r\n\r\nQGIS는 Open Street Map(이하 OSM) 레이어를 기본으로 제공한다.\r\n\r\nOSM이란, 전세계 지도 종사자들이 자율적으로 관리하는 세계지도다. 각국의 지도는 해당 국가의 개발자들이 기여하므로, 로컬라이징은 물론, 세계화도 잘 되어있어 당장 간편하게 쓰기 좋은 지도다. 단, 네이버나 카카오처럼 국내에 특화된 지도는 아니라서, 국내 한정 서비스에 적용하기는 다소 아쉽다.\r\n\r\n<br />\r\n\r\n물론 이건 어디까지나 서비스할 때 얘기고, 당장 데이터 놓고 위치 비교하기엔 이만한 게 없다.\r\n\r\n좌측 사이드바에서 [XYZ Tiles - OpenStreetMap]을 더블 클릭하여 레이어에 추가하자.\r\n\r\n레이어 순서에 따라 표시되는 우선순위가 달라지니, 가급적 OpenLayers를 제일 밑에 두도록 하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156783705-707ce5d6-c6ce-4d7f-9b49-ce13d824f9e6.png)\r\n\r\n더욱 비교하기 쉬워졌다. 데이터를 보면 얼추 세종시의 지형에 맞게 데이터가 배치된 것을 확인할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 데이터 확인하기\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156788688-ce4efff3-9648-45a9-8f19-fed8fc81ee21.png)\r\n\r\n데이터를 클릭해서 정보를 확인할 수 있다. 상단 메뉴에서 [객체 식별 (Ctrl + Shift + I)] 버튼을 클릭하고 객체를 누르면 정보를 확인할 수 있다.\r\n\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156793866-a6d13e58-fc2b-4b63-aabc-5e16112b07b2.png)\r\n\r\n레이어를 오른쪽 마우스로 클릭하면 사용 가능한 메뉴를 볼 수 있다. [속성 테이블 열기]를 클릭하면 모든 데이터의 속성을 볼 수 있다. DB의 형태와 매우 유사하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156789125-2c96cf14-43d8-4202-bfbf-752aacad0bcb.png)\r\n\r\n데이터를 찾거나, 선택한 데이터를 지도에 표시하는 것은 물론, 데이터의 수정, 삭제 또한 가능하다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 좌표계 설정하기\r\n\r\nQGIS는 각 레이어의 좌표계를 확인하고 주 좌표계로 변환하여 QGIS에 표시한다.\r\n\r\n예를 들어, 아래와 같다고 해보자.\r\n\r\n* 주 좌표계: EPSG:4326\r\n* A 레이어 좌표계: EPSG:5179\r\n* B 레이어 좌표계: EPSG:3857\r\n\r\n주 좌표계가 `EPSG:4326`이므로, A, B 좌표를 `EPSG:4326`으로 변환하여 QGIS에 표시한다. 최종적으로 사용자는 `EPSG:4326`으로 표현된 지도를 볼 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156792339-013c91ae-0762-44f0-a03d-fe76144271b2.png)\r\n\r\n주 좌표계는 QGIS 우측 하단에서 설정할 수 있다. 원하는 EPSG 코드를 찾아 지정하면, 해당 좌표계로 데이터가 자동 변환되어 표시된다.\r\n\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156792509-a23d95b7-0a64-4e2e-a483-0cfd0f553d93.png)\r\n\r\n각 레이어의 좌표계는 해당 메뉴를 통해 변환할 수 있다. 반드시 해당 레이어에 맞는 좌표계를 지정해야한다.\r\n\r\n예를 들어, `EPSG:5181` 좌표계로 정의된 레이어를 `EPSG:4326`으로 잘 못 지정하면 전혀 엉뚱한 위치로 계산된다.\r\n\r\n쉽게 설명하자면, 번역기에 이탈리아어를 영어로 인식하고 번역하는 것과 같은 이치다. 영어가 아닌 것을 영어라고 번역하니 전혀 의미없는 단어가 번역되기 때문. 마찬가지로, 레이어 좌표계를 잘 못 지정하면 전혀 엉뚱한 위치로 변환되므로 주의해야한다. 만약 이 현상이 나타났다면, 레이어의 좌표계를 다시 확인하기 바란다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 레이어 저장하기\r\n\r\nQGIS에서 데이터의 내용이나, 좌표계를 변경했을 경우, 이 데이터를 SHP 혹은 그에 준하는 공간정보 데이터로 출력해서 사용할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156793756-eb05a60b-be4f-4554-a309-610b0a61ab4b.png)\r\n\r\n[내보내기 - 객체를 다른 이름으로 저장]을 클릭하여 저장 메뉴를 호출한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156800667-0ef7c428-c905-4fa3-94a9-2cdda89193e3.png)\r\n\r\n원하는 데이터 형식과 설정을 입력하면, 데이터를 저장할 수 있다.","url":["2022-03-05-gis-guide-for-programmer-4","2022","03","05","gis-guide-for-programmer-4"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 3. 좌표계","excerpt":"1986년, NASA에서 우주왕복선 챌린저호를 발사했으나, 발사한 지 약 73초만에 폭발한 안타까운 사고가 있었다. 원인은 어이없게도 단위 실수. 국제적인 표준은 미터법임에도 불구하고, 미국을 포함한 몇몇 국가는 인치법을 표준으로 사용하고 있었다. 이러한 상황에서 우주선의 설계도 중 미터법으로 표기된 부품 O Ring을 인치법으로 제작했기 때문에 일어난 사고였다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-04T01:47:29+09:00","type":"posts","category":"GIS","tag":["GIS"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-04-gis-guide-for-programmer-3.md","content":"\r\n# 다 같은 좌표가 아니야!\r\n\r\n1986년, NASA에서 우주왕복선 챌린저호를 발사했으나, 발사한 지 약 73초만에 폭발한 안타까운 사고가 있었다.\r\n\r\n원인은 어이없게도 단위 실수. 국제적인 표준은 미터법임에도 불구하고, 미국을 포함한 몇몇 국가는 인치법을 표준으로 사용하고 있었다. 이러한 상황에서 우주선의 설계도 중 미터법으로 표기된 부품 O Ring을 인치법으로 제작했기 때문에 일어난 사고였다.\r\n\r\n<br />\r\n\r\n공간정보 또한 이와 비슷하게 좌표계라는 일종의 단위를 가지고 있다. 통상 공간정보의 좌표라고 하면 대부분 동경 127, 북위 37을 떠올린다.\r\n\r\n동경 127, 북위 37은 GPS에서 주로 사용하는 세계측지 중 하나인 `WGS-84` 좌표계다. 이와 같이 좌표계의 특성에 따라 표현되는 값도 다르며, 이를 구분하기 위해 EPSG:0000과 같이 EPSG 코드로 관리한다.\r\n\r\n방금 언급한 `WGS-84`의 코드는 `EPSG:4326`이다.\r\n\r\n|  EPSG 코드  |                     proj 인자                      |\r\n| :---------: | :------------------------------------------------: |\r\n| `EPSG:4326` | `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs` |\r\n\r\n이러한 체계를 좌표계라고 부르며, 공식적으론 프로젝션(Projection)이라 명칭한다. 프로젝션은 EPSG 코드와 proj 인자로 이루어진다.\r\n\r\nEPSG 코드는 좌표계의 명칭이며, proj 인자는 좌표계를 표현하는 수식으로 +proj=로 시작한다. 이 proj 인자는 좌표계의 표현 및 좌표계 변환에 사용된다.\r\n\r\nSHP의 prj 파일은 이 프로젝션에 대한 정보를 담고 있다.\r\n\r\n대부분의 데이터 제공자는 자신이 제공하는 공간정보 데이터에 대한 좌표계를 제공하니, 사용하기전에 이를 반드시 확인해야한다. <span class=\"red-500\">간혹 명시하지 않거나, 오기입하는 경우도 있으니 주의.</span>\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 타원체\r\n\r\n좌표는 현재 위치를 특정 값으로 표시하는 것이다. 지구는 구(Sphere) 형태를 띄고 있으므로, 좌표를 정확하게 표시하기 위해선 이 구의 모양을 정의할 필요가 있다.\r\n\r\n지구는 구 형태지만, 실제로 엄밀한 구는 아니다. 아, 그렇다고 평평하다는 뜻은 더더욱 아니다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156601191-e161a593-ccee-4f06-b5c8-b2ffce88bdaf.png)\r\n\r\n아름다운 구 형태였다면 좋았겠지만, 아쉽게도 지구의 모양은 문제가 좀 많다. 구라고 부르기 애매한 수준. 혹자는 감자라고도 칭한다.\r\n\r\n어쨌든 완벽한 구 형태가 아니다보니, 좌표를 계산함에 있어서 여러 보정이 필요하다.\r\n\r\n<br />\r\n\r\n이런 지구의 현실을 반영하여 지구의 형태를 정의한 것을 타원체라고 한다. 좌표계마다 사용하는 타원체는 제각각이며, 어떤 타원체를 사용하냐에 따라 그 특성이 달라진다.\r\n\r\n* GRS80: 세계 타원체 표준. 국제측지학회, 지구물리학연합에서 채택함\r\n* WGS84: 미국에서 군사용 GPS를 개발하는 과정에서 사용하기 위해 정의한 타원체.\r\n  * GRS80과 WGS84는 거의 동일하며, 단반경 0.01mm 정도의 매우 근소한 차이를 가진다.\r\n* BESSEL: 특정 구역을 기준으로 정의한 타원체. 특정 구역까지는 정확하나, 구역에서 멀어질수록 오차가 심해진다.\r\n  * 대한민국은 일제강점기의 영향으로 이전까진 도쿄를 기준으로 정의된 BESSEL 타원체를 사용했다.\r\n\r\n타원체와 관련된 정보를 찾다보면 **ITRF-2000**이라는 키워드가 보일텐데, ITRF-2000은 하나로 정의된 타원체가 아니라, 세계 공통 타원체를 ITRF-2000이라 부른다. 즉, 현재 기준으로 `GRS80`과 동일하다.\r\n\r\n<br />\r\n\r\nGPS라는 걸출한 기술이 개발되기 전까지는 각 구역을 중심으로 타원체를 정의하는 `BESSEL` 타원체를 많이 사용했다. GPS 기술 이전에는 전 세계의 타원체를 정의할 수단이나 기술이 전무했기 때문.\r\n\r\n그 중 우리나라는 위에서 언급했다시피, 일제강점기의 영향으로 인해 일본에서 진행한 국토조사 사업을 통해 BESSEL 동경 타원체를 사용하게 됐다.\r\n\r\n`EPSG:2096(동부)`, `EPSG:2097(중부)`, `EPSG:2096(서부)` 등이 이에 해당되며, 오래된 공간 정보 데이터를 찾다 보면 이 좌표계들을 사용하는 걸 볼 수도 있다.\r\n\r\n다행히 현재는 국제 표준을 위해 `GRS80` 타원체를 사용하는 좌표계로 변경했다. 아래 후술할 `EPSG:5180(서부)`, `EPSG:5181(중부)`, `EPSG:5183(동부)` 등이 이에 해당한다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 투영법\r\n\r\n여러분 머릿속에 지도를 떠올려보자. 종이든, 앱이든 상관없다. 생각해보면, 지구는 구지만, 지도는 평면이다. 물론 지구의 형태를 충실히 이행한 지구본이 있지만, 요즘의 지구본은 위치보다는 인테리어의 범주에 들어섰다. 단언컨데 여기서 그 누구도 위치를 찾기 위해 지구본을 들여다보지 않을 것이다.\r\n\r\n그말인즉슨, 우리에게 익숙한 지도를 만들기 위해선, 구를 평면화하는 작업이 필요하다. 어렸을 때 수학시간에 전개라는 개념을 배운 적이 있는가? 우유팩을 완전히 펼치는 과정을 생각하면 얼추 비슷하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156607735-9b23d446-1bdc-4dd1-9105-455906f51fc4.png)\r\n\r\n이처럼 좌표계에서 구를 평면화하는 것을 투영법이라 부른다.\r\n\r\n* TM(Transverse Mercator): BESSEL 타원체를 기준으로 투영한 평면좌표계\r\n* UTM(Universal TM): GRS80(혹은 WGS84) 타원체를 기준으로 투영한 평면좌표계\r\n* UTM-K: 일반적인 UTM은 적도를 기준으로 하므로, 한국과 약간의 오차가 발생한다. 이를 보정하여 한국에 맞게 정의한 것이 UTM-K다.\r\n  * UTM 투영체는 GRS80 타원체를 기준으로 하는데, UTM-K 중 몇몇 좌표계는 BESSEL 타원체를 사용한다. 자세한 이유는 불명.\r\n\r\n좌표계를 보면 중부, 동부 등으로 나눠져있는데, 이는 오차를 최소화하기 위해 기준점을 나눈 것이다.\r\n\r\n타원체를 정의하고, 이를 평면화하는 과정에서 발생하는 오차를 최대한 줄이기 위해 투영 기준점을 잡고, 해당 위치를 기준으로 투영하는 것이다. 대한민국은 동부, 중부, 서부, 제주원점이 존재(더 있을 수 있음)하며, 각 구역의 측위기준점을 기준으로 좌표계를 투영한다.\r\n\r\n국가급이 아닌 시군구, 지자체 단위에서 제공하는 공간 정보는 각 위치에 가장 최적화된 좌표계를 기준으로 제공한다. 예를들면 제주 관련 데이터는 제주원점, 강원도청에서 제공하는 데이터는 동부원점을 적용한다던가.\r\n\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 자주 사용하는 프로젝션\r\n\r\n사실 타원체니, 투영법이니 크게 중요하지 않다. 그냥 본인이 가진 데이터가 어떤 좌표계를 사용하는지만 잘 알면 사용하는 데 아무런 지장이 없다. 타원체, 투영법에 관계없이 모든 좌표계는 `EPSG:0000`의 형태로 관리되기 때문. 그냥 본인이 원하는 좌표계의 EPSG 코드만 알고 있으면 단순 사용에 아무런 문제가 없다.\r\n\r\n각 좌표계는 매칭되는 EPSG 코드와 proj 인자를 가진다. proj 인자는 해당 좌표계를 나타내는 일종의 수식으로, 이 인자를 통해 좌표계의 변환 연산이 가능하다. proj를 이해할 수 있다면, 이 좌표계가 어떤 특성을 가지는지 인자만 보고도 해석할 수 있다.\r\n\r\n|  파라미터   |                내용                |\r\n| :---------: | :--------------------------------: |\r\n|   `proj`    |               투영체               |\r\n|     `a`     |  장반경 (타원에서 가장 긴 반지름)  |\r\n|     `b`     | 단반경 (타원에서 가장 짧은 반지름) |\r\n| `lat` `lon` |        좌표계의 기준 경위도        |\r\n|   `x` `y`   |          좌표계의 기준 xy          |\r\n|     `k`     |            좌표계 배율             |\r\n|   `ellps`   |            타원체 종류             |\r\n\r\n대략적인 파라미터는 위와 같으며, `lat`, `lon`, `x`, `y`의 경우 `lat_ts`, `x_0`와 같이 뒤에 어떤 인자가 따라오느냐에 따라 의미하는 게 조금씩 달라지기도 한다.\r\n\r\n대충 이 정도만 알면 해당 좌표계의 인자가 뭘 의미하는 지 어렴풋이 파악할 수 있으며, 단순 좌표계를 사용하려는 개발자 선에선 이 이상 몰라도 상관없다. 아니, 이 조차 몰라도 사용에 지장은 없다.\r\n\r\n모든 좌표계를 숙지하거나, proj 인자를 외울 필요는 더더욱 없다. 단, 주로 사용하는 좌표계 정도는 알고 있으면 데이터 파악을 좀 더 쉽게 할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 세계 측지\r\n\r\n|  EPSG 코드  | proj 인자                                                                                                          |        비고         |\r\n| :---------: | :----------------------------------------------------------------------------------------------------------------- | :-----------------: |\r\n| `EPSG:3857` | `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs`                                                                 |         GPS         |\r\n| `EPSG:4326` | `+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs` | Google Maps, VWorld |\r\n\r\nWGS84 세계 측지인 EPSG:4326을 보자. 장, 단반경이 6378137로 동일한 완벽한 구 형태를 지향하고 있다. GPS 기준 좌표계답게 위경도 및 xy의 보정이 없다. `proj=merc`은 메르카토르 투영법을 사용했다는 의미다.\r\n\r\n여담으로, `EPSG:3857`은 투영법이 `longlat`으로 흔히 사용되는 평면 투영체인 `TM`, `UTM`과 달라 거리계산이 안 된다.\r\n\r\n즉, `EPSG:3857`로 표현된 두 점 사이의 거리를 계산해도, 이 값이 실제 거리를 나타내지 않는다.\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 국내 측지\r\n\r\n|  EPSG 코드  | proj 인자                                                                                               |   비고    |\r\n| :---------: | :------------------------------------------------------------------------------------------------------ | :-------: |\r\n| `EPSG:5179` | `+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m +no_defs` | NAVER Map |\r\n| `EPSG:5181` | `+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=GRS80 +units=m +no_defs`          | KAKAO Map |\r\n| `EPSG:5186` | `+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs`          | 중부원점  |\r\n\r\n이 밖에도 여러 좌표계가 있으므로, 필요할 때마다 찾아 사용하면 된다.\r\n\r\n[EPSG.io](https://epsg.io/)에서 다양한 좌표계의 정보를 확인할 수 있으니 참고할 것.","url":["2022-03-04-gis-guide-for-programmer-3","2022","03","04","gis-guide-for-programmer-3"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 2. GIS랑 인사하기","excerpt":"여러분들이 GIS를 처음 접했다면, 한 번 물어보고 싶다. 공간이란 뭘로 이루어져 있을까? 한 번 생각해보자. 다양한 답이 나왔을 것이라 생각한다. 무슨 답인지 내가 직접 못 듣는다는 게 좀 아쉽지만. 아마 대부분 추상적인 답이 나왔을 것이라 생각한다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-03T23:36:04+09:00","type":"posts","category":"GIS","tag":["GIS"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-03-gis-guide-for-programmer-2.md","content":"\r\n# GIS의 50가지 그림자\r\n\r\n여러분들이 GIS를 처음 접했다면, 한 번 물어보고 싶다. **공간이란 뭘로 이루어져 있을까?** 한 번 생각해보자.\r\n\r\n다양한 답이 나왔을 것이라 생각한다. 무슨 답인지 내가 직접 못 듣는다는 게 좀 아쉽지만. 아마 대부분 추상적인 답이 나왔을 것이라 생각한다.\r\n\r\n<br />\r\n\r\n어떤 사물을 파악할 때, <span class=\"red-500\">가장 효과적인 방법은 사물의 본질을 파악하는 것</span>이다. 철로 이루어진 어떤 물건이 있다고 해보자. 이걸 어디다 쓰는진 알 수 없지만, 단단한 게 필요할 때 요긴하게 쓸 수 있을 것이다. 필요하다면, 녹여서 다른 철제 물건으로 만들 수도 있다.\r\n\r\n반대로 이게 정확히 뭔지 모르고 \"어... 이거 그건데..? 그 뭐였더라...?\" 같은 추상적인 방법으로 접근한다면 그 사물이 뭔지 파악하는 건 매우 어렵다.\r\n\r\n공간을 구현해야한다는 관점에서 볼 때, 공간을 추상적인 개념으로 접근한다면 공간을 디지털화하기 매우 어려울 것이다. 때문에 우리는 공간을 다루기 이전에, 공간이 무엇으로 이루어지는지 그 개념을 명확하게 알 필요가 있다.\r\n\r\n공간은 **점(Point)**, **선(Line)**, **면(Polygon)**으로 이루어진다.\r\n\r\n* 공간에 점을 하나 찍으면 점이 생긴다.\r\n* 무수히 많은 점을 연달아 찍으면 선이 생긴다.\r\n* 무수히 많은 선을 연달아 그으면 면이 생긴다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156584563-367bd1e7-390d-4e3d-bef1-1ff3103b1a13.png)\r\n\r\n3차원 관점에서는 좀 더 복잡한 요소들이 작용하지만, 2차원은 단순한 점, 선, 면만으로 온전한 공간을 구현할 수 있다. 면은 선의 집합으로 표현할 수 있고, 선은 점의 집합으로 표현할 수 있으니, 공간은 점의 위치들로 표현이 가능하다. 이 글에서 궁극적으로 다룰 OpenLayers는 2차원 형태의 지도이므로, 이 정도로만 기억해도 당장엔 무리가 없다.\r\n\r\n공간이 무엇으로 이루어져 있는지 앞서 생각한 답과 점의 집합 중 어느게 더 구현하기 쉬울 지 비교해보자. 아마 점 $(x, y)$로 표현하는 것이 더 간단할 것이다.\r\n\r\n* 점: 하나의 $(x, y)$로 이루어진다.\r\n* 선: 다수의 $(x, y)$들로 이루어진다. 단, 가장 처음 $(x, y)$와 마지막 $(x, y)$가 달라야 한다.\r\n* 면: 다수의 $(x, y)$들로 이루어진다. 단, 가장 처음 $(x, y)$와 마지막 $(x, y)$가 서로 같아야 한다.\r\n\r\n선과 면의 차이에 주목하자. 선과 면 모두 무수히 많은 점들로 구성되어 있는데, 선과 면을 구분할 수 있는 가장 큰 차이는 가장 첫 좌표와 마지막 좌표가 동일한지 확인하는 것이다.\r\n\r\n<span class=\"blue-500\">첫 좌표와 마지막 좌표가 동일하면 온전히 하나의 면이 이루어진 것</span>으로 보며, 만약 육안으로 아무리 가까워보여도 <span class=\"blue-500\">첫 좌표와 마지막 좌표가 서로 일치하지 않으면 선</span>이다.\r\n\r\n3차원 공간은 GIS 지식에 대한 전공 수준의 이해 뿐만 아니라, 3D 프로그래밍에도 조예가 있어야하는 매우 복잡한 영역이니, 여기선 다루지 않는다. <del class=\"grey-500\">애초에 3차원 개발하려는 사람의 수준은 이 글을 아득히 뛰어넘는다.</del>\r\n\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n## 공간정보를 냉장고에 넣는 법\r\n\r\n디지털에서 공간을 표현하는 데 점의 위치를 이용한다는 것을 알았다. 그런데, 이 정보. 도대체 어떤 식으로 다뤄야될까?\r\n\r\n점의 경우 다행히 데이터의 표현 방식이 $(x, y)$로 명확하다. 하지만 선, 면으로 가면 얘기가 다소 복잡해진다. 우선 데이터의 양이 매우 많아진다. 데이터를 어떤 식으로 구분하는지에도 차이가 발생한다.\r\n\r\n* ${x_1}$,${y_1}$ ${x_2}$,${y_2}$ ... ${x_n}$,${y_n}$\r\n* ${x_1}$ ${y_1}$,${x_2}$ ${y_2}$, ... ${x_n}$ ${y_n}$\r\n\r\n위 처럼 같은 집합을 표현함에도 개발자에 따라 다양한 표현 방법이 나오게 된다. 특정 컬럼의 양이 기하급수적으로 늘어남은 물론이고, 문자열 연산도 수행해야한다. 더 큰 문제는 데이터 보관 주체마다 양식이 통일되지 않으므로, 호환성은 희망사항일 뿐이다.\r\n\r\n때문에 공간정보를 다루기 위한 여러 포맷이 고안됐다.\r\n\r\n<br />\r\n\r\n\r\n\r\n### SHP (Shape)\r\n\r\n가장 대표적인 공간정보 데이터 포맷이다. 미국의 ESRI에서 공간정보 데이터를 위해 고안한 형식이다. ESRI는 SHP 뿐만 아니라 QGIS라는 걸출한 GIS 오픈소스 툴을 만든 회사이기도 하다.\r\n\r\nSHP는 일반 데이터 컬럼은 데이터 형식에 맞게 저장하고(VARCHAR, NUMBER, DATE 등) 위치정보만 정해진 규격으로 저장한다. 해당 바이너리를 통해 데이터의 형식 및 좌표 데이터를 산출할 수 있다.\r\n\r\nSHP 파일은 기본적으로 아래 4가지 파일로 이루어져있다. shp를 제외한 나머지 파일은 shp를 보조하는 파일로, 없어도 shp를 다루는데 문제는 없다.\r\n\r\n* `shp`: 벡터 도형 데이터 (핵심)\r\n* `shx`: 벡터 도형 인덱스\r\n* `dbf`: 각 도형의 속성 데이터\r\n* `prj`: 좌표 정보\r\n\r\n공간정보 뿐만 아니라 다양한 부가 데이터를 쉽게 저장할 수 있으며, 구조 상 데이터베이스와 매우 유사하다는 이점이 있으며, 거의 대부분의 GIS 툴이 SHP를 지원한다.\r\n\r\n이러한 이점과 범용성에 힘입어 공간정보 데이터의 표준이 되었고, 대부분의 공간정보는 기본적으로 SHP로 제공된다고 봐도 무방하다. 즉, <span class=\"primary\">공간정보 데이터는 SHP 하나만 알고 있어도 된다.</span>\r\n\r\n<br />\r\n\r\n\r\n\r\n### GeoJSON\r\n\r\nJSON은 알겠는데, GeoJSON은 또 뭐야? 하겠지만, 우리가 아는 그 JSON 맞다. 단, 공간정보를 표현하기 위해 정해진 방식으로 구성된 JSON이다.\r\n\r\nGeoJSON의 양식은 아래와 같다.\r\n\r\nJavaScript와 친숙한 JSON을 차용함으로써, HTTP 통신으로 공간정보를 쉽게 호출하는 데 쓰인다. 이러한 특성 때문에, 공간정보 데이터를 보관한다는 목적 보다는 HTTP 데이터 통신 시 주로 사용한다.\r\n\r\n물론 GeoJSON도 공간정보를 보관하는데 무리가 없으며, 인지도 있는 GIS 툴은 GeoJSON을 지원한다. 또한 SHP와 달리 데이터의 CRUD에 별다른 툴이 필요하지 않다는 장점이 있다.\r\n\r\n\r\n\r\n### 기타\r\n\r\n그 밖에도 CSV, Excel, txt 등 여러 텍스트 기반 파일로 다루기도 한다. 단, 이러한 형식들은 공간정보를 저장하는데 적합하지 않아 공간 데이터의 추출 결과물이나, 점 데이터에 한해 제한적으로 사용하기도 한다.\r\n\r\n공간정보를 다루는 방법에 있어서 꼭 SHP나 GeoJSON으로만 한정되지 않는다는 것만 참고하자.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 둘러보기\r\n\r\n* [도로명주소 건물 데이터](http://data.nsdi.go.kr/dataset/14783) (로그인 필요)\r\n\r\n위 URL은 도로명주소의 건물 데이터를 제공받을 수 있는 URL이다. 건물 뿐만 아니라 시도, 시군구, 건물 진출입로, 도로 등 다양한 데이터를 제공하고 있다. 대부분 SHP로 제공한다는 점에 주목하자.","url":["2022-03-03-gis-guide-for-programmer-2","2022","03","03","gis-guide-for-programmer-2"]},{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 1. 머릿말","excerpt":"공간정보, 지리쪽에 업이 있거나 관심있는 사람이 아니라면, GIS라는 단어는 다소 생소한 단어다. 혹자는 GIS가 아니라 GPS 아니냐고 반문하기도 한다. GPS(Global Positioning System)는 3개 이상의 위성 신호를 통해 수신기의 위치를 계산할 수 있는 기법이다. GPS라 하면 흔히 네비게이션을 연상하기 쉽지만, 알게 모르게 GPS는 일상생활에 깊게 녹아들어 있다. 네비게이션, 스마트폰 지도, 배달 플랫폼의 라이더 위치 추적, 드론 군집비행, 군사학 등. GPS는 다양한 영역에 스며들어 그 이로움을 전해준다. 우리는 GPS를 통해, 공간정보라는 디지털 시대에서 공간을 디지털화한다는 것이 어떤 능력을 발휘하는 지 엿볼 수 있다. GIS(Global Information System)는 GPS와 같이 공간정보를 다루는 모든 기술에 대한 포괄적인 기술을 의미한다. GPS 뿐만 아니라, 지도, 좌표계와 같이 공간과 엮이는 모든 기술은 GIS라는 커다란 범주로 묶을 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-03T23:05:35+09:00","type":"posts","category":"GIS","tag":["GIS"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-03-gis-guide-for-programmer-1.md","content":"\r\n# 개요\r\n\r\n공간정보, 지리쪽에 업이 있거나 관심있는 사람이 아니라면, GIS라는 단어는 다소 생소한 단어다. 혹자는 GIS가 아니라 GPS 아니냐고 반문하기도 한다.\r\n\r\nGPS(Global Positioning System)는 3개 이상의 위성 신호를 통해 수신기의 위치를 계산할 수 있는 기법이다. GPS라 하면 흔히 네비게이션을 연상하기 쉽지만, 알게 모르게 GPS는 일상생활에 깊게 녹아들어 있다. 네비게이션, 스마트폰 지도, 배달 플랫폼의 라이더 위치 추적, 드론 군집비행, 군사학 등. GPS는 다양한 영역에 스며들어 그 이로움을 전해준다. 우리는 GPS를 통해, 공간정보라는 디지털 시대에서 공간을 디지털화한다는 것이 어떤 능력을 발휘하는 지 엿볼 수 있다.\r\n\r\nGIS(Global Information System)는 GPS와 같이 공간정보를 다루는 모든 기술에 대한 포괄적인 기술을 의미한다. GPS 뿐만 아니라, 지도, 좌표계와 같이 공간과 엮이는 모든 기술은 GIS라는 커다란 범주로 묶을 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156580872-dfd08787-3416-4595-b224-a12156075ffb.png)\r\n\r\n컴퓨터의 발전이래, 인류는 현실세계의 모든 것을 디지털화하고 있다. 이미 인류는 보고 듣는 모든 것들을 디지털화했다. 찰나의 순간, 기억을 저장한다는 욕구 이후로, 이젠 이러한 자료를 관리하고 제공하는 자들이 막대한 돈을 벌어들이고 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/156581103-fd79ade7-ab3e-424e-852c-8bfd3d4382b7.png)\r\n\r\n시청각의 디지털화는 시청각을 마음대로 다룰 수 있다는 뜻이나 다름없다. 정적 데이터인 사진의 합성은 이젠 애들 장난 수준이다. 발전된 영상 편집 기술은 물론 논란의 중심인 딥 페이크 기술을 보고 있자면 인식의 개념을 부정당하는 느낌이 들기도 한다.\r\n\r\n<br />\r\n<p align=\"center\" class=\"large grey-400\"><i>고도로 발달한 기술은 마법과 구별할 수 없다.</i></p>\r\n<br />\r\n\r\n동영상, 사진이 시청각을 다룬다면, GIS는 현실에서의 공간을 디지털화하고, 이를 다룰 수 있는 매우 멋진 기술이다. 지금은 지도나 위치정보 같은 데이터류를 다루는 것이 일반적이지만, 현재 각광받고 있는 메타버스 기술, 가상현실과 같이 '공간'이 주가 되는 기술에서 GIS는 그 핵심이 될 것이다.\r\n\r\n시청각 디지털이 시청각에 마법을 일으킨다면, GIS는 디지털 속 공간이라는 개념에 마법을 부릴 수 있다 하겠다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n...라고 말은 거창하게 적었지만 내가 무슨 GIS의 대가도 아니고, 그냥 GIS 살짝 담궈본 일개 프로그래머일 뿐이다.\r\n\r\n이직한 회사에서 GIS에 대한 소요가 좀 있는 거 같길래, 이전 회사에서 배웠던 기술도 좀 되살려볼 겸, 토이 프로젝트 식으로 GIS 서비스를 만들며 관련 기술에 대해 기록해볼까 한다.\r\n\r\n사실 한국에서의 GIS는 다른 기술에 비해 찬밥 신세를 면치 못 한다. 이런 원천기술류가 으레 그렇듯이, 깊게 들어가면 측량, 토목 쪽으로 빠져버리니 GIS라는 분야에 뜻을 가진 사람이 아니라면 깊게 들어가기도 애매하다. 당장 이 글을 읽는 당신 조차 그렇다. 당신은 개발자이기를 원하지, 절대 GIS 연구자이고 싶지 않을 테니.\r\n\r\n<br />\r\n\r\n사람들은 여행을 떠날 때 GIS로 이루어진 지도라는 걸 보고 여행하겠지만, 막상 GIS를 여행하려는 사람들은 한국에서 볼 게 적은 것이 현실이다. 남들은 여행길이 고생길이라고 할 때, GIS 여행자들은 여행 준비부터가 고생인 셈이다.\r\n\r\n<br />\r\n<p align=\"center\" class=\"large grey-400\"><i>우리 모두는 한 때 초심자였다.</i></p>\r\n<br />\r\n\r\n\"수학을 잘하고 싶어요!\"라고 말하는 초등학생에게 다짜고짜 수학의 정석을 풀라고 할 수 없다.\r\n\r\n\"프로그래밍 잘하고 싶어요!\"라고 말하는 국비 3일차 개발자에게 \"음 그래? 그럼 프로그래머스 5단계 풀어\"라고 할 수 없다.\r\n\r\n모든 것엔 입문이 있고, 순서라는 게 존재한다. 아이의 생각은 아이의 눈높이에서 봐야 가장 잘 이해할 수 있다.\r\n\r\n내 비록 꼬꼬마 프로그래머지만, 내 경험과 글, 시야를 통해 이제 막 OpenLayers 여행을 시작한 개발자들에게 작은 안내서라도 되어주길 바란다.\r\n\r\n<br />\r\n<br />\r\n<br />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 부록\r\n\r\n## 준비물\r\n\r\n* OpenLayers 6\r\n* React\r\n* GeoServer\r\n\r\n## 우리는 커서...\r\n\r\n* 프로그래밍에서 GIS를 어떤 식으로 다루는 지 알아봐요!\r\n* GeoServer로 GIS 서비스 환경을 만들어요!\r\n* React + OpenLayers 6로 GIS 서비스를 제공해요!\r\n  * OpenLayers 6는 ESNext를 지향하므로, React가 적합하답니다.","url":["2022-03-03-gis-guide-for-programmer-1","2022","03","03","gis-guide-for-programmer-1"]}],"data":{"header":{"title":"OpenLayers를 여행하는 개발자를 위한 안내서 - 5. OpenLayers","excerpt":"OpenLayers는 웹 브라우저에서 지도나 GIS 서비스를 제공하기 위한 JavaScript Library다. GIS 라이브러리 중 진입 장벽은 가장 높지만, 그에 상응하는 강력한 기능을 제공한다.","coverImage":"https://user-images.githubusercontent.com/50317129/156607880-c5abad92-1991-4c01-b85f-7153bf89cb64.png","date":"2022-03-05T03:39:25+09:00","type":"posts","category":"GIS","tag":["GIS","OpenLayers"],"group":"OpenLayers를 여행하는 개발자를 위한 안내서","comment":true,"publish":true},"name":"2022-03-05-gis-guide-for-programmer-5.md","content":"<h1 id=\"OpenLayers\">OpenLayers <a href=\"#OpenLayers\">🔗</a></h1><p>OpenLayers는 웹 브라우저에서 지도나 GIS 서비스를 제공하기 위한 JavaScript Library다. GIS 라이브러리 중 진입 장벽은 가장 높지만, 그에 상응하는 강력한 기능을 제공한다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>BASH</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-bash\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token comment\" data-tag=\"new\"># OpenLayers 설치</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1><span class=\"token function\">yarn</span> <span class=\"token function\">add</span> ol</td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>OpenLayers는 위와 같이 설치할 수 있다.</p>\n<br />\n<br />\n\n\n\n\n\n<h2 id=\"OpenLayers의-Map 객체 구조\">OpenLayers의 Map 객체 구조 <a href=\"#OpenLayers의-Map 객체 구조\">🔗</a></h2><p>OpenLayers의 핵심이 되는 <code class=\"inline-code\">Map</code> 객체엔 다양한 객체가 있다. 이 객체들이 서로 모이고 엮여, 하나의 상호작용 가능한 맵이 구현된다.</p>\n<p>하나의 맵에 많은 객체들이 연관된 만큼, 각각의 객체들이 무엇을 의미하는지 파악하지 못하면 원하는 걸 구현하기 위해 어떤걸 사용해야하는지 모르는 사태가 벌어진다. 불행히 관련 키워드조차 모른다면, 관련 정보를 찾는 것조차 어려워진다. 설상가상으로 GIS라는 영역은 국내에서 자료의 양이 그리 많지 않다.</p>\n<p>이런 시간낭비를 미연에 방지하기 위해, OpenLayers의 각 객체가 가지는 특성과, 무엇을 포함하는지와 같은 구조를 이해하면 구현이 좀 더 수월해질 것이다.</p>\n<p>\n\t\t<a href=\"https://user-images.githubusercontent.com/50317129/156811772-4fd36475-dcc9-41a5-a3ab-c7bcef24e8da.png\" target=\"_blank\" data-title=\"null\">\n\t\t\t<img src=\"https://user-images.githubusercontent.com/50317129/156811772-4fd36475-dcc9-41a5-a3ab-c7bcef24e8da.png\" alt=\"image\" />\n\t\t</a>\n\t\t</p>\n<p>위 그림은 OpenLayers의 주요 객체들을 도식화한 것이다. (그림의 객체가 OpenLayers의 전부는 아님)</p>\n<ul>\n<li><code class=\"inline-code\">Feature</code>: 점, 선, 면과 같은 요소 (벡터 레이어 한정)</li>\n<li><code class=\"inline-code\">Source</code>: 레이이의 데이터 원천. Feature의 모음과 같다. (SHP, GeoJSON 등)</li>\n<li><code class=\"inline-code\">Layer</code>: 데이터 원천을 토대로 정의한 데이터셋 (벡터, 이미지)</li>\n<li><code class=\"inline-code\">View</code>: 사용자가 현재 맵을 바라보는 방식의 정보</li>\n<li><code class=\"inline-code\">Interaction</code>: 맵의 상호작용 요소 (Zoom in, out 버튼 등)</li>\n<li><code class=\"inline-code\">Overlay</code>: 맵에 표시할 요소</li>\n</ul>\n<p>이 외에도 여러 객체들이 모여 하나의 맵을 구성하게 되고, 이 맵이 사용자에게 보여지게 된다.</p>\n<p>이를 잘 알아두면, 내가 필요한 정보에 따라 어떤 객체에 접근해야하는지 설계할 수 있다. 예를 들어, 각 <code class=\"inline-code\">Feature</code>에 접근하고 싶다면, <code class=\"inline-code\">Map</code>의 <code class=\"inline-code\">Layer</code> 객체에 접근해야한다. 또한, 사용자가 바라보는 위치의 중심, 영역이 필요하다면 <code class=\"inline-code\">View</code> 객체에 접근해야한다. 버튼을 만들고 싶다? <code class=\"inline-code\">Interaction</code>에 길이 있을 것이다.</p>\n<p>그 밖의 다양한 정보들은 <a href=\"https://openlayers.org/\" target=\"_blank\">OpenLayers Docs</a>를 참고하자. 공식문서가 엄청 자세하고 친절한 편은 아니니 참고할 것. 아 물론, 당연히 영어다.</p>\n","url":["2022-03-05-gis-guide-for-programmer-5","2022","03","05","gis-guide-for-programmer-5"],"toc":[{"text":"OpenLayers","tag":"OpenLayers","depth":1},{"text":"OpenLayers의 Map 객체 구조","tag":"OpenLayers의-Map 객체 구조","depth":2}]},"hash":"68edc3bd614"},"__N_SSG":true}