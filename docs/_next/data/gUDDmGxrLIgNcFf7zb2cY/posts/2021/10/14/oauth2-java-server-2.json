{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 1. OAuth2.0이란?","excerpt":"사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다. 이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다. 이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T00:56:31","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-1.md","content":"\r\n# 개요\r\n\r\n사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137170074-d678c0e1-d30a-4d38-91e5-543344e18ec3.png)\r\n\r\n이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다.\r\n\r\n이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.\r\n\r\n# OAuth\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137171256-3ca820ec-1435-4103-bc34-9c922832886c.png)\r\n\r\nOAuth는 Open Authentication의 약자로, 인증을 위한 표준 프로토콜이다.\r\n\r\n이전의 인증 방식은 사이트 혹은 애플리케이션에 직접 회원가입을 수행하여 내 정보를 제공하고, 비밀번호를 통해 인증하는 비밀번호 인증 방식을 취한다. 물론 이 비밀번호 인증 방식은 인터넷의 초창기부터 지금까지 사용하는 기법이지만, 그렇다고 문제가 아주 없는 것은 아니였다.\r\n\r\n* 서비스마다 운영되는 중구난방적인 인증 시스템\r\n* 사이트의 신뢰성 문제\r\n* 인터넷을 사용할수록 과적되는 인증 정보\r\n\r\nOAuth 이전에는 이렇다할 인증 표준이 존재하지 않았다. 표준이 없다보니 인증 시스템은 서비스마다 개성이 넘처흘렀다. 사이트마다 요구하는 정보, 방식이 천차만별로 다르니 사용자 입장에서는 매우 혼란스러울 것이다.\r\n\r\n그래도 이 점은 나름 사이트를 구분할 수 있는 일종의 척도(?)가 되기도 한다만, 더 큰 문제는 해당 사이트를 신뢰할만한 지표가 전혀 없다는 것이다. 내 정보를 왜 가져가는지, 어떻게 보관하는지 알 길이 없는 사용자들은 울며 겨자먹기로 서비스에게 내 정보를 제공하게 된다.\r\n\r\n이런 사이트들을 조금만 돌아다니면서 상호작용을 하다보면, 나도 모르는 새에 계정정보가 쌓여있을 것이다. 인증의 주체가 되는 \"나\"는 하나인데, 인증 표준의 부재로 인해 각 서비스마다 나 자신을 인증하기 위한 여러 방법을 소유하게되는 것이다.\r\n\r\n<br />\r\n\r\n이러한 비효율성을 타파하기 위해 Twitter 주도하에 인증 표준이 설립되었고, 이 것이 OAuth의 시초다. OAuth 라는 표준 프로토콜이 정의됨에 따라 각 서비스는 공통된 인터페이스로 사용자에게 인증을 요구할 수 있고, 사용자 역시 익숙하고 신뢰성있는 대형 플랫폼에 인증 정보를 입력하기 때문에 보안적인 측면은 물론, 절차 또한 간소화되는 이점을 가지게 된다.\r\n\r\nOAuth는 1.0을 시작으로, 1.0에 세션 고정 공격이라는 보안 취약점이 발견됨에 따라 현재는 2.0을 사용하고 있다.\r\n\r\n> <b class=\"orange-400\">OAuth1.0의 몰락</b>  \r\n> OAuth1.0은 <span class=\"primary\">세션 고정 공격</span>이라는 보안 취약점을 가지고 있다. 이를 해결하기 위해 OAuth2.0에서는 이러한 문제들이 해결되었으며, OAuth2.0은 OAuth1.0을 완전히 대체한다.\r\n\r\nOAuth2.0은 그 방식에 따라 4가지 방식으로 구분한다.\r\n\r\n이를 설명하기 앞서 OAuth에서 사용하는 키워드에 대해 알아보자\r\n\r\n|      키워드      |                             의미                             |\r\n| :--------------: | :----------------------------------------------------------: |\r\n|       User       |                            사용자                            |\r\n|     Consumer     |               OAuth를 제공하는 서비스 (웹 등)                |\r\n| Service Provider |                OAuth 서비스 제공자 (NAVER 등)                |\r\n|   Access Token   | Consumer가 Service Provider의 자원에 접근하기 위한 인증 코드 |\r\n|  Refresh Token   |             Access Token을 재발급하기 위한 코드              |\r\n\r\n아마 대부분 User의 범주에 속해있을 것이다. 여기서 궁극적으로 구축할 서비스는 Consumer가 된다.\r\n\r\n간혹 Service Provider는 인증 서버와 자원 서버로 분리해서 다루기도 한다.\r\n\r\nNAVER, Google과 같은 플랫폼은 Service Provider가 되며, 인증 절차를 통해 Access Token과 Refresh Token을 전달받게 된다.\r\n\r\n# OAuth Workflow\r\n\r\nOAuth2.0은 구현 방식에 따라 4가지 방식으로 구분된다.\r\n\r\n## 인가 코드 승인 (Authorization Code Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179813-de61fd8a-bbe6-4824-afdf-3652cde164bc.png)\r\n\r\n* 사용자가 Service Provider에 직접 인증을 수행\r\n* 인증에 성공하면 Consumer Frontend는 인가 코드를 전달받음\r\n* Consumer는 인가 코드를 Service Provider에 전달하여 Access, Refresh Token을 반환받음\r\n* Token 반환 이전에 인가 코드를 받는 과정이 추가되어 높은 수준의 보안을 제공함\r\n* Consumer의 Backend에서 Token 교환이 일어나므로 중간에 이를 탈취하기 어려움\r\n* 웹에서 사용되는 가장 보편적인 인증 형태로, 이 프로젝트 또한 인가 코드 승인 형태가 적용됨\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=code\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                내용                 |\r\n| :-----------: | :----------------------------: | :---------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> |  응답 타입으로, 값은 `code`로 고정  |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL            |\r\n|     state     |               N                |      임의로 생성한 고유 상태값      |\r\n|     scope     |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\ncode=dfnY865gHjUbnknt57yGV\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n```\r\n\r\n| 구분  |            내용             |\r\n| :---: | :-------------------------: |\r\n| code  |          인가 코드          |\r\n| state | 요청에서 전달한 고유 상태값 |\r\n\r\n`state`는 Consumer Backend에서 임의로 생성한 상태값으로, 통상 UUID를 하나 생성하여 사용한다.\r\n\r\n`code`와 입력했던 `state`가 반환된다. `code`를 통해 Service Provider에 요청하여 Access Token으로 교환할 수 있다.\r\n\r\n## 암시적 승인 (Implicit Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179833-fe688388-0d29-47c0-b4db-c4a42b26dccd.png)\r\n\r\n* 인가 코드 승인과 달리, 인증 성공 시 Consumer는 Token을 직접 전달받음\r\n* 각 플랫폼에서 제공되는 JavaScript SDK를 사용하여 구현\r\n* 인가 코드 승인에 비해 서버가 필요하지 않아 구현이 간단함\r\n* Token이 GET 방식으로 URL 파라미터에 담겨 전달되므로 보안에 취약하다.\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=token\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                 내용                 |\r\n| :-----------: | :----------------------------: | :----------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `token`으로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY  |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL             |\r\n|     state     |               N                |      임의로 생성한 고유 상태값       |\r\n|     scope     |               N                |              요청 권한               |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\n#access_token=kr40FkgksmGS92lffkGls\r\n&token_type=Bearer\r\n&expires_in=3600\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    state     |      요청에서 전달한 고유 상태값       |\r\n\r\n인가 코드 승인과 달리, 요청에 Access Token이 포함되어 전달된다.\r\n\r\n> <b class=\"orange-400\">파라미터가 왜 </b>`#`<b class=\"orange-400\">으로 시작하지?</b>  \r\n> `#`은 URI Fragment라는 식별자다. 해당 식별자는 URL 접근 시 서버에 전달되지 않기 때문에 보안적인 측면에서 이점을 가져가기 위한 조치다.\r\n\r\n## 리소스 소유자 암호 자격 승인 (Resource Owner Password Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179866-29962644-c0a7-42f8-a397-7b3b1c361082.png)\r\n\r\n* Service Provider에 ID, PW를 전달하여 Token을 전달받음\r\n* 보안 구조가 비밀번호 기반의 인증 뿐이므로 이를 구현하는 Consumer는 신뢰성이 매우 높아야 함\r\n\r\n``` input\r\nPOST /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=password\r\n&client_id=asj2y93bdjen3\r\n&username=username123\r\n&password=password123\r\n&scope=email,profile\r\n```\r\n\r\n|    구분    |           필수 여부            |                내용                 |\r\n| :--------: | :----------------------------: | :---------------------------------: |\r\n| grant_type | <span class=\"red-400\">Y</span> |  승인 타입으로, `password`로 고정   |\r\n| client_id  | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n|  username  | <span class=\"red-400\">Y</span> |               아이디                |\r\n|  password  | <span class=\"red-400\">Y</span> |              비밀번호               |\r\n|   scope    |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n    \"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n## 클라이언트 자격 승인 (Client Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179894-94e8f974-27cd-44b1-9c36-5e1d3dc69377.png)\r\n\r\n* 사용자가 Access Token을 외부 저장소에서 받아 인증하는 형식\r\n* 클라이언트 자체가 인증 수단이므로 절차가 매우 간소함\r\n* 통상 자기 자신의 정보만을 호출함\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=client_credentials\r\n&client_id=asj2y93bdjen3\r\n&client_secret=https://oauth2.example.com/callback\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                      내용                       |\r\n| :-----------: | :----------------------------: | :---------------------------------------------: |\r\n|  grant_type   | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `client_credentials`로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> |       Service Provider에서 제공한 API KEY       |\r\n| client_secret | <span class=\"red-400\">Y</span> |   Service Provider에서 제공한 API Secret KEY    |\r\n|     scope     |               N                |                    요청 권한                    |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n\t\"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n# 정리\r\n\r\n* OAuth2.0은 인증을 위한 표준 프로토콜으로, OAuth 프로토콜을 준수하는 서비스는 기본적으로 공통된 API를 사용해서 인증을 수행할 수 있다.\r\n* OAuth 프로토콜을 통해 인증 절차는 간소화하고, 보안 수준은 강화할 수 있다.\r\n* OAuth의 방식은 4가지로 구분되며, 보편적으로 인가 코드 승인 방식을 사용한다.\r\n* 암시적 승인은 Serverless 서비스나 앱에서 주로 사용된다.\r\n* 나머지 방식은 특수한 환경에서 사용된다.\r\n\r\n다음 장에서는 구축할 시스템의 구성에 대해 다룬다.\r\n\r\n# 참고\r\n\r\n* [IT위키 - OAuth](https://itwiki.kr/w/OAuth)\r\n* [Microsoft OAuth](https://docs.microsoft.com/ko-kr/azure/active-directory/develop/active-directory-v2-protocols)\r\n* [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)","url":["2021-10-14-oauth2-java-server-1","2021","10","14","oauth2-java-server-1"]},"next":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 3. scribeJAVA로 OAuth2.0 인증 모듈 구현하기","excerpt":"OAuth 라이브러리인 scribeJAVA를 통해 인증 모듈을 구현해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-20T01:26:40","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","Jersey"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-20-oauth2-java-server-3.md","content":"\r\n# 개요\r\n\r\nOAuth 라이브러리인 scribeJAVA를 통해 인증 모듈을 구현해보자.\r\n\r\n\r\n\r\n\r\n\r\n# OAuth 인증 모듈 구현하기\r\n\r\n이전 장에서도 언급했듯이, OAuth 인증 모듈은 그 공통된 특성으로 인해 추상 객체가 적합하다.\r\n\r\nscribeJAVA 모듈을 사용하여 추상 객체를 구현한다.\r\n\r\n\r\n\r\n## scribeJAVA 적용하기\r\n\r\n프로젝트에 scribeJAVA를 적용해보자.\r\n\r\n``` groovy\r\nimplementation group: 'com.github.scribejava', name: 'scribejava-apis', version: '8.3.1'\r\n```\r\n\r\n`build.gradle`의 dependencies에 위 의존성을 추가하는 것으로 scribeJAVA를 적용할 수 있다.\r\n\r\n\r\n\r\n## scribeJAVA 사용하기\r\n\r\n본격적으로 scribeJAVA를 사용해보자.\r\n\r\nscribeJAVA는 `OAuth20Service`라는 객체를 중심으로 동작한다. `OAuth20Service` 객체를 통해 아래의 로직을 수행할 수 있다.\r\n\r\n* 플랫폼 로그인 URL 생성\r\n* 인가 코드를 Access, Refresh Token으로 교환\r\n* Refresh Token을 통해 Access Token 갱신\r\n* 기타 OAuth 관련 요청 생성\r\n\r\n즉, OAuth 인증에 있어서 핵심이 되는 동작은 모두 이 `OAuth20Service` 객체를 중심으로 이루어진다.\r\n\r\n\r\n### OAuth20Service 객체 생성하기\r\n\r\n`OAuth20Service` 객체를 생성한다. 필요한 요소는 아래와 같다.\r\n\r\n|      구분      |     필수 여부     |           내용           |\r\n| :------------: | :---------------: | :----------------------: |\r\n|    API Key     |         Y         |          API 키          |\r\n| API Secret Key |         Y         |      API 시크릿 키       |\r\n|  Callback URL  |         Y         | 로그인 결과를 반환할 URL |\r\n|     Scope      | N (일부 플랫폼 Y) |           권한           |\r\n\r\nAPI Key, API Secret Key, Callback URL은 기본적으로 반드시 필요하며, 몇몇 플랫폼의 경우 Scope도 필수 사양으로 지정하는 경우가 있다. 이 프로젝트에 적용할 플랫폼들 중 Google이 그렇다. 구글은 후술할 플랫폼 로그인 URL 생성 시 Scope를 지정하지 않으면 오류를 출력한다.\r\n\r\nAPI Key, API Secret Key는 각 플랫폼에 OAuth 서비스 등록 시 부여해주며, Callback URL은 본인이 직접 정해서 입력하면 된다. 등록되지 않은 Callback URL로 로그인을 수행하면 오류가 출력된다. Callback URL은 여러개를 지정할 수 있다.\r\n\r\n각 플랫폼 별 OAuth 서비스를 등록하는 방법은 추후에 다루고, 일단 이런 부가적인 부분들은 준비가 됐다고 가정한다.\r\n\r\n``` java\r\nOAuth20Service service = new ServiceBuilder(\"{API_KEY}\").apiSecret(\"{SECRET_KEY}\").callback(\"{CALLBACK_URL}\").build(this);\r\n```\r\n\r\n이와 같이 생성할 수 있다. `build(this)`에서 `this`는 `DefaultApi20` 객체다. 아래는 `OAuth20Service` 객체의 메서드와 그 기능들이다.\r\n\r\n|         구분          |             내용              |\r\n| :-------------------: | :---------------------------: |\r\n| `getAuthorizationUrl` | 플랫폼 로그인 URL 반환 메서드 |\r\n|   `getAccessToken`    | OAuth2AccessToken 반환 메서드 |\r\n|     `signRequest`     |    OAuth 요청 등록 메서드     |\r\n|       `execute`       |    등록된 요청 수행 메서드    |\r\n\r\n이 프로젝트에선 위 4가지 용도만 알아도 무방하다.\r\n\r\n\r\n\r\n\r\n## AuthModule 생성하기\r\n\r\n이제 본격적으로 모듈 객체를 구현해보자. 인증 모듈은 반드시 `DefaultApi20`을 상속받아 구현해야한다.\r\n\r\n``` java\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n\t// 구현 예정\r\n}\r\n```\r\n\r\n`DefaultApi20` 추상 객체는 두 개의 추상 메서드를 가지고 있다. 즉, 이를 상속하는 `AuthModule`는 이 두 메서드를 구현해야할 책임이 있다.\r\n\r\n* `getAccessTokenEndpoint` - 접근 토큰 요청 URL 반환 메서드\r\n* `getAuthorizationBaseUrl` - 인증 URL 반환 메서드\r\n\r\n하지만 `AuthModule` 역시 추상 객체이므로, 이를 상속받아 사용할 하위 플랫폼 인증 모듈에게 이 책임을 위임할 수 있다. 즉, `DefaultApi20`의 추상 메서드는 `AuthModule`에서 구현하지 않고 이를 상속하는 하위 플랫폼 인증 모듈에서 구현할 것이다.\r\n\r\n인증 모듈 추상 객체는 위와 같은 형태를 가진다. NAVER, Google 등 플랫폼별 인증 모듈은 위 `AuthModule`을 상속받아 사용할 것이다. 인증 모듈의 핵심 동작은 대부분 `OAuth20Service` 객체로부터 이루어지니, `AuthModule`을 상속할 때 반드시 관련 객체를 받도록 명시하는 것이 좋아보인다.\r\n\r\n``` java\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n    protected OAuth20Service service;\r\n\t\r\n\t@Getter\r\n\tprotected String unique;\r\n\r\n    protected AuthModule(ServiceBuilderOAuth20 serviceBuilder, String unique)\r\n\t{\r\n\t\tservice = serviceBuilder.build(this);\r\n\t\t\r\n\t\tthis.unique = unique;\r\n\t}\r\n}\r\n```\r\n\r\n|      구분      |       데이터 형식       |                                  내용                                   |\r\n| :------------: | :---------------------: | :---------------------------------------------------------------------: |\r\n| serviceBuilder | `ServiceBuilderOAuth20` |                      `OAuth20Service` 객체의 빌더                       |\r\n|     unique     |        `String`         | 인증 모듈의 고유값. 플랫폼의 소문자 표기와 동일 (ex. NAVER -> naver 등) |\r\n\r\n생성자와 멤버 변수를 위와 같이 지정한다. 전부 `protected` 접근 제어자를 가지므로, `AuthModule`을 상속받은 객체에서만 생성자를 사용할 수 있으며, `service`, `unique` 파라미터 역시 마찬가지다.\r\n\r\n`ServiceBuilderOAuth20`를 인수로 할당받아 생성자에서 `OAuth20Service`로 빌드하여 멤버 변수 `service`에 할당한다. `AuthModule` 상속받은 객체의 어느 곳에서든 `service`와 `unique`에 접근할 수 있다.\r\n\r\n이 모듈에 기본적인 로직을 작성하고, 플랫폼마다 구현이 모두 다를 경우, 추상 메서드를 선언하여 이를 상속받는 객체가 이를 직접 구현하도록 위임한다.\r\n\r\n\r\n### 플랫폼 로그인 URL 반환 메서드\r\n\r\nscribeJAVA를 통해 플랫폼 로그인 URL 반환 메서드를 구현해보자. 예를 들어, 네이버 아이디로 로그인 버튼을 클릭하면 네이버 로그인 창이 뜰 것이다. 이 과정은 앞선 예시와 같은 플랫폼 로그인 창의 URL을 생성하는 것이다.\r\n\r\n`service`의 `getAuthorizationUrl` 메서드를 사용하는 것만으로 간단히 구현할 수 있다. `ServiceBuilderOAuth20`에 입력했던 API Key, Secret Key, Callback URL을 토대로 플랫폼 인증 URL을 생성하여 반환한다.\r\n\r\n``` java\r\npublic String getAuthorizationUrl(String state)\r\n{\r\n\treturn service.getAuthorizationUrl(state);\r\n}\r\n```\r\n\r\n`getAuthorizationBaseUrl`의 반환 URL을 기준으로 생성한다.\r\n\r\n인수인 `state`는 고유 상태값으로, 서버에서 임의의 UUID를 하나 생성해서 사용한다. 이는 보안을 위한 세션 체크용으로 사용하는 값이다.\r\n\r\n\r\n### OAuth2AccessToken 반환 메서드\r\n\r\n이번엔 `OAuth2AccessToken` 객체를 반환하는 메서드를 구현해보자. `OAuth2AccessToken`는 Access, Refresh Token. 토큰 종류, 유효시간을 가지는 scribeJAVA의 객체다.\r\n\r\n``` java\r\npublic OAuth2AccessToken getAccessToken(String code) throws IOException, ExecutionException, InterruptedException\r\n{\r\n    return service.getAccessToken(code);\r\n}\r\n```\r\n\r\n마찬가지로 `service`의 `getAccessToken` 메서드를 사용하여 간단히 구현할 수 있다. 인수인 `code`를 Service Provider에 전달하면, Access, Refresh Token을 제공한다.\r\n\r\n\r\n### Access Token 갱신 메서드\r\n\r\nAccess Token은 보안을 위해 만료시간이 굉장히 짧거나 세션 만료 시 같이 만료되는 것이 보통이다. 이 경우 원래대로라면 다시 인증을 받아야하고, 경우에 따라 사용자에게 플랫폼 로그인 수행을 다시 요구할 수도 있다.\r\n\r\n대부분의 OAuth 플랫폼은 인증 시 Access Token과 함께 Refresh Token을 같이 제공한다.\r\n\r\n|     구분      |   만료시간    | 인증 가능 여부 |                                               내용                                               |\r\n| :-----------: | :-----------: | :------------: | :----------------------------------------------------------------------------------------------: |\r\n| Access Token  | 짧거나 일시적 |      가능      |   인증을 담당하는 토큰. Access Token 존재 자체만으로 사용자가 인증 정보를 제공한다고 가정한다.   |\r\n| Refresh Token | 길거나 영구적 |     불가능     | Access Token을 재발급하는 토큰. Refresh Token 자체만으론 재발급 외의 유의미한 작업이 불가능하다. |\r\n\r\n두 토큰의 차이는 위와 같다.\r\n\r\nscribeJAVA에서 Refresh Token으로 Access Token을 재발급 받아보자.\r\n\r\n``` java\r\npublic OAuth2AccessToken getRefreshAccessToken(String refresh) throws IOException\r\n{\r\n\tHashMap<String, String> params = new HashMap<>();\r\n\tparams.put(\"client_id\", service.getApiKey());\r\n\tparams.put(\"client_secret\", service.getApiSecret());\r\n\tparams.put(\"refresh_token\", refresh);\r\n\t\r\n\tStringBuilder builder = new StringBuilder();\r\n\t\r\n\tfor (Map.Entry<String, String> param : params.entrySet())\r\n\t{\r\n\t\tbuilder.append(\"&\").append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8)).append(\"=\").append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\r\n\t}\r\n\t\r\n\tbyte[] paramBytes = builder.toString().getBytes(StandardCharsets.UTF_8);\r\n\t\r\n\tURL url = new URL(getRefreshTokenEndpoint());\r\n\t\r\n\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\tconnection.setRequestMethod(\"POST\");\r\n\tconnection.setDoOutput(true);\r\n\tconnection.getOutputStream().write(paramBytes);\r\n\t\r\n\tBufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\r\n\t\r\n\tStringBuilder responseBuilder = new StringBuilder();\r\n\tString temp;\r\n\t\r\n\twhile ((temp = reader.readLine()) != null)\r\n\t{\r\n\t\tresponseBuilder.append(temp);\r\n\t}\r\n\t\r\n\treader.close();\r\n\t\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tJsonNode node = mapper.readTree(responseBuilder.toString());\r\n\t\r\n\tString access_token = node.get(\"access_token\").textValue();\r\n\tString token_type = node.get(\"token_type\").textValue();\r\n\tint expires_in = node.get(\"expires_in\").intValue();\r\n\t\r\n\treturn new OAuth2AccessToken(access_token, token_type, expires_in, null, null, responseBuilder.toString());\r\n}\r\n\r\n@Override\r\npublic String getRefreshTokenEndpoint()\r\n{\r\n\treturn Util.builder(getAccessTokenEndpoint(), \"?grant_type=refresh_token\");\r\n}\r\n```\r\n\r\nAccess Token 재발급 코드는 위와 같다. 원래 `service.refreshAccessToken()` 메서드가 있긴 한데, `getRefreshTokenEndpoint` 처리가 플랫폼별로 다른건지, 제대로 동작이 안 되는 것 같다. 필자는 그냥 `HttpURLConnection`을 활용하여 OAuth2.0 스펙에 맞게끔 요청을 설계했다.\r\n\r\n`getRefreshTokenEndpoint` 메서드는 Refresh Token 관련 작업을 수행할 때 베이스가 되는 URL을 반환하는 메서드다. `getAccessTokenEndpoint` URL 뒤에 `?grant_type=refresh_token` 파라미터를 붙여 반환한다.\r\n\r\n`getRefreshTokenEndpoint`이 반환하는 URL을 기준삼아 `client_id`, `client_secret`, `refresh_token`을 파라미터로 담아 전송하여 응답을 받고, 여기서 필요한 내용을 추출하여 `OAuth2AccessToken` 객체를 생성하여 반환한다.\r\n\r\n\r\n### 유저 정보 호출 메서드\r\n\r\nAccess Token을 성공적으로 받아왔다면, 이를 통해 사용자 정보를 불러올 수 있다.\r\n\r\n``` java\r\npublic Response getUserInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n{\r\n\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getUserInfoEndPoint());\r\n\tservice.signRequest(access, oAuthRequest);\r\n\t\r\n\treturn service.execute(oAuthRequest);\r\n}\r\n\r\nabstract protected String getUserInfoEndPoint();\r\n\t\r\nabstract public UserInfoBean getUserInfoBean(String body) throws JsonProcessingException;\r\n```\r\n\r\n총 세 가지 메서드를 정의해야하는데, 하나는 직접 구현이고 나머지 두 개는 추상 메서드다.\r\n\r\n`getUserInfo` 메서드는 Access Token을 활용하여 해당 플랫폼의 UserInfo API로 요청을 보내 응답을 반환한다.\r\n\r\n`OAuthRequest` 객체를 선언하여 요청 메서드와 대상 URL을 지정한다. 이후 `service.signRequest`를 통해 `service`에 요청을 등록하고, `service.execute`로 해당 요청을 수행한다.\r\n\r\n`getUserInfoEndPoint` 메서드는 각 플랫폼의 UserInfo API URL을 반환하는 추상 메서드로, 플랫폼마다 URL이 다르기 때문에 추상 객체로 선언하여 하위 플랫폼 인증 모듈에게 구현 책임을 위임한다.\r\n\r\n`getUserInfoBean`는 `getUserInfo`의 응답을 받아 `UserInfoBean` DTO로 변환하여 이를 반환하는 추상 메서드다. 참고로 `UserInfoBean`은 scribeJAVA에 포함된 것이 아니라, 직접 작성한 DTO 객체다.\r\n\r\n플랫폼마다 사용자 정보의 응답값이 다르기 때문에, 이를 적절히 대응하고 값을 반환하고자 설계된 메서드다. 이 역시 하위 플랫폼 인증 모듈에게 구현을 위임한다.\r\n\r\n\r\n### 연동 해제 메서드\r\n\r\n플랫폼으로부터 완전히 연동을 해제하는 메서드가 필요하다.\r\n\r\n이는 단순히 로그아웃이 아니라, 플랫폼과 해당 사용자의 연결을 완전히 파기한다. 이 과정에서 사용자의 관련 데이터 및 정보 제공 동의 이력 역시 같이 파기된다.\r\n\r\n연동 해제 후 다시 로그인을 하게 되면, 처음 로그인을 수행하는 것 처럼 약관과 정보 제공 동의를 다시 선택해야한다.\r\n\r\n``` java\r\nabstract public boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException;\r\n```\r\n\r\n연동 해제의 경우 OAuth의 범주에선 살짝 벗어나있어서, 이 역시도 동일한 인터페이스를 가지진 않는다. 각 플랫폼마다의 구현이 천차만별이므로 추상 메서드로 정의한다.\r\n\r\n\r\n### 정보 제공 동의 갱신 URL 반환 메서드\r\n\r\n서비스를 운영하다보면 사용자에게 요구할 정보가 변경되기도 한다.\r\n\r\n만약 한참 잘 운영하다가 사용자에게 추가적인 정보를 받아야만 한다면? 정보를 호출해도 동의 내역 자체가 없으니 관련 정보는 얻을 수조차 없다.\r\n\r\n이러한 상황에 대비해 정보 제공 동의를 갱신하는 기능이 필요하다.\r\n\r\n``` java\r\nabstract public String getUpdateAuthorizationUrl(String state);\r\n```\r\n\r\n정보 제공 동의 갱신 역시 플랫폼마다 천차만별로 조금씩 다른 것 같다. 마찬가지로 추상 메서드로 정의하자.\r\n\r\n\r\n### API 객체 반환 메서드\r\n\r\n마지막으로 scribeJAVA와 직접적인 관련은 없지만, API 관련 요소를 불러오기위한 메서드가 필요하다.\r\n\r\nOAuth2.0을 사용하기 위해 필요한 3가지 요소는 API Key, API Secret Key, Callback URL이 필요하다. 이를 하드코딩해서 코드 안에 녹이는 건 그리 좋은 방법은 아니다.\r\n\r\n플랫폼별 API 요소를 `.properties` 파일로 관리하여 `WEB-INF/` 아래에서 관리할 것이다.\r\n\r\n> <b class=\"orange-400\">WEB-INF의 특별함</b>  \r\n> Tomcat의 `WEB-INF`는 조금 특별하다. 기본적으로 대상 경로 아래의 모든 폴더 및 파일은 웹 형태로 접근이 가능하지만, `WEB-INF` 아래에 위치하는 폴더 및 파일은 배포 대상에서 제외되므로 접근할 수 없다. 하지만 파일 시스템엔 여전히 존재하고 있으므로, 이에 구애받지 않는 JAVA 등 Backend에서의 접근엔 지장이 없다.  \r\n> API 키, 암호화 키 등 보안에 웹 서버 운영에 필요하면서도 각별한 보안이 요구되는 파일은 `WEB-INF` 아래에 관리하는 것이 좋다.\r\n\r\n이렇게 관리하고 `gitignore`에서 각 플랫폼의 설정파일을 제외하면 GitHub에 올려도 해당 파일을 제외하고 올린다. 따라서 이렇게 코드를 오픈해도 API 유출을 막을 수 있다.\r\n\r\n코드는 아래와 같다.\r\n\r\n``` java\r\nprotected static ApiKeyBean getApiKeyBean(String platform)\r\n{\r\n\tApiKeyBean apiKeyBean;\r\n\tapiKeyBean = new ApiKeyBean();\r\n\t\r\n\t// API 키 획득 시도\r\n\ttry\r\n\t{\r\n\t\tHashMap<String, String> map = Util.getProperties(platform);\r\n\t\t\r\n\t\tapiKeyBean.setApi(map.get(\"api\"));\r\n\t\tapiKeyBean.setSecret(map.get(\"secret\"));\r\n\t\tapiKeyBean.setCallback(map.get(\"callback\"));\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t}\r\n\t\r\n\treturn apiKeyBean;\r\n}\r\n```\r\n\r\n``` java\r\n@Getter\r\n@Setter\r\npublic class ApiKeyBean\r\n{\r\n\t// API 키\r\n\tprivate String api;\r\n\t\r\n\t// API SECRET 키\r\n\tprivate String secret;\r\n\t\r\n\t// 콜백 URL\r\n\tprivate String callback;\r\n}\r\n```\r\n\r\n`ApiKeyBean`은 직접 설계한 객체로, 위 코드와 같다. `lombok`이 적용되어 있다.\r\n\r\nJAVA는 `.properties` 파일을 읽어 key-value 형태의 HashMap으로 변환해주는 기능이 있다.\r\n\r\n``` properties\r\napi={API_KEY}\r\nsecret={SECRET_KEY}\r\ncallback={CALLBACK_URL}\r\n```\r\n\r\n설정 파일은 위와 같다. 이 메서드를 활용하여 각 플랫폼별 API 설정파일을 불러오도록 구성한다.\r\n\r\n\r\n\r\n## AuthModule 전체 코드\r\n\r\n``` java\r\npackage oauth.account.module;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.github.scribejava.core.builder.ServiceBuilderOAuth20;\r\nimport com.github.scribejava.core.builder.api.DefaultApi20;\r\nimport com.github.scribejava.core.model.OAuth2AccessToken;\r\nimport com.github.scribejava.core.model.OAuthRequest;\r\nimport com.github.scribejava.core.model.Response;\r\nimport com.github.scribejava.core.model.Verb;\r\nimport com.github.scribejava.core.oauth.AccessTokenRequestParams;\r\nimport com.github.scribejava.core.oauth.OAuth20Service;\r\nimport global.module.Util;\r\nimport lombok.Getter;\r\nimport oauth.account.bean.ApiKeyBean;\r\nimport oauth.account.bean.UserInfoBean;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URL;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n/**\r\n * 인증 모듈 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 23:30:47\r\n */\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n\tprotected OAuth20Service service;\r\n\t\r\n\t@Getter\r\n\tprotected String unique;\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param serviceBuilder: [ServiceBuilderOAuth20] API 서비스 빌더\r\n\t * @param unique: [String] 유니크 키\r\n\t */\r\n\tprotected AuthModule(ServiceBuilderOAuth20 serviceBuilder, String unique)\r\n\t{\r\n\t\tservice = serviceBuilder.build(this);\r\n\t\t\r\n\t\tthis.unique = unique;\r\n\t}\r\n\t\r\n\tabstract protected String getUserInfoEndPoint();\r\n\t\r\n\tabstract public UserInfoBean getUserInfoBean(String body) throws JsonProcessingException;\r\n\t\r\n\tabstract public boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException;\r\n\t\r\n\tabstract public String getUpdateAuthorizationUrl(String state);\r\n\t\r\n\t/**\r\n\t * 인증 URL 반환 메서드\r\n\t *\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [String] 인증 URL\r\n\t */\r\n\tpublic String getAuthorizationUrl(String state)\r\n\t{\r\n\t\treturn service.getAuthorizationUrl(state);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param code: [String] 인증 코드\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getAccessToken(String code) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\treturn service.getAccessToken(code);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param params: [AccessTokenRequestParams] AccessTokenRequestParams 객체\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getAccessToken(AccessTokenRequestParams params) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\treturn service.getAccessToken(params);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 갱신 및 반환 메서드\r\n\t *\r\n\t * @param refresh: [String] 리프레쉬 토큰\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getRefreshAccessToken(String refresh) throws IOException\r\n\t{\r\n\t\tHashMap<String, String> params = new HashMap<>();\r\n\t\tparams.put(\"client_id\", service.getApiKey());\r\n\t\tparams.put(\"client_secret\", service.getApiSecret());\r\n\t\tparams.put(\"refresh_token\", refresh);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (Map.Entry<String, String> param : params.entrySet())\r\n\t\t{\r\n\t\t\tbuilder.append(\"&\").append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8)).append(\"=\").append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\r\n\t\t}\r\n\t\t\r\n\t\tbyte[] paramBytes = builder.toString().getBytes(StandardCharsets.UTF_8);\r\n\t\t\r\n\t\tURL url = new URL(getRefreshTokenEndpoint());\r\n\t\t\r\n\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\t\tconnection.setRequestMethod(\"POST\");\r\n\t\tconnection.setDoOutput(true);\r\n\t\tconnection.getOutputStream().write(paramBytes);\r\n\t\t\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\r\n\t\t\r\n\t\tStringBuilder responseBuilder = new StringBuilder();\r\n\t\tString temp;\r\n\t\t\r\n\t\twhile ((temp = reader.readLine()) != null)\r\n\t\t{\r\n\t\t\tresponseBuilder.append(temp);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t\t\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(responseBuilder.toString());\r\n\t\t\r\n\t\tString access_token = node.get(\"access_token\").textValue();\r\n\t\tString token_type = node.get(\"token_type\").textValue();\r\n\t\tint expires_in = node.get(\"expires_in\").intValue();\r\n\t\t\r\n\t\treturn new OAuth2AccessToken(access_token, token_type, expires_in, refresh, null, responseBuilder.toString());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 응답 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [Response] 사용자 정보 응답\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic Response getUserInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getUserInfoEndPoint());\r\n\t\tservice.signRequest(access, oAuthRequest);\r\n\t\t\r\n\t\treturn service.execute(oAuthRequest);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 재발급 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 접근 토큰 재발급 요청 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getRefreshTokenEndpoint()\r\n\t{\r\n\t\treturn Util.builder(getAccessTokenEndpoint(), \"?grant_type=refresh_token\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * API 키 객체 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [ApiKeyBean] API 키 객체\r\n\t */\r\n\tprotected static ApiKeyBean getApiKeyBean(String platform)\r\n\t{\r\n\t\tApiKeyBean apiKeyBean;\r\n\t\tapiKeyBean = new ApiKeyBean();\r\n\t\t\r\n\t\t// API 키 획득 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tHashMap<String, String> map = Util.getProperties(platform);\r\n\t\t\t\r\n\t\t\tapiKeyBean.setApi(map.get(\"api\"));\r\n\t\t\tapiKeyBean.setSecret(map.get(\"secret\"));\r\n\t\t\tapiKeyBean.setCallback(map.get(\"callback\"));\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\treturn apiKeyBean;\r\n\t}\r\n}\r\n```\r\n\r\n전체 소스는 위와 같다.\r\n\r\n중간에 한 번씩 사용되는 `Util` 객체는 해당 프로젝트에서 범용적으로 사용되는 메서드를 모아놓은 공통 모듈이다.\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\nscribeJAVA를 통해 인증 모듈의 원형이되는 추상 객체를 구현했다. 해당 모듈을 토대로 각 플랫폼별 인증 모듈을 확장하여 개발할 수 있을 것이다.\r\n\r\n다음 장에서는 본격적으로 플랫폼별 OAuth 서비스 신청과 인증 모듈 구현에 대해 다룬다.","url":["2021-10-20-oauth2-java-server-3","2021","10","20","oauth2-java-server-3"]}},"group":[{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 3. scribeJAVA로 OAuth2.0 인증 모듈 구현하기","excerpt":"OAuth 라이브러리인 scribeJAVA를 통해 인증 모듈을 구현해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-20T01:26:40","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0","Jersey"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-20-oauth2-java-server-3.md","content":"\r\n# 개요\r\n\r\nOAuth 라이브러리인 scribeJAVA를 통해 인증 모듈을 구현해보자.\r\n\r\n\r\n\r\n\r\n\r\n# OAuth 인증 모듈 구현하기\r\n\r\n이전 장에서도 언급했듯이, OAuth 인증 모듈은 그 공통된 특성으로 인해 추상 객체가 적합하다.\r\n\r\nscribeJAVA 모듈을 사용하여 추상 객체를 구현한다.\r\n\r\n\r\n\r\n## scribeJAVA 적용하기\r\n\r\n프로젝트에 scribeJAVA를 적용해보자.\r\n\r\n``` groovy\r\nimplementation group: 'com.github.scribejava', name: 'scribejava-apis', version: '8.3.1'\r\n```\r\n\r\n`build.gradle`의 dependencies에 위 의존성을 추가하는 것으로 scribeJAVA를 적용할 수 있다.\r\n\r\n\r\n\r\n## scribeJAVA 사용하기\r\n\r\n본격적으로 scribeJAVA를 사용해보자.\r\n\r\nscribeJAVA는 `OAuth20Service`라는 객체를 중심으로 동작한다. `OAuth20Service` 객체를 통해 아래의 로직을 수행할 수 있다.\r\n\r\n* 플랫폼 로그인 URL 생성\r\n* 인가 코드를 Access, Refresh Token으로 교환\r\n* Refresh Token을 통해 Access Token 갱신\r\n* 기타 OAuth 관련 요청 생성\r\n\r\n즉, OAuth 인증에 있어서 핵심이 되는 동작은 모두 이 `OAuth20Service` 객체를 중심으로 이루어진다.\r\n\r\n\r\n### OAuth20Service 객체 생성하기\r\n\r\n`OAuth20Service` 객체를 생성한다. 필요한 요소는 아래와 같다.\r\n\r\n|      구분      |     필수 여부     |           내용           |\r\n| :------------: | :---------------: | :----------------------: |\r\n|    API Key     |         Y         |          API 키          |\r\n| API Secret Key |         Y         |      API 시크릿 키       |\r\n|  Callback URL  |         Y         | 로그인 결과를 반환할 URL |\r\n|     Scope      | N (일부 플랫폼 Y) |           권한           |\r\n\r\nAPI Key, API Secret Key, Callback URL은 기본적으로 반드시 필요하며, 몇몇 플랫폼의 경우 Scope도 필수 사양으로 지정하는 경우가 있다. 이 프로젝트에 적용할 플랫폼들 중 Google이 그렇다. 구글은 후술할 플랫폼 로그인 URL 생성 시 Scope를 지정하지 않으면 오류를 출력한다.\r\n\r\nAPI Key, API Secret Key는 각 플랫폼에 OAuth 서비스 등록 시 부여해주며, Callback URL은 본인이 직접 정해서 입력하면 된다. 등록되지 않은 Callback URL로 로그인을 수행하면 오류가 출력된다. Callback URL은 여러개를 지정할 수 있다.\r\n\r\n각 플랫폼 별 OAuth 서비스를 등록하는 방법은 추후에 다루고, 일단 이런 부가적인 부분들은 준비가 됐다고 가정한다.\r\n\r\n``` java\r\nOAuth20Service service = new ServiceBuilder(\"{API_KEY}\").apiSecret(\"{SECRET_KEY}\").callback(\"{CALLBACK_URL}\").build(this);\r\n```\r\n\r\n이와 같이 생성할 수 있다. `build(this)`에서 `this`는 `DefaultApi20` 객체다. 아래는 `OAuth20Service` 객체의 메서드와 그 기능들이다.\r\n\r\n|         구분          |             내용              |\r\n| :-------------------: | :---------------------------: |\r\n| `getAuthorizationUrl` | 플랫폼 로그인 URL 반환 메서드 |\r\n|   `getAccessToken`    | OAuth2AccessToken 반환 메서드 |\r\n|     `signRequest`     |    OAuth 요청 등록 메서드     |\r\n|       `execute`       |    등록된 요청 수행 메서드    |\r\n\r\n이 프로젝트에선 위 4가지 용도만 알아도 무방하다.\r\n\r\n\r\n\r\n\r\n## AuthModule 생성하기\r\n\r\n이제 본격적으로 모듈 객체를 구현해보자. 인증 모듈은 반드시 `DefaultApi20`을 상속받아 구현해야한다.\r\n\r\n``` java\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n\t// 구현 예정\r\n}\r\n```\r\n\r\n`DefaultApi20` 추상 객체는 두 개의 추상 메서드를 가지고 있다. 즉, 이를 상속하는 `AuthModule`는 이 두 메서드를 구현해야할 책임이 있다.\r\n\r\n* `getAccessTokenEndpoint` - 접근 토큰 요청 URL 반환 메서드\r\n* `getAuthorizationBaseUrl` - 인증 URL 반환 메서드\r\n\r\n하지만 `AuthModule` 역시 추상 객체이므로, 이를 상속받아 사용할 하위 플랫폼 인증 모듈에게 이 책임을 위임할 수 있다. 즉, `DefaultApi20`의 추상 메서드는 `AuthModule`에서 구현하지 않고 이를 상속하는 하위 플랫폼 인증 모듈에서 구현할 것이다.\r\n\r\n인증 모듈 추상 객체는 위와 같은 형태를 가진다. NAVER, Google 등 플랫폼별 인증 모듈은 위 `AuthModule`을 상속받아 사용할 것이다. 인증 모듈의 핵심 동작은 대부분 `OAuth20Service` 객체로부터 이루어지니, `AuthModule`을 상속할 때 반드시 관련 객체를 받도록 명시하는 것이 좋아보인다.\r\n\r\n``` java\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n    protected OAuth20Service service;\r\n\t\r\n\t@Getter\r\n\tprotected String unique;\r\n\r\n    protected AuthModule(ServiceBuilderOAuth20 serviceBuilder, String unique)\r\n\t{\r\n\t\tservice = serviceBuilder.build(this);\r\n\t\t\r\n\t\tthis.unique = unique;\r\n\t}\r\n}\r\n```\r\n\r\n|      구분      |       데이터 형식       |                                  내용                                   |\r\n| :------------: | :---------------------: | :---------------------------------------------------------------------: |\r\n| serviceBuilder | `ServiceBuilderOAuth20` |                      `OAuth20Service` 객체의 빌더                       |\r\n|     unique     |        `String`         | 인증 모듈의 고유값. 플랫폼의 소문자 표기와 동일 (ex. NAVER -> naver 등) |\r\n\r\n생성자와 멤버 변수를 위와 같이 지정한다. 전부 `protected` 접근 제어자를 가지므로, `AuthModule`을 상속받은 객체에서만 생성자를 사용할 수 있으며, `service`, `unique` 파라미터 역시 마찬가지다.\r\n\r\n`ServiceBuilderOAuth20`를 인수로 할당받아 생성자에서 `OAuth20Service`로 빌드하여 멤버 변수 `service`에 할당한다. `AuthModule` 상속받은 객체의 어느 곳에서든 `service`와 `unique`에 접근할 수 있다.\r\n\r\n이 모듈에 기본적인 로직을 작성하고, 플랫폼마다 구현이 모두 다를 경우, 추상 메서드를 선언하여 이를 상속받는 객체가 이를 직접 구현하도록 위임한다.\r\n\r\n\r\n### 플랫폼 로그인 URL 반환 메서드\r\n\r\nscribeJAVA를 통해 플랫폼 로그인 URL 반환 메서드를 구현해보자. 예를 들어, 네이버 아이디로 로그인 버튼을 클릭하면 네이버 로그인 창이 뜰 것이다. 이 과정은 앞선 예시와 같은 플랫폼 로그인 창의 URL을 생성하는 것이다.\r\n\r\n`service`의 `getAuthorizationUrl` 메서드를 사용하는 것만으로 간단히 구현할 수 있다. `ServiceBuilderOAuth20`에 입력했던 API Key, Secret Key, Callback URL을 토대로 플랫폼 인증 URL을 생성하여 반환한다.\r\n\r\n``` java\r\npublic String getAuthorizationUrl(String state)\r\n{\r\n\treturn service.getAuthorizationUrl(state);\r\n}\r\n```\r\n\r\n`getAuthorizationBaseUrl`의 반환 URL을 기준으로 생성한다.\r\n\r\n인수인 `state`는 고유 상태값으로, 서버에서 임의의 UUID를 하나 생성해서 사용한다. 이는 보안을 위한 세션 체크용으로 사용하는 값이다.\r\n\r\n\r\n### OAuth2AccessToken 반환 메서드\r\n\r\n이번엔 `OAuth2AccessToken` 객체를 반환하는 메서드를 구현해보자. `OAuth2AccessToken`는 Access, Refresh Token. 토큰 종류, 유효시간을 가지는 scribeJAVA의 객체다.\r\n\r\n``` java\r\npublic OAuth2AccessToken getAccessToken(String code) throws IOException, ExecutionException, InterruptedException\r\n{\r\n    return service.getAccessToken(code);\r\n}\r\n```\r\n\r\n마찬가지로 `service`의 `getAccessToken` 메서드를 사용하여 간단히 구현할 수 있다. 인수인 `code`를 Service Provider에 전달하면, Access, Refresh Token을 제공한다.\r\n\r\n\r\n### Access Token 갱신 메서드\r\n\r\nAccess Token은 보안을 위해 만료시간이 굉장히 짧거나 세션 만료 시 같이 만료되는 것이 보통이다. 이 경우 원래대로라면 다시 인증을 받아야하고, 경우에 따라 사용자에게 플랫폼 로그인 수행을 다시 요구할 수도 있다.\r\n\r\n대부분의 OAuth 플랫폼은 인증 시 Access Token과 함께 Refresh Token을 같이 제공한다.\r\n\r\n|     구분      |   만료시간    | 인증 가능 여부 |                                               내용                                               |\r\n| :-----------: | :-----------: | :------------: | :----------------------------------------------------------------------------------------------: |\r\n| Access Token  | 짧거나 일시적 |      가능      |   인증을 담당하는 토큰. Access Token 존재 자체만으로 사용자가 인증 정보를 제공한다고 가정한다.   |\r\n| Refresh Token | 길거나 영구적 |     불가능     | Access Token을 재발급하는 토큰. Refresh Token 자체만으론 재발급 외의 유의미한 작업이 불가능하다. |\r\n\r\n두 토큰의 차이는 위와 같다.\r\n\r\nscribeJAVA에서 Refresh Token으로 Access Token을 재발급 받아보자.\r\n\r\n``` java\r\npublic OAuth2AccessToken getRefreshAccessToken(String refresh) throws IOException\r\n{\r\n\tHashMap<String, String> params = new HashMap<>();\r\n\tparams.put(\"client_id\", service.getApiKey());\r\n\tparams.put(\"client_secret\", service.getApiSecret());\r\n\tparams.put(\"refresh_token\", refresh);\r\n\t\r\n\tStringBuilder builder = new StringBuilder();\r\n\t\r\n\tfor (Map.Entry<String, String> param : params.entrySet())\r\n\t{\r\n\t\tbuilder.append(\"&\").append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8)).append(\"=\").append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\r\n\t}\r\n\t\r\n\tbyte[] paramBytes = builder.toString().getBytes(StandardCharsets.UTF_8);\r\n\t\r\n\tURL url = new URL(getRefreshTokenEndpoint());\r\n\t\r\n\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\tconnection.setRequestMethod(\"POST\");\r\n\tconnection.setDoOutput(true);\r\n\tconnection.getOutputStream().write(paramBytes);\r\n\t\r\n\tBufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\r\n\t\r\n\tStringBuilder responseBuilder = new StringBuilder();\r\n\tString temp;\r\n\t\r\n\twhile ((temp = reader.readLine()) != null)\r\n\t{\r\n\t\tresponseBuilder.append(temp);\r\n\t}\r\n\t\r\n\treader.close();\r\n\t\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\t\r\n\tJsonNode node = mapper.readTree(responseBuilder.toString());\r\n\t\r\n\tString access_token = node.get(\"access_token\").textValue();\r\n\tString token_type = node.get(\"token_type\").textValue();\r\n\tint expires_in = node.get(\"expires_in\").intValue();\r\n\t\r\n\treturn new OAuth2AccessToken(access_token, token_type, expires_in, null, null, responseBuilder.toString());\r\n}\r\n\r\n@Override\r\npublic String getRefreshTokenEndpoint()\r\n{\r\n\treturn Util.builder(getAccessTokenEndpoint(), \"?grant_type=refresh_token\");\r\n}\r\n```\r\n\r\nAccess Token 재발급 코드는 위와 같다. 원래 `service.refreshAccessToken()` 메서드가 있긴 한데, `getRefreshTokenEndpoint` 처리가 플랫폼별로 다른건지, 제대로 동작이 안 되는 것 같다. 필자는 그냥 `HttpURLConnection`을 활용하여 OAuth2.0 스펙에 맞게끔 요청을 설계했다.\r\n\r\n`getRefreshTokenEndpoint` 메서드는 Refresh Token 관련 작업을 수행할 때 베이스가 되는 URL을 반환하는 메서드다. `getAccessTokenEndpoint` URL 뒤에 `?grant_type=refresh_token` 파라미터를 붙여 반환한다.\r\n\r\n`getRefreshTokenEndpoint`이 반환하는 URL을 기준삼아 `client_id`, `client_secret`, `refresh_token`을 파라미터로 담아 전송하여 응답을 받고, 여기서 필요한 내용을 추출하여 `OAuth2AccessToken` 객체를 생성하여 반환한다.\r\n\r\n\r\n### 유저 정보 호출 메서드\r\n\r\nAccess Token을 성공적으로 받아왔다면, 이를 통해 사용자 정보를 불러올 수 있다.\r\n\r\n``` java\r\npublic Response getUserInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n{\r\n\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getUserInfoEndPoint());\r\n\tservice.signRequest(access, oAuthRequest);\r\n\t\r\n\treturn service.execute(oAuthRequest);\r\n}\r\n\r\nabstract protected String getUserInfoEndPoint();\r\n\t\r\nabstract public UserInfoBean getUserInfoBean(String body) throws JsonProcessingException;\r\n```\r\n\r\n총 세 가지 메서드를 정의해야하는데, 하나는 직접 구현이고 나머지 두 개는 추상 메서드다.\r\n\r\n`getUserInfo` 메서드는 Access Token을 활용하여 해당 플랫폼의 UserInfo API로 요청을 보내 응답을 반환한다.\r\n\r\n`OAuthRequest` 객체를 선언하여 요청 메서드와 대상 URL을 지정한다. 이후 `service.signRequest`를 통해 `service`에 요청을 등록하고, `service.execute`로 해당 요청을 수행한다.\r\n\r\n`getUserInfoEndPoint` 메서드는 각 플랫폼의 UserInfo API URL을 반환하는 추상 메서드로, 플랫폼마다 URL이 다르기 때문에 추상 객체로 선언하여 하위 플랫폼 인증 모듈에게 구현 책임을 위임한다.\r\n\r\n`getUserInfoBean`는 `getUserInfo`의 응답을 받아 `UserInfoBean` DTO로 변환하여 이를 반환하는 추상 메서드다. 참고로 `UserInfoBean`은 scribeJAVA에 포함된 것이 아니라, 직접 작성한 DTO 객체다.\r\n\r\n플랫폼마다 사용자 정보의 응답값이 다르기 때문에, 이를 적절히 대응하고 값을 반환하고자 설계된 메서드다. 이 역시 하위 플랫폼 인증 모듈에게 구현을 위임한다.\r\n\r\n\r\n### 연동 해제 메서드\r\n\r\n플랫폼으로부터 완전히 연동을 해제하는 메서드가 필요하다.\r\n\r\n이는 단순히 로그아웃이 아니라, 플랫폼과 해당 사용자의 연결을 완전히 파기한다. 이 과정에서 사용자의 관련 데이터 및 정보 제공 동의 이력 역시 같이 파기된다.\r\n\r\n연동 해제 후 다시 로그인을 하게 되면, 처음 로그인을 수행하는 것 처럼 약관과 정보 제공 동의를 다시 선택해야한다.\r\n\r\n``` java\r\nabstract public boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException;\r\n```\r\n\r\n연동 해제의 경우 OAuth의 범주에선 살짝 벗어나있어서, 이 역시도 동일한 인터페이스를 가지진 않는다. 각 플랫폼마다의 구현이 천차만별이므로 추상 메서드로 정의한다.\r\n\r\n\r\n### 정보 제공 동의 갱신 URL 반환 메서드\r\n\r\n서비스를 운영하다보면 사용자에게 요구할 정보가 변경되기도 한다.\r\n\r\n만약 한참 잘 운영하다가 사용자에게 추가적인 정보를 받아야만 한다면? 정보를 호출해도 동의 내역 자체가 없으니 관련 정보는 얻을 수조차 없다.\r\n\r\n이러한 상황에 대비해 정보 제공 동의를 갱신하는 기능이 필요하다.\r\n\r\n``` java\r\nabstract public String getUpdateAuthorizationUrl(String state);\r\n```\r\n\r\n정보 제공 동의 갱신 역시 플랫폼마다 천차만별로 조금씩 다른 것 같다. 마찬가지로 추상 메서드로 정의하자.\r\n\r\n\r\n### API 객체 반환 메서드\r\n\r\n마지막으로 scribeJAVA와 직접적인 관련은 없지만, API 관련 요소를 불러오기위한 메서드가 필요하다.\r\n\r\nOAuth2.0을 사용하기 위해 필요한 3가지 요소는 API Key, API Secret Key, Callback URL이 필요하다. 이를 하드코딩해서 코드 안에 녹이는 건 그리 좋은 방법은 아니다.\r\n\r\n플랫폼별 API 요소를 `.properties` 파일로 관리하여 `WEB-INF/` 아래에서 관리할 것이다.\r\n\r\n> <b class=\"orange-400\">WEB-INF의 특별함</b>  \r\n> Tomcat의 `WEB-INF`는 조금 특별하다. 기본적으로 대상 경로 아래의 모든 폴더 및 파일은 웹 형태로 접근이 가능하지만, `WEB-INF` 아래에 위치하는 폴더 및 파일은 배포 대상에서 제외되므로 접근할 수 없다. 하지만 파일 시스템엔 여전히 존재하고 있으므로, 이에 구애받지 않는 JAVA 등 Backend에서의 접근엔 지장이 없다.  \r\n> API 키, 암호화 키 등 보안에 웹 서버 운영에 필요하면서도 각별한 보안이 요구되는 파일은 `WEB-INF` 아래에 관리하는 것이 좋다.\r\n\r\n이렇게 관리하고 `gitignore`에서 각 플랫폼의 설정파일을 제외하면 GitHub에 올려도 해당 파일을 제외하고 올린다. 따라서 이렇게 코드를 오픈해도 API 유출을 막을 수 있다.\r\n\r\n코드는 아래와 같다.\r\n\r\n``` java\r\nprotected static ApiKeyBean getApiKeyBean(String platform)\r\n{\r\n\tApiKeyBean apiKeyBean;\r\n\tapiKeyBean = new ApiKeyBean();\r\n\t\r\n\t// API 키 획득 시도\r\n\ttry\r\n\t{\r\n\t\tHashMap<String, String> map = Util.getProperties(platform);\r\n\t\t\r\n\t\tapiKeyBean.setApi(map.get(\"api\"));\r\n\t\tapiKeyBean.setSecret(map.get(\"secret\"));\r\n\t\tapiKeyBean.setCallback(map.get(\"callback\"));\r\n\t}\r\n\t\r\n\t// 예외\r\n\tcatch (Exception e)\r\n\t{\r\n\t\te.printStackTrace();\r\n\t}\r\n\t\r\n\treturn apiKeyBean;\r\n}\r\n```\r\n\r\n``` java\r\n@Getter\r\n@Setter\r\npublic class ApiKeyBean\r\n{\r\n\t// API 키\r\n\tprivate String api;\r\n\t\r\n\t// API SECRET 키\r\n\tprivate String secret;\r\n\t\r\n\t// 콜백 URL\r\n\tprivate String callback;\r\n}\r\n```\r\n\r\n`ApiKeyBean`은 직접 설계한 객체로, 위 코드와 같다. `lombok`이 적용되어 있다.\r\n\r\nJAVA는 `.properties` 파일을 읽어 key-value 형태의 HashMap으로 변환해주는 기능이 있다.\r\n\r\n``` properties\r\napi={API_KEY}\r\nsecret={SECRET_KEY}\r\ncallback={CALLBACK_URL}\r\n```\r\n\r\n설정 파일은 위와 같다. 이 메서드를 활용하여 각 플랫폼별 API 설정파일을 불러오도록 구성한다.\r\n\r\n\r\n\r\n## AuthModule 전체 코드\r\n\r\n``` java\r\npackage oauth.account.module;\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.github.scribejava.core.builder.ServiceBuilderOAuth20;\r\nimport com.github.scribejava.core.builder.api.DefaultApi20;\r\nimport com.github.scribejava.core.model.OAuth2AccessToken;\r\nimport com.github.scribejava.core.model.OAuthRequest;\r\nimport com.github.scribejava.core.model.Response;\r\nimport com.github.scribejava.core.model.Verb;\r\nimport com.github.scribejava.core.oauth.AccessTokenRequestParams;\r\nimport com.github.scribejava.core.oauth.OAuth20Service;\r\nimport global.module.Util;\r\nimport lombok.Getter;\r\nimport oauth.account.bean.ApiKeyBean;\r\nimport oauth.account.bean.UserInfoBean;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URL;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n/**\r\n * 인증 모듈 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.09.29 Wed 23:30:47\r\n */\r\nabstract public class AuthModule extends DefaultApi20\r\n{\r\n\tprotected OAuth20Service service;\r\n\t\r\n\t@Getter\r\n\tprotected String unique;\r\n\t\r\n\t/**\r\n\t * 생성자 메서드\r\n\t *\r\n\t * @param serviceBuilder: [ServiceBuilderOAuth20] API 서비스 빌더\r\n\t * @param unique: [String] 유니크 키\r\n\t */\r\n\tprotected AuthModule(ServiceBuilderOAuth20 serviceBuilder, String unique)\r\n\t{\r\n\t\tservice = serviceBuilder.build(this);\r\n\t\t\r\n\t\tthis.unique = unique;\r\n\t}\r\n\t\r\n\tabstract protected String getUserInfoEndPoint();\r\n\t\r\n\tabstract public UserInfoBean getUserInfoBean(String body) throws JsonProcessingException;\r\n\t\r\n\tabstract public boolean deleteInfo(String access) throws IOException, ExecutionException, InterruptedException;\r\n\t\r\n\tabstract public String getUpdateAuthorizationUrl(String state);\r\n\t\r\n\t/**\r\n\t * 인증 URL 반환 메서드\r\n\t *\r\n\t * @param state: [String] 고유 상태값\r\n\t *\r\n\t * @return [String] 인증 URL\r\n\t */\r\n\tpublic String getAuthorizationUrl(String state)\r\n\t{\r\n\t\treturn service.getAuthorizationUrl(state);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param code: [String] 인증 코드\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getAccessToken(String code) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\treturn service.getAccessToken(code);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 반환 메서드\r\n\t *\r\n\t * @param params: [AccessTokenRequestParams] AccessTokenRequestParams 객체\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getAccessToken(AccessTokenRequestParams params) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\treturn service.getAccessToken(params);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 갱신 및 반환 메서드\r\n\t *\r\n\t * @param refresh: [String] 리프레쉬 토큰\r\n\t *\r\n\t * @return [OAuth2AccessToken] 접근 토큰\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic OAuth2AccessToken getRefreshAccessToken(String refresh) throws IOException\r\n\t{\r\n\t\tHashMap<String, String> params = new HashMap<>();\r\n\t\tparams.put(\"client_id\", service.getApiKey());\r\n\t\tparams.put(\"client_secret\", service.getApiSecret());\r\n\t\tparams.put(\"refresh_token\", refresh);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (Map.Entry<String, String> param : params.entrySet())\r\n\t\t{\r\n\t\t\tbuilder.append(\"&\").append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8)).append(\"=\").append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\r\n\t\t}\r\n\t\t\r\n\t\tbyte[] paramBytes = builder.toString().getBytes(StandardCharsets.UTF_8);\r\n\t\t\r\n\t\tURL url = new URL(getRefreshTokenEndpoint());\r\n\t\t\r\n\t\tHttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n\t\tconnection.setRequestMethod(\"POST\");\r\n\t\tconnection.setDoOutput(true);\r\n\t\tconnection.getOutputStream().write(paramBytes);\r\n\t\t\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\r\n\t\t\r\n\t\tStringBuilder responseBuilder = new StringBuilder();\r\n\t\tString temp;\r\n\t\t\r\n\t\twhile ((temp = reader.readLine()) != null)\r\n\t\t{\r\n\t\t\tresponseBuilder.append(temp);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t\t\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\t\t\r\n\t\tJsonNode node = mapper.readTree(responseBuilder.toString());\r\n\t\t\r\n\t\tString access_token = node.get(\"access_token\").textValue();\r\n\t\tString token_type = node.get(\"token_type\").textValue();\r\n\t\tint expires_in = node.get(\"expires_in\").intValue();\r\n\t\t\r\n\t\treturn new OAuth2AccessToken(access_token, token_type, expires_in, refresh, null, responseBuilder.toString());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 사용자 정보 응답 반환 메서드\r\n\t *\r\n\t * @param access: [String] 접근 토큰\r\n\t *\r\n\t * @return [Response] 사용자 정보 응답\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t * @throws ExecutionException 실행 예외\r\n\t * @throws InterruptedException 인터럽트 예외\r\n\t */\r\n\tpublic Response getUserInfo(String access) throws IOException, ExecutionException, InterruptedException\r\n\t{\r\n\t\tOAuthRequest oAuthRequest = new OAuthRequest(Verb.GET, getUserInfoEndPoint());\r\n\t\tservice.signRequest(access, oAuthRequest);\r\n\t\t\r\n\t\treturn service.execute(oAuthRequest);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 접근 토큰 재발급 요청 URL 반환 메서드\r\n\t *\r\n\t * @return [String] 접근 토큰 재발급 요청 URL\r\n\t */\r\n\t@Override\r\n\tpublic String getRefreshTokenEndpoint()\r\n\t{\r\n\t\treturn Util.builder(getAccessTokenEndpoint(), \"?grant_type=refresh_token\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * API 키 객체 반환 메서드\r\n\t *\r\n\t * @param platform: [String] 플랫폼\r\n\t *\r\n\t * @return [ApiKeyBean] API 키 객체\r\n\t */\r\n\tprotected static ApiKeyBean getApiKeyBean(String platform)\r\n\t{\r\n\t\tApiKeyBean apiKeyBean;\r\n\t\tapiKeyBean = new ApiKeyBean();\r\n\t\t\r\n\t\t// API 키 획득 시도\r\n\t\ttry\r\n\t\t{\r\n\t\t\tHashMap<String, String> map = Util.getProperties(platform);\r\n\t\t\t\r\n\t\t\tapiKeyBean.setApi(map.get(\"api\"));\r\n\t\t\tapiKeyBean.setSecret(map.get(\"secret\"));\r\n\t\t\tapiKeyBean.setCallback(map.get(\"callback\"));\r\n\t\t}\r\n\t\t\r\n\t\t// 예외\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\treturn apiKeyBean;\r\n\t}\r\n}\r\n```\r\n\r\n전체 소스는 위와 같다.\r\n\r\n중간에 한 번씩 사용되는 `Util` 객체는 해당 프로젝트에서 범용적으로 사용되는 메서드를 모아놓은 공통 모듈이다.\r\n\r\n\r\n\r\n\r\n\r\n# 정리\r\n\r\nscribeJAVA를 통해 인증 모듈의 원형이되는 추상 객체를 구현했다. 해당 모듈을 토대로 각 플랫폼별 인증 모듈을 확장하여 개발할 수 있을 것이다.\r\n\r\n다음 장에서는 본격적으로 플랫폼별 OAuth 서비스 신청과 인증 모듈 구현에 대해 다룬다.","url":["2021-10-20-oauth2-java-server-3","2021","10","20","oauth2-java-server-3"]},{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 1. OAuth2.0이란?","excerpt":"사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다. 이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다. 이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T00:56:31","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-1.md","content":"\r\n# 개요\r\n\r\n사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137170074-d678c0e1-d30a-4d38-91e5-543344e18ec3.png)\r\n\r\n이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다.\r\n\r\n이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.\r\n\r\n# OAuth\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137171256-3ca820ec-1435-4103-bc34-9c922832886c.png)\r\n\r\nOAuth는 Open Authentication의 약자로, 인증을 위한 표준 프로토콜이다.\r\n\r\n이전의 인증 방식은 사이트 혹은 애플리케이션에 직접 회원가입을 수행하여 내 정보를 제공하고, 비밀번호를 통해 인증하는 비밀번호 인증 방식을 취한다. 물론 이 비밀번호 인증 방식은 인터넷의 초창기부터 지금까지 사용하는 기법이지만, 그렇다고 문제가 아주 없는 것은 아니였다.\r\n\r\n* 서비스마다 운영되는 중구난방적인 인증 시스템\r\n* 사이트의 신뢰성 문제\r\n* 인터넷을 사용할수록 과적되는 인증 정보\r\n\r\nOAuth 이전에는 이렇다할 인증 표준이 존재하지 않았다. 표준이 없다보니 인증 시스템은 서비스마다 개성이 넘처흘렀다. 사이트마다 요구하는 정보, 방식이 천차만별로 다르니 사용자 입장에서는 매우 혼란스러울 것이다.\r\n\r\n그래도 이 점은 나름 사이트를 구분할 수 있는 일종의 척도(?)가 되기도 한다만, 더 큰 문제는 해당 사이트를 신뢰할만한 지표가 전혀 없다는 것이다. 내 정보를 왜 가져가는지, 어떻게 보관하는지 알 길이 없는 사용자들은 울며 겨자먹기로 서비스에게 내 정보를 제공하게 된다.\r\n\r\n이런 사이트들을 조금만 돌아다니면서 상호작용을 하다보면, 나도 모르는 새에 계정정보가 쌓여있을 것이다. 인증의 주체가 되는 \"나\"는 하나인데, 인증 표준의 부재로 인해 각 서비스마다 나 자신을 인증하기 위한 여러 방법을 소유하게되는 것이다.\r\n\r\n<br />\r\n\r\n이러한 비효율성을 타파하기 위해 Twitter 주도하에 인증 표준이 설립되었고, 이 것이 OAuth의 시초다. OAuth 라는 표준 프로토콜이 정의됨에 따라 각 서비스는 공통된 인터페이스로 사용자에게 인증을 요구할 수 있고, 사용자 역시 익숙하고 신뢰성있는 대형 플랫폼에 인증 정보를 입력하기 때문에 보안적인 측면은 물론, 절차 또한 간소화되는 이점을 가지게 된다.\r\n\r\nOAuth는 1.0을 시작으로, 1.0에 세션 고정 공격이라는 보안 취약점이 발견됨에 따라 현재는 2.0을 사용하고 있다.\r\n\r\n> <b class=\"orange-400\">OAuth1.0의 몰락</b>  \r\n> OAuth1.0은 <span class=\"primary\">세션 고정 공격</span>이라는 보안 취약점을 가지고 있다. 이를 해결하기 위해 OAuth2.0에서는 이러한 문제들이 해결되었으며, OAuth2.0은 OAuth1.0을 완전히 대체한다.\r\n\r\nOAuth2.0은 그 방식에 따라 4가지 방식으로 구분한다.\r\n\r\n이를 설명하기 앞서 OAuth에서 사용하는 키워드에 대해 알아보자\r\n\r\n|      키워드      |                             의미                             |\r\n| :--------------: | :----------------------------------------------------------: |\r\n|       User       |                            사용자                            |\r\n|     Consumer     |               OAuth를 제공하는 서비스 (웹 등)                |\r\n| Service Provider |                OAuth 서비스 제공자 (NAVER 등)                |\r\n|   Access Token   | Consumer가 Service Provider의 자원에 접근하기 위한 인증 코드 |\r\n|  Refresh Token   |             Access Token을 재발급하기 위한 코드              |\r\n\r\n아마 대부분 User의 범주에 속해있을 것이다. 여기서 궁극적으로 구축할 서비스는 Consumer가 된다.\r\n\r\n간혹 Service Provider는 인증 서버와 자원 서버로 분리해서 다루기도 한다.\r\n\r\nNAVER, Google과 같은 플랫폼은 Service Provider가 되며, 인증 절차를 통해 Access Token과 Refresh Token을 전달받게 된다.\r\n\r\n# OAuth Workflow\r\n\r\nOAuth2.0은 구현 방식에 따라 4가지 방식으로 구분된다.\r\n\r\n## 인가 코드 승인 (Authorization Code Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179813-de61fd8a-bbe6-4824-afdf-3652cde164bc.png)\r\n\r\n* 사용자가 Service Provider에 직접 인증을 수행\r\n* 인증에 성공하면 Consumer Frontend는 인가 코드를 전달받음\r\n* Consumer는 인가 코드를 Service Provider에 전달하여 Access, Refresh Token을 반환받음\r\n* Token 반환 이전에 인가 코드를 받는 과정이 추가되어 높은 수준의 보안을 제공함\r\n* Consumer의 Backend에서 Token 교환이 일어나므로 중간에 이를 탈취하기 어려움\r\n* 웹에서 사용되는 가장 보편적인 인증 형태로, 이 프로젝트 또한 인가 코드 승인 형태가 적용됨\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=code\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                내용                 |\r\n| :-----------: | :----------------------------: | :---------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> |  응답 타입으로, 값은 `code`로 고정  |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL            |\r\n|     state     |               N                |      임의로 생성한 고유 상태값      |\r\n|     scope     |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\ncode=dfnY865gHjUbnknt57yGV\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n```\r\n\r\n| 구분  |            내용             |\r\n| :---: | :-------------------------: |\r\n| code  |          인가 코드          |\r\n| state | 요청에서 전달한 고유 상태값 |\r\n\r\n`state`는 Consumer Backend에서 임의로 생성한 상태값으로, 통상 UUID를 하나 생성하여 사용한다.\r\n\r\n`code`와 입력했던 `state`가 반환된다. `code`를 통해 Service Provider에 요청하여 Access Token으로 교환할 수 있다.\r\n\r\n## 암시적 승인 (Implicit Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179833-fe688388-0d29-47c0-b4db-c4a42b26dccd.png)\r\n\r\n* 인가 코드 승인과 달리, 인증 성공 시 Consumer는 Token을 직접 전달받음\r\n* 각 플랫폼에서 제공되는 JavaScript SDK를 사용하여 구현\r\n* 인가 코드 승인에 비해 서버가 필요하지 않아 구현이 간단함\r\n* Token이 GET 방식으로 URL 파라미터에 담겨 전달되므로 보안에 취약하다.\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=token\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                 내용                 |\r\n| :-----------: | :----------------------------: | :----------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `token`으로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY  |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL             |\r\n|     state     |               N                |      임의로 생성한 고유 상태값       |\r\n|     scope     |               N                |              요청 권한               |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\n#access_token=kr40FkgksmGS92lffkGls\r\n&token_type=Bearer\r\n&expires_in=3600\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    state     |      요청에서 전달한 고유 상태값       |\r\n\r\n인가 코드 승인과 달리, 요청에 Access Token이 포함되어 전달된다.\r\n\r\n> <b class=\"orange-400\">파라미터가 왜 </b>`#`<b class=\"orange-400\">으로 시작하지?</b>  \r\n> `#`은 URI Fragment라는 식별자다. 해당 식별자는 URL 접근 시 서버에 전달되지 않기 때문에 보안적인 측면에서 이점을 가져가기 위한 조치다.\r\n\r\n## 리소스 소유자 암호 자격 승인 (Resource Owner Password Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179866-29962644-c0a7-42f8-a397-7b3b1c361082.png)\r\n\r\n* Service Provider에 ID, PW를 전달하여 Token을 전달받음\r\n* 보안 구조가 비밀번호 기반의 인증 뿐이므로 이를 구현하는 Consumer는 신뢰성이 매우 높아야 함\r\n\r\n``` input\r\nPOST /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=password\r\n&client_id=asj2y93bdjen3\r\n&username=username123\r\n&password=password123\r\n&scope=email,profile\r\n```\r\n\r\n|    구분    |           필수 여부            |                내용                 |\r\n| :--------: | :----------------------------: | :---------------------------------: |\r\n| grant_type | <span class=\"red-400\">Y</span> |  승인 타입으로, `password`로 고정   |\r\n| client_id  | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n|  username  | <span class=\"red-400\">Y</span> |               아이디                |\r\n|  password  | <span class=\"red-400\">Y</span> |              비밀번호               |\r\n|   scope    |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n    \"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n## 클라이언트 자격 승인 (Client Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179894-94e8f974-27cd-44b1-9c36-5e1d3dc69377.png)\r\n\r\n* 사용자가 Access Token을 외부 저장소에서 받아 인증하는 형식\r\n* 클라이언트 자체가 인증 수단이므로 절차가 매우 간소함\r\n* 통상 자기 자신의 정보만을 호출함\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=client_credentials\r\n&client_id=asj2y93bdjen3\r\n&client_secret=https://oauth2.example.com/callback\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                      내용                       |\r\n| :-----------: | :----------------------------: | :---------------------------------------------: |\r\n|  grant_type   | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `client_credentials`로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> |       Service Provider에서 제공한 API KEY       |\r\n| client_secret | <span class=\"red-400\">Y</span> |   Service Provider에서 제공한 API Secret KEY    |\r\n|     scope     |               N                |                    요청 권한                    |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n\t\"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n# 정리\r\n\r\n* OAuth2.0은 인증을 위한 표준 프로토콜으로, OAuth 프로토콜을 준수하는 서비스는 기본적으로 공통된 API를 사용해서 인증을 수행할 수 있다.\r\n* OAuth 프로토콜을 통해 인증 절차는 간소화하고, 보안 수준은 강화할 수 있다.\r\n* OAuth의 방식은 4가지로 구분되며, 보편적으로 인가 코드 승인 방식을 사용한다.\r\n* 암시적 승인은 Serverless 서비스나 앱에서 주로 사용된다.\r\n* 나머지 방식은 특수한 환경에서 사용된다.\r\n\r\n다음 장에서는 구축할 시스템의 구성에 대해 다룬다.\r\n\r\n# 참고\r\n\r\n* [IT위키 - OAuth](https://itwiki.kr/w/OAuth)\r\n* [Microsoft OAuth](https://docs.microsoft.com/ko-kr/azure/active-directory/develop/active-directory-v2-protocols)\r\n* [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)","url":["2021-10-14-oauth2-java-server-1","2021","10","14","oauth2-java-server-1"]}],"data":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 2. 인증서버 설계하기","excerpt":"OAuth2.0 프로토콜에 대한 사전 지식도 얻었으니, 이를 통해 인증서버를 직접 구축해보자. Frontend, Backend 부분으로 나누어 웹 페이지를 통해 소셜 로그인을 수행하고, 직접 구현한 인증서버에서 이를 처리하는 시스템 일체를 구축하는 것이 궁극적인 목표다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T22:12:25","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-2.md","content":"<h1 id=\"개요\">개요 <a href=\"#개요\">🔗</a></h1><p>OAuth2.0 프로토콜에 대한 사전 지식도 얻었으니, 이를 통해 인증서버를 직접 구축해보자.</p>\n<p>Frontend, Backend 부분으로 나누어 웹 페이지를 통해 <span class=\"red-400\">소셜 로그인을 수행</span>하고, 직접 구현한 <span class=\"red-400\">인증서버에서 이를 처리하는 시스템 일체를 구축</span>하는 것이 궁극적인 목표다.</p>\n<p>인증 서버의 인증 방식은 <span class=\"primary\">인가 코드 승인 (Authorization Code Grant)</span>을 취한다.</p>\n<h1 id=\"제원\">제원 <a href=\"#제원\">🔗</a></h1><p>웹 페이지인 Frontend와 API 통신의 주체가 되는 인증서버인 Backend로 나뉜다.</p>\n<h2 id=\"Backend\">Backend <a href=\"#Backend\">🔗</a></h2><p><b class=\"large green-600\">💬 Language</b></p>\n<ul>\n<li><a href=\"https://www.java.com/ko/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/java-v16.0.2-007396?logo=java&logoWidth=25\" alt=\"Java\"></a></li>\n</ul>\n<p><b class=\"large green-600\">🧱 Framework</b></p>\n<ul>\n<li><a href=\"https://gradle.org/\" target=\"_blank\"><img src=\"https://img.shields.io/badge/gradle-02303A?logo=gradle&logoWidth=25\" alt=\"Gradle\"></a></li>\n<li><img src=\"https://img.shields.io/badge/jakarta.servlet--api-v5.0.0-blue\" alt=\"jakarta.servlet-api\"></li>\n<li><img src=\"https://img.shields.io/badge/lombok-v1.18.20-blue\" alt=\"lombok\"></li>\n<li><img src=\"https://img.shields.io/badge/jjwt-v0.9.1-blue\" alt=\"jjwt\"></li>\n<li><img src=\"https://img.shields.io/badge/scribejava--apis-v8.3.1-blue\" alt=\"scribejava-apis\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--server-v3.0.3-blue\" alt=\"jersey-server\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--container--servlet-v3.0.3-blue\" alt=\"jersey-container-servlet\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--hk2-v3.0.3-blue\" alt=\"jersey-hk2\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--media--json--jackson-v3.0.3-blue\" alt=\"jersey-media-json-jackson\"></li>\n</ul>\n<p><b class=\"large green-600\">📦 Publish</b></p>\n<ul>\n<li><a href=\"http://tomcat.apache.org/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/Tomcat-v10.0.12-F8DC75?logo=apachetomcat&logoWidth=25&logoColor=FFF\" alt=\"Tomcat\"></a></li>\n<li><a href=\"https://www.raspberrypi.org/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/RaspberryPi-F00?logo=raspberrypi&logoWidth=25&logoColor=FFF\" alt=\"Raspberry Pi\"></a></li>\n</ul>\n<p>Jersey는 RESTful API 프레임워크, scribeJAVA는 OAuth 프레임워크다.</p>\n<p>Jersey 3는 Servlet 5.0 최신 스펙인 <code class=\"inline-code\">jakarta.*</code>을 사용한다. 때문에 이를 구현한 Tomcat 10을 사용한다. Tomcat 10 미만 혹은 <code class=\"inline-code\">jakarta.*</code>을 구현하지 않는 등 <b class=\"red-600\">최신 서블릿 스펙을 사용할 수 없는 WAS의 경우 이 프로젝트는 배포할 수 없다.</b></p>\n<h2 id=\"Frontend\">Frontend <a href=\"#Frontend\">🔗</a></h2><p><b class=\"large green-600\">💬 Language</b></p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML\" target=\"_blank\"><img src=\"http://img.shields.io/badge/HTML5-E34F26?logo=html5&logoWidth=25&logoColor=FFF\" alt=\"HTML5\"></a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript\" target=\"_blank\"><img src=\"http://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoWidth=25&logoColor=000\" alt=\"JavaScript\"></a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS\" target=\"_blank\"><img src=\"http://img.shields.io/badge/CSS3-1572B6?logo=css3&logoWidth=25\" alt=\"CSS3\"></a></li>\n</ul>\n<p><b class=\"large green-600\">🧱 Framework</b></p>\n<ul>\n<li><a href=\"https://eslint.org/\" target=\"_blank\"><img src=\"https://img.shields.io/badge/eslint-%5E7.32.0-4B32C3?logo=eslint&logoWidth=25\" alt=\"eslint\"></a></li>\n</ul>\n<p><b class=\"large green-600\">📦 Publish</b></p>\n<ul>\n<li><a href=\"https://pages.github.com/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/GitHub%20Pages-000?logo=github&logoWidth=25&logoColor=FFF\" alt=\"GitHub\"></a></li>\n</ul>\n<p>원래는 Raspberry Pi로 배포하고 있었으나, 굳이 그럴 필요가 없어서 GutHub Pages로 배포한다.</p>\n<p>Frontend는 단순히 인증 서버와의 API 통신 및 정보 표출 정도만 수행하므로, React 같은 복잡한 기술은 최대한 지양하고 최대한 기본 기능으로만 구성했다.</p>\n<h1 id=\"구성\">구성 <a href=\"#구성\">🔗</a></h1><p>인증서버는 크게 세 부분으로 나눌 수 있다.</p>\n<ul>\n<li><code class=\"inline-code\">controller</code> - 지정한 URL의 요청을 받아 process에게 위임한다.</li>\n<li><code class=\"inline-code\">process</code> - API의 동작을 수행하고, 응답을 생성한다</li>\n<li><code class=\"inline-code\">module</code> - API 동작 수행에 필요한 모듈</li>\n</ul>\n<p>이는 패키지로 구분한다.</p>\n<h2 id=\"controller\">controller <a href=\"#controller\">🔗</a></h2><p>Jersey 프레임워크는 <code class=\"inline-code\">controller</code> 영역에서 동작한다.</p>\n<p>기존의 Servlet은 RESTful API를 설계하기위해 직접 구현해야할 부분이 존재한다.</p>\n<p>RESTful API를 효과적으로 설계하기 위해 Jersey 프레임워크를 사용한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137264829-4e703edf-e682-4793-a2b1-675056cba087.png\" alt=\"image\"></p>\n<p>controller는 <span class=\"primary\">정의된 process로 요청을 전달하고, process가 반환하는 응답을 요청자에게 다시 전달</span>한다.</p>\n<ul>\n<li><p><code class=\"inline-code\">/login</code></p>\n<ul>\n<li>GET <code class=\"inline-code\">/:platform</code> - 플랫폼별 인증 URL 반환 API</li>\n<li>PUT <code class=\"inline-code\">/put</code> - 정보 제공 동의 갱신 URL 반환 API</li>\n<li>POST <code class=\"inline-code\">/:platform</code> - 플랫폼별 로그인 API</li>\n<li>POST <code class=\"inline-code\">/auto</code> - 자동 로그인 API</li>\n</ul>\n</li>\n<li><p><code class=\"inline-code\">/logout</code></p>\n<ul>\n<li>POST <code class=\"inline-code\">/</code> - 로그아웃 API</li>\n</ul>\n</li>\n<li><p><code class=\"inline-code\">/revoke</code></p>\n<ul>\n<li>POST <code class=\"inline-code\">/</code> - 연동 해제 API</li>\n</ul>\n</li>\n<li><p><code class=\"inline-code\">/userinfo</code></p>\n<ul>\n<li>POST <code class=\"inline-code\">/</code> - 사용자 정보 API</li>\n</ul>\n</li>\n</ul>\n<p>해당 프로젝트에선 위 <code class=\"inline-code\">controller</code>들이 구현될 것이다.</p>\n<h2 id=\"process\">process <a href=\"#process\">🔗</a></h2><p><code class=\"inline-code\">process</code>에선 실제 로직이 구현되는 영역이다. 이 때 필요하다면 <code class=\"inline-code\">module</code>을 호출하기도 한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137265824-a2652f3c-c32f-42cf-9b5e-8f523530895e.png\" alt=\"image\"></p>\n<p><code class=\"inline-code\">process</code>는 <span class=\"primary\">수행 결과를 정해진 형식의 JSON을 기반으로 응답 객체</span>를 만들어 <code class=\"inline-code\">controller</code>로 반환한다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JSON</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-json\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1>    flag<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    title<span class=\"token operator\">:</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    message<span class=\"token operator\">:</span> <span class=\"token string\">\"test api response success\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    body<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>        key1<span class=\"token operator\">:</span> <span class=\"token string\">\"value1\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>        key2<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        key3<span class=\"token operator\">:</span> <span class=\"token number\">4932</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>        key4<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>            <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>            <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11>            <span class=\"token string\">\"C\"</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12>        <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13>        key5<span class=\"token operator\">:</span> <span class=\"token number\">93.203</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">파라미터</th>\n<th align=\"center\">필수 여부</th>\n<th align=\"center\">데이터 형식</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">flag</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">boolean</code></td>\n<td align=\"center\">응답 정상 여부</td>\n</tr>\n<tr>\n<td align=\"center\">title</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">String</code></td>\n<td align=\"center\">응답 제목</td>\n</tr>\n<tr>\n<td align=\"center\">message</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">String</code></td>\n<td align=\"center\">응답 메세지</td>\n</tr>\n<tr>\n<td align=\"center\">body</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">String | Number | boolean | Array | Object</code></td>\n<td align=\"center\">응답 정상 여부</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>응답 명세는 위와 같다.</p>\n<p><code class=\"inline-code\">process</code>는 GET, POST 등 HTTP Method에 따라 나누어 관리한다.</p>\n<h2 id=\"module\">module <a href=\"#module\">🔗</a></h2><p>module은 여러 <code class=\"inline-code\">process</code>에서 <span class=\"primary\">반복적으로 사용되는 로직의 모듈화를 구현한 객체</span>다.</p>\n<p>이 중 핵심 기능인 OAuth의 인증을 처리하는 모듈은 scribeJAVA 기반으로 작성된다.</p>\n<p>로그인, 사용자 정보 요청 등 인증과 관련된 로직을 수행하는 <code class=\"inline-code\">process</code>들은 모두 위 모듈을 호출하여 사용함으로써 중복 코드를 줄이고 유지보수성을 높인다.</p>\n<h1 id=\"OAuth-모듈\">OAuth 모듈 <a href=\"#OAuth-모듈\">🔗</a></h1><p>이 프로젝트의 Backend에 가장 중요한 역할을 담당하는 모듈로, OAuth 인증을 구현한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137314562-675ee988-0dad-4937-93a1-73753c2afee4.png\" alt=\"image\"></p>\n<p>요즘은 어느정도 규모있는 플랫폼이라면 OAuth 서비스를 제공한다. 플랫폼은 달라도 OAuth를 준수한다면 모두 공통된 요청 받아 공통된 응답을 제공할 것이다. 공통 프로토콜을 사용하므로, 인증 모듈 하나를 만들어 모든 인증을 거기서 처리하면 될 것이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137314573-599b1317-0e46-4698-ac65-04fef57933e8.png\" alt=\"image\"></p>\n<p>하지만 문제가 하나 있다. 아무리 공통 프로토콜을 사용한다지만, <span class=\"red-400\">플랫폼마다 추가적인 파라미터 혹은 헤더를 요구</span>하기도 한다. 조건문을 떡칠한다면 모를까, 고작 인증 모듈 하나에서 플랫폼별 요구사항을 하나하나 처리하기엔 문제가 많다. 조건문을 통한 분기 역시 유지보수적인 측면에서 그리 좋은 방식은 아니다.</p>\n<br />\n<br />\n\n<p>OAuth는 객체라기보단 일종의 개념에 더 가깝다. 이렇게 추상적인 개념의 형태는 JAVA의 인터페이스 내지는 추상 객체가 적합하다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137314582-cf0c24f7-5ad3-42f8-a7d7-de19e59c8582.png\" alt=\"image\"></p>\n<p>인증 모듈의 경우, 몇몇 플랫폼의 특이 사항으로 인해 문제가 발생하니, 기본적으로는 <span class=\"blue-600\">인증 모듈의 공통 로직을 사용하되, 추가적인 요구를 하는 플랫폼에 한해 로직을 변경하는 것이 효율적</span>일 것이다. 따라서 인증 모듈은 인터페이스보단 추상 객체가 더 어울릴 것이다.</p>\n<p>이렇게 인증 추상 모듈을 하나 생성하고, 각 소셜 플랫폼마다 인증 모듈을 상속받아 구현하게끔 설계하면 될 것이다.</p>\n<p>문제가 없는 플랫폼은 기 선언된 인증 모듈의 메서드를 그대로 사용하고, <span class=\"blue-600\">추가 요구사항이 있는 플랫폼은 해당 플랫폼의 인증 모듈에서 메서드를 오버라이딩</span>하여 요구사항에 맞게 재설계한다.</p>\n<h2 id=\"인증-모듈 기능\">인증 모듈 기능 <a href=\"#인증-모듈 기능\">🔗</a></h2><p>구현해야할 기능은 아래와 같다.</p>\n<ul>\n<li>플랫폼 로그인 URL 생성 로직</li>\n<li>정보 제공 동의 갱신 URL 생성 로직</li>\n<li>서비스 로그인 로직 (인가코드 -> Access Token)</li>\n<li>자동 로그인 로직</li>\n<li>로그아웃 로직</li>\n<li>사용자 정보 호출 로직</li>\n<li>연동 해제 로직</li>\n</ul>\n<p>최소한 위 기능이 구현되어야한다.</p>\n<p>사용자 정보 호출의 경우, 플랫폼마다 주는 응답이 천차만별로 다르다.</p>\n<p>사용자 정보는 OAuth로 전달받은 Access Token으로 Service Provider에 정보를 요청하여 받을 수 있다. OAuth는 어디까지나 인증을 받기 위한 표준 프로토콜로, <span class=\"red-400\">인증 토큰을 통해 수행하는 부가적인 활동에 대해서는 별다른 제약이 없으므로</span>, Access Token 발급 이후의 API 요청 및 응답은 플랫폼마다 천차만별로 다르다.</p>\n<p>때문에 사용자 정보 호출 로직의 경우, OAuth 표준 프로토콜에 구애받지 않는다. 이에 대응하기 위해 추상 메서드로 선언하여 각 모듈에서 응답을 정제하여 반환하도록 강제하자.</p>\n<h1 id=\"구조도\">구조도 <a href=\"#구조도\">🔗</a></h1><p><img src=\"https://user-images.githubusercontent.com/50317129/137319720-28a6d25b-6128-4873-bbb4-b0e0f5cce847.png\" alt=\"image\"></p>\n<p>OAuth 모듈을 사용하는 API의 구조를 도식화하면 위와 같다.</p>\n<p>Jersey가 URL을 캐치하여 정해진 process로 전달한다. process는 인증을 수행하기 위해 해당 플랫폼의 OAuth 구현체를 호출하여 로직을 수행할 것이다. 이후 결과가 반환되어 사용자에게 전달되는 구조다.</p>\n<h1 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h1><p>지금까지 인증 서버에 대한 설계를 진행했다. 다음 장엔 위 설계를 토대로 인증 서버를 본격적으로 구축해본다. 그 중에서도 scribeJAVA와 OAuth 인증 모듈에 대해 다룰 예정이다.</p>\n<p>구축 순서는 module -> process -> controller 순이다.</p>\n<p>가장 안쪽에 위치한 프로세스가 module이므로, module에서부터 바깥쪽으로 순차적으로 구현할 예정이다.</p>\n","url":["2021-10-14-oauth2-java-server-2","2021","10","14","oauth2-java-server-2"],"toc":[{"text":"개요","tag":"개요","depth":1},{"text":"제원","tag":"제원","depth":1},{"text":"Backend","tag":"Backend","depth":2},{"text":"Frontend","tag":"Frontend","depth":2},{"text":"구성","tag":"구성","depth":1},{"text":"controller","tag":"controller","depth":2},{"text":"process","tag":"process","depth":2},{"text":"module","tag":"module","depth":2},{"text":"OAuth 모듈","tag":"OAuth-모듈","depth":1},{"text":"인증 모듈 기능","tag":"인증-모듈 기능","depth":2},{"text":"구조도","tag":"구조도","depth":1},{"text":"정리","tag":"정리","depth":1}]},"hash":"be28863335a"},"__N_SSG":true}