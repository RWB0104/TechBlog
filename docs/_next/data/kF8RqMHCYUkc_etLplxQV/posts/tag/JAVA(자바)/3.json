{"pageProps":{"posts":[{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1019번 책 페이지","excerpt":"지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1페이지이고, 마지막 페이지는 N페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-28T12:28:50","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-28-a1019.md","content":"\r\n# 책 페이지\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1019번 문제](https://www.acmicpc.net/problem/1019)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 전체 페이지의 수가 $N$인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 $N$페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$이 주어진다. $N$은 $1,000,000,000$보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 4 1 1 1 1 1 1 1 1\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 명확하고 직관적이다. 1페이지부터 $N$페이지까지 나열할 때, <span class=\"green-400\">숫자가 사용된 수를 각 숫자별로 나타내는 문제</span>.\r\n\r\n165라는 숫자를 표기하기 위해선 $[ 1, 5, 6 ]$이 사용된다. 이렇게 <span class=\"green-400\">1부터 해당 숫자까지의 모든 숫자를 표현하기 위해 사용한 숫자의 수를 0부터 오름차순으로 출력</span>하면 된다. \r\n\r\n즉, $N = 5$라고 가정하면, 페이지 배열은 $[ 1, 2, 3, 4, 5 ]$까지 나열된다. 각 숫자가 사용된 수를 표로 나타내면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n1부터 5까지 나열하는데, 각각 숫자 하나씩 사용했으니 위 처럼 표시할 수 있다. 그렇다면 예제의 11은 어떨까?\r\n\r\n$[ 1, 2, 3, \\dots, 10, 11 ]$까지 나열된다. \r\n\r\n1부터 9까지는 각각 숫자가 하나씩 사용되며, 10은 1과 0이 사용되고, 11은 1이 두 개 사용된다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n위의 표만큼 숫자가 사용됐다. 이해를 위해 $N = 13$일 경우를 하나 더 해보자.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n$12 = [ 1, 2 ]$, $13 = [ 1, 3 ]$이 된다. 1 ~ 13에는 11도 포함되기 때문에, 11의 결과에 12, 13의 값을 각각 더해줘도 상관없다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n이 정도면 알고리즘이 원하는 게 무엇인지 이해했으리라 생각한다.\r\n\r\n## 🔎규칙 찾아보기\r\n\r\n사실 무식하게 접근하면, 그리 어려운 문제는 아니다. 하나하나 반복문 돌려가며 숫자 분해해서 해당하는 숫자의 배열에 집어넣으면 그만이니. 하지만 안타깝게도, 변수 $N$의 최대값은 10억 ~~(다행히 int의 최대값은 넘지 않는다.)~~ 에 육박한다. 그 말인즉는 무식하게 접근하면 안 된다는 의미.\r\n\r\n그렇다면 어딘가에 존재하는 규칙성을 발견해서 일반식을 설계해야한다는 뜻인데, 이럴땐 하나하나 나열해보면 알 수 있을 것이다.\r\n\r\n|   N   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   0   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   2   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   3   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   4   |   0   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |\r\n|   5   |   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   6   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |\r\n|   7   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |\r\n|   8   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |\r\n|   9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  10   |   1   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  11   |   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  12   |   1   |   5   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  13   |   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  14   |   1   |   7   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |\r\n|  15   |   1   |   8   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |\r\n|  16   |   1   |   9   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |\r\n|  17   |   1   |  10   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |\r\n|  18   |   1   |  11   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |\r\n|  19   |   1   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  20   |   2   |  12   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  21   |   2   |  13   |   4   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  22   |   2   |  13   |   6   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  23   |   2   |  13   |   7   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n\r\n규칙성을 찾아보기 위해 20 받고 살짝 더 얹어서 사용된 숫자를 나열해보았다. 어떤 패턴이 보이는 것 같긴 하다.\r\n\r\n1. 0은 10의 배수마다 1씩 증가한다.\r\n2. 각 1의 자리마다 해당하는 숫자가 1씩 증가하며, 값은 10의 자릿수 + 1이다.\r\n3. 10의 자릿수는 해당하는 숫자를 1씩 증가시킨다.\r\n\r\n그냥 쳐다보면 규칙성을 찾기 좀 어려울 수 있다. 해답은 <span class=\"red-400\">*0 ~ *9</span> 구간에 있다. 예를 들어, 10 ~ 29까지 나열해보자. 1부터 시작하는 것이 아니라, 임의의 구간 $A ~ B$를 기준으로 알고리즘을 계산한다고 가정하는 것이다.\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>10</td>\r\n\t\t\t\t<td>11</td>\r\n\t\t\t\t<td>12</td>\r\n\t\t\t\t<td>13</td>\r\n\t\t\t\t<td>14</td>\r\n\t\t\t\t<td>15</td>\r\n\t\t\t\t<td>16</td>\r\n\t\t\t\t<td>17</td>\r\n\t\t\t\t<td>18</td>\r\n\t\t\t\t<td>19</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>20</td>\r\n\t\t\t\t<td>21</td>\r\n\t\t\t\t<td>22</td>\r\n\t\t\t\t<td>23</td>\r\n\t\t\t\t<td>24</td>\r\n\t\t\t\t<td>25</td>\r\n\t\t\t\t<td>26</td>\r\n\t\t\t\t<td>27</td>\r\n\t\t\t\t<td>28</td>\r\n\t\t\t\t<td>29</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n위 표의 숫자들을 잘 보면, 1의 자리 숫자는 각각 하나씩 사용하는 것을 확인할 수 있다.\r\n\r\n## 1의 자리에서의 규칙\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>1<span class=\"red-A400\">0</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">1</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">2</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">3</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">4</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">5</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">6</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">7</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">8</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">9</span></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>2<span class=\"red-A400\">0</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">1</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">2</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">3</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">4</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">5</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">6</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">7</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">8</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">9</span></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n이제 좀 규칙성이 눈에 띄기 시작한다. 20 ~ 39와 같은 <span class=\"red-400\">*0 ~ *9</span> 형태의 범위에선 1의 자리에 해당하는 모든 숫자가 동일하게 사용된다. 10 ~ 19, 20 ~ 29 두 구간이 있으므로 각 구간별로 1씩 모든 숫자가 두 번 사용됐다.\r\n\r\n시작 페이지를 $n$, 마지막 페이지를 $N$이라고 가정할 때, 위 규칙을 일반식으로 표현하면 아래와 같다.\r\n\r\n$$\r\n(N \\div 10) - (n \\div 10) + 1 = \\text{1의 자리에 사용된 각각의 숫자 갯수}\r\n$$\r\n\r\n따라서 10 ~ 29 범위에서 모든 숫자는 두 번 사용된 것임을 알 수 있다.\r\n\r\n## p의 자리에서의 규칙\r\n\r\n문제는 위 식은 <span class=\"orange-400\">1의 자리에서만 적용되는 수식</span>이다. 페이지는 최대 10의 자리까지 존재할 수 있다. 즉, 통용되는 일반식을 구해야한다.\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>0</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>1</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>2</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>3</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>4</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>5</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>6</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>7</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>8</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>9</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>0</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>1</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>2</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>3</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>4</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>5</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>6</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>7</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>8</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>9</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n반대로 10의 자리수를 자세히 보자. 1이 10번 사용된다. 만약 100 ~ 199 구간이라면 1은 100개가 사용될 것이고, 1000 ~ 1999 구간이라면 1은 1000개가 사용될 것이다.\r\n\r\n쉽게 설명하기 위해 10 ~ 19, 100 ~ 199, 1000 ~ 1999 등 $n0* ~ n9*$ 같은 형태의 구간을 단위 구간이라고 정의하자. 이 때, 해당 구간에서 $n$이 사용되는 갯수는 아래와 같이 정의할 수 있다.\r\n\r\n$$\r\n((N \\div 10) - (n \\div 10) + 1) \\times \\text{p} = \\text{각각의 숫자 갯수}\r\n$$\r\n\r\n* $n$: 구간 시작 값\r\n* $N$: 구간 끝 값\r\n* $p$: 자릿수\r\n\r\n## 구간 보정하기\r\n\r\n이제 구간만 맞으면 호출되는 숫자를 구할 수는 있지만, 아직 제한적이다.\r\n\r\n우선, 본 알고리즘에서 시작 값은 1로 고정이다. 끝 값인 $N$ 역시 반드시 199와 같은 단위 구간의 형태로 들어오지도 않는다. 만약 $N = 35$라면 우리는 1 ~ 35 구간에 알고리즘을 적용해야 한다. 구간이 10 ~ 39라면 모를까, 형태가 전혀 다른 구간에는 위 일반식이 적용되지 않는다.\r\n\r\n해결 방법은 간단하다. 가늠좌 클리크 조정하듯이 구간에 맞게 값을 더하고 빼서 조정해주면 된다.\r\n\r\n1 ~ 35 구간에서, 1의 경우, 1보다 크며 0을 포함한 수 중 가장 가까운 값은 10이다. 따라서, 시작 값은 10까지 증가시키며, 증가시킨 숫자를 카운팅한다. 1부터 9까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n35의 경우 35보다 작으며 9를 포함한 수 중 가장 가까운 수는 29다. 마찬가지로 마지막 값은 29까지 감소시키며, 감소한 숫자를 카운팅한다. 35부터 30까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n즉, 초기값은 위 보정값을 더한 배열이며, 이후 계산은 계산된 초기값에 누적한다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| **1** | **2** | **2** | **8** | **2** | **2** | **1** | **1** | **1** | **1** |\r\n\r\n## 자릿수 보정하기\r\n\r\n$N = 1999$, $n = 1000$일 때, 1의 자리에 사용된 숫자의 갯수를 구하면 아래와 같다.\r\n\r\n$$\r\n((1999 / 10) - (1000 / 10) + 1) \\times 1 = 100\r\n$$\r\n\r\n1의 자리에서 각 숫자는 100개씩 사용됐다. 10의 자리에서는 어떨까?\r\n\r\n$N$, $n$을 각각 10으로 나누면 10의 자리에 대한 구간을 얻을 수 있다. 나눠진 숫자를 위의 일반식에 적용하면 된다.\r\n\r\n$$\r\n((199 / 10) - (100 / 10) + 1) \\times 10 = 100\r\n$$\r\n\r\n100의 자리는 $N$, $n$을 각각 100으로 나누어 계산하면 된다.\r\n\r\n$$\r\n((19 / 10) - (10 / 10) + 1) \\times 100 = 100\r\n$$\r\n\r\n1000의 자리는 $N$, $n$을 각각 1000으로 나누어 계산하면 된다. 그러나 $N = n = 1$이므로, 1에만 1000개가 사용된다.\r\n\r\n|  $p$  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  10   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n| 1000  |   0   | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|       |  300  | 1300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n따라서 1000 ~ 1999 구간은 위와 같이 계산된다.\r\n\r\n## 📃일반식 적용하기\r\n\r\n완벽한 이해를 위해, 위 개념을 토대로 $N = 4153$일 경우의 알고리즘을 계산해보자.\r\n\r\n$N = 4153$이므로, 구간은 1 ~ 4153이다.\r\n\r\n### 시작 페이지 구간 보정하기\r\n\r\n1보다 큰 수 중 1의 자리가 0인 가장 가까운 수 10까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n1부터 9까지 이동하여 10에 도착하므로, 1 ~ 9를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n### 마지막 페이지 구간 보정하기\r\n\r\n4153보다 작은 수 중 1의 자리가 9인 가장 가까운 수 4149까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n4153부터 4150까지 이동하여 4149까지 도착하므로, 이를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 4153  |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4152  |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4151  |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4150  |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n### 1의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 4149을 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((4149 / 10) - (10 / 10) + 1) \\times 1 = 414 - 1 + 1 = 414\r\n$$\r\n\r\n|   구분   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1의 자리 |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n\r\n### 10의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 1의 자리 일반식 구간 4149, 10을 각각 10으로 나눈다.\r\n\r\n10의 자리에 대한 구간은 $1 ~ 414$가 된다. 마찬가지로 일반식 적용을 위해 구간을 보정한다. 10의 자리이므로, <span class=\"red-400\">1 -> 2로의 이동은 실제로 10 -> 20으로의 이동임에 주의</span>하자.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  414  |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|  413  |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  412  |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  411  |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  410  |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 10의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 409를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((409 / 10) - (10 / 10) + 1) \\times 10 = (40 - 1 + 1) \\times 10 = 400\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n\r\n### 100의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 10의 자리 일반식 구간 409, 10을 각각 10으로 나눈다.\r\n\r\n100의 자리에 대한 구간은 $1 ~ 40$이 된다. 나머지는 10의 자리 프로세스와 동일하다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  40   |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 100의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 39를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((39 / 10) - (10 / 10) + 1) \\times 100 = (3 - 1 + 1) \\times 100 = 300\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n### 1000의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 100의 자리 일반식 구간 39, 10을 각각 10으로 나눈다.\r\n\r\n1000의 자리에 대한 구간은 $1 ~ 3$이 된다.\r\n\r\n여기서 문제가 하나 있는데, 마지막 구간에서 일의 자리가 9인 가장 작은 수는 -9다. 음수가 올 수 없으므로, 더 이상의 일반식 연산은 불가능하며, 개별적으로 더해주면 된다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 3 |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 총합 계산하기\r\n\r\n단계별로 구한 숫자를 정리하여 총합을 표로 나타낸다.\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1 ~ 9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   4153    |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4152    |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4151    |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4150    |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 1의 자리  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n|   1 ~ 9   |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n|    414    |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|    413    |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    412    |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    411    |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    410    |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n|   1 ~ 9   |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|    40     |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n|   1 ~ 3   |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   총합    | 1225  | 2290  | 2236  | 2236  | 1389  | 1229  | 1225  | 1225  | 1225  | 1225  |\r\n\r\n구간 1 ~ 4153에 대한 알고리즘 결과는 위와 같다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 백준 전체 1019 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/28/a1019\">1019 풀이</a>\r\n * @since 2021.06.28 Mon 12:28:50\r\n */\r\npublic class Main\r\n{\r\n\t// 숫자 카운트 배열\r\n\tprivate static final int[] counter = new int[10];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 마지막 페이지\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tsolve(N);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int item : counter)\r\n\t\t{\r\n\t\t\tbuilder.append(item).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(builder.toString().trim());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\treader.close();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 동작 함수\r\n\t *\r\n\t * @param num: [int] 마지막 페이지\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\t// 시작 페이지\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 자릿수\r\n\t\tint digit = 1;\r\n\t\t\r\n\t\twhile (start <= num)\r\n\t\t{\r\n\t\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\t\tcount(num, digit);\r\n\t\t\t\t\r\n\t\t\t\tnum--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\t\tif (num < start)\r\n\t\t\t{\r\n\t\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\t\tcount(start, digit);\r\n\t\t\t\t\r\n\t\t\t\tstart++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstart /= 10;\r\n\t\t\tnum /= 10;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 10; i++)\r\n\t\t\t{\r\n\t\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 자릿수 증가\r\n\t\t\tdigit *= 10;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 카운트 함수\r\n\t *\r\n\t * @param num: [int] 대상 숫자\r\n\t * @param digit: [int] 자릿수\r\n\t */\r\n\tprivate static void count(int num, int digit)\r\n\t{\r\n\t\twhile (num > 0)\r\n\t\t{\r\n\t\t\tcounter[num % 10] += digit;\r\n\t\t\tnum /= 10;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$N = 4153$일 때, 구간을 보정하는 과정에서 4153, 4152와 같은 수를 별도로 카운팅해야한다.\r\n\r\n``` java\r\n/**\r\n * 카운트 함수\r\n *\r\n * @param num: [int] 대상 숫자\r\n * @param digit: [int] 자릿수\r\n */\r\nprivate static void count(int num, int digit)\r\n{\r\n\twhile (num > 0)\r\n\t{\r\n\t\tcounter[num % 10] += digit;\r\n\t\tnum /= 10;\r\n\t}\r\n}\r\n```\r\n\r\n로직은 어렵지 않다. 4152의 경우 $[ 4, 1, 5, 2 ]$로 이루어져있으므로, 해당하는 숫자에 자릿수만큼 카운팅(1이면 1개, 10이면 10개)하면 된다.\r\n\r\n1의 자리는 $4152 \\,\\,\\, \\% \\,\\,\\, 10 = 2$와 같이 구할 수 있다. 10의 자리는 4152를 10으로 한 번 나누고 방금의 연산을 다시 진행하면 된다.  \r\n100, 1000 등 자릿수만큼 반복하여 계산하면 된다.\r\n\r\n``` java\r\n/**\r\n * 알고리즘 동작 함수\r\n *\r\n * @param num: [int] 마지막 페이지\r\n */\r\nprivate static void solve(int num)\r\n{\r\n\t// 시작 페이지\r\n\tint start = 1;\r\n\t\r\n\t// 자릿수\r\n\tint digit = 1;\r\n\t\r\n\twhile (start <= num)\r\n\t{\r\n\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t{\r\n\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\tcount(num, digit);\r\n\t\t\t\r\n\t\t\tnum--;\r\n\t\t}\r\n\t\t\r\n\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\tif (num < start)\r\n\t\t{\r\n\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t{\r\n\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\tcount(start, digit);\r\n\t\t\t\r\n\t\t\tstart++;\r\n\t\t}\r\n\t\t\r\n\t\tstart /= 10;\r\n\t\tnum /= 10;\r\n\t\t\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t}\r\n\t\t\r\n\t\t// 자릿수 증가\r\n\t\tdigit *= 10;\r\n\t}\r\n}\r\n```\r\n\r\n시작 페이지는 무조건 1로 고정이다. 시작 페이지가 마지막 페이지보다 커질 때까지 반복한다.\r\n\r\n첫 번째 `while`문에서 마지막 페이지를 1씩 감소시켜 9로 끝나는 구간으로 보정한다. 중간에 조건문이 있는데, 이 처리를 해주지 않으면 `num`이 9보다 작을 경우 연산 과정에서 `start`가 `num`을 초과하지 못해 무한루프를 타게 된다.\r\n\r\n두 번째 `while`문은 1페이지를 1씩 증가시켜 0으로 끝나는 구간으로 보정한다. 보정된 모든 값은 `count` 메소드를 통해 별도로 카운팅된다.\r\n\r\n위 과정을 통해 구간을 맞췄으니, 나머지는 위에 언급한 수식을 적용하고, 이를 반복한다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-28-a1019","2021","06","28","a1019"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1018번 체스판 다시 칠하기","excerpt":"지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8*8 크기의 체스판으로 만들려고 한다. 체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다. 보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8 X 8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-26T16:46:20","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER V","Brute Force(무차별 대입 공격)"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-26-a1018.md","content":"\r\n# 체스판 다시 칠하기\r\n\r\n# h1\r\n## h2\r\n\r\n\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1018번 문제](https://www.acmicpc.net/problem/1018)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 $M \\times N$ 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 $8 \\times 8$ 크기의 체스판으로 만들려고 한다.\r\n\r\n체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.\r\n\r\n보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 $8 \\times 8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 $8 \\times 8$ 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$과 $M$이 주어진다. $N$과 $M$은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 $N$개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n8 8\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBBBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n10 13\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nWWWWWWWWWWBWB\r\nWWWWWWWWWWBWB\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n12\r\n```\r\n\r\n# 풀이\r\n\r\n각 칸이 흰색 또는 검은색으로 칠해진 커다란 판에서 임의의 위치부터 $8 \\times 8$ 크기로 잘라 체스판을 만든다. 그 중 가장 적은 칸을 칠하여 체스판을 만들고자 할 때, 칠해야하는 최소값을 구하는 문제. 주어진 변수의 범위가 적어 그냥 무식하게 하나하나 비교하면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507886-2430ea00-d6a7-11eb-8c98-eecd7655f352.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 처럼 $N \\times M$의 배열에서 무작위 $8 \\times 8$ 크기의 배열을 뽑아내야한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507891-2c892500-d6a7-11eb-85b3-eb4d7803450d.png\" width=\"800px\" />\r\n</p>\r\n\r\n$10 \\times 10$짜리 배열을 기준으로, 해당 판에서 $8 \\times 8$ 배열을 선택하는 경우의 수는 총 9가지이며, 이를 도식화하면 위 그림과 같다. 이처럼 전체 배열에서 $8 \\times 8$만큼 한 칸씩 이동하며 비교하면 된다.\r\n\r\n``` java\r\nfor (int n = 0; n < N - 7; n++)\r\n{\r\n\tfor (int m = 0; m < M - 7; m++)\r\n\t{\r\n\t\t// TODO\r\n\t}\r\n}\r\n```\r\n\r\n위 코드와 같이 기술하면 가로부터 한 칸씩 이동하며, 끝에 도달할 경우 세로로 한 칸 이동한 뒤 다시 가로부터 한 칸씩 이동할 것이다. `n < N - 7`인 이유는 비교할 배열의 세로 길이가 8이기 때문. 살짝 헷갈린다면 `n <= N - 8`으로 대체해도 무방하다.\r\n\r\n체스판에는 두 가지 경우의 수가 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507898-33179c80-d6a7-11eb-9f2e-71a4829134df.png\" width=\"700px\" />\r\n</p>\r\n\r\n체스판의 상단 좌측을 기준으로 하얀색으로 시작하는 판과, 검은색으로 시작하는 판으로 두 가지가 존재한다. 하얀색을 `true`, 검은색을 `false`로 치환하여 하얀색 체스판과 검은색 체스판을 만들어 비교할 것이다.\r\n\r\n``` java\r\n// 상단 좌측이 하얀색으로 시작하는 체스판\r\nprivate static final boolean[][] WHITE = {\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n};\r\n\r\n// 상단 좌측이 검은색으로 시작하는 체스판\r\nprivate static final boolean[][] BLACK = {\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n};\r\n```\r\n\r\n코드는 위와 같다. 흑백과 같이 이지선다일 경우 `boolean`을 사용하는 것을 더 선호하므로 위와 같이 설계했다. `String` 배열로 \"W\", \"B\"를 넣어 만들어도 비교만 잘 해준다면 크게 상관없다. 이를 $8 \\times 8$의 모든 경우의 수와 비교하여 가장 작은 수를 출력하면 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1018 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/26/a1018\">1018 풀이</a>\r\n * @since 2021.06.26 Sat 16:46:20\r\n */\r\npublic class Main\r\n{\r\n\t// 상단 좌측이 하얀색으로 시작하는 체스판\r\n\tprivate static final boolean[][] WHITE = {\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t};\r\n\t\r\n\t// 상단 좌측이 검은색으로 시작하는 체스판\r\n\tprivate static final boolean[][] BLACK = {\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t};\r\n\t\r\n\t// 체스판\r\n\tprivate static boolean[][] board;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tint[] temp = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 세로 길이\r\n\t\tint N = temp[0];\r\n\t\t\r\n\t\t// 가로 길이\r\n\t\tint M = temp[1];\r\n\t\t\r\n\t\tboard = new boolean[N][M];\r\n\t\t\r\n\t\tfor (int n = 0; n < N; n++)\r\n\t\t{\r\n\t\t\tString[] line = reader.readLine().split(\"\");\r\n\t\t\t\r\n\t\t\tfor (int m = 0; m < M; m++)\r\n\t\t\t{\r\n\t\t\t\tboard[n][m] = line[m].equals(\"W\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 결과\r\n\t\tint result = Integer.MAX_VALUE;\r\n\t\t\r\n\t\t// 0 ~ 7까지 총 8칸을 전달하므로 최대값에서 7을 뺀다.\r\n\t\tfor (int n = 0; n < N - 7; n++)\r\n\t\t{\r\n\t\t\tfor (int m = 0; m < M - 7; m++)\r\n\t\t\t{\r\n\t\t\t\tint count = solve(n, m);\r\n\t\t\t\t\r\n\t\t\t\t// 현재 결과보다 더 작은 수일 경우\r\n\t\t\t\tif (result > count)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = count;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(Integer.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 새로 덧칠할 칸의 갯수 반환 함수\r\n\t *\r\n\t * @param x: [int] x의 시작좌표\r\n\t * @param y: [int] y의 시작좌표\r\n\t *\r\n\t * @return [int] 새로 덧칠할 칸의 갯수\r\n\t */\r\n\tprivate static int solve(int x, int y)\r\n\t{\r\n\t\tint white = 0;\r\n\t\tint black = 0;\r\n\t\t\r\n\t\tfor (int n = x; n < x + 8; n++)\r\n\t\t{\r\n\t\t\tfor (int m = y; m < y + 8; m++)\r\n\t\t\t{\r\n\t\t\t\t// 하얀색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\t\tif (board[n][m] != WHITE[n - x][m - y])\r\n\t\t\t\t{\r\n\t\t\t\t\twhite++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 검은색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\t\tif (board[n][m] != BLACK[n - x][m - y])\r\n\t\t\t\t{\r\n\t\t\t\t\tblack++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 둘 중 더 적게 칠할 수 있는 체스판의 값을 반환\r\n\t\treturn Math.min(white, black);\r\n\t}\r\n}\r\n```\r\n\r\n처음에 설계했을 땐, 잘라낸 $8 \\times 8$ 배열 `board`의 좌측 상단값인 `board[x][y]`의 색을 찾아서, 하얀색(true)일 경우 `WHITE`를, 검은색(false)일 경우 `BLACK`을 갖고 비교했는데 계속 틀렸다. 아래 케이스를 보면 이해가 쉽다.\r\n\r\n+ 입력\r\n\r\n``` tc\r\n8 8\r\nBBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\n```\r\n\r\n+ 출력\r\n\r\n```\r\n1\r\n```\r\n\r\n전체 판 자체가 $8 \\times 8$이므로 경우의 수는 판 자체로 하나다. 만약 처음 설계한대로 동작한다면 위 케이스에서 문제가 발생한다.\r\n\r\n위 케이스의 $board[0][0] = false$이므로 `BLACK`과 비교하게 된다. 이러면 $board[0][0]$를 제외한 나머지 63개의 칸을 전부 칠해야한다. 그런데 저 케이스, 자세히 한 번 보자. 사실 $board[0][0]$만 하얀색(true)로 칠해주면 그만이다. 즉, `BLACK`이 아닌 `WHITE`와 비교하면 값이 1인 것이다.\r\n\r\n``` java\r\n/**\r\n * 새로 덧칠할 칸의 갯수 반환 함수\r\n *\r\n * @param x: [int] x의 시작좌표\r\n * @param y: [int] y의 시작좌표\r\n *\r\n * @return [int] 새로 덧칠할 칸의 갯수\r\n */\r\nprivate static int solve(int x, int y)\r\n{\r\n\tint white = 0;\r\n\tint black = 0;\r\n\t\r\n\tfor (int n = x; n < x + 8; n++)\r\n\t{\r\n\t\tfor (int m = y; m < y + 8; m++)\r\n\t\t{\r\n\t\t\t// 하얀색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\tif (board[n][m] != WHITE[n - x][m - y])\r\n\t\t\t{\r\n\t\t\t\twhite++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 검은색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\tif (board[n][m] != BLACK[n - x][m - y])\r\n\t\t\t{\r\n\t\t\t\tblack++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 둘 중 더 적게 칠할 수 있는 체스판의 값을 반환\r\n\treturn Math.min(white, black);\r\n}\r\n```\r\n\r\n`solve()` 메소드는 알고리즘의 핵심 동작이다. `WHITE`와 `BLACK`을 전부 비교하는 이유가 여기에 있는데, 현재 배열에서 `WHITE`와 `BLACK`을 만드는데 필요한 칸의 숫자를 각각 구해서, 그 중 더 작은 수를 반환해야 올바르게 동작한다.\r\n\r\n## 분류\r\n\r\n* 브루트포스 알고리즘","url":["2021-06-26-a1018","2021","06","26","a1018"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1017번 소수 쌍","excerpt":"지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, {1, 4, 7, 10, 11, 12}가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다. 1 + 4 = $, 7 + 10 = 17$, $11 + 12 = 23 또는 1 + 10 = 11, 4 + 7 = 11, 11 + 12 = 23 수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 1 + 12 = 13으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-26T03:19:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM III","에라토스 테네스의 체","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-26-a1017.md","content":"\r\n# 소수 쌍\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1017번 문제](https://www.acmicpc.net/problem/1017)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, ${1, 4, 7, 10, 11, 12}$가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다.\r\n\r\n$1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$  \r\n또는  \r\n$1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$\r\n\r\n수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 $1 + 12 = 13$으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 리스트의 크기 $N$이 주어진다. N은 50보다 작거나 같은 자연수이며, 짝수이다. 둘째 줄에 리스트에 들어있는 수가 주어진다. 리스트에 들어있는 수는 1,000보다 작거나 같은 자연수이며, 중복되지 않는다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 정답을 출력한다. 없으면 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n6\r\n1 4 7 10 11 12\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4 10\r\n```\r\n\r\n# 풀이\r\n\r\n[1014번 컨닝](/posts/2021/06/23/a1014)문제를 통해 <span class=\"primary\">이분 매칭</span>을 접한 덕분인지, 지금까지 푼 <span class=\"teal-A400\">플래티넘</span> 중에서는 그나마 좀 이해되는 문제였다.\r\n\r\n역시 내용이 다소 난해한데, 알고리즘이 요구하는 동작은 다음과 같이 정리할 수 있다. 입력된 6개의 숫자 배열 ${ 1, 4, 7, 10, 11, 12 }$이 있다고 가정하자. 배열의 숫자를 한 쌍씩 짝지어 더하면 총 3개의 수가 나온다. 이렇게 <span class=\"red-A400\">짝지어 더한 수가 모두 소수일 경우, 입력의 첫 번째 숫자와 매칭된 숫자들을 오름차순으로 정렬하여 출력</span>하는 문제다.\r\n\r\n예제에서도 설명해주듯이, 짝지은 수가 모두 소수인 경우는 $1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$과 $1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$가 된다. 입력의 가장 첫 번째 숫자가 1이므로, 1와 매칭된 4, 10이 정답이 된다.\r\n\r\n## 소수 판별하기🍳\r\n\r\n이제 좀 더 세부적인 내용을 살펴보자. 문제 해결의 핵심은 <span class=\"primary\">소수</span>다. 이 알고리즘에선 소수 판별이 필요하다. 많은 판별방법이 있지만, 가장 대표적인 <span class=\"primary\">에라토스 테네스의 체</span>를 활용하면 어렵지 않게 해결할 수 있다.\r\n\r\n## 요소 한 쌍씩 그룹화하기\r\n\r\n소수 판별 방법도 마련했겠다, 입력된 숫자 배열을 적절히 짝지어야한다. <span class=\"lightBlue-A400\">핵심은 짝지은 수의 합이 소수</span>가 되는 것. 요소를 한번씩 다 더해보는 방법도 있겠지만, 배열의 크기가 커질 수록 요구되는 연산량 또한 높아지므로 적절하지 않다. 즉, 가능성 있는 조합으로만 그룹화해야한다.\r\n\r\n소수에 대해 생각해보자. <span class=\"green-A400\">소수는 1과 자기 자신으로만 나눠지는 수</span>다. 즉, 반드시 **소수는 홀수**여야 한다. 이 전제를 확장하면 <span class=\"green-A400\">짝지은 수의 합이 홀수</span>여야한다. 두 수를 더했을 때 홀수가 나오는 경우는 **홀수 + 짝수**로 한 가지 경우의 수만 존재한다.\r\n\r\n따라서 우리는 입력값을 홀수와 짝수 그룹으로 나누어 각 그룹끼리만 더하면 결과는 모두 홀수일 것이므로, 해당 수는 소수일 가능성이 있다. 두 개의 그룹을 겹치지 않게 조합해야하므로 <span class=\"primary\">이분 매칭</span>이 적절한 해답이 될 수 있다. 각 그룹은 홀수와 짝수로 나누고, 더했을 때 소수가 되는 쌍을 노드로 연결하면 <span class=\"primary\">이분 매칭</span>으로 접근 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 그림은 예제 1을 홀수와 짝수 그룹으로 나눠 이분매칭으로 표시한 그림이다. 위 숫자를 6개의 숫자를 매칭하면 3개의 노드가 나올 것이다. 각 숫자를 더하기 위해선 반드시 하나의 쌍을 이뤄야하므로, <span class=\"primary\">이분 매칭</span>의 결과는 반드시 $N \\div 2$가 되어야 한다.\r\n\r\n예제의 가장 첫 번째 수는 1이다. 즉, 우리는 <span class=\"green-A400\">모든 요소쌍의 합이 모두 소수가 되는 조합을 찾고 해당 조합들에서 각각 1과 매칭되는 숫자</span>를 구해야한다. 이를 확장시키면, 1과 짝을 이루는 수를 더한 값이 소수가 아닐 경우 애초에 비교할 필요가 없다.\r\n\r\n위 그림의 매칭 결과가 3이 나온다면, 모든 요소를 적절히 짝지어 더한 값이 모두 소수가 되는 조합이 있다는 뜻이다. 해당 조합을 저장하여 1과 짝지은 값을 찾으면 될 것이다.  \r\n만약, 홀수와 짝수의 갯수가 일치하지 않을 경우, 매칭이 불가능하므로 문제에 제시한 조건에 따라 -1을 반환해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png\" width=\"600px\" />\r\n</p>\r\n\r\n1과 더했을 때 소수가 되는 요소는 4, 10, 12 모두 해당하므로 이를 모두 노드로 연결할 수 있다. 1과 매칭 가능한 요소 중 하나를 연결하면, 나머지 4개 요소에 대해서만 <span class=\"primary\">이분 매칭</span>을 진행할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501823-9216ea80-d682-11eb-96de-8c01b66677bb.png\" width=\"600px\" />\r\n</p>\r\n\r\n만약, 1과 4를 매칭했다면 나머지 4개 요소에 대한 소수 매칭은 그림과 같이 표현할 수 있다. $[ 7, 10 ]$, $[ 11, 12 ]$ 조합의 합이 모두 소수이므로, $[ 1, 4 ]$, $[ 7, 10 ]$, $[ 11, 12 ]$ 조합은 알고리즘의 조건에 부합한다. 따라서 4는 정답에 포함된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501853-c8546a00-d682-11eb-86e2-6eef5c65ef69.png\" width=\"600px\" />\r\n</p>\r\n\r\n만약, 1과 12가 매칭된다면 어떨까? 이는 위 그림과 같이 표시할 수 있다. 7의 경우 4와 10 중 어떤걸 조합해도 소수지만, 11의 경우 4와 10 모두 소수가 아니므로 어떤식으로 매칭해도 4개 요소의 매칭 결과는 1이 된다. 즉, 1과 매칭된 조합 하나를 더한 최종 매칭 수는 2이므로 $N / 2$의 값에 부합하지 않으므로 해당 조합은 정답이 될 수 없다.  \r\n따라서 예제의 결과는 출력과 같이 `4 10`이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\n\r\n/**\r\n * 백준 전체 1017 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/26/a1017\">1017 풀이</a>\r\n * @since 2021.06.26 Sat 03:19:32\r\n */\r\npublic class Main\r\n{\r\n\t// 에라토스 테네스의 체 배열 (소수 판별용)\r\n\tprivate static final boolean[] IS_NOT_PRIME = eratosthenes();\r\n\t\r\n\t// 왼쪽 배열 (이분매칭의 기준)\r\n\tprivate static int[] left;\r\n\t\r\n\t// 오른쪽 배열\r\n\tprivate static int[] right;\r\n\t\r\n\t// 노드 연결 여부\r\n\tprivate static boolean[][] hasNode;\r\n\t\r\n\t// 방문 여부\r\n\tprivate static boolean[] isVisit;\r\n\t\r\n\t// 매칭된 수\r\n\tprivate static int[] matched;\r\n\t\r\n\t// 현재 선택 중인 수\r\n\tprivate static int selected;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 입력값 갯수\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 입력값 배열\r\n\t\tint[] numbers = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 첫 번째 수가 홀수일 경우\r\n\t\tif (numbers[0] % 2 != 0)\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 홀수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 첫 번째 수가 짝수일 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 짝수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일할 경우 (이분매칭 가능)\r\n\t\tif (left.length == right.length)\r\n\t\t{\r\n\t\t\thasNode = new boolean[left.length][right.length];\r\n\t\t\t\r\n\t\t\t// left의 첫 번째 행은 기준 매칭이므로 이분 매칭에서 제외한다.\r\n\t\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t\t{\r\n\t\t\t\tfor (int j = 0; j < right.length; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint ref = left[i] + right[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// left[i] + right[j]의 값이 소수일 경우\r\n\t\t\t\t\tif (!IS_NOT_PRIME[ref])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 노드를 연결한다.\r\n\t\t\t\t\t\thasNode[i][j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tLinkedList<Integer> list = new LinkedList<>();\r\n\t\t\t\r\n\t\t\t// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\n\t\t\tfor (int i = 0; i < N / 2; i++)\r\n\t\t\t{\r\n\t\t\t\t// left[0]와 right[i]의 합이 소수일 경우\r\n\t\t\t\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\tselected = i;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint size = bipartite();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 모든 요소가 매칭될 경우\r\n\t\t\t\t\tif (size == N / 2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlist.add(right[selected]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 하나도 매칭되지 않은 경우\r\n\t\t\tif (list.size() == 0)\r\n\t\t\t{\r\n\t\t\t\twriter.write(\"-1\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 매칭이 하나 이상 있을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 오름차순으로 정렬\r\n\t\t\t\tlist.sort(Integer::compareTo);\r\n\t\t\t\t\r\n\t\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\t\t\r\n\t\t\t\tfor (int item : list)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuilder.append(item).append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\twriter.write(builder.toString().trim());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일하지 않을 경우 (이분매칭 불가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"-1\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\t\tint size = 1;\r\n\t\t\r\n\t\tmatched = new int[left.length];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t{\r\n\t\t\tisVisit = new boolean[left.length];\r\n\t\t\t\r\n\t\t\t// 매칭 가능할 경우\r\n\t\t\tif (dfs(i))\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static boolean dfs(int num)\r\n\t{\r\n\t\t// 첫 방문일 경우\r\n\t\tif (!isVisit[num])\r\n\t\t{\r\n\t\t\tisVisit[num] = true;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 아레토스 테네스의 체 배열 반환 함수\r\n\t *\r\n\t * @return [boolean[]] 아레토스 테네스의 체\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tboolean[] isNotPrime = new boolean[2000];\r\n\t\t\r\n\t\tisNotPrime[0] = true;\r\n\t\tisNotPrime[1] = true;\r\n\t\t\r\n\t\tint maxPrime = (int) Math.ceil(Math.sqrt(2000));\r\n\t\t\r\n\t\tfor (int i = 2; i < maxPrime; i++)\r\n\t\t{\r\n\t\t\t// 소수일 경우\r\n\t\t\tif (!isNotPrime[i])\r\n\t\t\t{\r\n\t\t\t\tfor (int j = i + i; j < isNotPrime.length; j += i)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 소수가 아님을 표시하지 않았을 경우\r\n\t\t\t\t\tif (!isNotPrime[j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 소수의 배수는 소수가 아니므로 제외함\r\n\t\t\t\t\t\tisNotPrime[j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPrime;\r\n\t}\r\n}\r\n```\r\n\r\n편의상 항상 왼쪽을 기준으로 매칭한다. 올바른 조합 중 첫 번째 수와 매칭되는 수를 찾는 것이 목표인데, 첫 번째 수는 홀수, 짝수 모두 올 수 있다. 따라서 홀수가 먼저오냐, 짝수가 먼저오냐에 따라 해당하는 분류를 기준 배열로 할당한다.\r\n\r\n``` java\r\n// 첫 번째 수가 홀수일 경우\r\nif (numbers[0] % 2 != 0)\r\n{\r\n\t// 왼쪽 배열에 홀수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n}\r\n\r\n// 첫 번째 수가 짝수일 경우\r\nelse\r\n{\r\n\t// 왼쪽 배열에 짝수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n}\r\n```\r\n\r\n해당 소스는 위와 같다. 왼쪽 배열 `left`를 기준으로하여 홀수가 올 경우 `left`에 홀수 배열을, 아닐 경우 짝수 배열을 할당한다.\r\n\r\n소수 판별은 <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘을 통해, 요소로 올 수 있는 최대값인 2,000개 배열에 대한 소수 배열을 준비한다.\r\n\r\n> **잠깐, 문제에서는 요소로 올 수 있는 최대값이 1,000이라는데요?**  \r\n> 홀수와 짝수를 더하므로, 요소의 최대값은 각 요소의 최대값을 더한 999 + 1,000 = 1,999가 됩니다.\r\n\r\n배열이 2000개까지밖에 안 되므로, 연산할 때마다 비교하는 것 보다 미리 배열을 선언해서 비교하는 게 훨씬 효율적이라 판단했다.  \r\n만약 연산할 때마다 비교하려면, 비교할 수의 제곱근을 구하고, 2부터 제곱근까지 나눈다. 중간에 정확히 나누어 떨어지는 수가 있을 경우, 그 수는 소수가 아니다.\r\n\r\n``` java\r\n// 대상 숫자\r\nint number = 1000;\r\n\r\n// 소수 여부\r\nboolean isPrime = true;\r\n\r\n// 가장 작은 소수인 2부터 대상의 제곱근까지 나누기\r\nfor (int i = 2; i <= Math.sqrt(number); i++)\r\n{\r\n\t// 나누어 떨어지는 수가 있을 경우\r\n\tif (number % i == 0)\r\n\t{\r\n\t\tisPrime = false;\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n대충 위 형식처럼 짜면 된다.\r\n\r\n``` java\r\n// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\nfor (int i = 0; i < N / 2; i++)\r\n{\r\n\t// left[0]와 right[i]의 합이 소수일 경우\r\n\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t{\r\n\t\tselected = i;\r\n\t\t\r\n\t\tint size = bipartite();\r\n\t\t\r\n\t\t// 모든 요소가 매칭될 경우\r\n\t\tif (size == N / 2)\r\n\t\t{\r\n\t\t\tlist.add(right[selected]);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n그룹을 나누었으면, 입력값의 첫 번째 수 $left[0]$와 하나씩 매칭하여 기준 매칭을 선정한다. `!IS_NOT_PRIME[left[0] + right[i]]`을 통해 매칭이 소수일 경우에만 진행한다. 소수가 아닐 경우 비교해볼 필요도 없으니. `selected`는 현재 $left[0]$와 매칭된 요소를 의미한다. 이게 왜 필요하냐면, $left[0]$와 매칭된 요소의 경우 다른 요소와 매칭될 수 없으므로 매칭에서 제외해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501834-a3f88d80-d682-11eb-8e27-968a1c71e342.png\" width=\"600px\" />\r\n</p>\r\n\r\n이는 위 그림과 같이 나타낼 수 있다. 이미 1이 10과 매칭되었으므로, 10과 연결된 7, 11의 노드를 제거해야 정상적으로 매칭할 수 있다. 연결된 노드는 `hasNode` 배열에서 관리하고 있다. 예제 1을 기준으로 `hasNode`의 값은 다음과 같다.\r\n\r\n| $N, M$ |   4   |  10   |  12   |\r\n| :----: | :---: | :---: | :---: |\r\n|   1    | true  | true  | true  |\r\n|   7    | true  | true  | true  |\r\n|   11   | false | false | true  |\r\n\r\n만약 여기서, 1과 10을 매칭할 경우 hasNode는 아래와 같다.\r\n\r\n| $N, M$ |     4     |  **10**   |    12     |\r\n| :----: | :-------: | :-------: | :-------: |\r\n| **1**  | **false** | **true**  | **false** |\r\n|   7    |   true    | **false** |   true    |\r\n|   11   |   false   | **false** |   true    |\r\n\r\n1과 10에 연결된 다른 노드를 모두 제거하고, `hasNode[1][10] = true`로 지정해야 한다. 임시 배열을 선언해서 변경하는 경우도 있겠지만, 배열 연산 오버헤드를 줄이기 위해 `selected = 10`으로 지정하여 DFS 알고리즘 수행 시 `selected`와 동일한 인덱스를 false로 인식하게끔 설계했다.\r\n\r\n``` java\r\n/**\r\n * 이분 매칭 갯수 반환 함수\r\n *\r\n * @return [int] 이분 매칭 갯수\r\n */\r\nprivate static int bipartite()\r\n{\r\n\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\tint size = 1;\r\n\t\r\n\tmatched = new int[left.length];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int i = 1; i < left.length; i++)\r\n\t{\r\n\t\tisVisit = new boolean[left.length];\r\n\t\t\r\n\t\t// 매칭 가능할 경우\r\n\t\tif (dfs(i))\r\n\t\t{\r\n\t\t\tsize++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n\r\n/**\r\n * DFS 알고리즘 결과 반환 함수\r\n *\r\n * @param num: [int] 시작점\r\n *\r\n * @return [int] 매칭 갯수\r\n */\r\nprivate static boolean dfs(int num)\r\n{\r\n\t// 첫 방문일 경우\r\n\tif (!isVisit[num])\r\n\t{\r\n\t\tisVisit[num] = true;\r\n\t\t\r\n\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t{\r\n\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t{\r\n\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n<span class=\"primary\">이분 매칭</span> 소스는 위와 같다. `bipartite()`는 기본적인 이분 매칭 알고리즘과 크게 다르지 않다. `size`가 1부터 시작하는 이유는, 이미 입력의 첫 번째 수 `left[0]`과 합이 소수를 만족하는 `right[m]`과 매칭되었기 때문이다.\r\n\r\n`dfs()`에서 조건에 따라 필터링이 진행된다. 조건식은 `hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]]`와 같다.\r\n\r\n* `hasNode[num][i]`: `left[num]`과 `right[i]`가 서로 연결되어 있는지 (소수)\r\n* `i != selected`: `left[num]`이 `right[i]`와 매칭되지 않았는지\r\n* `!IS_NOT_PRIME[left[num] + right[i]]`: `left[num]`과 `right[i]` 소수인지\r\n\r\n위 조건식을 모두 만족할 경우에만 매칭을 수행한다.\r\n\r\n$N$이 반드시 짝수거나, 입력된 숫자의 홀수, 짝수가 반드시 동일하다는 조건이 존재하지 않으므로, 이 경우 -1을 출력해야한다. 또한, 모든 조건이 일치해도 매칭이 하나도 되지 않을 경우 역시 -1을 출력해야한다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 이분 매칭\r\n* 에라토스 테네스의 체","url":["2021-06-26-a1017","2021","06","26","a1017"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1016번 제곱 ㄴㄴ수","excerpt":"어떤 수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-23T00:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I","에라토스 테네스의 체"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-23-a1016.md","content":"\r\n# 제곱 ㄴㄴ수\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1016번 문제](https://www.acmicpc.net/problem/1016)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n어떤 수 $X$가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 두 정수 min과 max가 주어진다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 [min,max]구간에 제곱ㄴㄴ수가 몇 개인지 출력한다.\r\n\r\n## 제한\r\n\r\n* $1 ≤ \\text{min} ≤ 1,000,000,000,000$\r\n* $\\text{min} ≤ \\text{max} ≤ \\text{min} + 1,000,000$\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 10\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n7\r\n```\r\n\r\n# 풀이\r\n\r\n주어진 구간에서 제곱수(4, 9, 16 등)으로 나누어지지 않는 수의 갯수를 구하면 되는 문제.\r\n\r\n개념은 생각보다 간단하다. <span class=\"primary\">에라토스 테네스의 체</span>에 대해 알고있다면 생각보다 쉽게 접근할 수 있기도 하고. 의외로 문제는 다른 쪽에 있다.\r\n\r\n1. min, max의 최대값이 1조 단위다.\r\n2. 구간이 반드시 1부터 시작하지 않는다.\r\n3. 배열의 인덱스는 반드시 `int` 데이터만 가능하다.\r\n\r\n보편적인 정수 데이터인 `int`의 최대값이 약 21억인걸 감안하면 턱없이 큰 수. 때문에 `long` 데이터의 사용이 강제된다. 반면 배열의 인덱스는 `int` 데이터만 사용 가능하므로, `int`와 `long`의 적절한 데이터 선언 및 변환이 필요하다.\r\n\r\n최소값 <span class=\"lightBlue-A400\">min</span>과 최대값 <span class=\"lightBlue-A400\">max</span>는 그 수가 매우 클 수는 있어도, 그 차이는 백만 이하로만 나오므로 배열로 다루는데 무리가 없다.\r\n\r\n만약, min = 1,000,000,000,000(1조)이고, max = 1,000,000,500,000(1조 50만)일 경우, 실제로 비교해야할 구간은 약 50만개밖에 되지 않는다. 이 구간을 배열 $A$로 표시하면 $A[0] = 1,000,000,000,000\\text{(min)}$가 된다. 즉, $A[i] = i + \\text{min}$으로 다뤄야한다.\r\n\r\n**제곱수의 배수를 제외**해야한다는 점에서 소수의 배수를 제외하여 소수를 판별하는 <span class=\"primary\">에라토스 테네스의 체</span>의 개념와 매우 흡사하다. 즉, <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘에서 소수가 아닌 제곱수의 배수를 판별하게끔 살짝 변형시켜주면 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1016 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/23/a1016\">1016 풀이</a>\r\n * @since 2021.06.23 Fri 00:22:31\r\n */\r\npublic class Main\r\n{\r\n\t// 최소값\r\n\tprivate static long min;\r\n\t\r\n\t// 최대값\r\n\tprivate static long max;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tlong[] temp = Arrays.stream(reader.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\r\n\t\t\r\n\t\tmin = temp[0];\r\n\t\tmax = temp[1];\r\n\t\t\r\n\t\twriter.write(Integer.toString(solve()));\r\n\t\twriter.newLine();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @return [int] 제곱수로 나누어 떨어지지 않는 수의 갯수\r\n\t */\r\n\tprivate static int solve()\r\n\t{\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tboolean[] isNotPow = eratosthenes();\r\n\t\t\r\n\t\tfor (boolean item : isNotPow)\r\n\t\t{\r\n\t\t\t// 제곱수로 나누어 떨어지지 않는 수일 경우\r\n\t\t\tif (!item)\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 에라토스 테네스의 체 배열 반환 함수\r\n\t *\r\n\t * true: 제곱ㄴㄴ수가 아닌 수\r\n\t * false: 제곱ㄴㄴ수\r\n\t *\r\n\t * @return [boolean[]] 에라토스 테네스의 체 배열\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tint length = (int) (max - min + 1);\r\n\t\t\r\n\t\tboolean[] isNotPow = new boolean[length];\r\n\t\t\r\n\t\tfor (long i = 2; i * i <= max; i++)\r\n\t\t{\r\n\t\t\tlong pow = i * i;\r\n\t\t\t\r\n\t\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\t\r\n\t\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t\t{\r\n\t\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPow;\r\n\t}\r\n}\r\n```\r\n\r\n`solve()` 메소드는 단순히 갯수를 파악하는 로직이므로 그 의도만 알면 된다. 가장 핵심인 부분은 <span class=\"primary\">에라토스 테네스의 체</span>를 변형한 아래 코드다.\r\n\r\n``` java\r\n/**\r\n * 에라토스 테네스의 체 배열 반환 함수\r\n *\r\n * true: 제곱ㄴㄴ수가 아닌 수\r\n * false: 제곱ㄴㄴ수\r\n *\r\n * @return [boolean[]] 에라토스 테네스의 체 배열\r\n */\r\nprivate static boolean[] eratosthenes()\r\n{\r\n\tint length = (int) (max - min + 1);\r\n\t\r\n\tboolean[] isNotPow = new boolean[length];\r\n\t\r\n\tfor (long i = 2; i * i <= max; i++)\r\n\t{\r\n\t\tlong pow = i * i;\r\n\t\t\r\n\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\r\n\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t{\r\n\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn isNotPow;\r\n}\r\n```\r\n\r\n총 2개의 반복문이 돌아간다. 인덱스는 각각 $i$, $j$다.\r\n\r\n* $i$: 제곱수의 제곱근\r\n* $j$: 제곱수의 배수를 구하기 위한 인덱스\r\n\r\n1보다 큰 제곱수는 4이므로, 인덱스 $i$의 시작값은 2이며, 제곱수인 $i^2$의 크기가 max 이하일때 까지 반복한다. 만약, 구간이 10부터 30까지라면, $i$는 2<span class=\"grey-500\">(4)</span>부터 5<span class=\"grey-500\">(25)</span>까지 증가할 것이다.\r\n\r\n인덱스 $j$는 약간 복잡한데, 이는 구간의 존재 때문이다. 기본적으로 <span class=\"primary\">에라토스 테네스의 체</span>는 1부터 시작하므로 상관없지만, 해당 문제는 <span class=\"red-500\">시작값이 1이 아닐 경우</span>가 존재한다.\r\n\r\n예를 들어, $i = 2$이고 구간이 10 ~ 20까지라고 가정하자. $i^2 = 4$이므로 제곱수 4의 배수를 제거해야한다. 만약 평상시처럼 곱셈의 인덱스를 1부터 시작해서 $4 \\times 1$, $4 \\times 2$, $\\dots$와 같이 시작한다면 문제가 생긴다. 구간은 10부터인데 비해, 10 이하인 4, 8을 제거하게되니 이를 걸러내야한다. 만약 구간이 1000부터 시작이라면 250개의 쓸모없는 연산이 발생한다. 구간이 최대 1조부터 시작할 수 있음을 생각한다면 구간의 시작에 따라 곱셈 인덱스 $j$를 적절히 계산해야한다.\r\n\r\n$i = 2$일 경우, $i^2 = 4$이다. 구간의 시작이 10일 경우, 10 이하인 수 $4 \\times 1$, $4 \\times 2$는 건너뛰므로 곱셈 인덱스 $j$는 3부터 시작해야한다.\r\n\r\n$$\r\nj_{\\text{min}} = \r\n\\begin{cases}\r\n\t\\text{min} \\div i^2 \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 == 0)\\\\\r\n\t(\\text{min} \\div i^2) + 1 \\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 \\,\\,\\, !=  0)\r\n\\end{cases}\r\n$$\r\n\r\n즉, 곱셈 인덱스 $j$의 시작값의 일반식은 위와 같다.\r\n\r\n$\\text{제곱수의 배수} = j \\times i^2 \\,\\,\\, (j = 1, 2, 3, \\dots)$이므로, 해당값을 모두 제외하면 된다. 단, $j \\times i^2$는 실제 값이므로, 배열의 인덱스는 $(j \\times i^2) - \\text{min}$이다.\r\n\r\n배열에 `true`를 할당하는 이유는 `boolean[]`의 초기값이 `false`이기 때문. `Arrays.fill()` 메소드를 활용하여 `true`로 초기화할 수도 있으나, 의미론적으론 좋지만 불필요한 연산이므로 `false`를 제곱ㄴㄴ수로, `true`를 제곱ㄴㄴ수가 아닌 수로 지칭한다. 배열 이름이 `isNotPow`인 이유도 이때문.\r\n\r\n이후 `isNotPow` 배열을 순회하며, 값이 `false`인 수만 카운팅하면 된다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 에라토스 테네스의 체","url":["2021-06-23-a1016","2021","06","23","a1016"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1015번 수열 정렬","excerpt":"P[0], P[1], ..., P[N - 1]은 0부터 N - 1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다. 적용하는 방법은 B[P[i]] = A[i]이다. 배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-22T01:23:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER IV","정렬"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-22-a1015.md","content":"\r\n# 수열 정렬\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1015번 문제](https://www.acmicpc.net/problem/1015)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n$P[0], P[1], \\, \\dots \\, P[N - 1]$은 $0$부터 $N - 1$까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 $P$를 길이가 $N$인 배열 $A$에 적용하면 길이가 $N$인 배열 $B$가 된다. 적용하는 방법은 $B[P[i]] = A[i]$이다.\r\n\r\n배열 $A$가 주어졌을 때, 수열 $P$를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 배열 $A$의 크기 $N$이 주어진다. 둘째 줄에는 배열 $A$의 원소가 0번부터 차례대로 주어진다. $N$은 50보다 작거나 같은 자연수이고, 배열의 원소는 1,000보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 비내림차순으로 만드는 수열 $P$를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n2 3 1\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 2 0\r\n```\r\n\r\n# 풀이\r\n\r\n정렬에 대해 잘 알고 있다면 쉬어가는 문제. 한 마디로, <span class=\"amber-A400\">배열 속 요소들을 크기별 등수로 바꾸어 동일한 자리에 표시</span>해주면 된다.\r\n\r\n예제의 경우, 배열 $A$가 $[ 2, 3, 1 ]$로 주어졌는데, 이를 오름차순으로 표시하여 배열 $A1$로 만들면 $[ 1, 2, 3 ]$이 된다. 즉 $A1[0] = 1$이 된다. $A1$의 인덱스를 $A$의 요소의 순서에 맞게 출력하는 것이 알고리즘의 최종 동작이다.\r\n\r\n## 배열 A의 순서 기억하기\r\n\r\n첫 번째로, 정수형 배열의 오름차순 정렬은 매우 쉽다. `Arrays.sort(A);`만 적용해주면 될 일이기 때문. 문제는 정렬한 인덱스를 원본 배열 $A$의 순서대로 출력해야 한다는 것.\r\n\r\n이를 기억하는 장치로 배열 $A$를 2차원 배열로 만들어 $A[i][0]$에는 <span class=\"orange-A400\">i번째 입력값의 값</span>, $A[i][1]$에는 순번 인덱스 <span class=\"orange-A400\">i</span>를 입력한다.\r\n\r\n이를 표로 도식화하면 아래와 같다.\r\n\r\n|    $i$    |   0   |   1   |   2   |\r\n| :-------: | :---: | :---: | :---: |\r\n| $A[i][0]$ |   2   |   3   |   1   |\r\n| $A[i][1]$ |   0   |   1   |   2   |\r\n\r\n따라서 배열 $A$를 정렬해도, 순서를 기억할 수 있게 된다.\r\n\r\n|    $i$    |   0   |   1   |   2   |\r\n| :-------: | :---: | :---: | :---: |\r\n| $A[i][0]$ |   1   |   2   |   3   |\r\n| $A[i][1]$ |   2   |   0   |   1   |\r\n\r\n위 표는 오름차순 정렬을 적용한 것으로, $A[i][1]$을 통해 원래의 순서로 되돌릴 수 있을 것이다.\r\n\r\n## 정렬 후 되돌리기\r\n\r\n배열 $A$에 수열 $P$를 적용한 결과인 $B$를 구한다. 위에서 정렬을 통해 크기 순위를 계산했으므로, 이를 <span class=\"green-A400\">위치에 맞게 순서를 되돌려 출력</span>하면 된다.\r\n\r\n원래의 위치값은 $A[i][1]$이 가지고 있으므로, 이 인덱스를 활용하자. 배열 $B$의 식은 $B[A[i][1]] = i$와 같은 형태로 계산할 수 있다. 예를 들어, $i = 1$일 때 정렬된 배열 $A[1][1] = 0$이므로 $B[0] = 1$이 된다. 이를 코드로 구현하면 완성된다.\r\n\r\n## 이차원 배열 정렬하기\r\n\r\n여기서 작은 문제가 하나 생기는데, 바로 정렬이다. 대표적인 정렬 메소드인 `Arrays.sort(A);`의 경우 1차원 배열에서는 의도에 맞게 동작하나, 그 이상인 $n$차원 배열부터는 의도한대로 동작하지 않는다. 또한 `Arrays.sort(A);`는 무조건 오름차순으로만 동작한다.\r\n\r\n이를 해결하기 위해선, `sort()` 메소드를 직접 오버라이딩하면 된다. 물론 아예 구현해도 되지만, 여기서는 기본 API를 최대한 살려 sort 함수를 우리 의도에 맞게 오버라이딩한다.\r\n\r\n``` java\r\nArrays.sort(A, (next, current) -> {\r\n\t// 다음 원소가 현재 원소보다 클 경우\r\n\tif (next[0] < current[0])\r\n\t{\r\n\t\t// 현재 원소를 다음 원소의 뒤로 정렬\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// 다음 원소가 현재 원소보다 작을 경우\r\n\telse if (next[0] > current[0])\r\n\t{\r\n\t\t// 현재 원소를 다음 원소의 앞으로 정렬\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t// 다음 원소가 현재 원소와 동일할 경우\r\n\telse\r\n\t{\r\n\t\t// 현 위치 유지\r\n\t\treturn 0;\r\n\t}\r\n})\r\n```\r\n\r\n`Comparater` 인터페이스를 lambda 함수의 형태로 구현한 코드다. `current`는 <span class=\"blue-400\">현재 요소</span>를, `next`는 <span class=\"blue-400\">다음 요소</span>를 의미하며 <span class=\"blue-400\">반환값이 양수일 경우 현재 요소가 다음 요소보다 뒤로 정렬</span>되며, <span class=\"blue-400\">반환값이 음수일 경우 현재 요소가 다음 요소보다 앞으로 정렬</span>된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1015 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/22/a1015\">1015 풀이</a>\r\n * @since 2021.06.22 Tue 01:23:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열의 크기\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 원본 배열\r\n\t\tint[][] A = new int[N][2];\r\n\t\t\r\n\t\t// 정렬 배열\r\n\t\tint[] B = new int[N];\r\n\t\t\r\n\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tA[i][0] = Integer.parseInt(temp[i]);\r\n\t\t\tA[i][1] = i;\r\n\t\t}\r\n\t\t\r\n\t\t// 정렬 수행\r\n\t\tsort(A);\r\n\t\t\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tint index = A[i][1];\r\n\t\t\t\r\n\t\t\tB[index] = i;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int b : B)\r\n\t\t{\r\n\t\t\tbuilder.append(b).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString().trim());\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정렬 함수\r\n\t *\r\n\t * @param A: [int[][]] 대상 배열\r\n\t */\r\n\tprivate static void sort(int[][] A)\r\n\t{\r\n\t\tArrays.sort(A, (next, current) -> {\r\n\t\t\t// 현재값이 더 클 경우\r\n\t\t\tif (next[0] < current[0])\r\n\t\t\t{\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 다음값이 더 클 경우\r\n\t\t\telse if (next[0] > current[0])\r\n\t\t\t{\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 현재값과 다음값이 같을 경우, 사전순 정렬\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn Integer.compare(next[1], current[1]);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 정렬","url":["2021-06-22-a1015","2021","06","22","a1015"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1014번 컨닝","excerpt":"최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다. 시험은 N행 X M열 크기의 직사각형 교실에서 이루어진다. 교실은 1 X 1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다. 최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-18T16:42:44","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM IV","네트워크 플로우","최소 버텍스 커버","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-18-a1014.md","content":"\r\n# 컨닝\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1014번 문제](https://www.acmicpc.net/problem/1014)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.\r\n\r\n시험은 $N$행 $\\times$ $M$열 크기의 직사각형 교실에서 이루어진다. 교실은 $1 \\times 1$ 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.\r\n\r\n최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122051353-78bea480-ce1f-11eb-92c3-5fa4e3dc96b9.png\" width=\"500px\" />\r\n</p>\r\n\r\n위의 그림을 보자. $A$, $C$, $D$ 혹은 $E$에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, $B$에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.\r\n\r\n위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.\r\n\r\n최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $C$가 주어진다. 각각의 테스트 케이스는 아래와 같이 두 부분으로 이루어진다.\r\n\r\n첫 번째 부분에서는 교실의 세로길이 N과 가로길이 M이 한 줄에 주어진다. $(1 ≤ M ≤ 10, 1 ≤ N ≤ 10)$\r\n\r\n두 번째 부분에서는 정확하게 N줄이 주어진다. 그리고 각 줄은 M개의 문자로 이루어져있다. 모든 문자는 ‘.’(앉을 수 있는 자리) 또는 ‘x’(앉을 수 없는 자리, 소문자)로 구성된다.\r\n\r\n## 출력\r\n\r\n각각의 테스트 케이스에 대해 그 교실에서 시험을 볼 수 있는 최대 학생의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n4\r\n2 3\r\n...\r\n...\r\n2 3\r\nx.x\r\nxxx\r\n2 3\r\nx.x\r\nx.x\r\n10 10\r\n....x.....\r\n..........\r\n..........\r\n..x.......\r\n..........\r\nx...x.x...\r\n.........x\r\n...x......\r\n........x.\r\n.x...x....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4\r\n1\r\n2\r\n46\r\n```\r\n\r\n# 풀이\r\n\r\n또 한번의 <span class=\"teal-A400\">플래티넘</span> 문제. 하....\r\n\r\n문제 이름 그대로 컨닝을 못 참게 만드는 문제다. 문제를 푸는 방식에는 두 가지가 있다. <span class=\"primary\">네트워크 플로우</span>와 <span class=\"primary\">비트마스킹</span>. 본 포스팅에서는 <span class=\"primary\">네트워크 플로우</span> 방식을 차용한다. 이게 정석이라고 하기도 하고, JAVA 풀이는 죄다 <span class=\"primary\">비트마스킹</span> 방식이라서.\r\n\r\n나 같이 전공지식이 전무한 코더에게는 너무나도 가혹한 문제다. 지금까지 살면서 하나 깨달은 게 있다면, 아무리 처음 보는 개념이라도 계속 쳐다보면 언젠가 이해된다. 하루가 됐든 한 달이 됐든. 그 난리를 펴가며 이해한 내용은 아래와 같다.\r\n\r\n## 문제 분석하기\r\n\r\n문제 해결에 영향을 미치는 조건은 아래와 같다.\r\n\r\n1. 임의의 자리를 기준으로 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위 자리를 컨닝할 수 있다.\r\n2. 파손되어 앉을 수 없는 자리가 존재한다.\r\n\r\n임의의 자리가 있다고 가정하고 이를 도식화해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956338-de7cd480-d3bb-11eb-93ce-5c1ea19185af.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진과 같이 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 자신의 주변엔 최대 8개의 <span class=\"indigo-200\">자리</span>가 존재할 수 있다. 1번 규칙에 따라 컨닝이 가능한 자리를 도식하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956398-eccaf080-d3bb-11eb-9d2b-91e4aaa7ea40.png\" width=\"600px\" />\r\n</p>\r\n\r\n<span class=\"red-400\">컨닝 가능한 자리</span>는 위와 같이 6개로 표시된다. 엥? 분명히 1번 규칙에서는 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위만 가능하다고 했다. 해당 규칙에 따르면 4개 자리여야 할텐데, 왼쪽 대각선 아래, 오른쪽 대각선 아래는 왜 해당되는걸까?\r\n\r\n<span class=\"indigo-A400\">특정 자리</span>에서 왼쪽 대각선 아래, 오른쪽 대각선 아래를 컨닝할 순 없지만, 반대로 왼쪽 대각선 아래, 오른쪽 대각선 아래에선 <span class=\"indigo-A400\">특정 자리</span>를 컨닝할 수 있기 때문. <span class=\"lightBlue-A400\">컨닝을 할 수 있는 자리와 당할 수 있는 자리</span> 모두를 고려해야한다.\r\n\r\n반대로 컨닝이 불가능한 자리를 도식하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956442-f7858580-d3bb-11eb-8154-2bfe476ae278.png\" width=\"600px\" />\r\n</p>\r\n\r\n<span class=\"green-A400\">컨닝이 불가능한 자리</span>는 위와 같이 2개로 표시된다. 자신의 앞 뒤는 컨닝할 수 없다. 우리가 설계한 알고리즘이 이와 같은 결과를 계산할 수 있어야 한다. 그렇다면 이를 어떤 방법으로 해결할 수 있을까?\r\n\r\n이 문제를 해결하는 방법은 크게 두 가지가 있다.\r\n\r\n1. 최소 버텍스 커버, 이분 매칭\r\n2. DP, 비트마스킹\r\n\r\n이 중 1번 최소 버텍스 커버와 이분 매칭을 사용하여 풀고자 한다.\r\n\r\n## Miminum Vertex Cover(최소 버텍스 커버)\r\n\r\n<span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>는 모든 노드가 연결된 점(Vertex)의 최소 집합을 의미한다. 예를 들어, 아래와 같은 그림이 있다고 가정하자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956504-05d3a180-d3bc-11eb-8006-7f22037020b9.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진에서의 $A$ ~ $I$에 해당하는 9개 점이 Vertex, 각 점마다 연결된 선이 노드가 된다. 버텍스가 모든 노드를 커버할 수 있다면 <span class=\"amber-A400\">버텍스 커버</span>라 볼 수 있다. 그 중 <span class=\"green-A400\">모든 노드를 커버하는 가작 적은 버텍스의 집합</span>이 <span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>라 할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956549-108e3680-d3bc-11eb-802e-53765cacf3ed.png\" width=\"600px\" />\r\n</p>\r\n\r\n버텍스 $E$의 경우, 대다수의 노드를 포함하고 있지만 $\\overline{AB}$, $\\overline{BC}$, $\\overline{FI}$ 노드를 포함하지 않으므로 버텍스 $E$만으로는 <span class=\"amber-A400\">최소 버텍스 커버</span> 조합이 될 수 없다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956594-1b48cb80-d3bc-11eb-8b48-cf263fd7bcfe.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같이 $B$, $F$ 버텍스를 포함할 경우 존재하는 모든 노드를 포함하는 가장 적은 버텍스의 조합이므로 <span class=\"amber-A400\">최소 버텍스 커버</span>가 된다.\r\n\r\n유의깊게 봐야할 점은, <span class=\"amber-A400\">최소 버텍스 커버</span>를 통해 <span class=\"primary\">최대 독립 집합</span>을 구할 수 있다. <span class=\"amber-A400\">최소 버텍스 커버</span>에 해당하는 버텍스와 모든 노드를 제거해보자. 아래와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956663-2996e780-d3bc-11eb-97f7-d24bd59126fd.png\" width=\"600px\" />\r\n</p>\r\n\r\n이처럼, 전체 그룹에서 <span class=\"amber-A400\">최소 버텍스 커버</span>를 제거하면 <span class=\"orange-A400\">나머지 버텍스들은 그 어떤 버텍스끼리도 연결되지 않는 독립 버텍스</span>다. <span class=\"amber-A400\">최소 버텍스 커버</span>가 모든 노드를 연결한 버텍스의 최소 집함임을 생각한다면, 이를 뺀 나머지는 어떤 버텍스와도 연결되지 않는 버텍스 집합의 최대 조합이라고 할 수 있다. 즉, 최대 독립 집합 $=$ 전체 그룹 $-$ 최소 버텍스 커버로 표현할 수 있다.\r\n\r\n그래, 그건 그렇다 치고, 위 개념이 이 문제와 무슨 연관성이 있길래 이렇게 장황하게 서술할까? 이번엔 조금 다르게 이 문제와 연관지어 예시를 들어본다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956705-33204f80-d3bc-11eb-8e58-c1c96509d4fe.png\" width=\"600px\" />\r\n</p>\r\n\r\n그 어떤 자리도 파손되지 않은 온전한 9개 자리가 있다고 가정하자. 각 자리별로 컨닝이 가능한 자리를 노드로 연결하면 위와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956771-42070200-d3bc-11eb-908c-fc5c5db4f583.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진에서 <span class=\"amber-A400\">최소 버텍스 커버</span>는 $B$, $E$, $H$가 된다. 이 자리 3개로 위 사진의 모든 노드를 포함할 수 있기 때문이다. 이 자리들을 제거하여 <span class=\"primary\">최대 독립 집합</span>을 표현하면 어떻게 될까?\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956808-4cc19700-d3bc-11eb-82ff-dc32d98960c4.png\" width=\"600px\" />\r\n</p>\r\n\r\n나머지 자리인 $A$, $C$, $D$, $F$, $G$, $H$만 남게 되며, 각 자리는 그 어떤 노드와도 연결되어있지 않다. 이 사진에서의 노드는 컨닝 가능한 자리이므로, **노드가 없다는 것은 컨닝할 수 있는 자리가 없다**는 뜻이 된다. 즉, <span class=\"amber-A400\">최소 버텍스 커버</span> 로직을 설계하는 것이 이번 알고리즘의 키 포인트다.\r\n\r\n## 이분 매칭\r\n\r\n자, <span class=\"amber-A400\">최소 버텍스 커버</span>가 알고리즘의 키인 건 알았으니, 이를 구현하기만 하면 된다. 안타깝게도 <span class=\"amber-A400\">최소 버텍스 커버</span>를 코딩으로 계산하는 것은 매우 복잡한 일이다.\r\n\r\n**König's Theorem**(쾨닉의 정리)에 의하면 <span class=\"red-400\">모든 이분 그래프의 최대 매칭은 최소 버텍스 커버와 같다</span>고 증명한다. 즉, 위 그래프를 이분 그래프로 변경하여 최대 매칭을 구하면 <span class=\"amber-A400\">최소 버텍스 커버</span>를 구할 수 있다는 뜻이다.\r\n\r\n결론적으로, <span class=\"amber-A400\">최소 버텍스 커버</span>를 구하기 위해 <span class=\"teal-A400\">이분 매칭</span> 알고리즘을 구현해야 한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>의 연산에 사용하는 **이분 그래프**는 아래와 같은 특징을 가진다.\r\n\r\n* 모든 정점을 두 그룹으로 나눌 수 있다.\r\n* 모든 노드는 한 그룹에서 다른 그룹으로 연결된다.\r\n* 같은 그룹끼리는 연결되지 않는다.\r\n\r\n고등수학을 배웠다면 우리는 이미 이분 그래프를 접한적이 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956906-6367ee00-d3bc-11eb-8612-b27579146961.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진은 임의의 함수 $f(x)$에 대한 식을 도식화한 것이다. 위 함수 도식은 이분 그래프의 적절한 예시가 될 수 있다. 모든 그룹이 $x$ 혹은 $y$그룹으로 나뉘며, 모든 노드가 $x$에서 $y$로 연결된다.\r\n\r\n**이분 그래프의 매칭**은 각 그룹의 버텍스를 매칭하는 노드의 집합이다. 단, 각 노드의 끝 점은 다른 노드와 중복되지 않는다. **이분 그래프의 최대 매칭**은 이분 그래프의 매칭의 노드 수가 최대인 조합이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956970-71b60a00-d3bc-11eb-9019-0ffaef2ac35b.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같이 연결된 이분 그래프가 있다고 가정하자. $1$번 버텍스를 기준으로 $A$와 $B$에 노드가 연결되어있다. $\\overline{A1}$을 선택할 경우, $\\overline{B1}$은 매칭에서 제외된다. 노드의 끝 선이 $1$번 버텍스로 동일하기 때문이다. 각 노드의 끝 점은 다른 노드와 중복되지 않는다는 말의 의미는 이와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957021-7e3a6280-d3bc-11eb-8b24-07a0662def70.png\" width=\"600px\" />\r\n</p>\r\n\r\n1. $A$와 $1$번 버텍스를 잇는 노드 $\\overline{A1}$을 선택한다.\r\n2. $B$와 $1$번 버텍스를 잇는 노드 $\\overline{B1}$은 노드 $\\overline{A1}$이 $1$번 버텍스를 포함하므로 선택할 수 없다.\r\n3. 노드 $\\overline{A1}$의 시작 버텍스인 $A$에부터 다른 노드가 있는지 탐색한다.\r\n4. $A$ 버텍스와 연결된 다른 노드가 없으므로 노드 $\\overline{A1}$의 선택을 유지한다.\r\n5. $C$와 $1$번 버텍스를 잇는 노드 $\\overline{C1}$을 선택한다.\r\n6. 마지막 버텍스이므로 탐색을 종료하고 갯수를 계산한다.\r\n\r\n이와 같은 과정으로 이분 그래프의 최대 매칭의 수는 `2`가 된다. 물론 최대 매칭의 조합은 여러개가 될 수 있겠지만, 이 알고리즘에선 \"조합\"이 아니라 \"수\"가 중요하므로 경우의 수를 구할 필요는 없다.\r\n\r\n> **이분 그래프의 최대 매칭 조합**  \r\n> 위 그래프의 최대 매칭 조합은 $[ \\overline{A1}, \\overline{C2} ]$, $[ \\overline{A1}, \\overline{C3} ]$, $[ \\overline{B1}, \\overline{C2} ]$, $[ \\overline{B1}, \\overline{C3} ]$으로 최대 매칭의 수는 2이며 4가지 경우의 수가 존재한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>을 문제에 적용하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957080-898d8e00-d3bc-11eb-84f6-7b504b2d93b3.png\" width=\"600px\" />\r\n</p>\r\n\r\n이번엔 조금 복합적인 예시다. 버텍스 $A$와 $E$가 파손되어 앉을 수 없는 상황이다. 이러한 조건에서 컨닝 가능한 자리를 노드로 표현하면 위 사진과 같이 표현할 수 있다. 규칙의 특성 상, 한 쪽 열은 양 옆의 열에 영향을 준다. 즉, 홀수열과 짝수열로 그룹을 나눌 수 있다. 열의 홀짝을 기준으로 나눠 이분 그래프를 표시하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957152-9ca05e00-d3bc-11eb-8a63-1c7ae6e5edfb.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 이분 그래프의 최대 매칭은 2가 된다. 즉, 최소 버텍스 커버의 조합은 $B$, $H$고 파손되서 착석이 불가능한 자리는 $A$, $E$가 된다. 따라서 $C$, $D$, $F$, $G$, $I$가 컨닝 불가능한 자리가 된다. 단순히 자리의 \"수\"만 계산하면 되므로 `컨닝 불가능한 자리 = 전체 자리 - 최소 버텍스 커버 수 - 파손된 자리`가 된다. 따라서 위 그래프의 알고리즘 수행 결과는 5가 된다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>은 <span class=\"blue-400\">BFS(Breadth First Search, 너비 우선 탐색)</span> 혹은 <span class=\"blue-400\">DFS(Depth First Search, 깊이 우선 탐색)</span>으로 구현할 수 있다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1014 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/18/a1014\">1014 풀이</a>\r\n * @since 2021.06.18 Fri 16:42:44\r\n */\r\npublic class Main\r\n{\r\n\t// 교실 세로 길이 (y)\r\n\tprivate static int N;\r\n\t\r\n\t// 교실 가로 길이 (x)\r\n\tprivate static int M;\r\n\t\r\n\t// 자리 번호\r\n\tprivate static int[][] room;\r\n\t\r\n\t// 컨닝 가능한 자리\r\n\tprivate static boolean[][] nodes;\r\n\t\r\n\t// 방문 횟수\r\n\tprivate static int visitCount;\r\n\t\r\n\t// 버텍스별 방문 횟수\r\n\tprivate static int[] visit;\r\n\t\r\n\t// 버텍스 매칭 여부\r\n\tprivate static int[] matched;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 현재 자리에서 컨닝이 가능한 자리의 위치 상대좌표\r\n\t\tint[][] scopes = { { -1, 1 }, { -1, 0 }, { -1, -1 }, { 1, 1 }, { 1, 0 }, { 1, -1 } };\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint C = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\twhile (C-- > 0)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\tM = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 자리의 파손 여부\r\n\t\t\tboolean[][] canSit = new boolean[N][M];\r\n\t\t\t\r\n\t\t\t// 자리의 번호\r\n\t\t\tint numbering = 1;\r\n\t\t\t\r\n\t\t\t// 파손된 자리의 총 갯수\r\n\t\t\tint broken = 0;\r\n\t\t\t\r\n\t\t\troom = new int[N][M];\r\n\t\t\tnodes = new boolean[N * M][N * M];\r\n\t\t\t\r\n\t\t\tvisitCount = 1;\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\"\");\r\n\t\t\t\t\r\n\t\t\t\tfor (int m = 0; m < M; m++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 자리 번호 기록\r\n\t\t\t\t\troom[n][m] = numbering++;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 앉을 수 있는 경우\r\n\t\t\t\t\tif (temp[m].equals(\".\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 파손된 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// 파손 갯수 1 추가\r\n\t\t\t\t\t\tbroken++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\t// 홀수 열만 대상으로 동작함\r\n\t\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 앉을 수 있는 좌석일 경우\r\n\t\t\t\t\tif (canSit[n][m])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int[] scope : scopes)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// 컨닝 가능성 있는 자리의 상대좌표\r\n\t\t\t\t\t\t\tint no = n + scope[1];\r\n\t\t\t\t\t\t\tint mo = m + scope[0];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 상대좌표가 교실을 벗어나지 않으면서, 앉을 수 있을 경우\r\n\t\t\t\t\t\t\tif (no > -1 && mo > -1 && no < N && mo < M && canSit[no][mo])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// 노드 연결 표시\r\n\t\t\t\t\t\t\t\tnodes[room[n][m] - 1][room[no][mo] - 1] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tint result = bipartite();\r\n\t\t\t\r\n\t\t\twriter.write(Integer.toString(N * M - broken - result));\r\n\t\t\twriter.newLine();\r\n\t\t\twriter.flush();\r\n\t\t}\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 매칭 갯수\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tvisit = new int[N * M];\r\n\t\t\r\n\t\tmatched = new int[N * M];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int n = 0; n < N; n++)\r\n\t\t{\r\n\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t{\r\n\t\t\t\tvisitCount++;\r\n\t\t\t\t\r\n\t\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static int dfs(int num)\r\n\t{\r\n\t\t// 같은 버텍스가 아닐 경우\r\n\t\tif (visit[num] != visitCount)\r\n\t\t{\r\n\t\t\tvisit[num] = visitCount;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t\t{\r\n\t\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\t\tif (nodes[num][i])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn 0;\r\n\t}\r\n}\r\n```\r\n\r\n유의깊게 봐야할 코드는 아래와 같다.\r\n\r\n``` java\r\nprivate static int bipartite()\r\n{\r\n\t// 매칭 갯수\r\n\tint size = 0;\r\n\t\r\n\tvisit = new int[N * M];\r\n\t\r\n\tmatched = new int[N * M];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int n = 0; n < N; n++)\r\n\t{\r\n\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t{\r\n\t\t\tvisitCount++;\r\n\t\t\t\r\n\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n```\r\n\r\n위 코드가 이분매칭을 <span class=\"primary\">DFS 알고리즘</span>을 통해 구현한 것이다.  `for`문의 변수 선언 중 `m += 2`인 이유는 홀수열만 체크하기 위함이다.\r\n\r\n``` java\r\nprivate static int dfs(int num)\r\n{\r\n\t// 같은 버텍스가 아닐 경우\r\n\tif (visit[num] != visitCount)\r\n\t{\r\n\t\tvisit[num] = visitCount;\r\n\t\t\r\n\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t{\r\n\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\tif (nodes[num][i])\r\n\t\t\t{\r\n\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n이분매칭을 구현하는 <span class=\"primary\">DFS 알고리즘</span>의 코드는 위와 같다. `matched` 배열은 -1로 초기화되며, 매칭되는 버텍스의 번호를 할당받는다.\r\n\r\n$A$ 버텍스가 $B$ 버텍스와 연결된 노드 $\\overline{AB}$를 가질 경우, 이를 `matched[A] = B`와 같이 표시한다. 만약, $A$ 버텍스가 $B$ 버텍스를 연결하는 와중에 이미 $B$가 $C$와 연결되어있을 경우, $C$ 버텍스에 $B$가 아닌 다른 버텍스와 연결된 노드가 있는지 확인한다. 만약 가능할 경우, $\\overline{BC}$를 제거하고 $C$와 연결할 수 있는 다른 버텍스를 연결한다. 이후 $\\overline{AB}$를 연결한다.\r\n\r\n이 과정을 반복하여 연결을 수립할 수 있을 경우 1, 없을 경우 0을 반환한다. 이는 `boolean` 타입으로도 대체할 수 있으나, `dfs()`연산 결과를 더하기 때문에 편의상 `int`로 반환한다.\r\n\r\n## 비공식 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n10 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n42\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n21\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 8\r\n.X...X..\r\n..X.....\r\nX.......\r\n.X......\r\n..X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n18\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 7\r\nX...X..\r\n.X.....\r\n.......\r\nX......\r\n.X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n17\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 비트마스킹\r\n* 최대 유량\r\n* 비트필드를 이용한 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n[습격자 초라기](/posts/2021/06/06/a1006)가 매우 복잡한 케이스들을 이해하는데 할애했다면, 이 문제는 케이스가 복잡하다기 보단, 네트워크 플로우를 이해하고 적용하는데 대부분의 시간을 할애했다. 문제 보니까 가면 갈수록 플래티넘이 계속해서 나오는 구간도 있던데, 순서대로 푸는 규칙에 대해 진지하게 생각해봐야하나 싶다.\r\n\r\n## 참고\r\n\r\n* [개발괴발](https://m.blog.naver.com/kelle111/221537563173)\r\n* [Crocus](https://www.crocus.co.kr/814)","url":["2021-06-18-a1014","2021","06","18","a1014"]},{"header":{"title":"[JAVA] split vs StringTokenizer","excerpt":"알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.","coverImage":"https://www.textrazor.com/img/letters3.png","date":"2021-06-14T01:56:01","type":"posts","category":"JAVA","tag":["JAVA(자바)","String(문자열)","split","StringTokenizer"],"comment":true,"publish":true},"name":"2021-06-14-split-and-stringtokenizer.md","content":"\r\n# 개요\r\n\r\n알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.\r\n\r\n$$\r\n[ \"A\", \"B\", \"C\", \"D\" ] -> \"A B C D\"\r\n$$\r\n\r\n이를테면, 위와 같이 $[ \"A\", \"B\", \"C\", \"D\" ]$와 같은 배열을 전달하기 위해, 각 요소를 공백으로 구분하여 $\"A B C D\"$와 같이 전달하게 된다. 보통 내 경우 `split` 메소드를 활용하는데, 알고리즘 풀이를 찾아보다보니 `StringTokenizer`이라는 <span class=\"orange-400\">class</span>를 쓰는 코드들이 더러있었다. 처음보는 <span class=\"orange-400\">class</span>인데다, 접근성이 훨씬 뛰어난 `split`를 굳이 대체해서 쓰는 이유가 있을거라 판단. 직접 퍼포먼스를 비교해보기로 했다. 알고리즘은 수행속도 역시 중요한 지표로 작용하기 때문에, 조금이라도 시간을 줄일 필요가 있다. 안타깝게도 나는 코드 최적화 실력이 최악이라, 이런식으로 줄일 수 있는 자잘한 부분은 줄여야한다. 핵심 코드를 최적화할 생각은 안 하고 이런데서 시간을 단축하는게 꼭 다이어트한답시고 피자 먹으면서 제로콜라 마시는 느낌이긴 하나, `StringTokenizer`이 더 성능이 뛰어나다면 앞으로 푸는 알고리즘에 적용할 가치가 있을 것이다.\r\n\r\n## 테스트 환경\r\n\r\n| 구분  |                                                        내용                                                         |\r\n| :---: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| 언어  | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n|  OS   |                                                  Windows 10 64bit                                                   |\r\n|  CPU  |                                                   Intel i7-10700K                                                   |\r\n|  RAM  |                                                        32GB                                                         |\r\n\r\n# split 메소드\r\n\r\n`split` 메소드는 특정 <span class=\"lightBlue-400\">구분자</span>로 문자열을 분리하는 전통적인 메소드다. 굳이 JAVA가 아니더라도 C(++, #), JavaScript, Python 등 여러 언어에 존재하는 키워드라 어떤 언어든 문자열을 구분할 때 제일 먼저 시도하는 방법이다.\r\n\r\nJAVA의 `split`은 문자열 데이터 형식인 `String` <span class=\"orange-400\">class</span>에 포함된 메소드다. 문자열 데이터라면 `split`를 호출하여 문자열을 구분할 수 있다. 반환값은 `String[]` 객체.\r\n\r\n사용법은 아래와 같다.\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.13 Sun 22:50:57\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tString text = \"A B C D\";\r\n\t\t\r\n\t\tString[] splited = text.split(\" \");\r\n\t\t\r\n\t\tSystem.out.println(Arrays.toString(splited));\r\n\t}\r\n}\r\n```\r\n\r\n출력은 아래와 같다.\r\n\r\n``` tc\r\n[A, B, C, D]\r\n```\r\n\r\n문자열 `A B C D`가 공백을 기준으로 `[A, B, C, D]`로 분리된걸 확인할 수 있다. 그 밖에 한 가지 특이한 점이 있는데, JAVA의 `split` 메소드는 <span class=\"red-A400\">구분자에 정규식을 적용</span>할 수 있다. 이를 잘만 이용하면 복합적인 구분자를 사용할 수도 있다.\r\n\r\n# StringTokenizer\r\n\r\n이 포스팅을 쓰게 만든 직접적인 원인. `StringTokenizer` 역시 문자열을 구분하는데 특화된 <span class=\"orange-400\">class</span>의 일종이다. `String[]`을 반환하는 `split`과 달리 그 자체로 하나의 개별적인 <span class=\"orange-400\">class</span>라는 차이가 있다.\r\n\r\n`StringTokenizer tokenizer = new StringTokenizer(\"문자열\");`과 같은 형태로 초기화해서 사용한다. `StringTokenizer` 인스턴스를 사용하는데 알아두면 좋을법한 메소드는 아래와 같다.\r\n\r\n|    메소드     | 반환값  |         내용          |\r\n| :-----------: | :-----: | :-------------------: |\r\n|  countToken   |   int   |      토큰의 갯수      |\r\n|   nextToken   | String  |       다음 토큰       |\r\n| hasMoreTokens | boolean | 다음 토큰의 존재 유무 |\r\n\r\n`StringTokenizer tokenizer = new StringTokenizer(\"문자열\", \"구분자\");`와 같이 생성자의 인수에 구분자를 추가하여 원하는 구분자로 구분하게 할 수도 있다. 별도로 지정하지 않는다면 구분자는 `\\t\\n\\r\\t`로, 줄바꿈, 공백, 탭을 구분한다. 여기서 주의할 점이 하나 있는데, 기본 구분자 `\\t\\n\\r\\t`는 <span class=\"red-A400\">줄바꿈, 공백, 탭을 전부 포함</span>한다. 즉, `A B C D\\nA B C D`와 같이 공백과 줄바꿈이 혼용되어 있을 경우, 공백과 줄바꿈을 전부 구분하여 `[A, B, C, D, A, B, C, D]`와 같이 출력된다. 생성자에 구분자를 강제로 지정해줄 경우, 이를 막을 수 있다. 직접 지정할 경우 공백이나 줄바꿈이 아니더라도 여러 문자열을 사용할 수 있다.\r\n\r\n``` java\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.13 Sun 23:48:14\r\n */\r\npublic class Test\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tString text = \"A B C D\";\r\n\t\t\r\n\t\tStringTokenizer tokenizer = new StringTokenizer(text);\r\n\t\t\r\n\t\tString[] splited = new String[tokenizer.countTokens()];\r\n\t\t\r\n\t\tfor (int i = 0; i < splited.length; i++)\r\n\t\t{\r\n\t\t\tsplited[i] = tokenizer.nextToken();\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(Arrays.toString(splited));\r\n\t}\r\n}\r\n```\r\n\r\n출력은 동일하다.\r\n\r\n``` tc\r\n[A, B, C, D]\r\n```\r\n\r\n# 속도 비교\r\n\r\n그렇다면 `split`과 `StringTokenizer`의 성능은 어떨까? 이를 비교하기 위해 간단한 테스트 프로그램을 만들었다.\r\n\r\n1. 반복횟수 `t`가 할당된다.\r\n2. 케이스마다 5 ~ 20자의 랜덤한 문자열을 생성한다. 각 문자 사이엔 공백이 포함된다.\r\n3. 공백을 구분자로 문자열을 구분한다\r\n   1. `split` 사용\r\n   2. `StringTokenizer` 사용\r\n4. 총 소요 시간 및 평균 소요 시간을 계산한다\r\n5. 결과를 표시한다\r\n\r\n소스는 아래와 같다.\r\n\r\n``` java\r\nimport java.text.DecimalFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Random;\r\nimport java.util.StringTokenizer;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tint t = 10000;\r\n\t\t\r\n\t\tlong[] timer = { 0, 0 };\r\n\t\t\r\n\t\tint[] sum = { 0, 0 };\r\n\t\t\r\n\t\tfor (int i = 0; i < t; i++)\r\n\t\t{\r\n\t\t\tint random = (int) ((Math.random() * (20 - 5)) + 5);\r\n\t\t\t\r\n\t\t\tString text = getTestString(random);\r\n\t\t\t\r\n\t\t\t// split 로직 ----------------------------------------\r\n\t\t\tlong timeStart = System.nanoTime();\r\n\t\t\t\r\n\t\t\tString[] a1 = useSplit(text);\r\n\t\t\t\r\n\t\t\tlong timeEnd = System.nanoTime() - timeStart;\r\n\t\t\t\r\n\t\t\tsum[0] += a1.length;\r\n\t\t\t\r\n\t\t\ttimer[0] += timeEnd;\r\n\t\t\t\r\n\t\t\tSystem.out.println(Arrays.toString(a1) + \": \" + addComma(timeEnd) + \"ns\");\r\n\t\t\t// split 로직 ----------------------------------------\r\n\t\t\t\r\n\t\t\t// StringTokenizer 로직 ----------------------------------------\r\n\t\t\ttimeStart = System.nanoTime();\r\n\t\t\t\r\n\t\t\tString[] a2 = useStringTokenizer(text);\r\n\t\t\t\r\n\t\t\ttimeEnd = System.nanoTime() - timeStart;\r\n\t\t\t\r\n\t\t\tsum[1] += a2.length;\r\n\t\t\t\r\n\t\t\ttimer[1] += timeEnd;\r\n\t\t\t\r\n\t\t\tSystem.out.println(Arrays.toString(a2) + \": \" + addComma(timeEnd) + \"ns\");\r\n\t\t\t// StringTokenizer 로직 ----------------------------------------\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(addComma(t) + \"개 데이터 그룹 수행\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"split 결과\");\r\n\t\tSystem.out.println(\" * 총 소요: \" + addComma(timer[0]) + \"ns\");\r\n\t\tSystem.out.println(\" * 평균 소요: \" + addComma((timer[0] / t)) + \"ns\");\r\n\t\tSystem.out.println(\" * 분해한 요소: \" + addComma(sum[0]) + \"개\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"StringTokenizer 결과\");\r\n\t\tSystem.out.println(\" * 총 소요: \" + addComma(timer[1]) + \"ns\");\r\n\t\tSystem.out.println(\" * 평균 소요: \" + addComma((timer[1] / t)) + \"ns\");\r\n\t\tSystem.out.println(\" * 분해한 요소: \" + addComma(sum[1]) + \"개\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"split \" + (timer[0] == timer[1] ? \"==\" : (timer[0] > timer[1]) ? \"<\" : \">\") + \" StringTokenizer\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 구분된 문자열 반환 함수 (split)\r\n\t *\r\n\t * @param text: [String] 대상 문자열\r\n\t *\r\n\t * @return [String[]] 구분된 문자열\r\n\t */\r\n\tprivate static String[] useSplit(String text)\r\n\t{\r\n\t\treturn text.split(\" \");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 구분된 문자열 반환 함수 (StringTokenizer)\r\n\t *\r\n\t * @param text: [String] 대상 문자열\r\n\t *\r\n\t * @return [String[]] 구분된 문자열\r\n\t */\r\n\tprivate static String[] useStringTokenizer(String text)\r\n\t{\r\n\t\tStringTokenizer tokenizer = new StringTokenizer(text, \" \");\r\n\t\t\r\n\t\tint count = tokenizer.countTokens();\r\n\t\t\r\n\t\tString[] result = new String[count];\r\n\t\t\r\n\t\tfor (int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tresult[i] = tokenizer.nextToken();\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무작위 문자열 반환 함수\r\n\t *\r\n\t * @param n: [int] 문자 갯수\r\n\t *\r\n\t * @return [String] 무작위 문자\r\n\t */\r\n\tprivate static String getTestString(int n)\r\n\t{\r\n\t\tRandom random = new Random();\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tbuilder.append((char) ((random.nextInt(26)) + 97)).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString().trim();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 1000 단위 구분 숫자 반환 함수\r\n\t *\r\n\t * @param num: [long] 대상 숫자\r\n\t *\r\n\t * @return [String] 1000 단위 구분 숫자\r\n\t */\r\n\tprivate static String addComma(long num)\r\n\t{\r\n\t\tDecimalFormat format = new DecimalFormat(\",###\");\r\n\t\t\r\n\t\treturn format.format(num);\r\n\t}\r\n}\r\n```\r\n\r\n횟수별로 10번씩 돌린 결과를 아래의 표로 정리했다.\r\n\r\n* $t = 1$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    80.3us     |         44.8us          | split < StringTokenizer |\r\n|      2      |    83.7us     |         46.2us          | split < StringTokenizer |\r\n|      3      |    136.6us    |         31.8us          | split < StringTokenizer |\r\n|      4      |    111.3us    |         40.4us          | split < StringTokenizer |\r\n|      5      |    93.4us     |         32.2us          | split < StringTokenizer |\r\n|      6      |    104.5us    |         28.7us          | split < StringTokenizer |\r\n|      7      |    40.1us     |         42.7us          | split > StringTokenizer |\r\n|      8      |    40.1us     |         42.7us          | split > StringTokenizer |\r\n|      9      |    104.7us    |         28.3us          | split < StringTokenizer |\r\n|     10      |    38.3us     |         29.2us          | split < StringTokenizer |\r\n\r\n한 번만 반복할 경우, 8:2로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 100$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    1.12ms     |         0.602ms         | split < StringTokenizer |\r\n|      2      |    1.11ms     |         0.612ms         | split < StringTokenizer |\r\n|      3      |    1.06ms     |         0.562ms         | split < StringTokenizer |\r\n|      4      |    1.02ms     |         0.595ms         | split < StringTokenizer |\r\n|      5      |     1.ms      |         0.550ms         | split < StringTokenizer |\r\n|      6      |    1.16ms     |         0.651ms         | split < StringTokenizer |\r\n|      7      |     98ms      |         0.558ms         | split < StringTokenizer |\r\n|      8      |    1.11ms     |         0.627ms         | split < StringTokenizer |\r\n|      9      |    0.981ms    |         0.555ms         | split < StringTokenizer |\r\n|     10      |    1.23ms     |         0.666ms         | split < StringTokenizer |\r\n\r\n100번을 반복할 때 역시 10:0으로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 1,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    3.00ms     |         3.17ms          | split > StringTokenizer |\r\n|      2      |    2.53ms     |         2.71ms          | split > StringTokenizer |\r\n|      3      |    2.79ms     |         2.84ms          | split > StringTokenizer |\r\n|      4      |    2.53ms     |         2.67ms          | split > StringTokenizer |\r\n|      5      |    2.67ms     |         2.97ms          | split > StringTokenizer |\r\n|      6      |    2.58ms     |         2.87ms          | split > StringTokenizer |\r\n|      7      |    2.48ms     |         2.65ms          | split > StringTokenizer |\r\n|      8      |    2.69ms     |         3.01ms          | split > StringTokenizer |\r\n|      9      |    2.50ms     |         2.90ms          | split > StringTokenizer |\r\n|     10      |    2.62ms     |         2.94ms          | split > StringTokenizer |\r\n\r\n$2^1$, $2^3$처럼 끊어가다가 뜬금없이 1000을 넣은 이유는, 이상하게 $t = 1,000$일 땐 `split`이 압승한다.\r\n\r\n* $t = 10,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    9.91ms     |         9.27ms          | split < StringTokenizer |\r\n|      2      |    9.49ms     |         9.19ms          | split < StringTokenizer |\r\n|      3      |    9.02ms     |         8.61ms          | split < StringTokenizer |\r\n|      4      |    9.95ms     |         9.25ms          | split < StringTokenizer |\r\n|      5      |    9.03ms     |         8.87ms          | split < StringTokenizer |\r\n|      6      |    8.83ms     |         9.08ms          | split > StringTokenizer |\r\n|      7      |    9.14ms     |         8.68ms          | split < StringTokenizer |\r\n|      8      |    9.28ms     |         9.07ms          | split < StringTokenizer |\r\n|      9      |    9.49ms     |         9.66ms          | split > StringTokenizer |\r\n|     10      |    11.79ms    |         11.20ms         | split < StringTokenizer |\r\n\r\n다시 8:2로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 1,000,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |   306.86ms    |        373.06ms         | split > StringTokenizer |\r\n|      2      |   287.26ms    |        262.05ms         | split < StringTokenizer |\r\n|      3      |   289.92ms    |        255.51ms         | split < StringTokenizer |\r\n|      4      |   272.43ms    |        267.96ms         | split < StringTokenizer |\r\n|      5      |   278.35ms    |        322.28ms         | split > StringTokenizer |\r\n|      6      |   285.23ms    |        264.57ms         | split < StringTokenizer |\r\n|      7      |   273.37ms    |        268.18ms         | split < StringTokenizer |\r\n|      8      |   278.65ms    |        264.34ms         | split < StringTokenizer |\r\n|      9      |   278.56ms    |        266.62ms         | split < StringTokenizer |\r\n|     10      |   306.00ms    |        256.56ms         | split < StringTokenizer |\r\n\r\n8:2로 `StringTokenizer`이 압승한다.\r\n\r\n$t = 1,000$이라는 특수한 상황을 제외하고는 보편적으로 `StringTokenizer`가 성능이 더 우수하다. 저런 현상이 왜 발생하는지 이해는 잘 안 된다. 물론 통계라는게 숫자가 클 수록 의미가 커지므로 10번이라는 작은 횟수만으로 단정짓긴 어렵다.\r\n\r\n회사 컴퓨터(AMD Ryzen 2700X)에서는 모든 케이스에서 `StringTokenizer`의 속도가 빨랐다. CPU에 따라 연산 결과나 방식에 조금씩 차이가 있을 순 있겠다.\r\n\r\n[JAVA API](https://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html)에 의하면, `StringTokenizer`은 하위 호환성을 보장하기 위한 레거시 클래스라고 한다. JAVA API는 가급적 `StringTokenizer`보다 `split` 내지는 `regex` <span class=\"orange-400\">패키지</span>를 활용하도록 권고하고 있다.\r\n\r\n> **원문**  \r\n> `StringTokenizer` is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the `split` method of String or the `java.util.regex` package instead.\r\n\r\n# 결론\r\n\r\n표의 수치 상 `StringTokenizer`가 `split`에 비해 최대 약 20% 정도 더 빠르다. 하지만 JAVA API에서 가급적 다른 대체제를 사용하도록 권고하고 있고, 백만번의 연산에도 $ms$ 단위에서 움직인다. 상대적으론 차이가 있어도 객관적인 지표로 봤을땐 별다른 차이가 없는 셈. 문자열 분리하자고 새로운 <span class=\"orange-400\">class</span>를 다룰 바에 그냥 문자열 자체를 다루는 `split`을 사용하는 게 더 효율적이라 생각한다.","url":["2021-06-14-split-and-stringtokenizer","2021","06","14","split-and-stringtokenizer"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1013번 Contact","excerpt":"푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다. 이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-13T04:53:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","정규 표현식","GOLD","GOLD V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-13-a1013.md","content":"\r\n# Contact\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1013번 문제](https://www.acmicpc.net/problem/1013)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n> “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”\r\n\r\n푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다.\r\n\r\n이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.\r\n\r\n전파의 기본 단위는 $\\{ 0 , 1 \\}$ 두 가지로 구성되어있으며, $x+ (  )$ 는 임의의 개수(최소 1개) $x$의 반복으로 이루어진 전파의 집합을 나타낸다.\r\n\r\n$(xyx)+ (  )$ 는 괄호 내의 $xyx$의 반복으로 이루어진 전파의 집합을 뜻한다. 아래는 이해를 돕기 위한 예제이다.\r\n\r\n* 1+ = { 1, 11, 111, 1111, 11111, … }\r\n* 10+ = { 10, 100, 1000, 10000, 100000, … }\r\n* (01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }\r\n* (1001)+ = { 1001, 10011001, 100110011001, … }\r\n* 10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }\r\n* (10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }\r\n\r\n반복을 의미하는 + 외에도 or 를 의미하는 $|$ 기호가 있다. $\\{ x | y \\}$ 는 $x$ 혹은 $y$를 의미하는 것으로, $\\{ 0+ | 1+ \\}$ 는 $\\{ 0 , 1 , 00 , 11 , 000 , 111 , \\dotsm \\}$ 의 집합을 의미한다. 아래는 두 기호를 복합적으로 사용한 예이다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n최근 김동혁 박사는 아레시보 전파망원경에서 star Vega(직녀성) 으로부터 수신한 전파 기록의 일부를 조사하여 그 전파들의 패턴을 분석하여 아래와 같이 기록하였다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n김동혁 박사는 다양한 전파 기록 중에서 위의 패턴을 지니는 전파를 가려내는 프로그램을 필요로 한다. 이를 수행할 수 있는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 전파를 표현하는, $\\{ 0, 1 \\}$만으로 이루어진 문자열이 공백 없이 주어진다. 문자열 길이는 $(1 ≤ N ≤ 200)$의 범위를 갖는다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 전파가 문제에서 제시한 패턴이면 “YES”를 그렇지 않은 경우는 “NO”를 출력한다. 출력 문자열은 모두 대문자로 구성되어 있다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n10010111\r\n011000100110001\r\n0110001011001\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\nNO\r\nNO\r\nYES\r\n```\r\n\r\n# 풀이\r\n\r\n정규식을 대강 알고있다면 이게 왜 <span class=\"amber-A400\">GOLD V</span>인지 다소 이해되지 않는 수준의 문제다. 정규식이 어려운 이유는 원하는 패턴에 맞춰 정규식을 설계하는 건데, 그 정규식을 대놓고 준다. 사실상 정규식의 개념을 아냐 모르느냐를 물어보는 문제.\r\n\r\n나의 경우, 일하다가 간간히 쓸 일이 생겨서 몇 번 다뤄본적이 있어 그리 생소하지 않았다. [regexr](https://regexr.com/)에서 정규식을 설계하고 테스트를 할 수 있으니 참고하자. 정규식 관련해서는 유명한 사이트.\r\n\r\n문제에 대놓고 $(100+1+ | 01)+$라는 정규식 자체를 제공하기 때문에, 그냥 문자열 받아서 정규식과 일치하는지 보면 된다.\r\n\r\nJAVA에서는 `Pattern.matches({정규식 문자열}, {문자열});`과 같이 사용하며, 일치여부를 `boolean`으로 반환한다.\r\n\r\n아래 소스를 보면 알겠지만 진짜 간단하다. 정규식을 아는 사람에겐 <span class=\"brown-500\">BRONZE</span> 수준의 문제.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * 백준 전체 1013 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/13/a1013\">1013 풀이</a>\r\n * @since 2021.06.13 Sun 04:34:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString text = reader.readLine();\r\n\t\t\t\r\n\t\t\t// 정규식 일치 여부\r\n\t\t\tString result = Pattern.matches(\"(100+1+|01)+\", text) ? \"YES\" : \"NO\";\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 문자열\r\n* 정규 표현식\r\n\r\n## 여담\r\n\r\n문제가 생각보다 쉬워서, \"사실 이렇게 하면 안 되는게 아닐까?\"하고 찾아보니 역시나 다른 방식으로 접근하는 방법이 공유되어 있었다. 정규표현식이 아닌 DFA(오토마타 전이 그래프)를 활용하는 방식이다. 정규표현식을 공식적으로 지원해주지 않는 언어라면 대체제로 시도해봄직하다. 백준에선 외부 라이브러리를 사용할 수 없을테니.","url":["2021-06-13-a1013","2021","06","13","a1013"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1012번 유기농 배추","excerpt":"차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-13T01:42:10","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","DFS(깊이 우선 탐색)","BFS(너비 우선 탐색)","SILVER","SILVER II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-13-a1012.md","content":"\r\n# 유기농 배추\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1012번 문제](https://www.acmicpc.net/problem/1012)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)\r\n\r\n한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.\r\n\r\n예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.\r\n\r\n(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">밭</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">0</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t\t<td align=\"center\">1</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 $M(1 ≤ M ≤ 50)$과 세로길이 $N(1 ≤ N ≤ 50)$, 그리고 배추가 심어져 있는 위치의 개수 $K(1 ≤ K ≤ 2500)$이 주어진다. 그 다음 $K$줄에는 배추의 위치 $X(0 ≤ X ≤ M-1)$, $Y(0 ≤ Y ≤ N-1)$가 주어진다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n10 8 17\r\n0 0\r\n1 0\r\n1 1\r\n4 2\r\n4 3\r\n4 5\r\n2 4\r\n3 4\r\n7 4\r\n8 4\r\n9 4\r\n7 5\r\n8 5\r\n9 5\r\n7 6\r\n8 6\r\n9 6\r\n10 10 1\r\n5 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n5\r\n1\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 3 6\r\n0 2\r\n1 2\r\n2 2\r\n3 2\r\n4 2\r\n4 0\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n2\r\n```\r\n\r\n# 풀이\r\n\r\n<span class=\"primary\">DFS(깊이 우선 탐색)</span> 혹은 <span class=\"primary\">BFS(너비 우선 탐색)</span>을 활용하는 기본적인 알고리즘. 추가적인 연산 없이 두 알고리즘 중 익숙한걸 적용하면 끝난다.\r\n\r\n배추흰지렁이는 배추 위에 놓을 수 있으며, 이 벌레는 <span class=\"green-A400\">배추에서 상하좌우로 인접한 배추로 이동</span>할 수 있다. 즉, 배추가 상하좌우로 연결되어있는 구역들의 갯수가 벌레가 필요한 갯수다.\r\n\r\n문제에 예시로 주어진 테이블을 기준으로 보면 아래와 같이 배추가 심어진 구역을 나눌 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121783894-45e09a80-cbec-11eb-99b4-5ed3f3acecd1.png\" width=\"500px\" />\r\n</p>\r\n\r\n위 그림과 같이 총 5개의 구역이 있으므로 벌레 또한 5마리가 필요하다.\r\n\r\nDFS를 적용하면 아래와 같은 절차로 동작한다.\r\n\r\n1. 현재 구역에 배추가 있는지 확인한다.\r\n   1. 배추가 없을 경우 통과한다.\r\n2. 배추가 있을 경우 현재 구역을 처음 탐색하는지 확인한다.\r\n   1. 이미 탐색한 구역일 경우 통과한다.\r\n3. 현재 구역을 방문처리하고, 벌레의 수를 하나 추가한다.\r\n4. 상하좌우로 인접한 구역에 배추가 있는지 확인한다.\r\n   1. 상: $(x, y - 1)$\r\n   2. 하: $(x, y + 1)$\r\n   3. 좌: $(x - 1, y)$\r\n   4. 우: $(x + 1, y)$\r\n5. 배추가 있고, 처음 탐색하는지 확인한다.\r\n   1. 이미 탐색한 구역일 경우 통과한다.\r\n6. 현재 구역을 방문처리한다. 같은 구역이므로 벌레의 수는 추가하지 않는다.\r\n7. 1 ~ 7과정을 반복한다.\r\n\r\nDFS에서의 깊이는 각 구역의 상하좌우 개념과 동일하다. 상하좌우를 비교할 경우, $x$, $y$값이 정해진 밭의 크기 안에 포함되어야 함을 잊지 말자.\r\n\r\n이를 도식화하면 아래와 같이 나타낼 수 있다. 이미 방문한 구역을 녹색으로 표시한다.\r\n\r\n<b class=\"teal-A400 large\">탐색을 수행한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786679-82b48d80-cbfc-11eb-8360-9dae381cc44d.png\" width=\"500px\" />\r\n</p>\r\n\r\n탐색 중인 위치에 배추가 있는지, 처음 방문한 곳인지 확인한다. 그림의 $(0, 0)$의 경우 배추가 있으며 처음 방문한 구역이므로 조건에 해당된다.\r\n\r\n<b class=\"teal-A400 large\">벌레를 추가하고 방문 표시를 한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786686-94963080-cbfc-11eb-9a6a-722d7e3723f2.png\" width=\"500px\" />\r\n</p>\r\n\r\n새로운 구역이므로 벌레 하나를 추가한다. 방문한 구역은 방문 표시를 함으로써 중복 검색을 방지한다.\r\n\r\n<b class=\"teal-A400 large\">인접구역을 탐색한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786712-a677d380-cbfc-11eb-8150-daf8d827a0eb.png\" width=\"500px\" />\r\n</p>\r\n\r\n인접구역인 상하좌우 구역을 탐색한다. $(0, 0)$을 기준으로 $(0, 1)$, $(0, -1)$, $(-1, 0)$, $(1, 0)$이다. 구역의 좌표는 0 이상이어야 하므로, 유효한 구역은 $(0, 1)$, $(1, 0)$ 두 곳이다.\r\n\r\n<b class=\"teal-A400 large\">인접구역에 대해 방문 표시를 한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786730-c27b7500-cbfc-11eb-822c-1956cfd2b954.png\" width=\"500px\" />\r\n</p>\r\n\r\n$(1, 0)$ 역시 방문 전이며, 배추가 있는 구역이다. 인접구역이므로 벌레는 추가하지 않으며, 방문 표시만 한다. 또 다른 인접구역에 대해 동일한 과정을 반복한다.\r\n\r\n위와 같은 과정을 반복하여 구역의 수를 계산할 수 있다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1012 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/13/a1012\">1012 풀이</a>\r\n * @since 2021.06.13 Sun 01:30:12\r\n */\r\npublic class Main\r\n{\r\n\t// 배추밭의 가로 길이(x)\r\n\tprivate static int M;\r\n\t\r\n\t// 배추밭의 세로 길이(y)\r\n\tprivate static int N;\r\n\t\r\n\t// 배추밭\r\n\tprivate static int[][] area;\r\n\t\r\n\t// 구역 방문 여부\r\n\tprivate static boolean[][] isVisit;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tM = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\tN = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 배추 갯수\r\n\t\t\tint K = Integer.parseInt(temp[2]);\r\n\t\t\t\r\n\t\t\tarea = new int[M][N];\r\n\t\t\t\r\n\t\t\tisVisit = new boolean[M][N];\r\n\t\t\t\r\n\t\t\t// 필요한 배추흰지렁이 수\r\n\t\t\tint bugs = 0;\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(temp[0]);\r\n\t\t\t\tint y = Integer.parseInt(temp[1]);\r\n\t\t\t\t\r\n\t\t\t\tarea[x][y] = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int y = 0; y < N; y++)\r\n\t\t\t{\r\n\t\t\t\tfor (int x = 0; x < M; x++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 방문하지 않은 구역에 배추가 있을 경우\r\n\t\t\t\t\tif (area[x][y] == 1 && !isVisit[x][y])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbugs++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdfs(x, y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(bugs);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 깊이 우선 탐색 알고리즘\r\n\t *\r\n\t * @param x: [int] x좌표\r\n\t * @param y: [int] y좌표\r\n\t */\r\n\tprivate static void dfs(int x, int y)\r\n\t{\r\n\t\t// x의 상하좌우 이동\r\n\t\tint[] dx = { 0, 0, -1, 1 };\r\n\t\t\r\n\t\t// y의 상하좌우 이동\r\n\t\tint[] dy = { -1, +1, 0, 0 };\r\n\t\t\r\n\t\tisVisit[x][y] = true;\r\n\t\t\r\n\t\tfor (int i = 0; i < 4; i++)\r\n\t\t{\r\n\t\t\tint xn = x + dx[i];\r\n\t\t\tint yn = y + dy[i];\r\n\t\t\t\r\n\t\t\t// x, y좌표가 구역 내부에 있으며, 방문하지 않은 구역에 배추가 있을 경우\r\n\t\t\tif ((xn > -1 && xn < M) && (yn > -1 && yn < N) && area[xn][yn] == 1 && !isVisit[xn][yn])\r\n\t\t\t{\r\n\t\t\t\tdfs(xn, yn);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 그래프 이론\r\n* 그래프 탐색\r\n* 너비 우선 탐색\r\n* 깊이 우선 탐색","url":["2021-06-13-a1012","2021","06","13","a1012"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1011번 Fly me to the Alpha Centauri","excerpt":"우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다. 그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k - 1 , k 혹은 k + 1 광년만을 다시 이동할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-11T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-11-a1011.md","content":"\r\n# 다리 놓기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1011번 문제](https://www.acmicpc.net/problem/1011)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.\r\n\r\n그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 $k$광년을 이동하였을 때는 $k - 1$ , $k$ 혹은 $k + 1$ 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/rlaehdgur.JPG\" width=\"600px\" />\r\n</p>\r\n\r\n김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 $x$지점에서 $y$지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 $y$지점에 도착해서도 공간 이동장치의 안전성을 위하여 $y$지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.\r\n\r\n김우현을 위해 $x$지점부터 정확히 $y$지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $T$가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 $x$와 목표 위치 $y$가 정수로 주어지며, $x$는 항상 $y$보다 작은 값을 갖는다. $(0 ≤ x < y < 2^31)$\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 $x$지점으로부터 $y$지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0 3\r\n1 5\r\n45 50\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n3\r\n4\r\n```\r\n\r\n# 풀이\r\n\r\nFrank Sinatra의 [Fly me to the moon](https://www.youtube.com/embed/ZEcqHA7dbwM)을 오마주한 제목인 거 같다.\r\n\r\n<p align=\"center\">\r\n\t<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZEcqHA7dbwM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\r\n</p>\r\n\r\n시나트라를 Fallout NV의 Blue Moon으로 처음 접했었는데, 그 후에 Come fly with me나 Theme from Newyork Newyork 같이 좋은 곡들이 너무 많아서 자주 듣는 편이다.\r\n\r\n문제로 돌아와서, 러프하게 보면 \"무작정 빨리가면 되지 않나?\"라고 생각할 수 있다. 하지만 아래 두 조건이 발목을 잡는다.\r\n\r\n1. 처음, 끝 구간은 반드시 <span class=\"primary\">한 칸만 워프</span>할 수 있다.\r\n2. $k$만큼 이동할 경우, <span class=\"primary\">$k - 1$ ~ $k + 1$만큼만 이동 가능</span>함\r\n3. 반드시 <span class=\"primary\">정확한 지점에 도착</span>해야함 (통과 X)\r\n\r\n위 조건들 때문에 새벽 2시 강남의 \"과학\"마냥 쏘다니면 안 된다.\r\n\r\n경우의 수는 아니고, 정해진 규칙이 있으니 이를 계산하여 순서대로 나열하면 단서를 발견할 수 있을 것 같다.\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   2   | 1 1           |     2     |\r\n|   3   | 1 1 1         |     3     |\r\n|   4   | 1 2 1         |     3     |\r\n|   5   | 1 2 1 1       |     4     |\r\n|   6   | 1 2 2 1       |     4     |\r\n|   7   | 1 2 2 1 1     |     5     |\r\n|   8   | 1 2 2 2 1     |     5     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  10   | 1 2 3 2 1 1   |     6     |\r\n|  11   | 1 2 3 2 2 1   |     6     |\r\n|  12   | 1 2 3 3 2 1   |     6     |\r\n|  13   | 1 2 3 3 2 1 1 |     7     |\r\n|  14   | 1 2 3 3 2 2 1 |     7     |\r\n|  15   | 1 2 3 3 3 2 1 |     7     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n잘 안 보일 수도 있으나, 규칙성 찾을 때 가장 만만한 제곱수(1, 4, 9...)를 기준으로 규칙을 정의할 수 있다. 특징은 아래와 같다.\r\n\r\n* 제곱수 이후로 가동 횟수가 1 증가한다.\r\n* 현재 제곱수와 다음 제곱수의 중간에서 가동 횟수가 1 증가한다.\r\n\r\n즉, 제곱수 이후로 가시적인 변화가 있으며, 제곱수를 기준으로 구간의 중간에서 가동률이 1 증가한다.\r\n\r\n### 제곱수의 가동 횟수 일반식\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   4   | 1 2 1         |     3     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n제곱수의 가동률은 아래와 같다. 제곱수 $n$의 가동 횟수 일반식은 아래와 같다.\r\n\r\n$$\r\n2\\sqrt{n} - 1\r\n$$\r\n\r\n9의 경우 $2 * 3 - 1 = 5$이므로 식이 성립함을 알 수 있다.\r\n\r\n### 제곱수가 아닌 수의 가동 횟수 일반식\r\n\r\n제곱수 사이의 중간에서 가동 횟수가 바뀌므로, 이 중간값을 계산하면 된다. 제곱수가 아닌 일반적인 숫자 $k$가 있다고 가정하자. 이 규칙은 제곱수를 중심으로 돌아가므로, $k$를 통해 제곱수를 구해야 한다. 구해야 할 요소는 아래와 같다.\r\n\r\n* $k$보다 크면서 가장 가까운 제곱수\r\n* $k$가 속한 제곱수 구간의 중간값\r\n\r\n1. $k$에 제곱근 연산을 수행하고 이를 반올림한다. $k$보다 크면서 $k$와 가장 가까운 제곱수의 제곱근 $\\sqrt{n}$이 계산된다.\r\n2. $\\sqrt{n}$을 제곱하여 가장 근접한 제곱수 $n$을 계산한다.\r\n3. $n - \\sqrt{n}$의 식으로 $k$가 속한 제곱수 구간의 중간값$t$을 계산한다.\r\n4. $k > t$일 경우, $n$의 가동 횟수와 동일한 $2\\sqrt{n} - 1$식을 적용한다.\r\n5. $k <= t$일 경우, $n$의 가동 횟수에서 1을 뺀 $2\\sqrt{n} - 2$식을 적용한다.\r\n\r\n위 방법을 토대로 7의 가동 횟수를 계산해보자.\r\n\r\n$\\sqrt{7} \\fallingdotseq 2.646$이므로, 이를 반올림하면 3이 계산된다. 즉, 7보다 크면서 가장 가까운 제곱수는 $3^2 = 9$다.\r\n\r\n$9 - \\sqrt{9} = 9 - 3 = 6$이므로, $k$가 속한 제곱수 구간의 중간값은 6이다. 숫자가 6보다 클 경우 9와 가동 횟수가 동일하다. 주어진 숫자는 7이므로 9의 가동 횟수와 동일하다.\r\n\r\n9의 가동횟수는 $2\\sqrt{9} - 1 = 6 - 1 = 5$이므로 7의 가동 횟수 역시 5가 된다.\r\n\r\n위 절차를 코드로 녹여내면 된다. 코드 구현 난이도는 낮다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1011 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/11/a1011\">1011 풀이</a>\r\n * @since 2021.06.11 Fri 09:06:34\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 현재 위치\r\n\t\t\tdouble x = Double.parseDouble(temp[0]);\r\n\t\t\t\r\n\t\t\t// 목표 위치\r\n\t\t\tdouble y = Double.parseDouble(temp[1]);\r\n\t\t\t\r\n\t\t\t// x, y 사이의 거리\r\n\t\t\tdouble distance = y - x;\r\n\t\t\t\r\n\t\t\tSystem.out.println(solve(distance));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가동횟수 반환 함수\r\n\t *\r\n\t * @param distance: [double] 거리\r\n\t *\r\n\t * @return [int] 가동횟수\r\n\t */\r\n\tprivate static int solve(double distance)\r\n\t{\r\n\t\tint result;\r\n\t\t\r\n\t\tdouble ref = Math.sqrt(distance);\r\n\t\t\r\n\t\t// 제곱수일 경우\r\n\t\tif (ref % 1 == 0)\r\n\t\t{\r\n\t\t\tresult = (int) (2 * ref - 1);\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tdouble next = Math.ceil(ref);\r\n\t\t\t\r\n\t\t\t// 이전 제곱수와 다음 제곱수의 중간보다 큰 수일 경우\r\n\t\t\tif (distance > Math.pow(next, 2) - next)\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 2);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n주의할 점이 하나 있는데, $x$와 $y$의 최대값이 $2^31$이다. int의 최대값은 2,147,483,647이지만, $2^31$은 2,147,483,64<span class=\"red-A200\">8</span>이므로 $x$, $y$의 거리 계산 시 int를 사용하면 안 된다. 결과만 int형으로 출력해야 한다.\r\n\r\n메모이제이션을 적용할까 했지만, 배열을 $2^31$ 크기만큼 초기화해야 하므로 오히려 오버헤드가 더 심하게 발생할 것 같다. 재귀함수도 아니니 메모이제이션을 적용해도 별차이 없을 것 같다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-11-a1011","2021","06","11","a1011"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1010번 다리 놓기","excerpt":"재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Combination(조합)","SILVER","SILVER V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1010.md","content":"\r\n# 다리 놓기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1010번 문제](https://www.acmicpc.net/problem/1010)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|  0.5초   |    128MB    |\r\n\r\n## 문제\r\n\r\n재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 <span class=\"primary\">사이트</span>라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 $N$개의 사이트가 있고 동쪽에는 $M$개의 사이트가 있다는 것을 알았다. $(N ≤ M)$\r\n\r\n재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. <span class=\"red-600\">(이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.)</span> 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 ($N$개) 다리를 지으려고 한다. <span class=\"red-600\">다리끼리는 서로 겹쳐질 수 없다</span>고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/pic1.JPG\" width=\"400px\" />\r\n</p>\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 $N$, $M$ $(0 < N ≤ M < 30)$이 주어진다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n2 2\r\n1 5\r\n13 29\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n5\r\n67863915\r\n```\r\n\r\n# 풀이\r\n\r\n규칙을 정리하면 아래와 같다.\r\n\r\n1. $N$구역에서 $M$구역으로 다리를 건설한다.\r\n2. $N <= M$이다.\r\n3. 사이트 당 연결된 다리는 하나다.\r\n4. 다리끼리는 서로 겹쳐서 연결되면 안 된다.\r\n\r\n1000번 부터 문제 풀면서, [1007번 벡터](/posts/2021/06/09/a1007)로 인해 조합이라는 키워드를 쉽게 연상할 수 있었다. 문제에서 $N$구역에서 $M$구역으로 다리를 건설한다고 서술하므로 $N$을 기준으로 생각하기 쉽다. 반대로 $M$을 기준으로 생각하면 해결의 실마리가 보인다. $M$구역의 사이트에서 $N$구역의 사이트 갯수만큼 연결할 사이트에 대한 조합을 계산하면 되기 때문.\r\n\r\n예를 들어 $N$구역에 3개의 사이트가 있고, $M$구역에 5개의 사이트가 있다고 가정하자.\r\n\r\n| 구분  | $M_1$ | $M_2$ | $M_3$ | $M_4$ | $M_5$ |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   O   |   O   |   O   |       |       |\r\n|   2   |   O   |   O   |       |   O   |       |\r\n|   3   |   O   |   O   |       |       |   O   |\r\n|   4   |   O   |       |   O   |   O   |       |\r\n|   5   |   O   |       |   O   |       |   O   |\r\n|   6   |   O   |       |       |   O   |   O   |\r\n|   7   |       |   O   |   O   |   O   |       |\r\n|   8   |       |   O   |   O   |       |   O   |\r\n|   9   |       |   O   |       |   O   |   O   |\r\n|  10   |       |       |   O   |   O   |   O   |\r\n\r\n총 10개의 경우의 수가 존재한다. 이는 $_5C_3$의 계산 결과와 일치한다.\r\n\r\n$$\r\n_5C_3 = \\frac{5!}{3! \\times 2!} = \\frac{5 \\times 4 \\times 3 \\times 2 \\times 1}{(3 \\times 2 \\times 1) \\times (2 \\times 1)} = \\frac{5 \\times 4}{2 \\times 1} = 10\r\n$$\r\n\r\n> ❓ **숫자가 왜 감탄(!)을 하죠?**  \r\n> Factorial(팩토리얼) 연산자로 $n! = n \\times (n - 1) \\times (n - 2) \\times ... \\times 1$과 같은 형태로 연산한다.\r\n\r\n더도말고 덜도말고 조합 알고리즘을 설계하면 된다. 조합의 요소를 반환할 필요 없이, 조합의 갯수만 구하면 되므로 [1007번 벡터](/posts/2021/06/09/a1007)문제보다 더 간단하다.\r\n\r\n## Gotta Go FAST!\r\n\r\n무턱대로 위 식으로 조합 알고리즘을 짜면 <span class=\"red-A400\">시간 초과</span> 오류를 볼 수 있다. 그도 그럴 것이, 원리 자체는 쉽지만 시간제한이 0.5s로 매우 짧기 때문. $M$의 값이 최대 30이므로, 최대 $30!$에 대한 연산을 수행해야하기 때문이다. 그러므로 <span class=\"blue-A400\">Memoization(메모이제이션)</span>이라는 최적화를 적용해야 한다.\r\n\r\n> ❓ **Memoization(메모이제이션)이란?**  \r\n> 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장해놓고 필요 시 사용하여 반복적인 연산 작업을 제거하는 기술.\r\n\r\n조합을 재귀적으로 표현하면 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\n_nC_r = _{n-1}C_{r-1} + _{n-1}C_r\r\n$$\r\n\r\n아래의 그림을 보면 이해하기 쉽다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121479130-b036e680-ca04-11eb-96ed-620c4fc3086a.png\" width=\"700px\" />\r\n</p>\r\n\r\n만약, $_5C_3$을 연산한다면 아래와 같이 진행된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121479160-b6c55e00-ca04-11eb-97da-a4708798a715.png\" width=\"700px\" />\r\n</p>\r\n\r\n이 중, $_3C_2$의 경우 $_4C_2$, $_4C_3$을 계산할 때 필요하므로 여러번 호출된다. 만약, 메모이제이션이 적용되지 않았다면, $_3C_2$이 필요할 때마다 1에서부터 다시 연산해야한다. $_{30}C_{14}$와 같이 숫자가 커지면 위 그림의 깊이도 깊어지기 때문에 많은 오버헤드가 발생한다.\r\n\r\n만약 이렇게 연산된 값을 버리지 않고 메모리상에 저장한 뒤 쓸 수 있다면 연산에서 엄청난 이점이 발생한다. $_3C_2$을 이미 저장했다면 $_4C_2$, $_4C_3$을 계산할 때 저장된 $_3C_2$을 즉시 꺼내 사용할 수 있다. 복잡한 연산을 건너뛸 수 있으며, 동일한 값이 여러번 호출되도 상관없다.\r\n\r\n해당 문제의 조합 알고리즘의 연산에서 한 번 연산된 값을 임의의 배열에 저장하여 이를 활용하면 0.5초라는 짧은 시간을 충족할 수 있을 것이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1010 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/a1010\">1010 풀이</a>\r\n * @since 2021.06.09 Tue 14:14:09\r\n */\r\npublic class Main\r\n{\r\n\t// 다리 건설 경우의 수\r\n\tprivate static final int[][] dp = new int[31][31];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint N = Integer.parseInt(temp[0]);\r\n\t\t\tint M = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\tSystem.out.println(combination(M, N));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 결과 반환 함수\r\n\t *\r\n\t * @param n: 원소 갯수\r\n\t * @param r: 조합 갯수\r\n\t *\r\n\t * @return {int} 조합\r\n\t */\r\n\tprivate static int combination(int n, int r)\r\n\t{\r\n\t\t// 이미 계산된 값일 경우\r\n\t\tif (dp[n][r] > 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r];\r\n\t\t}\r\n\t\t\r\n\t\t// 원소의 갯수가 조합의 갯수와 동일하거나 0일 경우\r\n\t\telse if (n == r || r == 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r] = 1;\r\n\t\t}\r\n\t\t\r\n\t\t// 일반적인 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn dp[n][r] = combination(n - 1, r - 1) + combination(n - 1, r);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$dp[n][r]$는 int형 배열이므로 기본값이 0이다. 즉, $dp[n][r] > 0$일 경우 $_nC_r$가 이미 계산되었다는 뜻이므로, 이미 저장된 값을 반환한다.\r\n\r\n$_5C_0$, $_5C_5$와 같이 $_nC_0$, $_nC_n$일 경우 그 값은 1이다. 해당 케이스의 경우 1을 반환한다. (전체를 선택하거나, 아무것도 선택하지 않는 방법은 하나뿐이다.)\r\n\r\n나머지 일반적인 경우 $_nC_r$의 재귀적 표현 방식인 $_{n-1}C_{r-1} + _{n-1}C_{r}$을 적용하면 된다.\r\n\r\n또한 $dp$ 이차원 배열은 31행렬로 초기화되는데, 그 이유는 $dp$의 행렬이 되는 $N$과 $M$의 최대값이 30이기 때문. 배열은 인덱스가 0부터 시작하므로 1을 더해야 한다.\r\n\r\n또한 케이스별로 $dp$를 초기화하지 않는데, 이는 <span class=\"green-A400\">조합이 범용적이므로 재사용이 가능하기 때문</span>이다. 1번 케이스나 100번 케이스나 $_5C_3$의 값은 10이다. 따라서 초기화를 하지 않으면 오히려 이전 케이스에서 계산했던 내용을 그대로 사용할 수 있어서 이득이다. 만약 첫 번째 케이스에서 $_{30}C_{12}$와 같이 큰 수를 계산했다면, 이후 케이스의 $_{12}C_{5}$와 같은 모든 하위 조합들은 연산을 통째로 건너뛸 수도 있을 것이다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 다이나믹 프로그래밍\r\n* 조합론","url":["2021-06-09-a1010","2021","06","09","a1010"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1009번 분산처리","excerpt":"재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T11:06:38","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","수학","BRONZE","BRONZE IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1009.md","content":"\r\n# 분산처리\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1009번 문제](https://www.acmicpc.net/problem/1009)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    128MB    |\r\n\r\n## 문제\r\n\r\n재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.\r\n\r\n1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터 ...\r\n\r\n10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터 ...\r\n\r\n총 데이터의 개수는 항상 $a^b$개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 $a$와 $b$가 주어진다. $(1 ≤ a < 100, 1 ≤ b < 1,000,000)$\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n1 6\r\n3 7\r\n6 2\r\n7 100\r\n9 635\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n7\r\n6\r\n1\r\n9\r\n```\r\n\r\n# 풀이\r\n\r\n문제속에 답이 있다. 1번 컴퓨터부터 10번 컴퓨터까지 데이터를 처리하는데, 가장 마지막에 데이터를 처리하는 컴퓨터의 번호를 반환하면 된다.\r\n\r\n데이터 12개가 주어졌다고 가정해보자\r\n\r\n| 컴퓨터 | 데이터 |\r\n| :----: | :----: |\r\n|   1    |   1    |\r\n|   2    |   2    |\r\n|   3    |   3    |\r\n|   4    |   4    |\r\n|   5    |   5    |\r\n|   6    |   6    |\r\n|   7    |   7    |\r\n|   8    |   8    |\r\n|   9    |   9    |\r\n|   10   |   10   |\r\n|   1    |   11   |\r\n|   2    |   12   |\r\n\r\n위 표를 통해 어렵지않게 규칙을 찾을 수 있다. <span class=\"green-A400\">데이터를 처리하는 컴퓨터의 번호는 데이터의 1의 자릿수가 가진 값과 동일</span>하다.\r\n\r\n즉, 789235번째 테이터는 5번 컴퓨터가 처리한다는 것이다. 789235에서 1의 자릿수가 5이기 때문.\r\n\r\n따라서 <span class=\"green-A400\">우리는 주어진 데이터 번호에서 1의 자릿수를 추출</span>하면 된다. 고맙게도 컴퓨터의 갯수가 10으로 고정이다. <span class=\"green-A400\">데이터의 번호를 10으로 나누면 1의 자리가 나머지로 남으므로, 이를 활용</span>하면 된다.\r\n\r\n즉 $a^b \\% 10$을 사용하면 된다.\r\n\r\n단, 몇가지 주의할 사항이 있다. 첫 번째로, $a^b$의 값이 너무 커지게 되면 연산 퍼포먼스에도 영향을 미치게된다. 그 전에 값이 너무 커지게되면 약간의 오차도 발생한다.\r\n\r\n어차피 우리는 1의 자리만 필요하므로 이를 나름 센스있게 우회할 수 있다.\r\n\r\n| $a^b$ |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n| $7^3$ |   7   |  49   |  343  |\r\n\r\n위 표는 7의 3제곱을 차례로 계산한 표다. 어차피 우리는 1의 자리만 필요하므로, 굳이 <span class=\"orange-A400\">전체를 계산할 필요 없이, 1의 자리를 기준으로 계산</span>해도 상관없다. 아래의 식을 보면 더욱 명확하다.\r\n\r\n$$\r\n7^3\\text{의 1의 자리} = 49 * 7 \\, \\% \\, 10 = 3\r\n$$\r\n\r\n$$\r\n7^3\\text{의 1의 자리} = (49 \\, \\% \\, 10) * 7 \\% 10 = 9 * 7 \\, \\% \\, 10 = 3\r\n$$\r\n\r\n49에서 7을 곱하는게 아니라 <span class=\"green-A400\">일의 자리 9만 구하여 곱함</span>에 주목하자. 두 번째 식과 같이 <span class=\"green-A400\">수의 일의 자리만 계산하는 방법</span>으로 연산의 오버헤드를 줄일 수 있다.\r\n\r\n두 번째는 10번 째 컴퓨터에 대한 처리다. 예시로, 30번 째 데이터에 대한 처리 공식은 $30 \\, \\% \\, 10 = 0$과 같다. <span class=\"orange-A400\">계산 결과가 0일 경우 10으로 치환</span>해야 한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1009 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/a1009\">1009 풀이</a>\r\n * @since 2021.06.09 Tue 11:06:38\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint a = Integer.parseInt(temp[0]);\r\n\t\t\tint b = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\tint result = 1;\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j <= b; j++)\r\n\t\t\t{\r\n\t\t\t\tresult = result * a % 10;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 0일 경우 10으로 처리\r\n\t\t\tresult = result == 0 ? 10 : result;\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현","url":["2021-06-09-a1009","2021","06","09","a1009"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1008번 A / B","excerpt":"두 정수 A와 B를 입력받은 다음, A / B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T10:25:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1008.md","content":"\r\n# A / B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1008번 문제](https://www.acmicpc.net/problem/1008)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 $A$와 $B$를 입력받은 다음, $A / B$를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $A$와 $B$가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 $A / B$를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 $10^{-9}$ 이하이면 정답이다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 3\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.33333333333333333333333333333333\r\n```\r\n\r\n$10^{-9}$ 이하의 오차를 허용한다는 말은 꼭 소수 9번째 자리까지만 출력하라는 뜻이 아니다.\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n4 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.8\r\n```\r\n\r\n# 풀이\r\n\r\n[백준 1000 A + B](/posts/2021/05/21/a1000), [백준 1001 A - B](/posts/2021/05/21/a1001)에 이은 사칙연산 문제. 틀리기도 어렵다.\r\n\r\nJAVA의 경우, <span class=\"deepOrange-A400\">int</span>로 나누면 정수 부분만 반환하기 때문에, 반드시 <span class=\"deepOrange-A400\">double</span> 같은 실수형 데이터로 선언하여 나눠야 한다는 점만 주의하자.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1008 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/a1008\">1008 풀이</a>\r\n * @since 2021.06.09 Tue 10:23:59\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] line = reader.readLine().split(\" \");\r\n\t\t\r\n\t\tdouble a = Double.parseDouble(line[0]);\r\n\t\tdouble b = Double.parseDouble(line[1]);\r\n\t\t\r\n\t\tSystem.out.println(a / b);\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-06-09-a1008","2021","06","09","a1008"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1007번 벡터","excerpt":"평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다. V에 있는 벡터의 갯수는 P에 있는 점의 절반이다. 평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T00:50:26","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Brute Force(무차별 대입 공격)","Combination(조합)","GOLD","GOLD II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1007.md","content":"\r\n# 습격자 초라기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1007번 문제](https://www.acmicpc.net/problem/1007)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n평면 상에 $N$개의 점이 찍혀있고, 그 점을 집합 $P$라고 하자. 집합 $P$의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 $P$의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, $P$에 속하는 모든 점은 한 번씩 쓰여야 한다.\r\n\r\n$V$에 있는 벡터의 갯수는 $P$에 있는 점의 절반이다.\r\n\r\n평면 상의 점이 주어졌을 때, 집합 $P$의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n테스트 케이스의 첫째 줄에 점의 갯수 $N$이 주어진다. $N$은 짝수이다. 둘째 줄부터 $N$개의 줄에 점의 좌표가 주어진다. $N$은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4\r\n5 5\r\n5 -5\r\n-5 5\r\n-5 -5\r\n2\r\n-100000 -100000\r\n100000 100000\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.000000000000\r\n282842.712474619038\r\n```\r\n\r\n# 풀이\r\n\r\n두 개의 점으로 하나의 벡터를 만들 수 있다. $N <= 20$이므로 주어지는 점의 최대 갯수는 20개다. $N = 20$이라고 가정하면, 만들 수 있는 벡터의 수는 그 절반인 10개다. 20개의 점을 어떻게 잇느냐에 따라서 벡터 10개를 만드는 수 많은 경우의 수가 발생한다. 이 경우의 수에서 <span class=\"red-A400\">벡터의 총합이 가장 작은 값을 계산</span>하는 게 이 알고리즘의 결과다.(10개의 벡터 중 가장 짧은 벡터를 계산하는 것이 아님에 유의하자.)\r\n\r\n이 알고리즘의 핵심은 <span class=\"green-A400\">$N$개의 원소에서 $N / 2$개의 벡터를 만들 수 있는 경우를 계산해서 최소값을 계산</span>하면 된다. $N$의 최대값이 20으로 매우 작으므로 하나하나 비교하는 것이 가능하다. 애초에 알고리즘 자체가 Brute Force(무차별 대입 공격)으로 분류돼있기도 하고.\r\n\r\n좌표 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$가 있으며, 이 좌표에서 두 벡터인 $v_1$, $v_2$를 만든다고 가정하자.(조건은 알고리즘 문제와 동일) $v_1$이 $(x_1, y_1), (x_2, y_2)$으로 이루어져 있으며, $v_2$는 $(x_3, y_3), (x_4, y_4)$로 이루어져있다고 가정하자. 각 벡터를 좌표를 통해 표현하면 아래와 같다.\r\n\r\n$$\r\nv_1 = (x_2 - x_1, y_2 - y_1)\r\n$$\r\n\r\n$$\r\nv_2 = (x_4 - x_3, y_4 - y_3)\r\n$$\r\n\r\n벡터의 합은 벡터 좌표의 단순합으로 이루어진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121457485-b4520c80-c9e2-11eb-8de4-660f9a86a7a1.png\" width=\"700px\" />\r\n</p>\r\n\r\n즉, 벡터의 총합 $v$는 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\nv = v_1 + v_2 = (x_2 + x_4 - x_1 - x_3, y_2 + y_4 - y_1 - y_3)\r\n$$\r\n\r\n$$\r\n||v|| = \\sqrt{(x_2 + x_4 - x_1 - x_3)^2 + (y_2 + y_4 - y_1 - y_3)^2}\r\n$$\r\n\r\n위 식으로 계산한 값의 최소값이 알고리즘의 해답이 된다. 즉, 우리는 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$을 조건에 맞게 조합해야한다. 각 조합의 $||v||$를 계산한 뒤, 이 중 최소값을 반환하면 될 것 같다.\r\n\r\n무턱대고 10개의 벡터를 for문 돌려가며 하나하나 만드는 방법은 안 된다. 좀 더 효율적으로 벡터를 계산하는 방법을 생각해보자.\r\n\r\n$v$식을 자세히 보면 쓸만한 특징일 하나 찾을 수 있는데, 각각의 좌표 $x$, $y$를 계산할 때 좌표의 절반은 더해지고, 절반은 빼진다. 좌표가 4개일 경우 2개는 더해지고, 나머지 2개는 빼진다. 만약 10개라면? 5개는 더해지고, 5개는 빼질 것이다.\r\n\r\n이를 활용하면 전체 좌표 $N$의 절반인 $N / 2$만큼의 좌표 조합을 구한다면 어떨까? 반은 더해지는 좌표, 나머지 반은 빼지는 좌표로 구분할 수 있다. 이후 각 좌표를 더하고 빼주면 손쉽게 $||v||$를 계산할 수 있을 것이다.\r\n\r\n따라서, 점을 반으로 나누어 <span class=\"green-A400\">양의 연산에 사용할 점과 음의 연산에 사용될 점의 경우의 수를 구하는 것이 이번 알고리즘의 핵심</span>이다. $_nC_r$(조합, Combination)을 사용하면 이를 쉽게 구할 수 있을 겻이다. $_nC_{(n / 2)}$를 계산하여, 선택된 좌표는 더하고, 선택되지 않은 좌표는 뺀다.\r\n\r\n예제 1의 $_4C_2$의 경우의 수는 아래와 같다.\r\n\r\n|     양의 좌표     |     음의 좌표     |   $v$    | $\\Vert v \\Vert$ |\r\n| :---------------: | :---------------: | :------: | :-------------: |\r\n|  (5, 5), (5, -5)  | (-5, 5), (-5, -5) | (20, 0)  |       20        |\r\n|  (5, 5), (-5, 5)  | (5, -5), (-5, -5) | (0, 20)  |       20        |\r\n| (5, 5), (-5, -5)  | (5, -5), (-5, 5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, 5)  | (5, 5), (-5, -5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, -5) |  (5, 5), (-5, 5)  | (0, -20) |       20        |\r\n| (-5, 5), (-5, -5) |  (5, 5), (5, -5)  | (-20, 0) |       20        |\r\n\r\n위와 같은 이유로 예제 1에서 벡터 총합의 최소값은 0이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1007 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/a1007\">1007 풀이</a>\r\n * @since 2021.06.09 Tue 00:50:26\r\n */\r\npublic class Main\r\n{\r\n\t// 결과\r\n\tprivate static double result;\r\n\t\r\n\t// 조합 선택 여부\r\n\tprivate static boolean[] isChecked;\r\n\t\r\n\t// 점의 배열\r\n\tprivate static int[][] P;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 점의 갯수\r\n\t\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\t\r\n\t\t\tresult = Double.MAX_VALUE;\r\n\t\t\t\r\n\t\t\tisChecked = new boolean[N];\r\n\t\t\t\r\n\t\t\tP = new int[N][2];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < N; j++)\r\n\t\t\t{\r\n\t\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tP[j][0] = Integer.parseInt(temp[0]);\r\n\t\t\t\tP[j][1] = Integer.parseInt(temp[1]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcombination(0, N / 2);\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t * @param count: [int] 조합할 원소 갯수\r\n\t */\r\n\tprivate static void combination(int index, int count)\r\n\t{\r\n\t\t// 조합할 원소 갯수가 더 이상 없을 경우\r\n\t\tif (count == 0)\r\n\t\t{\r\n\t\t\tresult = Math.min(result, getVector());\r\n\t\t}\r\n\t\t\r\n\t\t// 조합할 원소 갯수가 아직 남아있을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = index; i < P.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisChecked[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(i + 1, count - 1);\r\n\t\t\t\t\r\n\t\t\t\tisChecked[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 벡터 계산 함수\r\n\t *\r\n\t * @return [double] 벡터 크기\r\n\t */\r\n\tprivate static double getVector()\r\n\t{\r\n\t\tint x = 0;\r\n\t\tint y = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < P.length; i++)\r\n\t\t{\r\n\t\t\t// 양수로 선택된 점일 경우\r\n\t\t\tif (isChecked[i])\r\n\t\t\t{\r\n\t\t\t\tx += P[i][0];\r\n\t\t\t\ty += P[i][1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 음수로 선택된 점일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx -= P[i][0];\r\n\t\t\t\ty -= P[i][1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 브루트포스 알고리즘","url":["2021-06-09-a1007","2021","06","09","a1007"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1006번 습격자 초라기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-06T22:42:02","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","PLATINUM","PLATINUM III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-06-a1006.md","content":"\r\n# 습격자 초라기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1006번 문제](https://www.acmicpc.net/problem/1006)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg\" width=\"400px\" />\r\n</p>\r\n\r\n초라기는 각각 $W$명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.\r\n\r\n1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.\r\n2. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.\r\n3. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 $W$ 보다 작거나 같아야 한다.\r\n\r\n이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n첫째 줄에는 (구역의 개수)/2 값 $N$과 특수 소대원의 수 $W$가 주어진다. ($1 ≤ N ≤ 10000$, $1 ≤ W ≤ 10000$).\r\n\r\n둘째 줄에는 $1 ~ N$번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 $N + 1 ~ 2N$번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ $W$)\r\n\r\n## 출력\r\n\r\n각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n8 100\r\n70 60 55 43 57 60 44 50\r\n58 40 47 90 45 52 80 40\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n## 힌트\r\n\r\n하나의 특수 소대로 인접한 두 영역을 커버할 수 있는 배치는 (2,10), (9,16), (4,5), (7,8), (13,14) 이다. 그리고 나머지 6개 구역은 각각 하나의 특수 소대로 커버할 수 있다. 그러므로 최소 11개 특수 소대를 침투시켜야 한다.\r\n\r\n# 풀이\r\n\r\n백준 알고리즘을 순서대로 푸는 나 같은 초심자들에게 <span class=\"red-A400\">힘의 차이</span>를 느끼게 해주는 문제라고 한다. [solved.ac](https://solved.ac/)에 의하면 문제 등급이 무려 <span class=\"teal-A400\">PLATINUM III</span> 수준. 지금까지 푼 문제 중 가장 높은 등급이 [ACM Craft](/posts/2021/06/01/a1005) (<span class=\"amber-A400\">GOLD III</span>) 수준임을 감안하면 월등히 높은 수준의 문제. 실제로 풀면서도 혼자서는 도저히 방법이 안 떠오르는데다, 풀이를 봐도 이해가 잘 안 됐다.\r\n\r\n해당 문제에 주어지는 <span class=\"primary\">구역</span>은 원형이다. 문제를 쉽게 접근하기 위해선 이 원형을 임의로 잘라 직사각형 형태로 전개해야 한다. 즉, <span class=\"error\">풀 때는 직사각형 형태지만, 실제로는 원형이므로 직사각형의 잘린 양 끝부분까지 염두하여 계산</span>을 해야한다. 난이도를 상승시키는 요인 중 하나.\r\n\r\n케이스에 제시된 예제를 기준으로 구역을 사각형으로 도식화하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n위 사진과 같이 8x8 배열로 표현할 수 있다. 여기서 여기서 6번째 행까지 특수소대로 채울 수 있는 최소값은 어떻게 구할 수 있을까?\r\n\r\n역으로 한번 생각해보자. 우리 특수소대는 너무나 유능해서 항상 최소의 팀만으로 목표 구역을 점령한다고 해보자. 작전 보고서엔 아래와 같이 점령한 구역을 표시하며, 이를 <span class=\"yellow-a500\">노란색</span> 영역으로 마킹해서 보여준다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926996-378d0d00-c71a-11eb-9b0f-baacb8da1647.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, <span class=\"yellow-a500\">노란색</span> 영역은 최소의 특수소대팀이 투입된 것이며, 우리가 실제로 구현할 알고리즘의 결과물이기도 하다.\r\n\r\n문제의 설정 상, 특수소대는 반드시 한 팀이 온전히 투입되어야 하며, 최소로 투입 가능한 인원 역시 한 팀이다. 그렇다면 위 사진에서 특수소대 한 팀이 커버할 수 있는 영역을 제외해보면 아래와 같이 세 케이스 $a$, $b$, $c$로 나눌 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927024-568b9f00-c71a-11eb-9309-7e4ef2f06ac2.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, 우리가 저 세 케이스에 대한 특수소대팀의 최소값을 계산할 수 있다면, 결과적으로 6번째 행 전체를 커버하는 특수소대팀의 수를 구할 수 있다. 이미 최소 인원이 나머지 구역을 점령한 상황에서, 투입할 수 있는 최소 인원인 한 팀만 투입할 수 있기 때문.\r\n\r\n여러 블로그에서 위 세 그림을 많이 봤을 텐데, 뜬금없이 저런 그림이 등장함에는 이와같은 배경이 있는 것이다.\r\n\r\n## 변수\r\n\r\n알고리즘 설계에 사용할 변수는 아래와 같다.\r\n\r\n* $T$: 케이스 수\r\n* $N$: 구역의 행 수\r\n* $e$: 구역별 적의 수\r\n* $a_i$: 첫 번째 케이스의 특수소대 최소 투입 수\r\n* $b_i$: 두 번째 케이스의 특수소대 최소 투입 수\r\n* $c_i$: 세 번째 케이스의 특수소대 최소 투입 수\r\n\r\n## a 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927050-77ec8b00-c71a-11eb-8034-5b02a6c04246.png\" width=\"512px\" />\r\n</p>\r\n\r\n첫번째 케이스로 $a_5$의 최소값 공식을 설계하자.\r\n\r\n위에서 했던 방식과 마찬가지로 추론하면 $a_5$에서 한팀을 뺀 $a_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927077-90f53c00-c71a-11eb-96cd-38edba684b10.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = c_5$ 이므로 $a_5 = c_5 + 1$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{05} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927092-9c486780-c71a-11eb-91c7-1922f98a1b01.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = b_4$ 이므로 $a_5 = b_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $a_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $a_5 = c_5 + 1$ -> $a_{i+1} = c_{i+1} + 1$\r\n* $a_5 = b_4 + 1$ -> $a_{i+1} = b_i + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## b 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927110-ac604700-c71a-11eb-989a-3d97d8e6a3ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5$의 최소값 공식을 설계하자.\r\n\r\n$b_5$에서 한팀을 뺀 $b_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927135-c0a44400-c71a-11eb-9c22-4e1303799b3b.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = c_5$ 이므로 $b_5 = c_5 + 1$\r\n\r\n$a_5$의 식과 동일하다.\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{14} + e_{15} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927154-d285e700-c71a-11eb-8b25-14fd85e1b1b0.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = a_4$ 이므로 $b_5 = a_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $b_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $b_5 = c_5 + 1$ -> $b_{n+1} = c_{n+1} + 1$\r\n* $b_5 = a_4 + 1$ -> $b_{n+1} = a_n + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## c 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927173-e3365d00-c71a-11eb-9c1b-dfb34ab3b444.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5$의 최소값 공식을 설계하자. ($c_5$는 4행까지 채워짐에 유의하자)\r\n\r\n$c_5$에서 한팀을 뺀 $c_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 여러 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927189-f47f6980-c71a-11eb-8c17-2120a82b4b6e.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 - 1 = a_4$ 이므로 $c_5 = a_4 + 1$\r\n\r\n$c_5 - 1 = b_4$ 이므로 $c_5 = b_4 + 1$\r\n\r\n두 케이스 중 더 작은 케이스가 $c_5$이므로 아래의 식으로 귀결된다.\r\n\r\n$c_5 = min(a_4 + 1, b_4 + 1)$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927199-ff39fe80-c71a-11eb-8b45-bb4f13aadf08.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 한팀이 네개의 구역을 커버할 수 있을 경우\r\n\r\n$c_i$의 경우 한 가지 특이 케이스가 발생한다. $a_i$, $b_i$의 경우 최소 투입인원인 1을 뺀 값만을 계산했다. $c_i$의 경우 직사각형이라는 특징 때문에 최대 4개 구역을 2팀이 점령할 수 있다.\r\n\r\n$e_{03} + e_{04} ≤ W$ 이고 $e_{13} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927226-11b43800-c71b-11eb-8845-7597a3a502b8.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_3 + 2$\r\n\r\n모든 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $c_{i+1} = min(a_{i} + 1, b_{i} + 1)$\r\n* $c_{i+1} = c_{i} + 1$\r\n* $c_{i+1} = c_{i-1} + 2$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 최종 일반식\r\n\r\n구한 일반식을 정리하면 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 원형 구조 적용을 위한 초기값 지정하기\r\n\r\n위 수식을 코드로 녹여내면 되지만, 완벽한 건 아니다. 왜냐하면 이 구역이 <span class=\"red-A400\">선형이 아닌 원형 구조</span>이기 때문.\r\n\r\n지금까지 우리는 원리 이해 및 수식 도출의 편의를 위해 원타곤을 임의로 잘라 표타곤으로 전개하여 수식을 계산했다. 이러한 <span class=\"green-A700\">선형 구조는 시작점과 도착점이 있지만 원형은 순환 구조</span>이므로 이에 맞춰 조건식을 작성해야 한다. 즉, <span class=\"red-A400\">원형 구조에 호환되도록 일부 케이스에 초기값을 지정</span>해야 최종적으로 원하는 알고리즘을 작성할 수 있다.\r\n\r\n아래의 사진은 원타곤과 표타곤을 비교한 것이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927246-2b557f80-c71b-11eb-92bf-fe5f92cf5504.png\" width=\"512px\" />\r\n</p>\r\n\r\n이 처럼, 원형 구조는 $e_{00}, e_{07}$끼리도 연결이 가능하지만, 선형 구조는 구조상 불가능하다. 때문에 이러한 케이스들의 초기값을 지정해줘야한다.\r\n\r\n대충 감이 오겠지만, 걸친 모양에 따라 총 4가지 케이스가 존재한다.\r\n\r\n### 걸치지 않을 경우 (기본)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$ 혹은 $e_{10}, e_{17}$과 같이 영역이 겹치지 않을 경우. 선형 구조에서도 적용 가능한 기본적인 케이스다. $a_i, b_i, c_i$의 모양과 연관지어 생각하면 아래와 같이 도식이 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927267-4a541180-c71b-11eb-8596-497ba12219e4.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_i$는 $i$열의 윗 칸만 채우므로 $e_{00}$만 점령한 상태이므로 1\r\n\r\n$b_i$는 $i$열의 아래 칸만 채우므로 $e_{01}$만 점령한 상태이므로 1\r\n\r\n$c_i$는 $i - 1$열을 채우는데, $c_{-1}$은 논리상 불가능하므로 0\r\n\r\n즉 초기값은 아래와 같다.\r\n\r\n$$\r\na_0 = 1\r\n$$\r\n\r\n$$\r\nb_0 = 1\r\n$$\r\n\r\n$$\r\nc_0 = 0\r\n$$\r\n\r\n$i = 0$일 때의 초기값을 지정한다.\r\n\r\n이 케이스일 경우 $c_N$이 알고리즘의 답이 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_8$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927320-88e9cc00-c71b-11eb-8ae4-3dfb03d4e0f0.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 윗 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927336-9bfc9c00-c71b-11eb-837d-77c000661702.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$을 점령할 경우. 원형 구조에서만 가능한 케이스다. **걸치지 않는 경우**를 제외한 나머지 케이스는 전부 원형 구조에서만 가능한 케이스이니 참고할 것. $i = 0$일 때는 영향을 받지 않아 **걸치지 않는 경우**와 동일하다. 걸치기 위해선 반드시 두 행 이상이 필요하기 때문에, $N > 1$을 충족해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927372-a880f480-c71b-11eb-84cc-689658a3a89c.png\" width=\"512px\" />\r\n</p>\r\n\r\n연결된 부분을 체크패턴으로 하이라이팅 했다. 이 둘이 서로 연결되기 때문에, 다른 구역의 특수소대가 점령할 수 없다. 따라서 <b class=\"red-A400\">해당 부분은 초기값 계산 시 없는 영역으로 생각하면 된다.</b> 이러한 특징을 감안하면 아래와 같이 초기값을 지정할 수 있다.\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 2\r\n$$\r\n\r\n$$\r\nb_1 = \r\n\\begin{cases}\r\n\t1, & (e_{10} + e_{11} ≤ W)\\\\\r\n\t2, & (e_{10} + e_{11} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $b_{N-1} + 1$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927427-b767a700-c71b-11eb-9306-0931ede25cba.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 아래 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927442-c6e6f000-c71b-11eb-8f51-2fab907fbcc2.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927459-d1a18500-c71b-11eb-9c6c-07919e9f4f8d.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = \r\n\\begin{cases}\r\n\t1, & (e_{00} + e_{01} ≤ W)\\\\\r\n\t2, & (e_{00} + e_{01} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_1 = 2\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $a_{N-1} + 1$이 알고리즘의 답이 된다. $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927475-e120ce00-c71b-11eb-8bd6-c44d4137fae8.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 두 행 모두 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927491-ee3dbd00-c71b-11eb-98b9-f0d4209ec965.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$, $e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927507-fd246f80-c71b-11eb-8e78-f08c15922ad8.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$, $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 1\r\n$$\r\n\r\n$$\r\nb_1 = 1\r\n$$\r\n\r\n$$\r\nc_1 = 0\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $c_{N-1} + 2$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$, $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_{N-1} + 2$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927519-07df0480-c71c-11eb-9fdf-c8f05858b72d.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 최종 케이스\r\n\r\n* 기본\r\n  * $a_0 = 1$\r\n  * $b_0 = 1$\r\n  * $c_0 = 0$\r\n\r\n<br />\r\n\r\n* 윗 행만 걸칠 경우 $(e_{00} + e_{0(N-1))} ≤ W)$\r\n  * $a_1 = 2$\r\n  * $b_1 = \\begin{cases} 1, & (e_{10} + e_{11} ≤ W)\\\\ 2, & (e_{10} + e_{11} > W) \\end{cases}$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 아래 행만 걸칠 경우 $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = \\begin{cases} 1, & (e_{00} + e_{01} ≤ W)\\\\ 2, & (e_{00} + e_{01} > W) \\end{cases}$\r\n  * $b_1 = 2$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 두 행 모두 걸칠 경우 $(e_{00} + e_{0(N-1)} ≤ W)$, $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = 1$\r\n  * $b_1 = 1$\r\n  * $c_1 = 0$\r\n\r\n비로소 알고리즘을 구현하기 위한 모든 준비물이 갖춰졌다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1006 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/06/a1006\">1006 풀이</a>\r\n * @since 2021.06.06 Sun 22:44:45\r\n */\r\npublic class Main\r\n{\r\n\tprivate static int N;\r\n\tprivate static int W;\r\n\t\r\n\tprivate static int[][] e;\r\n\t\r\n\tprivate static int[] a;\r\n\tprivate static int[] b;\r\n\tprivate static int[] c;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tint result = 2147483647;\r\n\t\t\t\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 행 수\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\t// 특수소대원 수\r\n\t\t\tW = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 구역별 적 배열\r\n\t\t\te = new int[2][N];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < 2; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tfor (int k = 0; k < N; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\te[j][k] = Integer.parseInt(temp[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ta = new int[N];\r\n\t\t\tb = new int[N];\r\n\t\t\tc = new int[N + 1];\r\n\t\t\t\r\n\t\t\ta[0] = 1;\r\n\t\t\tb[0] = 1;\r\n\t\t\tc[0] = 0;\r\n\t\t\t\r\n\t\t\t// 인덱스 0부터 시작\r\n\t\t\tsolve(0);\r\n\t\t\t\r\n\t\t\tresult = Math.min(result, c[N]);\r\n\t\t\t\r\n\t\t\t// 두 행 이상일 경우\r\n\t\t\tif (N > 1)\r\n\t\t\t{\r\n\t\t\t\t// 두 행 모두 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W && e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 1;\r\n\t\t\t\t\tb[1] = 1;\r\n\t\t\t\t\tc[1] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, c[N - 1] + 2);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 윗 행만 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 2;\r\n\t\t\t\t\tb[1] = e[1][0] + e[1][1] > W ? 2 : 1;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, b[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아래 행만 걸칠 경우\r\n\t\t\t\tif (e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = e[0][0] + e[0][1] > W ? 2 : 1;\r\n\t\t\t\t\tb[1] = 2;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, a[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 함수\r\n\t *\r\n\t * @param num: [int] 시작 인덱스\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\tfor (int i = num; i < N; i++)\r\n\t\t{\r\n\t\t\tc[i + 1] = Math.min(a[i] + 1, b[i] + 1);\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\tif (e[0][i] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i] + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두개의 구역 2개를 점령할 수 있을 경우\r\n\t\t\tif (i > 0 && e[0][i - 1] + e[0][i] <= W && e[1][i - 1] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i - 1] + 2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// a, b팀의 인덱스 보정 (c팀은 인덱스가 하나 더 많음)\r\n\t\t\tif (i < N - 1)\r\n\t\t\t{\r\n\t\t\t\ta[i + 1] = c[i + 1] + 1;\r\n\t\t\t\tb[i + 1] = c[i + 1] + 1;\r\n\t\t\t\t\r\n\t\t\t\t// a팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[0][i] + e[0][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[i + 1] = Math.min(a[i + 1], b[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// b팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[1][i] + e[1][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\tb[i + 1] = Math.min(b[i + 1], a[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n6월 1일부터 풀기 시작해서 이 문제를 완전히 이해하는데 근 일주일 가까이 걸렸다. 나름의 풀이를 작성해야하는데, 남의 풀이가 아닌 내 풀이를 작성하기 위해선 해당 문제를 온전히 이해할 필요가 있었다. 내가 다른 사람들의 풀이를 보면서 이해하지 못해서 내 스스로 생각하고 이해한 걸 나름대로 녹여냈다. 다른 사람이 내 글을 보고 이 어려운 문제를 쉽게 이해할 수 있었으면 좋겠다.\r\n\r\n이해하고 봐도 다소 난해한데, 이걸 원리부터 코드까지 이끌어내어 풀어내는 사람은 정말 대단한 거 같다. 아님 내가 실력이 없는건가.\r\n\r\n## 참고\r\n\r\n* [The Casterian](https://casterian.net/archives/1356)\r\n* [굳건하게](https://travelbeeee.tistory.com/354)\r\n* [테스트 케이스](https://www.acmicpc.net/board/view/11381)","url":["2021-06-06-a1006","2021","06","06","a1006"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1005번 ACM Craft","excerpt":"서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-01T01:27:56","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","위상 정렬","GOLD","GOLD III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-01-a1005.md","content":"\r\n# ACM Craft\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1005번 문제](https://www.acmicpc.net/problem/1005)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다.\r\n\r\n이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219763-b1cf1480-c276-11eb-8131-a3471db1cfc4.png\" width=\"1024px\" />\r\n</p>\r\n\r\n위의 예시를 보자.\r\n\r\n이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할 수 있다. (동시에 진행이 가능하다.) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번 건물의 건설을 시작할 수 있다.\r\n\r\n따라서 4번 건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물와 3번 건물을 동시에 건설하기 시작하면 2번은 1초 뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을 수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.\r\n\r\n프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM Craft 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정 건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정 건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.\r\n\r\n## 입력\r\n\r\n첫째 줄에는 테스트케이스의 갯수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다, 첫째 줄에 건물의 갯수 $N$과 건물 간의 건설순서 규칙의 총 갯수 $K$가 주어진다.(전물의 번호는 1번 부터 $N$번 까지 존재한다.)\r\n\r\n둘째 줄에는 각 건물 당 건설에 걸리는 시간 $D$가 공백을 사이로 주어진다. 셋째 줄부터 $K + 2$줄 까지 건설순서 $X$ $Y$가 주어진다.(이는 건물 X를 지은 다음에 건물 $Y$를 짓는 것이 가능하다는 의미이다.)\r\n\r\n마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 $W$가 주어진다.\r\n\r\n## 출력\r\n\r\n건물 $W$를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.  \r\n건설순서는 모든 건물이 건설 가능하도록 주어진다.\r\n\r\n## 제한\r\n\r\n* $2 ≤ N ≤ 1,000$\r\n* $1 ≤ K ≤ 100,000$\r\n* $1 ≤ X, Y, W ≤ N$\r\n* $0 ≤ D ≤ 100,000)$ $D$는 정수\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4 4\r\n10 1 100 10\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4\r\n8 8\r\n10 20 1 5 8 7 1 43\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n5 7\r\n6 7\r\n7 8\r\n7\r\n```\r\n+ 출력\r\n\r\n``` tc\r\n120\r\n39\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n3 2\r\n1 2 3\r\n3 2\r\n2 1\r\n1\r\n4 3\r\n5 5 5 5\r\n1 2\r\n1 3\r\n2 3\r\n4\r\n5 10\r\n100000 99999 99997 99994 99990\r\n4 5\r\n3 5\r\n3 4\r\n2 5\r\n2 4\r\n2 3\r\n1 5\r\n1 4\r\n1 3\r\n1 2\r\n4\r\n4 3\r\n1 1 1 1\r\n1 2\r\n3 2\r\n1 4\r\n4\r\n7 8\r\n0 0 0 0 0 0 0\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4 5\r\n4 6\r\n5 7\r\n6 7\r\n7\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n6\r\n5\r\n399990\r\n2\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 이해가 되는데, 이를 코딩으로 풀어내기가 어려웠던 알고리즘. <span class=\"primary\">위상정렬</span> 알고리즘에 대한 이해가 있어야한다.  \r\n문제의 경우, 스타크래프트의 건물 테크트리랑 비슷한 개념으로 접근하면 된다. 군수공장을 짓기 위해선 병영을 지어야하는 것처럼, 요구 트리가 있는 건물의 경우 해당 건물을 반드시 완료해야 하며, 하나의 건물이 여러 요구 트리를 가질 경우도 존재한다. 물론 이 경우 요구하는 건물들을 **모두** 건설한 뒤에 건설 가능하다. 요구하는 건물들 중 하나만 건설하면 충족되는게 아니다.\r\n\r\n<span class=\"primary\">위상정렬</span>은 <span class=\"green-A400\">순서가 정해진 작업을 수행할 때, 이 순서를 결정하는 알고리즘</span>이다. <span class=\"primary\">위상정렬</span>은 반드시 DAG(Directed Acyclic Graph, 유향 비순환 그래프) 형태여야 한다. 즉, 순서를 도식화했을 때 반드시 <span class=\"red-A400\">시작/도착점이 존재</span>해야 한다. 시작/도착점이 구분되지 않는 순환 형태일 경우 위상정렬을 적용할 수 없다.\r\n\r\n위상정렬은 순서를 정하는 알고리즘이고, 순서도의 형태에 따라 여러가지의 답이 나올 수 있다. 이 문제는 최적의 답을 도출하기 위해 각 **건물을 건설하는데 필요한 요구 건물**과 **건설 시간**을 적용했다.\r\n\r\n다음 건물을 건설하기 위해선 요구 건물을 모두 건설해야하므로 요구 건물의 건설시간이 가장 많은 건물이 다음 순서가 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219453-3b321700-c276-11eb-9029-ec105c694854.png\" width=\"1024px\" />\r\n</p>\r\n\r\n예시 1번의 두 번째 케이스를 예시로 하여 위상정렬을 도식화하면 위 사진과 같다.\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   0   |   1   |   1   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n위 표는 도식를 수치화하여 정리한 것이다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">1. 순서의 시작점(진입선이 없는 점)을 찾는다. 시작점이 여러개일 경우 시작점 중 무작위로 하나를 선택해도 무방하다. (위 예시는 시작점이 하나)</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219469-4127f800-c276-11eb-91c8-db36e543c217.png\" width=\"1024px\" />\r\n</p>\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">2. 시작점 1을 큐에 넣고, 시작점에 연결된 진출선을 전부 제거한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219471-438a5200-c276-11eb-9cd3-ca5f31dfb19b.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   0   |   0   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |\r\n| :---: | :---: |\r\n\r\n이 과정에서 2와 3이 새로운 시작점이 된 것을 확인할 수 있다.\r\n\r\n1을 건설하는데 걸리는 시간은 1초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">3. 2에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219484-45ecac00-c276-11eb-8114-a6c4c8b17036.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   0   |   0   |   0   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |\r\n| :---: | :---: | :---: |\r\n\r\n4와 5의 진입선이 0이 된다. 즉, 4와 5를 건설할 수 있게 된다.\r\n\r\n2를 건설하는데는 $10(1) + 20(2)$로 총 30초가 소요된다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">4. 3에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219493-48e79c80-c276-11eb-8f48-cf132cab8f5c.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   0   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n\r\n6의 진입선이 0이 된다. 6을 건설할 수 있게 된다.\r\n\r\n3의 건설시간은 $10(1) + 1(3)$으로 총 11초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">5. 4에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219504-4be28d00-c276-11eb-9b40-07c5ea51cbd9.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |\r\n| :---: | :---: | :---: | :---: | :---: |\r\n\r\n4는 진출선이 없으므로 큐에만 추가된다.\r\n\r\n4의 건설시간은 $10(1) + 20(2) + 5(4)$로 총 35초\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">6. 5에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219509-4edd7d80-c276-11eb-9c5f-fc17d373bf50.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   0   |   1   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7이 5와 6에 연결되어 있으므로, 7의 진입선은 1이 된다. 아직 7을 건설할 수 없다.\r\n\r\n5의 건설시간은 $10(1) + 20(2) + 8(5)$로 총 38초\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">7. 6에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219520-53099b00-c276-11eb-9c99-060dcd2039d8.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   0   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7의 진입선이 0이 된다. 7을 건설할 수 있게 된다.\r\n\r\n6의 건설시간은 $10(1) + 1(3) + 7(6)$으로 총 18초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">8. 7에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219527-56048b80-c276-11eb-866b-9b411445b22b.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   0   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n8의 진입선이 0이 된다.\r\n\r\n1 ~ 6까지는 요구 건물이 하나였지만, 7은 두개이다. 앞서 언급했듯이, 5와 6 중 건설시간이 더 긴 것을 기준으로 계산해야한다.\r\n\r\n즉, 7의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7)$로 총 39초\r\n\r\n5번을 기준으로 계산하므로, <span class=\"red-A400\">6번과 중간인 3번은 계산에서 제외</span>된다. 만약, 3의 건설시간을 1초에서 4초로 증가시켜도 결과에 영향을 미치지 않는다. 3의 건설시간을 무시하기 때문이다. 단, 3의 건설시간이 너무 커지게되면 5보다 6의 건설시간이 같이 커지게 되어 결과에 영향을 미치게 된다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">9. 8에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219535-58ff7c00-c276-11eb-907c-2a90cc84c596.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n문제는 7에 대한 건설시간을 요구하고 있으므로 8은 무시해도 무방하다. \r\n8의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7) + 43(8)$로 총 82초\r\n\r\n## 전체 소스\r\n\r\n`time`, `matrix`, `link`의 배열 크기가 $N + 1$이다. 별다른 이유는 아니고, 건물은 1번부터 시작하는데 배열은 0번부터 시작한다. 이러한 차이에서 오는 혼란을 방지하기 위해 건물이 총 4개면 배열의 크기를 5로(0, 1, 2, 3, 4, 5)로 지정하여 0을 제외하고 1부터 사용한다.\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1005 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.05.31 Mon 19:11:58\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\t// 케이스 갯수\r\n\t\tint T = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 건물 갯수\r\n\t\t\tint N = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 규칙(건설시간) 갯수\r\n\t\t\tint K = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 건물별 건설시간 배열\r\n\t\t\tint[] time = new int[N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결여부 배열\r\n\t\t\tboolean[][] maxtrix = new boolean[N + 1][N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결 갯수 배열\r\n\t\t\tint[] link = new int[N + 1];\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j < N + 1; j++)\r\n\t\t\t{\r\n\t\t\t\ttime[j] = scanner.nextInt();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물\r\n\t\t\t\tint X = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\t// 상위 건물\r\n\t\t\t\tint Y = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\tmaxtrix[X][Y] = true;\r\n\t\t\t\tlink[Y]++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표 건물\r\n\t\t\tint W = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tbuilder.append(calcTopologicalSort(time, maxtrix, link)[W]).append(\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString());\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위상정렬 결과 반환 함수\r\n\t *\r\n\t * @param time: [int[]] 건물별 건설시간\r\n\t * @param matrix: [boolean[][]] 건물별 연결여부\r\n\t * @param link: [int[]] 건물별 연결 갯수\r\n\t *\r\n\t * @return [int[]] 건물별 종 건설시간 배열\r\n\t */\r\n\tprivate static int[] calcTopologicalSort(int[] time, boolean[][] matrix, int[] link)\r\n\t{\r\n\t\tQueue<Integer> queue = new LinkedList<>();\r\n\t\t\r\n\t\tint[] result = new int[link.length];\r\n\t\t\r\n\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t{\r\n\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\tif (link[i] == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = time[i];\r\n\t\t\t\tqueue.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\t// 하위 건물\r\n\t\t\tint prev = queue.poll();\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물 건설을 요구 하는 건물일 경우\r\n\t\t\t\tif (matrix[prev][i])\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = Math.max(result[i], result[prev] + time[i]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 해당 건물의 요구 건물 갯수 1 감소\r\n\t\t\t\t\t--link[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\t\t\tif (link[i] == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tqueue.add(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 그래프 이론\r\n* 위상 정렬","url":["2021-06-01-a1005","2021","06","01","a1005"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1004번 어린 왕자","excerpt":"어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-22T21:42:23","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","기하학","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-22-a1004.md","content":"\r\n# 어린 왕자\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1004번 문제](https://www.acmicpc.net/problem/1004)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfcmhrjj_113gw6bcng2_b.gif\" width=\"512px\" />\r\n</p>\r\n\r\n빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.\r\n\r\n위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. (행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다고 가정한다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.)\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 $(x_1, y_1)$과 도착점 $(x_2, y_2)$이 주어진다. 두 번째 줄에는 행성계의 개수 $n$이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 $(c_x, c_y, r)$이 주어진다. 입력제한은 다음과 같다. $(-1000 ≤ x_1, y_1, x_2, y_2, c_x, c_y ≤ 1000, 1 ≤ r ≤ 1000, 1 ≤ n ≤ 50)$\r\n\r\n좌표와 반지름은 모두 정수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n-5 1 12 1\r\n7\r\n1 1 8\r\n-3 -1 1\r\n2 2 2\r\n5 5 1\r\n-4 5 1\r\n12 1 1\r\n12 1 2\r\n-5 1 5 1\r\n1\r\n0 0 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n1002번째 알고리즘의 내용을 응용하면 쉽게 풀 수 있는 문제인 것 같다. 실제로 별다른 레퍼런스를 찾지도 않고 풀 수 있었으니.\r\n\r\n문제를 풀기 전에 몇 가지 집고 넘아갈 게 있다.  \r\n숫자들 때문에 입력의 한 세트를 착각하기 쉽다.\r\n\r\n위 예제를 기준으로 설명하면, 첫 번째 숫자는 세트의 갯수. 본문에서는 `2`이므로, 두 세트를 테스트하므로 결과는 두 줄이 출력된다.  \r\n이후 테스트에 필요한 데이터가 출력된다.\r\n\r\n-5 1 12 1 <= $x_1, y_1, x_2, y_2$  \r\n7 <= 행성 갯수  \r\n1 1 8 <= $c_{x1}, c_{y1}, r_1$  \r\n-3 -1 1  \r\n2 2 2  \r\n5 5 1  \r\n-4 5 1  \r\n12 1 1  \r\n12 1 2 <= 행성 갯수만큼 출력됨\r\n\r\n또한, 결과는 행성계의 진입/이탈 횟수를 통틀어서 출력하므로 굳이 진입/이탈을 구분하여 저장할 필요는 없다.\r\n\r\n문제에서 **출발점에서 도착점까지 가는데 통과해야하는 행성계(이하 원, circle)의 최소**를 목적으로 두기 때문에, 반드시 통과해야하는 원만 계산하면 된다.  \r\n출발/도착점이 임의의 원 안에 포함될 경우 반드시 진입/이탈이 일어난다. 따라서, 출발/도착점을 온전히 포함하는 원의 갯수를 계산하면 진입/이탈의 횟수를 구할 수 있다.  \r\n주의할 점이 있는데, **한 원이 출발/도착점을 모두 포함할 경우 계산에서 제외**시켜야 한다.  \r\n하나의 원이 출발/도착점을 전부 포함할 경우, 원 안에서 이동하기 때문에 진입/이탈이 일어나지 않기 때문.  \r\n\r\n![example](https://user-images.githubusercontent.com/50317129/120758690-188d5000-c54d-11eb-917c-f910eb7b3199.png)\r\n\r\n원리는 간단하다. 원점과 점의 거리를 계산한다. 계산한 거리가 원의 반지름보다 짧을 경우, 해당 원은 점을 포함하는 셈이다.  \r\n이를 식으로 정리하면 아래와 같다.\r\n\r\n|     변수     |      의미      |\r\n| :----------: | :------------: |\r\n|   $x$, $y$   |   원점 좌표    |\r\n| $x_o$, $y_o$ | 원의 원점 좌표 |\r\n|     $r$      |  원의 반지름   |\r\n\r\n변수는 위 표와 같이 정의하고 <span class=\"green-A700\">한 원이 원점을 포함하는 식</span>을 전개한다.\r\n\r\n$$\r\n\\sqrt{(x_0 - x)^2 + (y_0 - y)^2} < r\r\n$$\r\n\r\n위 식을 코드로 표현하면 되는 비교적 간단한 알고리즘이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1004 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.24 Sat 02:15:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint length = scanner.nextInt();\r\n\t\tscanner.nextLine();\r\n\t\t\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tString base = scanner.nextLine();\r\n\t\t\t\r\n\t\t\tint x_start = Integer.parseInt(base.split(\" \")[0]);\r\n\t\t\tint y_start = Integer.parseInt(base.split(\" \")[1]);\r\n\t\t\t\r\n\t\t\tint x_end = Integer.parseInt(base.split(\" \")[2]);\r\n\t\t\tint y_end = Integer.parseInt(base.split(\" \")[3]);\r\n\t\t\t\r\n\t\t\tint through = 0;\r\n\t\t\t\r\n\t\t\tint count = scanner.nextInt();\r\n\t\t\tscanner.nextLine();\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < count; j++)\r\n\t\t\t{\r\n\t\t\t\tString circle = scanner.nextLine();\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(circle.split(\" \")[0]);\r\n\t\t\t\tint y = Integer.parseInt(circle.split(\" \")[1]);\r\n\t\t\t\tint r = Integer.parseInt(circle.split(\" \")[2]);\r\n\t\t\t\t\r\n\t\t\t\tboolean hasStartContain = hasContain(x_start, y_start, x, y, r);\r\n\t\t\t\tboolean hasEndContain = hasContain(x_end, y_end, x, y, r);\r\n\t\t\t\t\r\n\t\t\t\t// 해당 행성이 출발 혹은 도착점 중 하나만을 포함할 경우\r\n\t\t\t\tif (!(hasStartContain && hasEndContain) && (hasStartContain || hasEndContain))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrough++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(through);\r\n\t\t}\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 출발/도착점 포함 여부 반환 함수\r\n\t *\r\n\t * @param xo: [int] 출발/도착점의 x좌표\r\n\t * @param yo: [int] 출발/도착점의 y좌표\r\n\t * @param x: [int] 행성의 x좌표\r\n\t * @param y: [int] 행성의 y좌표\r\n\t * @param r: [int] 행성의 반지름\r\n\t *\r\n\t * @return [boolean] 출발/도착점 포함 여부\r\n\t */\r\n\tprivate static boolean hasContain(int xo, int yo, int x, int y, int r)\r\n\t{\r\n\t\treturn Math.sqrt(Math.pow(xo - x, 2) + Math.pow(yo - y, 2)) < r;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 기하학","url":["2021-05-22-a1004","2021","05","22","a1004"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1003번 피보나치 함수","excerpt":"다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T23:29:03","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","피보나치 수열","Dynamic Programming(동적 프로그래밍)","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1003.md","content":"\r\n# 피보나치 함수\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1003번 문제](https://www.acmicpc.net/problem/1003)\r\n\r\n## 조건\r\n\r\n|        시간제한         | 메모리 제한 |\r\n| :---------------------: | :---------: |\r\n| 0.25초 (추가 시간 없음) |    128MB    |\r\n\r\n## 문제\r\n\r\n다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.\r\n\r\n``` cpp\r\nint fibonacci(int n) {\r\n    if (n == 0) {\r\n        printf(\"0\");\r\n        return 0;\r\n    } else if (n == 1) {\r\n        printf(\"1\");\r\n        return 1;\r\n    } else {\r\n        return fibonacci(n‐1) + fibonacci(n‐2);\r\n    }\r\n}\r\n```\r\n\r\n$fibonacci(3)$을 호출하면 다음과 같은 일이 일어난다.\r\n\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$ (첫 번째 호출)을 호출한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$ (두 번째 호출)과 $fibonacci(0)$을 호출한다.\r\n* 두 번째 호출한 $fibonacci(1)$은 1을 출력하고 1을 리턴한다.\r\n* $fibonacci(0)$은 0을 출력하고 0을 리턴한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$과 $fibonacci(0)$의 결과를 얻고, 1을 리턴한다.\r\n* 첫 번째 호출한 $fibonacci(1)$은 1을 출력하고, 1을 리턴한다.\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$의 결과를 얻고, 2를 리턴한다.\r\n\r\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, $fibonacci(N)$을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 적성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.  \r\n각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0\r\n1\r\n3\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 0\r\n0 1\r\n1 2\r\n```\r\n\r\n# 풀이\r\n\r\n알고리즘 풀면서 느끼는 거지만, 문제가 뭘 말하는 지 이해가 안 되는 경우가 많은 것 같다. 내가 멍청해서 그런건가.\r\n\r\n이 문제를 풀기 위해선, 피보나치 수열에 대한 식을 이해하고 있어야 한다.  \r\n피보나치 수열이 $f()$일 때, $n$번째 피보나치 수열의 식은 $f(n) = f(n - 1) + f(n - 2)$로 정의할 수 있다.\r\n\r\n$n = 0, 1$일 때의 초기값이 정해져있다. (식의 특성 상 초기값이 없으면 계산할 수가 없다.)  \r\n$f(0) = 0$  \r\n$f(1) = 1$  \r\n초기값은 위와 같으며, 실질적으로 $n >= 2$ 부터 의미있는 연산이 수행된다.\r\n\r\n다시 문제로 돌아가서, 임의의 수 N이 주어질 경우 $f(N)$을 수행하면서 $f(0)$, $f(1)$이 몇 번 호출되는지를 구하면 된다.  \r\n예를 들어, $N = 4$라고 가정하고 식을 전개하면 아래와 같다.  \r\n$f(4) = f(3) + f(2)$  \r\n위 식에서 $f(3)$은 $f(2) + f(1)$로 치환할 수 있으며, 같은 이유로 $f(2)$ 역시 $f(1) + f(0)$으로 치환 가능하다.  \r\n$f(4) = f(2) + f(1) + f(1) + f(0)$  \r\n$= f(1) + f(0) + f(1) + f(1) + f(0)$\r\n\r\n결과적으로 $f(4) = 2(f0) + 3f(1)$로 정리할 수 있다.  \r\n따라서 이 문제의 알고리즘은 $N = 4$일 경우 `2 3`이 출력되어야 한다.\r\n\r\n우선 식을 정리하여 한 눈에 보면 문제 해결에 도움이 될 것 같다.  \r\n피보나치 수열을 쭉 정리하면 아래와 같다.\r\n\r\n|  $n$  | $f(0)$의 갯수 | $f(1)$의 갯수 | $f(n)$ |\r\n| :---: | :-----------: | :-----------: | :----: |\r\n|   0   |       1       |       0       |   0    |\r\n|   1   |       0       |       1       |   1    |\r\n|   2   |       1       |       1       |   1    |\r\n|   3   |       1       |       2       |   2    |\r\n|   4   |       2       |       3       |   3    |\r\n|   5   |       3       |       5       |   5    |\r\n|   6   |       5       |       8       |   8    |\r\n|   7   |       8       |      13       |   13   |\r\n|   8   |      13       |      21       |   21   |\r\n|   9   |      21       |      34       |   34   |\r\n\r\n표로 정리하니 어느정도 규칙성이 눈에 보이기 시작한다.\r\n\r\n* N의 $f(1)$ 출력 갯수는 $f(N)$과 동일하다.  \r\n* N의 $f(0)$ 출력 갯수는 $f(N - 1)$과 동일하다.\r\n\r\n즉, $N = 4$일 경우 알고리즘은 $f(3)$ $f(4)$가 출력되면 된다.\r\n\r\n여기서 단순하게 생각하면 아래와 같이 코드를 짤 수 있다.\r\n\r\n## 완성....?\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[][] arr = new Integer[41][2];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// N = 0일 때, 0이 호출되는 횟수\r\n\t\tarr[0][0] = 1;\r\n\r\n\t\t// N = 0일 때, 1이 호출되는 횟수\r\n\t\tarr[0][1] = 0;\r\n\r\n\t\t// N = 1일 때, 0이 호출되는 횟수\r\n\t\tarr[1][0] = 0;\r\n\r\n\t\t// N = 1일 때, 1이 호출되는 횟수\r\n\t\tarr[1][1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tint f0 = fibonacci(n - 1);\r\n\t\t\tint f1 = fibonacci(n);\r\n\r\n\t\t\tSystem.out.println(f0 + \" \" + f1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 인덱스가 0일 경우\r\n\t\tif (n == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 1일 경우\r\n\t\telse if (n == 1)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 2 이상일 경우 (연산 가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 코드는 크게 두 가지 문제가 있는데, 우선 $n = 0, 1$일 때의 처리가 정상적으로 이루어지지 않고 있다.  \r\n$f(1) = f(0) + f(-1)$  \r\nN이 문제되기 이전에 이 코드는 런타임 시간 초과로 실패한다. 왜일까?\r\n\r\n위 코드는 **불필요한 연산을 너무 많이 수행한다.** 피보나치 수열의 특성 상 $f(N)$을 계산할 경우, $f(N - 1)$, $f(N - 2)$ ... 등과 같이 N 이하의 피보나치 값까지 전부 계산하게 된다.  \r\n다시 말하면, $f(6)$을 연산할 경우 계산 과정에서 자연스레 $f(4)$, $f(2)$ 등의 피보나치 값을 구할 수 있다.\r\n\r\n위 이론을 알고리즘에 적용하면 아래와 같이 응용할 수 있다.  \r\nN을 총 3번 입력한다고 가정하면 $N_1$, $N_2$, $N_3$으로 구분할 수 있다.\r\n\r\n$N_2 = 8$ -> $f(8)$ 부터 $f(0)$까지의 값을 구할 수 있음.  \r\n$N_3 = 4$ -> $f(4)$ 부터 $f(0)$까지의 값을 구할 수 있음.\r\n\r\n피보나치 연산값을 저장하면 $N_n > N_n+1$일 경우 굳이 **추가적인 연산을 진행하지 않고 이미 저장된 값을 출력**만 함으로써, 런타임 리소스를 줄일 수 있다.\r\n\r\n클래스의 멤버변수로 **Integer 배열을 선언**하여 피보나치 수열값을 저장하고, 알고리즘 연산에 이를 활용하면 될 것 같다.\r\n\r\n> int는 Primitive(자료형) 데이터고, Integer는 Wrapper 클래스다. Wrapper 클래스는 null 입력이 가능하다는 특징이 있으므로, Integer 역시 숫자 이외에 null값을 입력할 수 있다.  \r\nInteger 배열의 초기값은 null로 지정되므로, 배열의 값이 null인 인덱스는 아직 피보나치 수열 계산이 이루어지지 않은 인덱스라고 판단할 수 있다.\r\n\r\n다행히 문제에서 주어진 $N$의 조건은 $0 <= N <= 40$이므로, 배열의 인덱스는 최대 41을 넘지 않음을 알 수 있다.  \r\n(배열은 0부터 시작하므로 40개가 아닌 0을 포함한 41개임에 유의하자)\r\n\r\n이후 피보나치 연산에서 각 과정의 값을 배열에 저장하는 로직을 추가한다.  \r\n배열의 값이 null일 경우, 아직 연산이 진행되지 않았으므로 피보나치 연산을 수행하고 배열에 저장한다.  \r\n반대로, 배열이 특정 숫자값을 가질 경우, 이미 연산이 진행된 인덱스이므로 별도의 연산을 거치지 않고 해당 값을 바로 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\npackage all.a1003;\r\n\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[] arr = new Integer[41];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 0)\r\n\t\tarr[0] = 0;\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 1)\r\n\t\tarr[1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tfibonacci(n);\r\n\r\n\t\t\t// n이 0일 경우\r\n\t\t\tif (n == 0)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"1 0\");\r\n\t\t\t}\r\n\r\n\t\t\t// n이 1일 경우\r\n\t\t\telse if (n == 1)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"0 1\");\r\n\t\t\t}\r\n\r\n\t\t\t// 초기값이 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(new StringBuffer().append(arr[n - 1]).append(\" \").append(arr[n]).toString());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscanner.close();\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 해당 인덱스의 피보나치가 아직 연산되지 않았을 경우\r\n\t\tif (arr[n] == null)\r\n\t\t{\r\n\t\t\tarr[n] = fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\r\n\t\treturn arr[n];\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍","url":["2021-05-21-a1003","2021","05","21","a1003"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1002번 터렛","excerpt":"조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:56:10","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","기하학","SILVER","SILVER IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1002.md","content":"\r\n# 터렛\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1002번 문제](https://www.acmicpc.net/problem/1002)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg\" width=\"128px\" />\r\n</p>\r\n\r\n이석원은 조규현과 백승환에게 상대편 마린(류재영)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.  \r\n조규현의 좌표 $(x_1, y_1)$와 백승환의 좌표 $(x_2, y_2)$가 주어지고, 조규현이 계산한 류재명과의 거리 $r_1$과 백승환이 계산한 류재명과의 거리 $r_2$가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.  \r\n한 줄에 $x_1$, $y_1$, $r_1$, $x_2$, $y_2$, $r_2$가 주어진다. $x_1$, $y_1$, $x_2$, $y_2$는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 점수이고, $r_1$, $r_2$는 10,000보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0 0 13 40 0 37\r\n0 0 30 0 7 4\r\n1 1 1 1 1 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n2\r\n1\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n예제의 요소를 사람 이름으로 두었으나, 문제 이해에 방해가 되니 간단하게 서술하면 아래와 같다.  \r\n임의의 위치에 있는 점 $A$, $B$, $C$가 존재하며, $A$와 $C$의 거리, $B$와 $C$의 거리가 주어진다.  \r\n이 때, $C$가 실제로 위치할 수 있는 점의 갯수를 구하는 것. 즉, 간단하게 **두 원의 접점을 구하는 문제**라고 정의할 수 있다.  \r\n원이 완벽하게 겹칠 경우, **그 수가 무수히 많으므로 -1로 표현**하라는 조건이 포함된다.\r\n\r\n이를 그림으로 표현하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120757881-14146780-c54c-11eb-94ee-ab79d997000e.png)\r\n\r\n변수는 아래와 같이 정리할 수 있다.\r\n\r\n|  $n$  |   $x_n$   |   $y_n$   |   $r_n$    |\r\n| :---: | :-------: | :-------: | :--------: |\r\n|   1   | A의 x좌표 | A의 y좌표 | A의 반지름 |\r\n|   2   | B의 x좌표 | B의 y좌표 | B의 반지름 |\r\n\r\n케이스를 세분화하면 총 6가지로 나눌 수 있다.\r\n\r\n1. 두 원이 정확히 겹칠 경우 (-1)\r\n2. 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n3. 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n4. 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n5. 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n6. 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\r\n본 풀이에선 $x_1$, $y_1$과 $x_2$, $y_2$의 거리($distance$) 및 $r_1$, $r_2$를 합한 길이($sum$)와 뺀 길이($sub$)의 절대값을 이용하여 진행한다.\r\n\r\n$$\r\ndistance = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\r\n$$\r\n\r\n$$\r\nsum = r_1 + r_2\r\n$$\r\n\r\n$$\r\nsub = \\vert r_1 - r_2 \\vert\r\n$$\r\n\r\n* <b class=\"primary\">case 1 - 두 원이 정확히 겹칠 경우</b>\r\n\r\n\t두 원의 위치 및 반지름이 서로 동일한 상황.  \r\n\t$distance$가 0이며, $r_1$과 $r_2$의 길이가 동일할 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이보다 짧은 상황.  \r\n\t$distance < sub$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합보다 긴 상황.  \r\n\t$distance > sum$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 4 - 두 원이 서로 겹치면서 인접하는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이와 일치하는 상황.  \r\n\t$distance == sub$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합과 일치하는 상황.  \r\n\t$distance == sum$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우</b>\r\n\r\n\t두 원이 서로 적당히 겹치는 상황.  \r\n\t$distance < sum$ $\\&\\&$ $distance > sub$일 경우 성립한다.\r\n\r\n굳이 식으로 표현하지 않아도, 위의 5개 케이스에 부합하지 않는 모든 상황에 적용하면 된다.  \r\n위 케이스들을 `if`문을 사용하여 적절히 표현하면 된다. `switch`문의 경우 하나의 변수를 기준으로 분기를 판단하므로 해당 알고리즘에 적용하기엔 다소 부적절하다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1002 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:56:10\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint x1 = scanner.nextInt();\r\n\t\t\tint y1 = scanner.nextInt();\r\n\t\t\tint r1 = scanner.nextInt();\r\n\r\n\t\t\tint x2 = scanner.nextInt();\r\n\t\t\tint y2 = scanner.nextInt();\r\n\t\t\tint r2 = scanner.nextInt();\r\n\r\n\t\t\tSystem.out.println(calcPoints(x1, y1, r1, x2, y2, r2));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 접점 갯수 반환 함수\r\n\t *\r\n\t * case 1 - 두 원이 정확히 겹칠 경우 (-1)\r\n\t * case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n\t * case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n\t * case 4 - 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n\t * case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n\t * case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\t *\r\n\t * @param x1: [int] A의 x좌표\r\n\t * @param y1: [int] A의 y좌표\r\n\t * @param r1: [int] A와 C 사이의 거리\r\n\t * @param x2: [int] B의 x좌표\r\n\t * @param y2: [int] B의 y좌표\r\n\t * @param r2: [int] B와 C 사이의 거리\r\n\t *\r\n\t * @return [int] 접점 갯수\r\n\t */\r\n\tprivate static int calcPoints(int x1, int y1, int r1, int x2, int y2, int r2)\r\n\t{\r\n\t\t// 두 점 사이의 거리 계산식\r\n\t\tdouble distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n\r\n\t\tint sum = r1 + r2;\r\n\t\tint sub = Math.abs(r1 - r2);\r\n\r\n\t\t// case 1 - 두 원이 정확히 겹칠 경우\r\n\t\tif (distance == 0 && r1 == r2)\r\n\t\t{\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse if (distance < sub)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우\r\n\t\telse if (distance > sum)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// case 4 - 두 원이 서로 겹치면서 인접하는 경우\r\n\t\telse if (distance == sub)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우\r\n\t\telse if (distance == sum)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 기하학","url":["2021-05-21-a1002","2021","05","21","a1002"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1001번 A - B","excerpt":"두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:51:19","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1001.md","content":"\r\n# A - B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1001번 문제](https://www.acmicpc.net/problem/1001)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 A - B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n```\r\n\r\n# 풀이\r\n\r\n1000번 문제에서 연산만 달라지는 뺄셈 알고리즘\r\nScanner로 두 숫자를 입력받아 뺄셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1001 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:51:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\r\n\t\tscanner.close();\r\n\r\n\t\tSystem.out.println(a - b);\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-05-21-a1001","2021","05","21","a1001"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1000번 A + B","excerpt":"두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:38:17","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-a1000.md","content":"\r\n# A + B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1000번 문제](https://www.acmicpc.net/problem/1000)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 A + B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n```\r\n\r\n# 풀이\r\n\r\n알고리즘이라고 하기 뭐한 기초적인 연산 알고리즘\r\nScanner로 두 숫자를 입력받아 덧셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1000 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:38:17\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\r\n\t\tscanner.close();\r\n\r\n\t\tSystem.out.println(a + b);\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-05-21-a1000","2021","05","21","a1000"]},{"header":{"title":"백준 알고리즘 시작하기","excerpt":"코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다. 그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다. 풀이의 규칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-start-beakjoon.md","content":"\r\n# 백준 알고리즘\r\n\r\n코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다.\r\n\r\n그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다.\r\n\r\n풀이의 규칙은 아래와 같다.\r\n\r\n1. 가급적 문제번호 순서대로 진행한다.\r\n2. 기본 언어는 <span class=\"orange-A400\">JAVA</span>로 진행한다.\r\n3. 원리는 과하다 싶을 정도로 최대한 자세하게 적는다.\r\n4. 번은 개인주의야\r\n5. 숏코딩을 지양하고, 이해하기 쉽도록 성능이 허락하는 선에서 풀어 쓴다.\r\n6. 주석을 적극 활용한다.\r\n7. 채점결과가 반드시 <b class=\"green-A400\">맞았습니다!!</b>인 코드를 기준으로 한다.\r\n8. 풀이에 제시되는 코드는 그대로 복사해도 알고리즘 풀이가 가능하도록 코딩한다.\r\n9. 신명호는 놔둔다.","url":["2021-05-21-start-beakjoon","2021","05","21","start-beakjoon"]}],"categories":{"WEB":{"count":7,"flag":true},"CS":{"count":10,"flag":true},"알고리즘":{"count":30,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false},"잡담":{"count":1,"flag":false}},"images":["celeb1.webp","celeb10.webp","celeb11.webp","celeb12.webp","celeb13.webp","celeb14.webp","celeb15.webp","celeb16.webp","celeb2.webp","celeb3.webp","celeb4.webp","celeb5.webp","celeb6.webp","celeb7.webp","celeb8.webp","celeb9.webp","city1.webp","city10.webp","city11.webp","city12.webp","city13.webp","city14.webp","city15.webp","city2.webp","city3.webp","city4.jpg","city4.webp","city5.webp","city6.webp","city7.webp","city8.webp","city9.webp","code1.webp","code2.webp","code3.webp","funk1.webp","funk2.webp","funk3.webp","funk4.webp","funk5.webp","funk6.webp","game1.webp","signal.webp"],"tag":"JAVA(자바)","page":3},"__N_SSG":true}