{"pageProps":{"header":{"title":"URI? URL? URN? 리소스 식별자 구분하기","excerpt":"우리가 인터넷 상에서 특정한 데이터에 접근할 때 URL이라는 것을 활용하여 접근한다. 원하는 자료의 URL을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 URL을 호출하여 응답을 얻는 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028437-a63ddc80-c02f-11eb-9d41-7c50d7002a42.png","date":"2021-05-29T03:30:17","type":"posts","category":"WEB","tag":["WEB(웹)","URI","URL","URN"],"comment":true,"publish":true},"name":"2021-05-29-uri-url-urn.md","url":["2021-05-29-uri-url-urn","2021","05","29","uri-url-urn"],"toc":"<ul><li><a href=\"#URL!-URI... URN??\">URL! URI... URN??</a></li><li><a href=\"#UR*-톱아보기\">UR* 톱아보기</a></li><ul><li><a href=\"#URI(Uniform-Resource Identifier, 통합 자원 식별자)\">URI(Uniform Resource Identifier, 통합 자원 식별자)</a></li><li><a href=\"#URL(Uniform-Resource Locater, 통합 자원 지시자)\">URL(Uniform Resource Locater, 통합 자원 지시자)</a></li><li><a href=\"#URN(Uniform-Resource Name, 통합 자원 이름)\">URN(Uniform Resource Name, 통합 자원 이름)</a></li><li><a href=\"#정리\">정리</a></li></ul><li><a href=\"#구조\">구조</a></li><ul><li><a href=\"#URL-구조\">URL 구조</a></li><ul><li><a href=\"#Protocol(프로토콜)\">Protocol(프로토콜)</a></li><li><a href=\"#SLD(Second-Level Domain, 서브도메인, 호스트)\">SLD(Second Level Domain, 서브도메인, 호스트)</a></li><li><a href=\"#Domain(도메인)\">Domain(도메인)</a></li><li><a href=\"#TLD(Top-Level Domain, 최상위 도메인)\">TLD(Top Level Domain, 최상위 도메인)</a></li><ul><li><a href=\"#ccTLD(country-code TLD, 국가 코드 최상위 도메인)\">ccTLD(country code TLD, 국가 코드 최상위 도메인)</a></li><li><a href=\"#gTLD(generic-TLD, 일반 최상위 도메인)\">gTLD(generic TLD, 일반 최상위 도메인)</a></li></ul><li><a href=\"#Port(포트)\">Port(포트)</a></li><li><a href=\"#잘-알려진 포트(well-known Port)\">잘 알려진 포트(well-known Port)</a></li><li><a href=\"#등록된-포트(registered Port)\">등록된 포트(registered Port)</a></li><ul><li><a href=\"#왜?-하필 개발 관련 프로그램들만?\">왜? 하필 개발 관련 프로그램들만?</a></li></ul><li><a href=\"#동적-포트(dynamic Port)\">동적 포트(dynamic Port)</a></li><li><a href=\"#Path(경로)\">Path(경로)</a></li><li><a href=\"#Query-String(쿼리 문자열)\">Query String(쿼리 문자열)</a></li></ul><li><a href=\"#URN-구조\">URN 구조</a></li><ul><li><a href=\"#Protocol(프로토콜)\">Protocol(프로토콜)</a></li><li><a href=\"#NID(Namespace-Identifier, 네임스페이스 지시자)\">NID(Namespace Identifier, 네임스페이스 지시자)</a></li><li><a href=\"#NSS(Namespace-Specific String, 네임스페이스 특정 문자)\">NSS(Namespace Specific String, 네임스페이스 특정 문자)</a></li></ul>","content":"<h1 id=\"URL!-URI... URN??\">URL! URI... URN?? <a href=\"#URL!-URI... URN??\">🔗</a></h1><p>우리가 인터넷 상에서 <strong>특정한 데이터</strong>에 접근할 때 <span class=\"primary\">URL</span>이라는 것을 활용하여 접근한다.<br>원하는 자료의 <span class=\"primary\">URL</span>을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 <span class=\"primary\">URL</span>을 호출하여 응답을 얻는 것이다.</p>\n<p>개발자나, 굳이 개발자가 아니더라도 관련 정보를 찾다보면 심심치않게 <span class=\"primary\">URI</span>라는 용어를 접하게 된다.<br>I와 L의 오묘한 유사성 때문에 아예 <span class=\"primary\">URI</span>를 <span class=\"primary\">URL</span>로 오독하는가 하면, 오타라고 생각하는 사람도 더러 있을 것이다.<br>하지만 <span class=\"primary\">URL</span>과 <span class=\"primary\">URI</span>는 그 의미가 비슷하면서도 살짝 다르다.</p>\n<p>누구나 알고있는 <span class=\"primary\">URL</span>과 아리까리한 <span class=\"primary\">URI</span>, 생소한 <span class=\"primary\">URN</span>. 이들에 대해 알아보자</p>\n<h1 id=\"UR*-톱아보기\">UR* 톱아보기 <a href=\"#UR*-톱아보기\">🔗</a></h1><p><span class=\"primary\">URI</span>, <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>은 구조상 서로 연관이 있다.</p>\n<h2 id=\"URI(Uniform-Resource Identifier, 통합 자원 식별자)\">URI(Uniform Resource Identifier, 통합 자원 식별자) <a href=\"#URI(Uniform-Resource Identifier, 통합 자원 식별자)\">🔗</a></h2><p><span class=\"primary\">URI</span>는 우리말로 <strong>통합 자원 식별자</strong>라고 한다. <span class=\"primary\">URI</span>는 앞서 말한 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>을 포함하는 상위 개념으로, <span class=\"orange-400\">인터넷 상에 존재하는 <strong>자원을 구분</strong>하는 식별자</span>라 할 수 있다. 웹 상에서 자원을 식별하는 모든 수단이 곧 <span class=\"primary\">URI</span>이라 할 수 있다.</p>\n<h2 id=\"URL(Uniform-Resource Locater, 통합 자원 지시자)\">URL(Uniform Resource Locater, 통합 자원 지시자) <a href=\"#URL(Uniform-Resource Locater, 통합 자원 지시자)\">🔗</a></h2><p><span class=\"primary\">URL</span>은 굳이 우리말로 하자면 <strong>통합 자원 지시자</strong>라고 할 수 있겠지만, 흔히 인터넷 상에서 <strong>주소</strong>라 함은 99% 이 <span class=\"primary\">URL</span>을 의미한다. 1994년 <strong>RFC-1738</strong>에 정의되어있다.<br><span class=\"primary\">URL</span>은 <strong>Locater</strong>라는 키워드에 걸맞게 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 <strong>위치</strong>를 나타내는 식별자</span>라 할 수 있다. 여기서 <strong>위치</strong>라는 키워드에 주목하자. <span class=\"primary\">URL</span>은 자원의 위치정보를 가지므로, 어떠한 이유로든 자원의 위치가 변경되면 <span class=\"primary\">URL</span>은 자원을 찾을 수 없으며, 변경된 위치를 추적할 수도 없다. 이 때 맞이하게 되는 HTTP 오류가 누구나 알고있는 404 Not Found다.<br>당장 내가 이 게시물의 이름을 한 글자만 변경해도, 지금까지의 <span class=\"primary\">URL</span>은 아무 쓸모가 없어지며, 사용자들 또한 해당 <span class=\"primary\">URL</span>로 이 게시물에 접근할 수 없다. 또한, 이 <span class=\"primary\">URL</span>을 통해 원래 있던 게시물의 <span class=\"primary\">URL</span>을 논리적으로 유추할 수도 없다.</p>\n<h2 id=\"URN(Uniform-Resource Name, 통합 자원 이름)\">URN(Uniform Resource Name, 통합 자원 이름) <a href=\"#URN(Uniform-Resource Name, 통합 자원 이름)\">🔗</a></h2><p><span class=\"primary\">URN</span>은 <strong>통합 자원 이름</strong>이다. 눈치가 빠른 분들은 아시겠지만, <span class=\"primary\">URN</span>은 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 <strong>이름</strong>을 나타내는 식별자</span>다. 자원의 이름은 고유한 값을 가지므로, 인터넷 상의 수 많은 자원들 중 특정 자원을 식별할 수 있는 것이다.<br><span class=\"primary\">URN</span>은 대부분 위에 언급한 두 개념에 비해 생소할 것이다. 그도 그럴 것이, <span class=\"primary\">URN</span>은 위 두 개념보다 훨씬 뒤에 나온 개념이기 때문이다. 1997년 <strong>RFC-2141</strong>에 정의되어있다. <span class=\"primary\">URL</span>보다 3년 뒤에 출범하여 그 역사가 상대적으로 짧다.  </p>\n<p><span class=\"primary\">URL</span>의 치명적인 단점은 <strong>위치</strong>정보 외에 다른 정보를 저장하지 않는다. 이 상황에서 해당 자원을 찾아야 한다면? 안타깝게도 <span class=\"primary\">URL</span>만으로는 찾아낼 수 없다. 구글링해서 운 좋게 찾아낸다면 모를까.<br>반면 <span class=\"primary\">URN</span>을 사용한다면 어떨까? 위치가 아무리 변경된다 하더라도, 자원의 고유한 이름을 통해 찾기 때문에 자원이 웹 상에서 완전히 삭제된 게 아니라면 손쉽게 찾아낼 수 있을 것이다.</p>\n<h2 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h2><p>난 어려운 개념을 이해할 때 현실세계와 연관지어 이해하는 걸 좋아한다. 위 세 개념을 현실에서 특정 사람의 신원을 확인하는 과정과 접목해서 정리하면 아래와 같이 정리할 수 있을 것 같다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">구분</th>\n<th align=\"center\">현실</th>\n<th align=\"center\">값</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">자원</td>\n<td align=\"center\">나 자신</td>\n<td align=\"center\">나</td>\n</tr>\n<tr>\n<td align=\"center\">URI</td>\n<td align=\"center\">나를 식별할 수 있는 모든 식별자</td>\n<td align=\"center\">-</td>\n</tr>\n<tr>\n<td align=\"center\">URL</td>\n<td align=\"center\">내가 사는 주소</td>\n<td align=\"center\">서울특별시 A구 가동</td>\n</tr>\n<tr>\n<td align=\"center\">URN</td>\n<td align=\"center\">내 주민등록번호</td>\n<td align=\"center\">000000-0000000</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p><span class=\"small red-A400\">※ URN은 모든 자원의 고유값이므로, 사람과 연관지었을 때, 중복 가능성이 있는 이름 보다는 고유값인 주민등록번호가 더 적합하다.</span></p>\n<p>예를 들어, 내 정보가 위와 같다고 가정해보자. 내가 사는 주소 및 내 주민등록번호 모두 내 신원을 확인할 수 있는 방식(<span class=\"primary\">URI</span>)이므로, 나를 찾기에 적합하다.<br>만약 내 주소(<span class=\"primary\">URL</span>)를 통해 확인할 경우, 내가 이사(자원의 이동)를 가게 되면 해당 주소엔 아무것도 없으며, 날 찾을 수도 없다(404 HTTP 에러). 또한, 내가 예전에 살던 주소만으로 내가 이사간 주소를 유추해낼 수도 없을 것이다.</p>\n<p>반면, 내 주민등록번호(<span class=\"primary\">URN</span>)을 통해 확인할 경우, 내 주민등록번호와 매칭되는 사람을 찾는 것으로 나를 식별할 수 있다. 이 과정에서 내가 어디에 있는지는 전혀 중요치 않은 것이다. 주민등록번호 자체가 말소(자원 삭제)되지 않는 한, 내가 어디에서 무엇을 하고있든 내 신원을 확인할 수 있다.</p>\n<h1 id=\"구조\">구조 <a href=\"#구조\">🔗</a></h1><p>그렇다면 이들은 어떻게 생겼는지 알아보자. <span class=\"primary\">URI</span>는 자원의 식별자를 포괄하여 지칭하는 개념 그 자체이므로, 구조라고 할 건 없다. 하위 개념인 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>에 대해 알아보자.</p>\n<h2 id=\"URL-구조\">URL 구조 <a href=\"#URL-구조\">🔗</a></h2><p><span class=\"primary\">URL</span>은 아래와 같은 구조로 이루어진다. 매우 익숙할 것이다.</p>\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">https</span>://<span class=\"green-400\">rwb0104</span>.<span class=\"yellow-400\">github</span>.<span class=\"pink-400\">com</span>:<span class=\"amber-400\">443</span>/<span class=\"cyan-400\">posts</span><span class=\"teal-400\">?category=WEB&page=1</span></p>\n\n<p>구조별로 색상을 입혔으며, 순서대로 기술한다.</p>\n<h3 id=\"Protocol(프로토콜)\">Protocol(프로토콜) <a href=\"#Protocol(프로토콜)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"lightBlue-400\">https</span> 부분.</p>\n<p>통신규약을 의미한다. 작성일 기준으로, 이 규약엔 계층별로 많은 <span class=\"lightBlue-400\">프로토콜</span>이 존재하는데, 웹 통신을 수행할 땐 크게 두 가지로 나뉜다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">구분</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">HTTP</td>\n<td align=\"center\">W3 상에서의 HTML 문서 통신규약</td>\n</tr>\n<tr>\n<td align=\"center\">HTTPS</td>\n<td align=\"center\">암호화된 HTTP 통신 규약</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>현재는 포털, 쇼핑몰같은 대형 비즈니스 사이트나 블로그, 카페 등 중소규모의 개인 사이트까지 <span class=\"red-A400\">HTTPS의 사용이 반 강제적으로 권장</span>되어 있다. 특히 전자상거래가 접목된 비즈니스 사이트의 경우 필수로 적용해야 한다. 더군다나 <span class=\"red-A400\">HTTPS가 적용되지 않는 사이트(localhost 제외)에 접근할 경우 브라우저 측에서 보안 관련 경고 메시지</span>를 띄우니, 규모에 관계없이 웹 사이트를 운영할 경우 HTTPS는 필수로 적용하는 편이다.</p>\n<h3 id=\"SLD(Second-Level Domain, 서브도메인, 호스트)\">SLD(Second Level Domain, 서브도메인, 호스트) <a href=\"#SLD(Second-Level Domain, 서브도메인, 호스트)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"green-400\">rwb0104</span> 부분.</p>\n<p>도메인 앞에 붙으며, <span class=\"green-400\">서브도메인</span>을 통해 하나의 <span class=\"yellow-400\">도메인</span>으로 다중 서비스를 제공할 수 있다. 하나의 <span class=\"yellow-400\">도메인</span>에 여러 <span class=\"green-400\">서브도메인</span>을 생성할 수 있으며, 우리가 흔히 아는 <code class=\"inline-code\">www</code> 외에도 <code class=\"inline-code\">dev</code>, <code class=\"inline-code\">admin</code>, <code class=\"inline-code\">m</code> 용도에 따라 다양한 문자열을 지정할 수 있다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">URL</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\"><a href=\"https://naver.com\" target=\"_blank\">naver.com</a></td>\n<td align=\"center\">기본 네이버 홈페이지. 각 플랫폼(데스크탑, 모바일 등)에 가장 적합한 사이트로 리다이렉트</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://www.naver.com\" target=\"_blank\">www.naver.com</a></td>\n<td align=\"center\">데스크탑용 네이버 홈페이지</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://m.naver.com\" target=\"_blank\">m.naver.com</a></td>\n<td align=\"center\">모바일용 네이버 홈페이지</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://map.naver.com\" target=\"_blank\">map.naver.com</a></td>\n<td align=\"center\">네이버 지도</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>위는 네이버 서비스의 <span class=\"green-400\">서브도메인</span>으로, <code class=\"inline-code\">naver.com</code> <span class=\"yellow-400\">도메인</span>을 중심으로 각기 다른 서비스를 제공하는 것을 확인할 수 있다.</p>\n<h3 id=\"Domain(도메인)\">Domain(도메인) <a href=\"#Domain(도메인)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"yellow-400\">github</span> 부분.</p>\n<p>URL의 중심이 되는 부분으로, 제공하는 웹 서비스의 아이덴티티 역할을 겸한다. 때문에 <span class=\"yellow-400\">도메인</span>에는 대부분 해당 웹 서비스의 이름이 들어간다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">서비스</th>\n<th align=\"center\">URL</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">네이버</td>\n<td align=\"center\"><a href=\"https://naver.com\" target=\"_blank\">naver.com</a></td>\n</tr>\n<tr>\n<td align=\"center\">다음</td>\n<td align=\"center\"><a href=\"https://www.daum.com\" target=\"_blank\">www.daum.com</a></td>\n</tr>\n<tr>\n<td align=\"center\">GitHub</td>\n<td align=\"center\"><a href=\"https://github.com\" target=\"_blank\">github.com</a></td>\n</tr>\n<tr>\n<td align=\"center\">Instagram</td>\n<td align=\"center\"><a href=\"https://instagram.com\" target=\"_blank\">instagram.com</a></td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>대부분의 서비스가 <span class=\"yellow-400\">도메인</span>으로 서비스의 이름을 사용하고 있다.</p>\n<h3 id=\"TLD(Top-Level Domain, 최상위 도메인)\">TLD(Top Level Domain, 최상위 도메인) <a href=\"#TLD(Top-Level Domain, 최상위 도메인)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"pink-400\">com</span> 부분.</p>\n<p><span class=\"pink-400\">최상위 도메인</span>이란, 앞서 언급한 <span class=\"green-400\">서브도메인</span>, <span class=\"yellow-400\">도메인</span>을 관리하는 업체 혹은 기관이라고 볼 수 있다.<br>앞서 언급한 개념의 경우, 중복되지 않는 선에서 사용자가 임의로 지정할 수 있다. 하지만 <span class=\"pink-400\">최상위 도메인</span>의 경우 현재 운영 중인 업체나 기관 중 하나를 <strong>선택</strong>해서 등록해야 한다. <span class=\"pink-400\">최상위 도메인</span>을 선택할 경우, 당신의 도메인은 해당 <span class=\"pink-400\">최상위 도메인</span>을 운영하는 곳에서 관리하게 된다.  </p>\n<p><span class=\"pink-400\">최상위 도메인</span>은 운영 주체에 따라 두 가지로 나뉜다.</p>\n<h4 id=\"ccTLD(country-code TLD, 국가 코드 최상위 도메인)\">ccTLD(country code TLD, 국가 코드 최상위 도메인) <a href=\"#ccTLD(country-code TLD, 국가 코드 최상위 도메인)\">🔗</a></h4><p>국가를 나타내는 <span class=\"pink-400\">최상위 도메인</span>이다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">ccTLD</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">.kr</td>\n<td align=\"center\">한국(KISA)</td>\n</tr>\n<tr>\n<td align=\"center\">.us</td>\n<td align=\"center\">미국(LLC)</td>\n</tr>\n<tr>\n<td align=\"center\">.jp</td>\n<td align=\"center\">일본</td>\n</tr>\n<tr>\n<td align=\"center\">.io</td>\n<td align=\"center\">영국령 인도양</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p><span class=\"pink-400\">ccTLD</span>는 위 표와 같이 국가 코드 형태이며, 각 국가기관이 직접 관리한다. 즉, <code class=\"inline-code\">.kr</code>을 가진 모든 도메인은 <strong>한국의 KISA(한국 인터넷 진흥원)에서 관리</strong>한다.</p>\n<h4 id=\"gTLD(generic-TLD, 일반 최상위 도메인)\">gTLD(generic TLD, 일반 최상위 도메인) <a href=\"#gTLD(generic-TLD, 일반 최상위 도메인)\">🔗</a></h4><p>사이트 혹은 사이트를 소유한 조직, 기관의 특성에 따라 사용하는 <span class=\"pink-400\">최상위 도메인</span>이다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">gTLD</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">.com</td>\n<td align=\"center\">영리 단체 및 기관</td>\n</tr>\n<tr>\n<td align=\"center\">.net</td>\n<td align=\"center\">네트워크 관리기관</td>\n</tr>\n<tr>\n<td align=\"center\">.org</td>\n<td align=\"center\">비영리 기관</td>\n</tr>\n<tr>\n<td align=\"center\">.gov</td>\n<td align=\"center\">정부 기관</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p><span class=\"pink-400\">gTLD</span>는 위 표와 같이 다양한 종류가 있으며, 그 중 몇몇은 자주 접했을 것이다. 정부기관이 왜 여기있나 생각할 수도 있는데, <span class=\"pink-400\">ccTLD</span>는 <strong>국가 코드</strong>만 해당된다. 국가 예하의 정부기관, 군사조직 등은 구분 상 <span class=\"pink-400\">gTLD</span>로 분류된다.<br>마찬가지로, 각 <span class=\"pink-400\">최상위 도메인</span>은 <strong>해당 <span class=\"pink-400\">최상위 도메인</span>을 소유한 기관 혹은 기업에서 관리</strong>한다.</p>\n<blockquote>\n<p>현재 운영 중인 <span class=\"pink-400\">최상위 도메인</span>은 <a href=\"https://www.iana.org/domains/root/db\" target=\"_blank\">IANA</a>에서 확인할 수 있다.</p>\n</blockquote>\n<p>여담으로, <span class=\"pink-400\">최상위 도메인</span>에 중복된 <span class=\"yellow-400\">도메인</span>을 등록할 수 없다. 예를 들어, 내가 <code class=\"inline-code\">aaa.com</code> URL을 등록한다고 가정해보자.<br>우선 제일 먼저 <code class=\"inline-code\">.com</code>을 관리하는 업체에 <code class=\"inline-code\">aaa</code>라는 <span class=\"yellow-400\">도메인</span>을 등록해야 한다. 하지만, 이미 누군가가 <code class=\"inline-code\">aaa.com</code>을 등록했다면 해당 소유주가 <span class=\"yellow-400\">도메인</span>의 소유권을 포기하기 전까진 <code class=\"inline-code\">aaa.com</code> <span class=\"yellow-400\">도메인</span>을 소유할 수 없다.<br>물론 <code class=\"inline-code\">.com</code>이 아닌 <code class=\"inline-code\">.kr</code>이나 <code class=\"inline-code\">.net</code>에는 등록할 수 있다. 하지만 <code class=\"inline-code\">socket.io</code> 처럼 <span class=\"yellow-400\">도메인</span>과 <span class=\"pink-400\">최상위 도메인</span>까지 의미론적으로 구성했다면, 이러한 상황이 달갑지 않을 것이다. 때문에 일전에 이슈됐던 <span class=\"primary\">덮죽 상표권 선점</span>과 비슷한 일이 일어나기도 한다.</p>\n<h2 id=\"Port(포트)\">Port(포트) <a href=\"#Port(포트)\">🔗</a></h2><p><span class=\"primary\">URL</span>상의 <span class=\"amber-400\">443</span> 부분. 앞에 반드시 <code class=\"inline-code\">:</code>이 붙는다.</p>\n<p>인터넷에 연결된 모든 디바이스는 사용하는 네트워크의 IP를 할당받는다. 할당받은 IP 내에서 해당 디바이스가 수행 중인 모든 프로세스의 통신이 이루어진다. <span class=\"amber-400\">포트</span>는 프로세스의 데이터가 IO되는 통로다. 작업 시, 각 프로세스 별로 고유한 <span class=\"amber-400\">포트</span>를 할당받으며, 하나의 <span class=\"amber-400\">포트</span>는 반드시 하나의 프로세스와 1:1 매칭된다. 반면, 하나의 프로세스는 여러 <span class=\"amber-400\">포트</span>를 할당받을 수 있다.<br><strong>특정 프로세스와 통신하기 위해선 반드시 해당 프로세스가 할당받은 <span class=\"amber-400\">포트</span>에 데이터를 전송</strong>해야 한다. 때문에 <span class=\"amber-400\">포트</span> 통신은 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 크게 중요하지 않으며, 어떤 <span class=\"amber-400\">포트</span>로 보내는지가 중요하다.</p>\n<p>웹 통신에서의 기본<span class=\"amber-400\">포트</span>는 아래와 같다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">포트</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">80</td>\n<td align=\"center\">HTTP 기본 포트</td>\n</tr>\n<tr>\n<td align=\"center\">443</td>\n<td align=\"center\">HTTPS 기본 포트</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>아마 이러한 숫자를 처음 볼 수도 있는데, 대부분의 웹 사이트 <span class=\"primary\">URL</span>에는 <span class=\"amber-400\">포트</span>를 확인할 수 없다. 사이트가 <strong>각 프로토콜의 기본 <span class=\"amber-400\">포트</span>로 서비스될 경우, <span class=\"primary\">URL</span>에서 <span class=\"amber-400\">포트</span>를 생략</strong>할 수 있다. 즉, <code class=\"inline-code\">https://naver.com</code>의 <span class=\"amber-400\">포트</span>번호는 <code class=\"inline-code\">443</code>이지만, <code class=\"inline-code\">443</code>은 HTTPS의 기본 <span class=\"amber-400\">포트</span>이므로 생략된다. 만약, <code class=\"inline-code\">443</code>이 아닌 <code class=\"inline-code\">8080</code>, <code class=\"inline-code\">9200</code>과 같은 <strong>임의의 <span class=\"amber-400\">포트</span>로 서비스를 제공할 경우, <span class=\"amber-400\">포트</span>를 반드시 명시해야하므로 생략이 불가능</strong>하다. 이 경우 <span class=\"primary\">URL</span>은 <code class=\"inline-code\">https://naver.com:8080</code>이 될 것이다.<br>위와 같은 이유로, 대부분의 웹 사이트는 서비스하는 프로토콜에 맞는 기본 <span class=\"amber-400\">포트</span>를 사용한다.</p>\n<p><span class=\"amber-400\">포트</span>는 <strong>0 ~ 65535</strong>의 범위를 가지며, 크게 세 가지로 구분할 수 있다.</p>\n<h3 id=\"잘-알려진 포트(well-known Port)\">잘 알려진 포트(well-known Port) <a href=\"#잘-알려진 포트(well-known Port)\">🔗</a></h3><p><strong>0 ~ 1023</strong>의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터에서 기본적으로 사용되는 주요 프로세스에 기본적으로 할당되는 포트로, ICANN(Internet Corporation for Assigned Names and Numbers, 국제 인터넷주소 관리기구)에 의해 통제된다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">포트</th>\n<th align=\"center\">기능</th>\n<th align=\"center\">용도</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">20, 21</td>\n<td align=\"center\">FTP</td>\n<td align=\"center\">파일 송수신</td>\n</tr>\n<tr>\n<td align=\"center\">22</td>\n<td align=\"center\">SFTP</td>\n<td align=\"center\">파일 암호화 송수신</td>\n</tr>\n<tr>\n<td align=\"center\">23</td>\n<td align=\"center\">Telnet</td>\n<td align=\"center\">터미널 통신</td>\n</tr>\n<tr>\n<td align=\"center\">25</td>\n<td align=\"center\">SMTP</td>\n<td align=\"center\">메일 전송</td>\n</tr>\n<tr>\n<td align=\"center\">53</td>\n<td align=\"center\">DNS</td>\n<td align=\"center\">DNS 통신</td>\n</tr>\n<tr>\n<td align=\"center\">67</td>\n<td align=\"center\">DHCP</td>\n<td align=\"center\">DHCP 통신</td>\n</tr>\n<tr>\n<td align=\"center\">80</td>\n<td align=\"center\">HTTP</td>\n<td align=\"center\">HTML 통신</td>\n</tr>\n<tr>\n<td align=\"center\">443</td>\n<td align=\"center\">HTTPS</td>\n<td align=\"center\">HTML 암호화 통신</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>어디까지나 초기에 지정되는 <span class=\"amber-400\">포트</span>이므로, 추후 <strong>사용자의 의도에 따라 비어있는 다른 포트로 변경</strong>할 수도 있다. 즉, 초기값일뿐, 강제는 아니다.</p>\n<h3 id=\"등록된-포트(registered Port)\">등록된 포트(registered Port) <a href=\"#등록된-포트(registered Port)\">🔗</a></h3><p><strong>1024 ~ 49151</strong>의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터의 기본 프로세스는 아니지만, 주요 프로그램들이 기본으로 사용하고자 ICANN에 등록한 <span class=\"amber-400\">포트</span>다. <span class=\"amber-400\">잘 알려진 포트</span>와 마찬가지로 프로그램의 설정을 통해 <strong>사용자의 의도에 따라 비어있는 다른 포트로 변경</strong>할 수 있다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">포트</th>\n<th align=\"center\">기능</th>\n<th align=\"center\">용도</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">1433</td>\n<td align=\"center\">MSSQL</td>\n<td align=\"center\">MSSQL DB 통신</td>\n</tr>\n<tr>\n<td align=\"center\">3306</td>\n<td align=\"center\">MySQL</td>\n<td align=\"center\">MySQL DB 통신</td>\n</tr>\n<tr>\n<td align=\"center\">3389</td>\n<td align=\"center\">RDP</td>\n<td align=\"center\">원격 데스크톱 접근 (Windows)</td>\n</tr>\n<tr>\n<td align=\"center\">5432</td>\n<td align=\"center\">PostgreSQL</td>\n<td align=\"center\">PostgreSQL DB 통신</td>\n</tr>\n<tr>\n<td align=\"center\">8080</td>\n<td align=\"center\">HTTP 통신(Tomcat 등)</td>\n<td align=\"center\">HTTP 통신 (80포트 대용)</td>\n</tr>\n<tr>\n<td align=\"center\">27017</td>\n<td align=\"center\">MongoDB</td>\n<td align=\"center\">MongoDB 통신</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>주로 <span class=\"primary\">DB</span>같은 개발 관련 프로그램들이 많이 등록돼있다.</p>\n<h4 id=\"왜?-하필 개발 관련 프로그램들만?\">왜? 하필 개발 관련 프로그램들만? <a href=\"#왜?-하필 개발 관련 프로그램들만?\">🔗</a></h4><p>개발 관련 프로그램들은 그 특성 상 통신의 방식이 <strong>항상 일정</strong>해야 한다. 만약 DB의 <span class=\"amber-400\">포트</span>가 기동할 때마다 수시로 변경된다면 어떨까? 이유를 막론하고 DB가 재기동될 경우, 개발자는 DB가 사용 중인 임의의 <span class=\"amber-400\">포트</span>를 추적하여 프로그램의 DB 통신 코드를 변경해야하는 매우 불합리한 상황이 발생하게 된다.  </p>\n<p>이에 비해 게임이나 IDE 같은 일반적인 프로그램들은 굳이 통신의 방식이 일정할 필요는 없다. 어찌됐든 <strong>서버에 정보를 요청하는 순간, 서버는 자연스레 내 통신 정보를 알게되기 때문</strong>이다. 서버는 요청했던 경로로 다시 데이터를 반환해주면 된다. 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 별로 중요하지 않는 이유가 여기에 있다.</p>\n<h3 id=\"동적-포트(dynamic Port)\">동적 포트(dynamic Port) <a href=\"#동적-포트(dynamic Port)\">🔗</a></h3><p><strong>49152 ~ 65535</strong>의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 대다수의 프로그램들은 <span class=\"amber-400\">포트</span> 기본값이 지정되지 않는 경우가 대부분이다. 이러한 프로그램들은 <span class=\"amber-400\">동적 포트</span> 중 사용 가능한 임의의 빈 <span class=\"amber-400\">포트</span>를 자동으로 점유한다. 때문에 ICANN이 관리하지도 않으며, 특정 프로그램이 고유한 <span class=\"amber-400\">포트</span>로 등록되어있지도 않다. 자유석을 생각하면 편하다.</p>\n<h3 id=\"Path(경로)\">Path(경로) <a href=\"#Path(경로)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"cyan-400\">posts</span> 부분. 웹 사이트의 하위 경로를 의미한다. <span class=\"cyan-400\">경로</span>는 <code class=\"inline-code\">/</code>로 구분하며, 경로 입력을 통해 서버 내의 원하는 자원에 접근할 수 있다.</p>\n<ul>\n<li><a href=\"https://blog.itcode.dev\" target=\"_blank\">https://blog.itcode.dev</a><ul>\n<li>posts<ul>\n<li>index.html</li>\n<li>a1000<ul>\n<li>index.html</li>\n</ul>\n</li>\n<li>a1001<ul>\n<li>index.html</li>\n</ul>\n</li>\n<li>uri-url-urn<ul>\n<li>index.html</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>project<ul>\n<li>index.html</li>\n</ul>\n</li>\n<li>index.html</li>\n</ul>\n</li>\n</ul>\n<p>위 트리는 이 블로그의 단편적인 디렉토리 예시다. 이 중 해당 게시물에 접근하려면 <span class=\"cyan-400\">경로</span>는 <code class=\"inline-code\">/posts/uri-url-urn/index.html</code>와 같이 구성할 수 있다. <span class=\"primary\">index.html은 생략이 가능</span>하므로 <code class=\"inline-code\">/posts/uri-url-urn</code>로 접근해도 무방하다.</p>\n<blockquote>\n<p><strong>아시나요?</strong><br><strong>index.html</strong> 경로의 기본 HTML을 의미함. 더이상의 하위 경로를 표시하지 않을 경우, 해당 경로의 index.html를 응답한다.</p>\n</blockquote>\n<p><span class=\"cyan-400\">경로</span>는 서버의 구조에 따라 결정되므로, 사이트마다 천차만별이다.</p>\n<h3 id=\"Query-String(쿼리 문자열)\">Query String(쿼리 문자열) <a href=\"#Query-String(쿼리 문자열)\">🔗</a></h3><p><span class=\"primary\">URL</span>상의 <span class=\"teal-400\">?category=WEB&page=1</span> 부분. 해당 <span class=\"cyan-400\">경로</span>에 임의의 데이터를 같이 전송할 때 사용한다.<br><span class=\"primary\">key=value</span> 형태로 이루어지며, 각 <code class=\"inline-code\">key</code>는 <span class=\"purple-400\">Parameter(파라미터)</span>라 칭한다. 첫 <span class=\"purple-400\">파라미터</span>는 <code class=\"inline-code\">?</code>로 시작하며, 이후 각 <span class=\"purple-400\">파라미터</span>들은 <code class=\"inline-code\">&amp;</code>으로 구분된다. 즉 <code class=\"inline-code\">?key1=value1&amp;key2=value2&amp;key3=value3</code>과 같은 양식으로 전개된다.</p>\n<p>임의의 키워드를 전달하여 페이지의 동작을 제어할 수 있다. <span class=\"primary\">URL</span> 중 <strong>사용자의 니즈가 가장 활발하게 반영</strong>되는 부분. <span class=\"teal-400\">쿼리 문자열</span>은 각각의 <code class=\"inline-code\">key</code>에 대한 역할을 정의해야 하므로, 개발자가 각 <span class=\"purple-400\">파라미터</span>의 <code class=\"inline-code\">key</code>가 동작하는 로직을 작성했을 때 그 의미가 있다.</p>\n<h2 id=\"URN-구조\">URN 구조 <a href=\"#URN-구조\">🔗</a></h2><p>지금까지 <span class=\"primary\">URL</span>에 대해선 상당히 장황하게 설명했지만, <span class=\"primary\">URN</span>의 경우 <span class=\"primary\">URL</span>보다 역사가 짧다. 이미 3년이라는 시간 사이에 <span class=\"primary\">URL</span>이 표준으로 자리매김한 탓에, 현재까지도 비주류를 면치 못 해 구현된 예시도 그리 많지 않은게 현실이다.<br><span class=\"primary\">URL</span>이 위치만 바뀌어도 찾을 수 없다는 단점은, 오히려 제공중인 데이터를 은닉하는 측면 등 상황에 따라 오히려 유용하게 사용할 여지도 있다. 즉, <span class=\"primary\">URL</span>의 단점이 마냥 나쁜것만은 아닌 셈이다. 이는 곳 <span class=\"primary\">URN</span>의 장점이 현재 구축된 <span class=\"primary\">URL</span>체계를 갈아 엎을 정도로 매력적이지 않다는 주장을 뒷받침한다.</p>\n<p><span class=\"primary\">URN</span>은 아래와 같은 구조로 이루어진다. 각 요소는 <code class=\"inline-code\">:</code>으로 구분한다.</p>\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">urn</span>:<span class=\"green-400\">isbn</span>:<span class=\"yellow-400\">1234567890</span></p>\n\n<h3 id=\"Protocol(프로토콜)\">Protocol(프로토콜) <a href=\"#Protocol(프로토콜)\">🔗</a></h3><p><span class=\"primary\">URN</span>상의 <span class=\"lightBlue-400\">urn</span> 부분. <code class=\"inline-code\">urn</code>으로 시작하면 <span class=\"primary\">URN</span>체계로 보면 된다.</p>\n<h3 id=\"NID(Namespace-Identifier, 네임스페이스 지시자)\">NID(Namespace Identifier, 네임스페이스 지시자) <a href=\"#NID(Namespace-Identifier, 네임스페이스 지시자)\">🔗</a></h3><p><span class=\"primary\">URN</span>상의 <span class=\"green-400\">isbn</span> 부분. <strong>자원이 저장된 저장소</strong>를 표시한다.<br><code class=\"inline-code\">isbn</code>은 서지정보유통지원시스템으로 도서 일련번호에 대한 정보를 저장하는 저장소이다. 즉, <code class=\"inline-code\">isbn</code>을 <span class=\"green-400\">NID</span>로 지정하면 도서 관련 자원을 식별할 수 있다.</p>\n<h3 id=\"NSS(Namespace-Specific String, 네임스페이스 특정 문자)\">NSS(Namespace Specific String, 네임스페이스 특정 문자) <a href=\"#NSS(Namespace-Specific String, 네임스페이스 특정 문자)\">🔗</a></h3><p><span class=\"primary\">URN</span>상의 <span class=\"yellow-400\">1234567890</span> 부분. <strong>자원을 식별할 수 있는 고유값</strong>이다.<br><span class=\"green-400\">NID</span>가 <code class=\"inline-code\">isbn</code>으로 지정되어 있으므로, ISBN의 일련번호가 1234567890인 도서를 식별하는 <span class=\"primary\">URN</span>이라 볼 수 있다.</p>\n","meta":{"group":[{"header":{"title":"Tomcat 9 vs 10","excerpt":"필자는 Jersey 3 라이브러리를 활용하여 API 서버를 구성하고 있다. 코드를 작성하고 올바른 URL을 호출했음에도, 404 오류가 계속 출력됐다. 간단한 테스트 서블릿을 작성하고, 공식 문서와 아무리 비교를 해도 별다른 특이점을 찾을 수 없었다. 알고보니, Jersey 3는 Servlet 5.0을 지원하기 때문에 Servlet 5.0 스펙을 구현한 Tomcat 10 이상부터 구동이 가능하다는 것을 처음 알았다. 지금껏 톰캣의 버전을 크게 신경쓰지 않았으나, 이 계기로 Tomcat 9와 Tomcat 10에 큰 차이가 있다는 것을 깨달았다.","coverImage":"https://user-images.githubusercontent.com/50317129/168463019-ff20eb0d-7fa5-4866-9086-77b1df7a4a78.png","date":"2022-02-12T19:20:41+09:00","type":"posts","tag":["JAVA(자바)","WAS","Tomcat(톰캣)"],"comment":true,"publish":true},"name":"2022-02-12-tomcat-9-and-10.md","url":["2022-02-12-tomcat-9-and-10","2022","02","12","tomcat-9-and-10"]},{"header":{"title":"[Ubuntu] Ubuntu 원격 프로토콜 보안 강화하기","excerpt":"SSH, SFTP와 같은 원격 프로토콜은 서버의 접근성을 향상시켜주지만, 서버의 보안성을 극도로 훼손한다. 공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다. 따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다. 외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/133300948-2ee9b77a-1589-4afc-8489-fb402a13520f.png","date":"2021-09-15T01:53:21","type":"posts","category":"Ubuntu","tag":["Ubuntu","SSH","SFTP"],"comment":true,"publish":true},"name":"2021-09-15-increase-ubuntu-remote-security.md","url":["2021-09-15-increase-ubuntu-remote-security","2021","09","15","increase-ubuntu-remote-security"]},{"header":{"title":"[Ubuntu] ufw로 방화벽 포트 설정하기","excerpt":"모든 건물에는 입구가 존재한다. 일반적인 상황에서, 누구든지 해당 건물에 드나들기 위해선 좋든 싫든 입구를 통과해야한다. 이 입구라는 것이 또 마냥 열려있는 건 아니라서, 필요 시엔 개방되어있다가도 특정 시간에는 폐쇄되기도 한다. 심지어 어떤 곳은 까다롭기 그지없어서, 사람을 가려받기도 한다. 이를테면 보안구역이라던가, 금요일 밤의 클럽이라던가. PC통신도 이와 원리가 별반 다를 바 없다. 보기엔 그냥 막 통신하는 것 같아도, 저마다 할당받은 입구를 통해 PC에 드나든다. PC가 건물이라고 한다면, PC의 입구는 포트(PORT)라 할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/132039520-3efc64ec-28c2-499c-af29-dfe153f53852.png","date":"2021-09-04T01:26:20","type":"posts","category":"Ubuntu","tag":["Ubuntu","방화벽"],"comment":true,"publish":true},"name":"2021-09-04-firewall-with-ufw.md","url":["2021-09-04-firewall-with-ufw","2021","09","04","firewall-with-ufw"]},{"header":{"title":"블로그 텍스트 색상 예시","excerpt":"색상 테스트","coverImage":"https://user-images.githubusercontent.com/50317129/130466968-83b176c7-2175-4740-85de-12914252d160.png","date":"2021-08-20T15:43:00","type":"posts","category":"잡담","tag":["개발 블로그"],"comment":true,"publish":true},"name":"2021-08-20-color-test.md","url":["2021-08-20-color-test","2021","08","20","color-test"]},{"header":{"title":"블로그 개편기","excerpt":"이 블로그를 처음 개발한지가 한 5월 쯤으로 기억한다. 4월부터 접한 리액트에 흥미가 생겨 두서없이 만든게 시작이였으니, 결과물은 내 생각보다 훨씬 조잡하지 않았나 생각했다. 다행스럽게(?)도 블로그 또한 그런 내 믿음을 져버리기 싫었는지, 동작 과정에서 크고 작은 문제들을 보여주곤 했다. 동작 자체에 영향을 미칠 정도로 크리티컬한 문제는 아니였다만, 내 신경엔 영향을 미칠 정도로 거슬리는 부분이 몇 가지 있었다. 아무도 관심 없지만 이왕 만든거 이번 포스팅을 통해 블로그의 개선점을 정리해놓고자 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/127343484-697c4678-edf3-49fa-8a4d-86775a804428.png","date":"2021-07-26T04:54:40","type":"posts","category":"React","tag":["React(리액트)","Next.js","개발 블로그","TypeScript","SCSS"],"comment":true,"publish":true},"name":"2021-07-26-brand-new.md","url":["2021-07-26-brand-new","2021","07","26","brand-new"]},{"header":{"title":"IntelliJ(인텔리제이) 시작 시 오류(java.net.BindException: Address already in use: bind)","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/121893356-d6d48480-cd58-11eb-80bb-d4611be3bd40.png","date":"2021-06-14T21:59:16","type":"posts","category":"JAVA","tag":["IntelliJ(인텔리제이)","Hyper-V","오류 해결책"],"comment":true,"publish":true},"name":"2021-06-14-intellij-error-onstart.md","url":["2021-06-14-intellij-error-onstart","2021","06","14","intellij-error-onstart"]},{"header":{"title":"[JAVA] split vs StringTokenizer","excerpt":"알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.","coverImage":"https://www.textrazor.com/img/letters3.png","date":"2021-06-14T01:56:01","type":"posts","category":"JAVA","tag":["JAVA(자바)","String(문자열)","split","StringTokenizer"],"comment":true,"publish":true},"name":"2021-06-14-split-and-stringtokenizer.md","url":["2021-06-14-split-and-stringtokenizer","2021","06","14","split-and-stringtokenizer"]},{"header":{"title":"Compiler(컴파일러) & Interpreter(인터프리터)","excerpt":"천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다. 하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 컴퓨터가 알아먹을 수 있어야 실행된다는 얘기다. 글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 컴퓨터는 개발 이래로 초지일관 기계어만을 고집한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.","coverImage":"https://user-images.githubusercontent.com/50317129/120613280-0a79f980-c491-11eb-81a9-15e63062db75.png","date":"2021-06-03T17:25:23","type":"posts","category":"CS","tag":["Compiler(컴파일러)","Interpreter(인터프리터)"],"comment":true,"publish":true},"name":"2021-06-03-compiler-interpreter.md","url":["2021-06-03-compiler-interpreter","2021","06","03","compiler-interpreter"]},{"header":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true},"name":"2021-05-30-unsupported-version-error.md","url":["2021-05-30-unsupported-version-error","2021","05","30","unsupported-version-error"]},{"header":{"title":"URI? URL? URN? 리소스 식별자 구분하기","excerpt":"우리가 인터넷 상에서 특정한 데이터에 접근할 때 URL이라는 것을 활용하여 접근한다. 원하는 자료의 URL을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 URL을 호출하여 응답을 얻는 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028437-a63ddc80-c02f-11eb-9d41-7c50d7002a42.png","date":"2021-05-29T03:30:17","type":"posts","category":"WEB","tag":["WEB(웹)","URI","URL","URN"],"comment":true,"publish":true},"name":"2021-05-29-uri-url-urn.md","url":["2021-05-29-uri-url-urn","2021","05","29","uri-url-urn"]},{"header":{"title":"Tomcat(톰캣) 현재 콘솔창에서 구동하기","excerpt":"오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-26T16:32:16","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-26-tomcat-current-window.md","url":["2021-05-26-tomcat-current-window","2021","05","26","tomcat-current-window"]},{"header":{"title":"Tomcat(톰캣) 콘솔창 한글 인코딩 깨짐 현상 해결하기","excerpt":"톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상. Windows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-22T12:52:51","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-22-tomcat-encoding-euckr.md","url":["2021-05-22-tomcat-encoding-euckr","2021","05","22","tomcat-encoding-euckr"]},{"header":{"title":"도메인이란?","excerpt":"도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다. 인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 고유한 12자리 숫자로 구성된 IP주소를 가진다. IP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다. 유동 IP: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨. 고정 IP: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함. 우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, 특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요하다.","coverImage":"https://user-images.githubusercontent.com/50317129/120056028-b2985880-c074-11eb-8cc3-39f5f10a2c7f.png","date":"2021-05-22T12:52:51","type":"posts","category":"WEB","tag":["WEB(웹)","Domain(도메인)"],"comment":true,"publish":true},"name":"2021-05-22-about-domain.md","url":["2021-05-22-about-domain","2021","05","22","about-domain"]},{"header":{"title":"Jekyll에서 Next.js로","excerpt":"Jekyll에서 Next.js로의 블로그 이동기","coverImage":"https://user-images.githubusercontent.com/50317129/119211732-cf6de280-baee-11eb-8539-f2f5344fecb1.png","date":"2021-05-21T15:09:33","type":"posts","category":"잡담","tag":["React(리액트)","Next.js","개발 블로그","Jekyll"],"comment":true,"publish":true},"name":"2021-05-21-jekyll-to-nextjs.md","url":["2021-05-21-jekyll-to-nextjs","2021","05","21","jekyll-to-nextjs"]}],"next":{"header":{"title":"Tomcat(톰캣) 현재 콘솔창에서 구동하기","excerpt":"오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-26T16:32:16","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-26-tomcat-current-window.md","url":["2021-05-26-tomcat-current-window","2021","05","26","tomcat-current-window"]},"prev":{"header":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true},"name":"2021-05-30-unsupported-version-error.md","url":["2021-05-30-unsupported-version-error","2021","05","30","unsupported-version-error"]}}},"__N_SSG":true}