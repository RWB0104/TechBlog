{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 1. OAuth2.0이란?","excerpt":"사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다. 이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다. 이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T00:56:31","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-1.md","content":"\r\n# 개요\r\n\r\n사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137170074-d678c0e1-d30a-4d38-91e5-543344e18ec3.png)\r\n\r\n이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다.\r\n\r\n이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.\r\n\r\n# OAuth\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137171256-3ca820ec-1435-4103-bc34-9c922832886c.png)\r\n\r\nOAuth는 Open Authentication의 약자로, 인증을 위한 표준 프로토콜이다.\r\n\r\n이전의 인증 방식은 사이트 혹은 애플리케이션에 직접 회원가입을 수행하여 내 정보를 제공하고, 비밀번호를 통해 인증하는 비밀번호 인증 방식을 취한다. 물론 이 비밀번호 인증 방식은 인터넷의 초창기부터 지금까지 사용하는 기법이지만, 그렇다고 문제가 아주 없는 것은 아니였다.\r\n\r\n* 서비스마다 운영되는 중구난방적인 인증 시스템\r\n* 사이트의 신뢰성 문제\r\n* 인터넷을 사용할수록 과적되는 인증 정보\r\n\r\nOAuth 이전에는 이렇다할 인증 표준이 존재하지 않았다. 표준이 없다보니 인증 시스템은 서비스마다 개성이 넘처흘렀다. 사이트마다 요구하는 정보, 방식이 천차만별로 다르니 사용자 입장에서는 매우 혼란스러울 것이다.\r\n\r\n그래도 이 점은 나름 사이트를 구분할 수 있는 일종의 척도(?)가 되기도 한다만, 더 큰 문제는 해당 사이트를 신뢰할만한 지표가 전혀 없다는 것이다. 내 정보를 왜 가져가는지, 어떻게 보관하는지 알 길이 없는 사용자들은 울며 겨자먹기로 서비스에게 내 정보를 제공하게 된다.\r\n\r\n이런 사이트들을 조금만 돌아다니면서 상호작용을 하다보면, 나도 모르는 새에 계정정보가 쌓여있을 것이다. 인증의 주체가 되는 \"나\"는 하나인데, 인증 표준의 부재로 인해 각 서비스마다 나 자신을 인증하기 위한 여러 방법을 소유하게되는 것이다.\r\n\r\n<br />\r\n\r\n이러한 비효율성을 타파하기 위해 Twitter 주도하에 인증 표준이 설립되었고, 이 것이 OAuth의 시초다. OAuth 라는 표준 프로토콜이 정의됨에 따라 각 서비스는 공통된 인터페이스로 사용자에게 인증을 요구할 수 있고, 사용자 역시 익숙하고 신뢰성있는 대형 플랫폼에 인증 정보를 입력하기 때문에 보안적인 측면은 물론, 절차 또한 간소화되는 이점을 가지게 된다.\r\n\r\nOAuth는 1.0을 시작으로, 1.0에 세션 고정 공격이라는 보안 취약점이 발견됨에 따라 현재는 2.0을 사용하고 있다.\r\n\r\n> <b class=\"orange-400\">OAuth1.0의 몰락</b>  \r\n> OAuth1.0은 <span class=\"primary\">세션 고정 공격</span>이라는 보안 취약점을 가지고 있다. 이를 해결하기 위해 OAuth2.0에서는 이러한 문제들이 해결되었으며, OAuth2.0은 OAuth1.0을 완전히 대체한다.\r\n\r\nOAuth2.0은 그 방식에 따라 4가지 방식으로 구분한다.\r\n\r\n이를 설명하기 앞서 OAuth에서 사용하는 키워드에 대해 알아보자\r\n\r\n|      키워드      |                             의미                             |\r\n| :--------------: | :----------------------------------------------------------: |\r\n|       User       |                            사용자                            |\r\n|     Consumer     |               OAuth를 제공하는 서비스 (웹 등)                |\r\n| Service Provider |                OAuth 서비스 제공자 (NAVER 등)                |\r\n|   Access Token   | Consumer가 Service Provider의 자원에 접근하기 위한 인증 코드 |\r\n|  Refresh Token   |             Access Token을 재발급하기 위한 코드              |\r\n\r\n아마 대부분 User의 범주에 속해있을 것이다. 여기서 궁극적으로 구축할 서비스는 Consumer가 된다.\r\n\r\n간혹 Service Provider는 인증 서버와 자원 서버로 분리해서 다루기도 한다.\r\n\r\nNAVER, Google과 같은 플랫폼은 Service Provider가 되며, 인증 절차를 통해 Access Token과 Refresh Token을 전달받게 된다.\r\n\r\n# OAuth Workflow\r\n\r\nOAuth2.0은 구현 방식에 따라 4가지 방식으로 구분된다.\r\n\r\n## 인가 코드 승인 (Authorization Code Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179813-de61fd8a-bbe6-4824-afdf-3652cde164bc.png)\r\n\r\n* 사용자가 Service Provider에 직접 인증을 수행\r\n* 인증에 성공하면 Consumer Frontend는 인가 코드를 전달받음\r\n* Consumer는 인가 코드를 Service Provider에 전달하여 Access, Refresh Token을 반환받음\r\n* Token 반환 이전에 인가 코드를 받는 과정이 추가되어 높은 수준의 보안을 제공함\r\n* Consumer의 Backend에서 Token 교환이 일어나므로 중간에 이를 탈취하기 어려움\r\n* 웹에서 사용되는 가장 보편적인 인증 형태로, 이 프로젝트 또한 인가 코드 승인 형태가 적용됨\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=code\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                내용                 |\r\n| :-----------: | :----------------------------: | :---------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> |  응답 타입으로, 값은 `code`로 고정  |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL            |\r\n|     state     |               N                |      임의로 생성한 고유 상태값      |\r\n|     scope     |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\ncode=dfnY865gHjUbnknt57yGV\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n```\r\n\r\n| 구분  |            내용             |\r\n| :---: | :-------------------------: |\r\n| code  |          인가 코드          |\r\n| state | 요청에서 전달한 고유 상태값 |\r\n\r\n`state`는 Consumer Backend에서 임의로 생성한 상태값으로, 통상 UUID를 하나 생성하여 사용한다.\r\n\r\n`code`와 입력했던 `state`가 반환된다. `code`를 통해 Service Provider에 요청하여 Access Token으로 교환할 수 있다.\r\n\r\n## 암시적 승인 (Implicit Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179833-fe688388-0d29-47c0-b4db-c4a42b26dccd.png)\r\n\r\n* 인가 코드 승인과 달리, 인증 성공 시 Consumer는 Token을 직접 전달받음\r\n* 각 플랫폼에서 제공되는 JavaScript SDK를 사용하여 구현\r\n* 인가 코드 승인에 비해 서버가 필요하지 않아 구현이 간단함\r\n* Token이 GET 방식으로 URL 파라미터에 담겨 전달되므로 보안에 취약하다.\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=token\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                 내용                 |\r\n| :-----------: | :----------------------------: | :----------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `token`으로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY  |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL             |\r\n|     state     |               N                |      임의로 생성한 고유 상태값       |\r\n|     scope     |               N                |              요청 권한               |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\n#access_token=kr40FkgksmGS92lffkGls\r\n&token_type=Bearer\r\n&expires_in=3600\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    state     |      요청에서 전달한 고유 상태값       |\r\n\r\n인가 코드 승인과 달리, 요청에 Access Token이 포함되어 전달된다.\r\n\r\n> <b class=\"orange-400\">파라미터가 왜 </b>`#`<b class=\"orange-400\">으로 시작하지?</b>  \r\n> `#`은 URI Fragment라는 식별자다. 해당 식별자는 URL 접근 시 서버에 전달되지 않기 때문에 보안적인 측면에서 이점을 가져가기 위한 조치다.\r\n\r\n## 리소스 소유자 암호 자격 승인 (Resource Owner Password Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179866-29962644-c0a7-42f8-a397-7b3b1c361082.png)\r\n\r\n* Service Provider에 ID, PW를 전달하여 Token을 전달받음\r\n* 보안 구조가 비밀번호 기반의 인증 뿐이므로 이를 구현하는 Consumer는 신뢰성이 매우 높아야 함\r\n\r\n``` input\r\nPOST /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=password\r\n&client_id=asj2y93bdjen3\r\n&username=username123\r\n&password=password123\r\n&scope=email,profile\r\n```\r\n\r\n|    구분    |           필수 여부            |                내용                 |\r\n| :--------: | :----------------------------: | :---------------------------------: |\r\n| grant_type | <span class=\"red-400\">Y</span> |  승인 타입으로, `password`로 고정   |\r\n| client_id  | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n|  username  | <span class=\"red-400\">Y</span> |               아이디                |\r\n|  password  | <span class=\"red-400\">Y</span> |              비밀번호               |\r\n|   scope    |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n    \"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n## 클라이언트 자격 승인 (Client Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179894-94e8f974-27cd-44b1-9c36-5e1d3dc69377.png)\r\n\r\n* 사용자가 Access Token을 외부 저장소에서 받아 인증하는 형식\r\n* 클라이언트 자체가 인증 수단이므로 절차가 매우 간소함\r\n* 통상 자기 자신의 정보만을 호출함\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=client_credentials\r\n&client_id=asj2y93bdjen3\r\n&client_secret=https://oauth2.example.com/callback\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                      내용                       |\r\n| :-----------: | :----------------------------: | :---------------------------------------------: |\r\n|  grant_type   | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `client_credentials`로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> |       Service Provider에서 제공한 API KEY       |\r\n| client_secret | <span class=\"red-400\">Y</span> |   Service Provider에서 제공한 API Secret KEY    |\r\n|     scope     |               N                |                    요청 권한                    |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n\t\"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n# 정리\r\n\r\n* OAuth2.0은 인증을 위한 표준 프로토콜으로, OAuth 프로토콜을 준수하는 서비스는 기본적으로 공통된 API를 사용해서 인증을 수행할 수 있다.\r\n* OAuth 프로토콜을 통해 인증 절차는 간소화하고, 보안 수준은 강화할 수 있다.\r\n* OAuth의 방식은 4가지로 구분되며, 보편적으로 인가 코드 승인 방식을 사용한다.\r\n* 암시적 승인은 Serverless 서비스나 앱에서 주로 사용된다.\r\n* 나머지 방식은 특수한 환경에서 사용된다.\r\n\r\n다음 장에서는 구축할 시스템의 구성에 대해 다룬다.\r\n\r\n# 참고\r\n\r\n* [IT위키 - OAuth](https://itwiki.kr/w/OAuth)\r\n* [Microsoft OAuth](https://docs.microsoft.com/ko-kr/azure/active-directory/develop/active-directory-v2-protocols)\r\n* [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)","url":["2021-10-14-oauth2-java-server-1","2021","10","14","oauth2-java-server-1"]},"next":null},"group":[{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 1. OAuth2.0이란?","excerpt":"사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다. 이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다. 이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T00:56:31","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-1.md","content":"\r\n# 개요\r\n\r\n사이트를 돌아다니다보면 로그인이 필요한 사이트를 심심치않게 만나볼 수 있다. 그리고 이런 사이트들은 대부분 \"네이버로 로그인하기\"와 같은 플랫폼 로그인을 제공한다. 사이트 뿐만 아니라 근래 들어 출시되는 앱 역시 대부분 플랫폼을 통한 인증 서비스를 제공한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137170074-d678c0e1-d30a-4d38-91e5-543344e18ec3.png)\r\n\r\n이를 활용하면 매우 간단한 절차를 통해 회원가입 또는 로그인을 수행할 수 있게 된다. 이러한 서비스는 네이버 뿐만 아니라 Google, 카카오 등 어느정도 규모있는 플랫폼의 대부분은 이러한 \"플랫폼으로 로그인하기\"와 같은 기능을 제공한다.\r\n\r\n이렇게 플랫폼의 정보를 활용하여 타 사이트에서 인증을 수행하는 것을 OAuth 프로토콜이라 한다.\r\n\r\n# OAuth\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137171256-3ca820ec-1435-4103-bc34-9c922832886c.png)\r\n\r\nOAuth는 Open Authentication의 약자로, 인증을 위한 표준 프로토콜이다.\r\n\r\n이전의 인증 방식은 사이트 혹은 애플리케이션에 직접 회원가입을 수행하여 내 정보를 제공하고, 비밀번호를 통해 인증하는 비밀번호 인증 방식을 취한다. 물론 이 비밀번호 인증 방식은 인터넷의 초창기부터 지금까지 사용하는 기법이지만, 그렇다고 문제가 아주 없는 것은 아니였다.\r\n\r\n* 서비스마다 운영되는 중구난방적인 인증 시스템\r\n* 사이트의 신뢰성 문제\r\n* 인터넷을 사용할수록 과적되는 인증 정보\r\n\r\nOAuth 이전에는 이렇다할 인증 표준이 존재하지 않았다. 표준이 없다보니 인증 시스템은 서비스마다 개성이 넘처흘렀다. 사이트마다 요구하는 정보, 방식이 천차만별로 다르니 사용자 입장에서는 매우 혼란스러울 것이다.\r\n\r\n그래도 이 점은 나름 사이트를 구분할 수 있는 일종의 척도(?)가 되기도 한다만, 더 큰 문제는 해당 사이트를 신뢰할만한 지표가 전혀 없다는 것이다. 내 정보를 왜 가져가는지, 어떻게 보관하는지 알 길이 없는 사용자들은 울며 겨자먹기로 서비스에게 내 정보를 제공하게 된다.\r\n\r\n이런 사이트들을 조금만 돌아다니면서 상호작용을 하다보면, 나도 모르는 새에 계정정보가 쌓여있을 것이다. 인증의 주체가 되는 \"나\"는 하나인데, 인증 표준의 부재로 인해 각 서비스마다 나 자신을 인증하기 위한 여러 방법을 소유하게되는 것이다.\r\n\r\n<br />\r\n\r\n이러한 비효율성을 타파하기 위해 Twitter 주도하에 인증 표준이 설립되었고, 이 것이 OAuth의 시초다. OAuth 라는 표준 프로토콜이 정의됨에 따라 각 서비스는 공통된 인터페이스로 사용자에게 인증을 요구할 수 있고, 사용자 역시 익숙하고 신뢰성있는 대형 플랫폼에 인증 정보를 입력하기 때문에 보안적인 측면은 물론, 절차 또한 간소화되는 이점을 가지게 된다.\r\n\r\nOAuth는 1.0을 시작으로, 1.0에 세션 고정 공격이라는 보안 취약점이 발견됨에 따라 현재는 2.0을 사용하고 있다.\r\n\r\n> <b class=\"orange-400\">OAuth1.0의 몰락</b>  \r\n> OAuth1.0은 <span class=\"primary\">세션 고정 공격</span>이라는 보안 취약점을 가지고 있다. 이를 해결하기 위해 OAuth2.0에서는 이러한 문제들이 해결되었으며, OAuth2.0은 OAuth1.0을 완전히 대체한다.\r\n\r\nOAuth2.0은 그 방식에 따라 4가지 방식으로 구분한다.\r\n\r\n이를 설명하기 앞서 OAuth에서 사용하는 키워드에 대해 알아보자\r\n\r\n|      키워드      |                             의미                             |\r\n| :--------------: | :----------------------------------------------------------: |\r\n|       User       |                            사용자                            |\r\n|     Consumer     |               OAuth를 제공하는 서비스 (웹 등)                |\r\n| Service Provider |                OAuth 서비스 제공자 (NAVER 등)                |\r\n|   Access Token   | Consumer가 Service Provider의 자원에 접근하기 위한 인증 코드 |\r\n|  Refresh Token   |             Access Token을 재발급하기 위한 코드              |\r\n\r\n아마 대부분 User의 범주에 속해있을 것이다. 여기서 궁극적으로 구축할 서비스는 Consumer가 된다.\r\n\r\n간혹 Service Provider는 인증 서버와 자원 서버로 분리해서 다루기도 한다.\r\n\r\nNAVER, Google과 같은 플랫폼은 Service Provider가 되며, 인증 절차를 통해 Access Token과 Refresh Token을 전달받게 된다.\r\n\r\n# OAuth Workflow\r\n\r\nOAuth2.0은 구현 방식에 따라 4가지 방식으로 구분된다.\r\n\r\n## 인가 코드 승인 (Authorization Code Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179813-de61fd8a-bbe6-4824-afdf-3652cde164bc.png)\r\n\r\n* 사용자가 Service Provider에 직접 인증을 수행\r\n* 인증에 성공하면 Consumer Frontend는 인가 코드를 전달받음\r\n* Consumer는 인가 코드를 Service Provider에 전달하여 Access, Refresh Token을 반환받음\r\n* Token 반환 이전에 인가 코드를 받는 과정이 추가되어 높은 수준의 보안을 제공함\r\n* Consumer의 Backend에서 Token 교환이 일어나므로 중간에 이를 탈취하기 어려움\r\n* 웹에서 사용되는 가장 보편적인 인증 형태로, 이 프로젝트 또한 인가 코드 승인 형태가 적용됨\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=code\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                내용                 |\r\n| :-----------: | :----------------------------: | :---------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> |  응답 타입으로, 값은 `code`로 고정  |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL            |\r\n|     state     |               N                |      임의로 생성한 고유 상태값      |\r\n|     scope     |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\ncode=dfnY865gHjUbnknt57yGV\r\n&state=6b773c55-b688-4a77-adaf-0bd25f4c4111\r\n```\r\n\r\n| 구분  |            내용             |\r\n| :---: | :-------------------------: |\r\n| code  |          인가 코드          |\r\n| state | 요청에서 전달한 고유 상태값 |\r\n\r\n`state`는 Consumer Backend에서 임의로 생성한 상태값으로, 통상 UUID를 하나 생성하여 사용한다.\r\n\r\n`code`와 입력했던 `state`가 반환된다. `code`를 통해 Service Provider에 요청하여 Access Token으로 교환할 수 있다.\r\n\r\n## 암시적 승인 (Implicit Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179833-fe688388-0d29-47c0-b4db-c4a42b26dccd.png)\r\n\r\n* 인가 코드 승인과 달리, 인증 성공 시 Consumer는 Token을 직접 전달받음\r\n* 각 플랫폼에서 제공되는 JavaScript SDK를 사용하여 구현\r\n* 인가 코드 승인에 비해 서버가 필요하지 않아 구현이 간단함\r\n* Token이 GET 방식으로 URL 파라미터에 담겨 전달되므로 보안에 취약하다.\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\nresponse_type=token\r\n&client_id=asj2y93bdjen3\r\n&redirect_url=https://oauth2.example.com/callback\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                 내용                 |\r\n| :-----------: | :----------------------------: | :----------------------------------: |\r\n| response_type | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `token`으로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY  |\r\n| redirect_url  | <span class=\"red-400\">Y</span> |            응답 반환 URL             |\r\n|     state     |               N                |      임의로 생성한 고유 상태값       |\r\n|     scope     |               N                |              요청 권한               |\r\n\r\n<br />\r\n<br />\r\n\r\n``` output\r\nGET /callback\r\nHost: oauth2.example.com\r\n\r\n#access_token=kr40FkgksmGS92lffkGls\r\n&token_type=Bearer\r\n&expires_in=3600\r\n&state=97c66e11-d0e0-4c86-833c-e08bed40748d\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    state     |      요청에서 전달한 고유 상태값       |\r\n\r\n인가 코드 승인과 달리, 요청에 Access Token이 포함되어 전달된다.\r\n\r\n> <b class=\"orange-400\">파라미터가 왜 </b>`#`<b class=\"orange-400\">으로 시작하지?</b>  \r\n> `#`은 URI Fragment라는 식별자다. 해당 식별자는 URL 접근 시 서버에 전달되지 않기 때문에 보안적인 측면에서 이점을 가져가기 위한 조치다.\r\n\r\n## 리소스 소유자 암호 자격 승인 (Resource Owner Password Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179866-29962644-c0a7-42f8-a397-7b3b1c361082.png)\r\n\r\n* Service Provider에 ID, PW를 전달하여 Token을 전달받음\r\n* 보안 구조가 비밀번호 기반의 인증 뿐이므로 이를 구현하는 Consumer는 신뢰성이 매우 높아야 함\r\n\r\n``` input\r\nPOST /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=password\r\n&client_id=asj2y93bdjen3\r\n&username=username123\r\n&password=password123\r\n&scope=email,profile\r\n```\r\n\r\n|    구분    |           필수 여부            |                내용                 |\r\n| :--------: | :----------------------------: | :---------------------------------: |\r\n| grant_type | <span class=\"red-400\">Y</span> |  승인 타입으로, `password`로 고정   |\r\n| client_id  | <span class=\"red-400\">Y</span> | Service Provider에서 제공한 API KEY |\r\n|  username  | <span class=\"red-400\">Y</span> |               아이디                |\r\n|  password  | <span class=\"red-400\">Y</span> |              비밀번호               |\r\n|   scope    |               N                |              요청 권한              |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n    \"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n## 클라이언트 자격 승인 (Client Credentials Grant)\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/137179894-94e8f974-27cd-44b1-9c36-5e1d3dc69377.png)\r\n\r\n* 사용자가 Access Token을 외부 저장소에서 받아 인증하는 형식\r\n* 클라이언트 자체가 인증 수단이므로 절차가 매우 간소함\r\n* 통상 자기 자신의 정보만을 호출함\r\n\r\n``` input\r\nGET /auth\r\nHost: oauth2.example.com\r\n\r\ngrant_type=client_credentials\r\n&client_id=asj2y93bdjen3\r\n&client_secret=https://oauth2.example.com/callback\r\n&scope=email,profile\r\n```\r\n\r\n|     구분      |           필수 여부            |                      내용                       |\r\n| :-----------: | :----------------------------: | :---------------------------------------------: |\r\n|  grant_type   | <span class=\"red-400\">Y</span> | 응답 타입으로, 값은 `client_credentials`로 고정 |\r\n|   client_id   | <span class=\"red-400\">Y</span> |       Service Provider에서 제공한 API KEY       |\r\n| client_secret | <span class=\"red-400\">Y</span> |   Service Provider에서 제공한 API Secret KEY    |\r\n|     scope     |               N                |                    요청 권한                    |\r\n\r\n<br />\r\n<br />\r\n\r\n``` json\r\n{\r\n    \"access_token\": \"dGkdi93ns2kdkV9dkA3\",\r\n    \"token_type\": \"Bearer\",\r\n    \"expires_in\": 3600,\r\n\t\"scope\": \"email,profile\"\r\n}\r\n```\r\n\r\n|     구분     |                  내용                  |\r\n| :----------: | :------------------------------------: |\r\n| access_token |               접근 토큰                |\r\n|  token_type  | 접근 토큰의 타입으로, 통상 Bearer 사용 |\r\n|  expires_in  |           토큰 유효기간 (초)           |\r\n|    scope     |               요청 권한                |\r\n\r\n# 정리\r\n\r\n* OAuth2.0은 인증을 위한 표준 프로토콜으로, OAuth 프로토콜을 준수하는 서비스는 기본적으로 공통된 API를 사용해서 인증을 수행할 수 있다.\r\n* OAuth 프로토콜을 통해 인증 절차는 간소화하고, 보안 수준은 강화할 수 있다.\r\n* OAuth의 방식은 4가지로 구분되며, 보편적으로 인가 코드 승인 방식을 사용한다.\r\n* 암시적 승인은 Serverless 서비스나 앱에서 주로 사용된다.\r\n* 나머지 방식은 특수한 환경에서 사용된다.\r\n\r\n다음 장에서는 구축할 시스템의 구성에 대해 다룬다.\r\n\r\n# 참고\r\n\r\n* [IT위키 - OAuth](https://itwiki.kr/w/OAuth)\r\n* [Microsoft OAuth](https://docs.microsoft.com/ko-kr/azure/active-directory/develop/active-directory-v2-protocols)\r\n* [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)","url":["2021-10-14-oauth2-java-server-1","2021","10","14","oauth2-java-server-1"]}],"data":{"header":{"title":"[OAuth2.0] ScribeJAVA로 OAuth2.0 인증서버 구축하기 - 2. 인증서버 설계하기","excerpt":"OAuth2.0 프로토콜에 대한 사전 지식도 얻었으니, 이를 통해 인증서버를 직접 구축해보자. Frontend, Backend 부분으로 나누어 웹 페이지를 통해 소셜 로그인을 수행하고, 직접 구현한 인증서버에서 이를 처리하는 시스템 일체를 구축하는 것이 궁극적인 목표다.","coverImage":"https://user-images.githubusercontent.com/50317129/137171016-99af1db1-a346-4def-9329-6072b927bdc0.png","date":"2021-10-14T22:12:25","type":"posts","category":"JAVA","tag":["JAVA","OAuth2.0"],"group":"OAuth2.0 인증서버 구축기","comment":true,"publish":true},"name":"2021-10-14-oauth2-java-server-2.md","content":"<h1 id=\"개요\">개요 <a href=\"#개요\">🔗</a></h1><p>OAuth2.0 프로토콜에 대한 사전 지식도 얻었으니, 이를 통해 인증서버를 직접 구축해보자.</p>\n<p>Frontend, Backend 부분으로 나누어 웹 페이지를 통해 <span class=\"red-400\">소셜 로그인을 수행</span>하고, 직접 구현한 <span class=\"red-400\">인증서버에서 이를 처리하는 시스템 일체를 구축</span>하는 것이 궁극적인 목표다.</p>\n<p>인증 서버의 인증 방식은 <span class=\"primary\">인가 코드 승인 (Authorization Code Grant)</span>을 취한다.</p>\n<h1 id=\"제원\">제원 <a href=\"#제원\">🔗</a></h1><p>웹 페이지인 Frontend와 API 통신의 주체가 되는 인증서버인 Backend로 나뉜다.</p>\n<h2 id=\"Backend\">Backend <a href=\"#Backend\">🔗</a></h2><p><b class=\"large green-600\">💬 Language</b></p>\n<ul>\n<li><a href=\"https://www.java.com/ko/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/java-v16.0.2-007396?logo=java&logoWidth=25\" alt=\"Java\"></a></li>\n</ul>\n<p><b class=\"large green-600\">🧱 Framework</b></p>\n<ul>\n<li><a href=\"https://gradle.org/\" target=\"_blank\"><img src=\"https://img.shields.io/badge/gradle-02303A?logo=gradle&logoWidth=25\" alt=\"Gradle\"></a></li>\n<li><img src=\"https://img.shields.io/badge/jakarta.servlet--api-v5.0.0-blue\" alt=\"jakarta.servlet-api\"></li>\n<li><img src=\"https://img.shields.io/badge/lombok-v1.18.20-blue\" alt=\"lombok\"></li>\n<li><img src=\"https://img.shields.io/badge/jjwt-v0.9.1-blue\" alt=\"jjwt\"></li>\n<li><img src=\"https://img.shields.io/badge/scribejava--apis-v8.3.1-blue\" alt=\"scribejava-apis\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--server-v3.0.3-blue\" alt=\"jersey-server\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--container--servlet-v3.0.3-blue\" alt=\"jersey-container-servlet\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--hk2-v3.0.3-blue\" alt=\"jersey-hk2\"></li>\n<li><img src=\"https://img.shields.io/badge/jersey--media--json--jackson-v3.0.3-blue\" alt=\"jersey-media-json-jackson\"></li>\n</ul>\n<p><b class=\"large green-600\">📦 Publish</b></p>\n<ul>\n<li><a href=\"http://tomcat.apache.org/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/Tomcat-v10.0.12-F8DC75?logo=apachetomcat&logoWidth=25&logoColor=FFF\" alt=\"Tomcat\"></a></li>\n<li><a href=\"https://www.raspberrypi.org/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/RaspberryPi-F00?logo=raspberrypi&logoWidth=25&logoColor=FFF\" alt=\"Raspberry Pi\"></a></li>\n</ul>\n<p>Jersey는 RESTful API 프레임워크, scribeJAVA는 OAuth 프레임워크다.</p>\n<p>Jersey 3는 Servlet 5.0 최신 스펙인 <code class=\"inline-code\">jakarta.*</code>을 사용한다. 때문에 이를 구현한 Tomcat 10을 사용한다. Tomcat 10 미만 혹은 <code class=\"inline-code\">jakarta.*</code>을 구현하지 않는 등 <b class=\"red-600\">최신 서블릿 스펙을 사용할 수 없는 WAS의 경우 이 프로젝트는 배포할 수 없다.</b></p>\n<h2 id=\"Frontend\">Frontend <a href=\"#Frontend\">🔗</a></h2><p><b class=\"large green-600\">💬 Language</b></p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML\" target=\"_blank\"><img src=\"http://img.shields.io/badge/HTML5-E34F26?logo=html5&logoWidth=25&logoColor=FFF\" alt=\"HTML5\"></a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript\" target=\"_blank\"><img src=\"http://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoWidth=25&logoColor=000\" alt=\"JavaScript\"></a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS\" target=\"_blank\"><img src=\"http://img.shields.io/badge/CSS3-1572B6?logo=css3&logoWidth=25\" alt=\"CSS3\"></a></li>\n</ul>\n<p><b class=\"large green-600\">🧱 Framework</b></p>\n<ul>\n<li><a href=\"https://eslint.org/\" target=\"_blank\"><img src=\"https://img.shields.io/badge/eslint-%5E7.32.0-4B32C3?logo=eslint&logoWidth=25\" alt=\"eslint\"></a></li>\n</ul>\n<p><b class=\"large green-600\">📦 Publish</b></p>\n<ul>\n<li><a href=\"https://pages.github.com/\" target=\"_blank\"><img src=\"http://img.shields.io/badge/GitHub%20Pages-000?logo=github&logoWidth=25&logoColor=FFF\" alt=\"GitHub\"></a></li>\n</ul>\n<p>원래는 Raspberry Pi로 배포하고 있었으나, 굳이 그럴 필요가 없어서 GutHub Pages로 배포한다.</p>\n<p>Frontend는 단순히 인증 서버와의 API 통신 및 정보 표출 정도만 수행하므로, React 같은 복잡한 기술은 최대한 지양하고 최대한 기본 기능으로만 구성했다.</p>\n<h1 id=\"구성\">구성 <a href=\"#구성\">🔗</a></h1><p>인증서버는 크게 세 부분으로 나눌 수 있다.</p>\n<ul>\n<li><code class=\"inline-code\">controller</code> - 지정한 URL의 요청을 받아 process에게 위임한다.</li>\n<li><code class=\"inline-code\">process</code> - API의 동작을 수행하고, 응답을 생성한다</li>\n<li><code class=\"inline-code\">module</code> - API 동작 수행에 필요한 모듈</li>\n</ul>\n<p>이는 패키지로 구분한다.</p>\n<h2 id=\"controller\">controller <a href=\"#controller\">🔗</a></h2><p>Jersey 프레임워크는 <code class=\"inline-code\">controller</code> 영역에서 동작한다.</p>\n<p>기존의 Servlet은 RESTful API를 설계하기위해 직접 구현해야할 부분이 존재한다.</p>\n<p>RESTful API를 효과적으로 설계하기 위해 Jersey 프레임워크를 사용한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137264829-4e703edf-e682-4793-a2b1-675056cba087.png\" alt=\"image\"></p>\n<p>controller는 <span class=\"primary\">정의된 process로 요청을 전달하고, process가 반환하는 응답을 요청자에게 다시 전달</span>한다.</p>\n<ul>\n<li>GET <code class=\"inline-code\">/login/:platform</code> - 플랫폼별 인증 URL 반환 API</li>\n<li>POST <code class=\"inline-code\">/login/:platform</code> - 플랫폼별 로그인 API</li>\n<li>POST <code class=\"inline-code\">/login/auto</code> - 자동 로그인 API</li>\n<li>POST <code class=\"inline-code\">/logout</code> - 로그아웃 API</li>\n<li>GET <code class=\"inline-code\">/userinfo</code> - 유저 정보 반환 API</li>\n</ul>\n<p>해당 프로젝트에선 위 <code class=\"inline-code\">controller</code>들이 구현될 것이다.</p>\n<h2 id=\"process\">process <a href=\"#process\">🔗</a></h2><p><code class=\"inline-code\">process</code>에선 실제 로직이 구현되는 영역이다. 이 때 필요하다면 <code class=\"inline-code\">module</code>을 호출하기도 한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137265824-a2652f3c-c32f-42cf-9b5e-8f523530895e.png\" alt=\"image\"></p>\n<p><code class=\"inline-code\">process</code>는 <span class=\"primary\">수행 결과를 정해진 형식의 JSON을 기반으로 응답 객체</span>를 만들어 <code class=\"inline-code\">controller</code>로 반환한다.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JSON</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"copyCode(this);\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\" data-icon=\"clipboard\" class=\"i-clipboard\"><path fill=\"currentColor\" d=\"M336 64h-80c0-35.3-28.7-64-64-64s-64 28.7-64 64H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 40c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm144 418c0 3.3-2.7 6-6 6H54c-3.3 0-6-2.7-6-6V118c0-3.3 2.7-6 6-6h42v36c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-36h42c3.3 0 6 2.7 6 6z\"></path></svg></button>\n\n\t\t\t\t\t\t<pre class=\"language-json\"><table><tbody><tr data-number=0><td class=\"line-number\" data-number=\"0\">0</td><td class=\"line-code\" data-number=0><span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=1><td class=\"line-number\" data-number=\"1\">1</td><td class=\"line-code\" data-number=1>    flag<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=2><td class=\"line-number\" data-number=\"2\">2</td><td class=\"line-code\" data-number=2>    title<span class=\"token operator\">:</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=3><td class=\"line-number\" data-number=\"3\">3</td><td class=\"line-code\" data-number=3>    message<span class=\"token operator\">:</span> <span class=\"token string\">\"test api response success\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=4><td class=\"line-number\" data-number=\"4\">4</td><td class=\"line-code\" data-number=4>    body<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span></td></tr>\n<tr data-number=5><td class=\"line-number\" data-number=\"5\">5</td><td class=\"line-code\" data-number=5>        key1<span class=\"token operator\">:</span> <span class=\"token string\">\"value1\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=6><td class=\"line-number\" data-number=\"6\">6</td><td class=\"line-code\" data-number=6>        key2<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=7><td class=\"line-number\" data-number=\"7\">7</td><td class=\"line-code\" data-number=7>        key3<span class=\"token operator\">:</span> <span class=\"token number\">4932</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=8><td class=\"line-number\" data-number=\"8\">8</td><td class=\"line-code\" data-number=8>        key4<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></td></tr>\n<tr data-number=9><td class=\"line-number\" data-number=\"9\">9</td><td class=\"line-code\" data-number=9>            <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=10><td class=\"line-number\" data-number=\"10\">10</td><td class=\"line-code\" data-number=10>            <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=11><td class=\"line-number\" data-number=\"11\">11</td><td class=\"line-code\" data-number=11>            <span class=\"token string\">\"C\"</span></td></tr>\n<tr data-number=12><td class=\"line-number\" data-number=\"12\">12</td><td class=\"line-code\" data-number=12>        <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></td></tr>\n<tr data-number=13><td class=\"line-number\" data-number=\"13\">13</td><td class=\"line-code\" data-number=13>        key5<span class=\"token operator\">:</span> <span class=\"token number\">93.203</span></td></tr>\n<tr data-number=14><td class=\"line-number\" data-number=\"14\">14</td><td class=\"line-code\" data-number=14>    <span class=\"token punctuation\">}</span></td></tr>\n<tr data-number=15><td class=\"line-number\" data-number=\"15\">15</td><td class=\"line-code\" data-number=15><span class=\"token punctuation\">}</span></td></tr></tbody></table></pre>\n\t\t\t\t\t</div>\n\t\t\t\t\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">파라미터</th>\n<th align=\"center\">필수 여부</th>\n<th align=\"center\">데이터 형식</th>\n<th align=\"center\">내용</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">flag</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">boolean</code></td>\n<td align=\"center\">응답 정상 여부</td>\n</tr>\n<tr>\n<td align=\"center\">title</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">String</code></td>\n<td align=\"center\">응답 제목</td>\n</tr>\n<tr>\n<td align=\"center\">message</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">String</code></td>\n<td align=\"center\">응답 메세지</td>\n</tr>\n<tr>\n<td align=\"center\">body</td>\n<td align=\"center\">Y</td>\n<td align=\"center\"><code class=\"inline-code\">String | Number | boolean | Array | Object</code></td>\n<td align=\"center\">응답 정상 여부</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>응답 명세는 위와 같다.</p>\n<p><code class=\"inline-code\">process</code>는 GET, POST 등 HTTP Method에 따라 나누어 관리한다.</p>\n<h2 id=\"module\">module <a href=\"#module\">🔗</a></h2><p>module은 여러 <code class=\"inline-code\">process</code>에서 <span class=\"primary\">반복적으로 사용되는 로직의 모듈화를 구현한 객체</span>다.</p>\n<p>이 중 핵심 기능인 OAuth의 인증을 처리하는 모듈은 scribeJAVA 기반으로 작성된다.</p>\n<p>로그인, 사용자 정보 요청 등 인증과 관련된 로직을 수행하는 <code class=\"inline-code\">process</code>들은 모두 위 모듈을 호출하여 사용함으로써 중복 코드를 줄이고 유지보수성을 높인다.</p>\n<h1 id=\"OAuth-모듈\">OAuth 모듈 <a href=\"#OAuth-모듈\">🔗</a></h1><p>이 프로젝트의 Backend에 가장 중요한 역할을 담당하는 모듈로, OAuth 인증을 구현한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137314562-675ee988-0dad-4937-93a1-73753c2afee4.png\" alt=\"image\"></p>\n<p>요즘은 어느정도 규모있는 플랫폼이라면 OAuth 서비스를 제공한다. 플랫폼은 달라도 OAuth를 준수한다면 모두 공통된 요청 받아 공통된 응답을 제공할 것이다. 공통 프로토콜을 사용하므로, 인증 모듈 하나를 만들어 모든 인증을 거기서 처리하면 될 것이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137314573-599b1317-0e46-4698-ac65-04fef57933e8.png\" alt=\"image\"></p>\n<p>하지만 문제가 하나 있다. 아무리 공통 프로토콜을 사용한다지만, <span class=\"red-400\">플랫폼마다 추가적인 파라미터 혹은 헤더를 요구</span>하기도 한다. 조건문을 떡칠한다면 모를까, 고작 인증 모듈 하나에서 플랫폼별 요구사항을 하나하나 처리하기엔 문제가 많다. 조건문을 통한 분기 역시 유지보수적인 측면에서 그리 좋은 방식은 아니다.</p>\n<br />\n<br />\n\n<p>OAuth는 객체라기보단 일종의 개념에 더 가깝다. 이렇게 추상적인 개념의 형태는 JAVA의 인터페이스 내지는 추상 객체가 적합하다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/137314582-cf0c24f7-5ad3-42f8-a7d7-de19e59c8582.png\" alt=\"image\"></p>\n<p>인증 모듈의 경우, 몇몇 플랫폼의 특이 사항으로 인해 문제가 발생하니, 기본적으로는 <span class=\"blue-600\">인증 모듈의 공통 로직을 사용하되, 추가적인 요구를 하는 플랫폼에 한해 로직을 변경하는 것이 효율적</span>일 것이다. 따라서 인증 모듈은 인터페이스보단 추상 객체가 더 어울릴 것이다.</p>\n<p>이렇게 인증 추상 모듈을 하나 생성하고, 각 소셜 플랫폼마다 인증 모듈을 상속받아 구현하게끔 설계하면 될 것이다.</p>\n<p>문제가 없는 플랫폼은 기 선언된 인증 모듈의 메서드를 그대로 사용하고, <span class=\"blue-600\">추가 요구사항이 있는 플랫폼은 해당 플랫폼의 인증 모듈에서 메서드를 오버라이딩</span>하여 요구사항에 맞게 재설계한다.</p>\n<h2 id=\"인증-모듈 기능\">인증 모듈 기능 <a href=\"#인증-모듈 기능\">🔗</a></h2><p>구현해야할 기능은 아래와 같다.</p>\n<ul>\n<li>플랫폼 로그인 URL 생성 로직</li>\n<li>서비스 로그인 로직 (인가코드 -> Access Token)</li>\n<li>자동 로그인 로직</li>\n<li>로그아웃 로직</li>\n<li>사용자 정보 호출 로직</li>\n</ul>\n<p>최소한 위 기능이 구현되어야한다.</p>\n<p>사용자 정보 호출의 경우, 플랫폼마다 주는 응답이 천차만별로 다르다.</p>\n<p>사용자 정보는 OAuth로 전달받은 Access Token으로 Service Provider에 정보를 요청하여 받을 수 있다. OAuth는 어디까지나 인증을 받기 위한 표준 프로토콜로, <span class=\"red-400\">인증 토큰을 통해 수행하는 부가적인 활동에 대해서는 별다른 제약이 없으므로</span>, Access Token 발급 이후의 API 요청 및 응답은 플랫폼마다 천차만별로 다르다.</p>\n<p>때문에 사용자 정보 호출 로직의 경우, OAuth 표준 프로토콜에 구애받지 않는다. 이에 대응하기 위해 추상 메서드로 선언하여 각 모듈에서 응답을 정제하여 반환하도록 강제하자.</p>\n<h1 id=\"구조도\">구조도 <a href=\"#구조도\">🔗</a></h1><p><img src=\"https://user-images.githubusercontent.com/50317129/137319720-28a6d25b-6128-4873-bbb4-b0e0f5cce847.png\" alt=\"image\"></p>\n<p>OAuth 모듈을 사용하는 API의 구조를 도식화하면 위와 같다.</p>\n<p>Jersey가 URL을 캐치하여 정해진 process로 전달한다. process는 인증을 수행하기 위해 해당 플랫폼의 OAuth 구현체를 호출하여 로직을 수행할 것이다. 이후 결과가 반환되어 사용자에게 전달되는 구조다.</p>\n<h1 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h1><p>지금까지 인증 서버에 대한 설계를 진행했다. 다음 장엔 기본적인 서버 구축을 진행하며, 특히 Jersey를 통한 RESTful API의 틀을 구축한다.</p>\n","url":["2021-10-14-oauth2-java-server-2","2021","10","14","oauth2-java-server-2"],"toc":[{"text":"개요","tag":"개요","depth":1},{"text":"제원","tag":"제원","depth":1},{"text":"Backend","tag":"Backend","depth":2},{"text":"Frontend","tag":"Frontend","depth":2},{"text":"구성","tag":"구성","depth":1},{"text":"controller","tag":"controller","depth":2},{"text":"process","tag":"process","depth":2},{"text":"module","tag":"module","depth":2},{"text":"OAuth 모듈","tag":"OAuth-모듈","depth":1},{"text":"인증 모듈 기능","tag":"인증-모듈 기능","depth":2},{"text":"구조도","tag":"구조도","depth":1},{"text":"정리","tag":"정리","depth":1}]},"hash":"9a45ddb35da"},"__N_SSG":true}