{"pageProps":{"posts":[{"header":{"title":"긍정적인 시나리오 최적화","excerpt":"지금까지는 항상 알고리즘을 비관적인 관점으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다. 이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-24T04:54:40","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","삽입 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-24-about-algorithm-chapter06.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 6장 긍정적인 시나리오 최적화\r\n\r\n지금까지는 항상 알고리즘을 <span class=\"orange-400\">비관적인 관점</span>으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다.\r\n\r\n이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.\r\n\r\n## 6-1. 삽입 정렬\r\n\r\n이 장에서는 <span class=\"primary\">삽입 정렬</span> 알고리즘을 토대로 전개한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834021-dcb0625e-80fb-4567-bd8d-982ae60a04c0.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬할 배열은 위와 같으며, 원리는 아래와 같다.\r\n\r\n1. 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" />\r\n</p>\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" />\r\n</p>\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n3. 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n## 6-2. 삽입 정렬해보기\r\n\r\n이전 문단의 원리를 토대로 삽입 정렬을 수행한다.\r\n\r\n1. 패스스루 1: 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 패스스루 1: 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" />\r\n</p>\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" />\r\n</p>\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n1. 패스스루 1: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n4. 패스스루 2: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834064-d8e10cd3-d825-47d4-9a29-ee3a95b9cb60.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 9\r\n* 비교값: -\r\n\r\n세 번째 요소의 값인 9를 임시 변수로 할당한다.\r\n\r\n5. 패스스루 2: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834073-83c7f417-d7ac-43ce-8421-0119ef5d4712.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 9\r\n* 비교값: 7\r\n\r\n임시 변수보다 비교값이 작을 경우, 비교를 종료하고 현재 공백에 임시 변수를 삽입한다. 이 케이스의 경우 바로 왼쪽에 위치한 요소가 7로 9보다 작으므로, 그 즉시 비교가 종료되며 삽입을 진행한다.\r\n\r\n5. 패스스루 2: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834078-3e4fda60-79af-4f58-9915-aca42d5babfd.png\" width=\"600px\" />\r\n</p>\r\n\r\n공교롭게도, 원래의 위치에 임시 변수 9가 삽입된다.\r\n\r\n6. 패스스루 3: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834085-ce09440c-11a9-418c-ac7e-07c307bb16b5.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: -\r\n\r\n네 번째 요소의 값인 2를 임시 변수로 할당한다.\r\n\r\n7. 패스스루 3: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834098-f4dbef5a-0a59-4668-aa73-0e98b431895a.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 9\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834107-74cc6e75-3a59-4fa3-8c66-56160cdb6913.png\" width=\"600px\" />\r\n</p>\r\n\r\n비교값 9가 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834113-25e6eac5-d5eb-4380-918f-249eaf9de4d1.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 7\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834120-2df440ae-cad4-4f7b-a3fd-708b2ec0b6d3.png\" width=\"600px\" />\r\n</p>\r\n\r\n비교값 7이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834129-5ee81114-faf3-43cd-ba96-4e3f46a705a8.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 2\r\n* 비교값: 3\r\n\r\n비교값 3이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834134-09db5b58-6c7a-49af-a1e9-b3125e85dd6b.png\" width=\"600px\" />\r\n</p>\r\n\r\n8. 패스스루 3: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834141-cc23a70b-f809-4783-affb-cefae7faa2cf.png\" width=\"600px\" />\r\n</p>\r\n\r\n가장 맨 첫 요소에 임시 변수 2가 삽입된다.\r\n\r\n9. 패스스루 4: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834150-6cd89c4c-6f2a-4360-b4cc-677d073ccd85.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 5\r\n* 비교값: -\r\n\r\n다섯 번째 요소의 값인 5를 임시 변수로 할당한다.\r\n\r\n10. 패스스루 4: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834157-416ea349-6684-496b-bb98-cbd456232e54.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 임시 변수: 5\r\n* 비교값: 9\r\n\r\n비교값 9가 임시 변수 5보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834166-f03e3731-66b8-4b66-95e8-51d176a92bee.png\" width=\"600px\" />\r\n</p>\r\n\r\n11. 패스스루 4: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834174-6b6b0444-fc8a-4983-814f-e54e93914765.png\" width=\"600px\" />\r\n</p>\r\n\r\n네 번째 요소에 임시 변수 5가 삽입된다.\r\n\r\n가장 마지막 요소까지 기준 인덱스가 이동했으므로, 해당 패스스루를 마지막으로 종료한다.\r\n\r\n## 6-3. 삽입 정렬 구현\r\n\r\n삽입 정렬의 과정을 토대로 이를 <span class=\"orange-400\">JAVA</span>로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 삽입 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 02:40:19\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int shiftCount = 0;\r\n\tprivate static int deleteCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tselectionSort(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 시프트 작업량: \");\r\n\t\twriter.write(String.valueOf(shiftCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삭제 작업량: \");\r\n\t\twriter.write(String.valueOf(deleteCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + shiftCount + deleteCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 삽입 정렬 알고리즘\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t */\r\n\tprivate static void selectionSort(int[] array)\r\n\t{\r\n\t\tfor (int i = 1; i < array.length; i++)\r\n\t\t{\r\n\t\t\t// 임시 변수\r\n\t\t\tint temp = array[i];\r\n\t\t\t\r\n\t\t\t// 빈 공간\r\n\t\t\tint blank = i;\r\n\t\t\t\r\n\t\t\t// 삭제 작업 추가\r\n\t\t\tdeleteCount++;\r\n\t\t\t\r\n\t\t\t// 공백 표시\r\n\t\t\tarray[i] = Integer.MIN_VALUE;\r\n\t\t\t\r\n\t\t\tfor (int j = i - 1; j > -1; j--)\r\n\t\t\t{\r\n\t\t\t\t// 비교 작업 추가\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소가 임시 변수보다 클 경우\r\n\t\t\t\tif (array[j] > temp)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 시프트 작업 추가\r\n\t\t\t\t\tshiftCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = array[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tblank--;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아닐 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 삽입 작업 추가\r\n\t\t\tinsertCount++;\r\n\t\t\t\r\n\t\t\tarray[blank] = temp;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n10 9 8 7 6 5 4 3 2 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n - 비교 작업량: 45\r\n - 시프트 작업량: 45\r\n - 삭제 작업량: 9\r\n - 삽입 작업량: 9\r\n - 총 작업량: 108\r\n```\r\n\r\n소스와 입력, 출력값은 위와 같다. 사용자로부터 임의의 배열을 입력받아 삽입 정렬을 수행하고, 졍렬 결과와 각 작업량을 구분하여 표시한다.\r\n\r\n실제 핵심 동작은 `selectionSort` 메소드에서 이루어진다. 공백은 `Integer.MIN_VALUE`를 삽입하여 표시하며, 삭제됨을 표현하기 위한 것으로 작업량에 포함되지 않는다.\r\n\r\n``` java\r\nfor (int i = 1; i < array.length; i++)\r\n{\r\n\t// 임시 변수\r\n\tint temp = array[i];\r\n\t\r\n\t// 빈 공간\r\n\tint blank = i;\r\n\t\r\n\t// 삭제 작업 추가\r\n\tdeleteCount++;\r\n\t\r\n\t// 공백 표시\r\n\tarray[i] = Integer.MIN_VALUE;\r\n\t\r\n\t// ...\r\n}\r\n```\r\n\r\n첫 번째 `for`문은 각 패스스루를 의미한다. 각 패스스루마다 기준 인덱스 `i`, 임시 변수 `temp`, 삭제된 요소의 인덱스 `blank`가 새로 정의된다. 이 과정에서 삭제 연산이 고정으로 한 번 수행된다.\r\n\r\n``` java\r\nfor (int j = i - 1; j > -1; j--)\r\n{\r\n\t// 비교 작업 추가\r\n\tcompareCount++;\r\n\t\r\n\t// 현재 요소가 임시 변수보다 클 경우\r\n\tif (array[j] > temp)\r\n\t{\r\n\t\t// 시프트 작업 추가\r\n\t\tshiftCount++;\r\n\t\t\r\n\t\tarray[blank] = array[j];\r\n\t\t\r\n\t\tblank--;\r\n\t\t\r\n\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n두 번째 `for`문은 각 기준 인덱스 `i`의 왼쪽 요소부터 0까지 비교 및 시프트 작업을 의미한다. 각 사이클마다 비교 작업 한 번이 반드시 발생하며, 임시 변수와 현재 요소 간의 크기에 따라 시프트 작업이 발생할 수 있다.\r\n\r\n``` java\r\nfor (int i = 1; i < array.length; i++)\r\n{\r\n\t// ...\r\n\t\r\n\t// 삽입 작업 추가\r\n\tinsertCount++;\r\n\t\r\n\tarray[blank] = temp;\r\n}\r\n```\r\n\r\n모든 비교가 끝나면 현재 공백인 요소에 임시 변수를 삽입한다. 이 과정에서 삽입 작업 한 번이 반드시 발생한다.\r\n\r\n## 6-4. 삽입 정렬의 효율성\r\n\r\n삽입 정렬 시 발생하는 작업을 분석하여 그 효율성에 대해 알아보자. 삽입 정렬은 <span class=\"orange-400\">삭제</span>, <span class=\"orange-400\">비교</span>, <span class=\"orange-400\">시프트</span>, <span class=\"orange-400\">삽입</span>의 4개 작업으로 이루어져있다.\r\n\r\n삽입 정렬에서 가장 최악의 케이스는 요소가 역순으로 정렬된 배열이다. 모든 요소가 역순으로 정렬될 경우, 발생할 수 있는 모든 작업이 발생한다. 최악의 경우에 발생하는 각 작업량을 일반식으로 정의하면 아래와 같다.\r\n\r\n* 삭제: $N - 1$\r\n* 비교: $N^2 \\div 2$ (대략적인 값)\r\n* 시프트: $N^2 \\div 2$ (대략적인 값)\r\n* 삽입: $N - 1$\r\n\r\n이를 토대로 삽입 정렬의 시간 복잡도는 $O(N^2 + 2N - 2)$임을 알 수 있다. 빅 오 표기법은 <span class=\"blue-400\">상수를 무시</span>하므로 $O(N^2 + N)$으로 간략하게 표기할 수 있다. 하지만 빅 오 표기법은 상수만 무시하는 게 아니다. <span class=\"blue-400\">가장 높은 차수를 제외한 나머지 차수 또한 무시</span>한다. 그말인 즉슨, $N^2 + N$에서 가장 높은 차수는 $N^2$이므로, $N$은 무시한다. 따라서 최종적으로 삽입 정렬의 시간 복잡도는 $O(N^2)$이 된다.\r\n\r\n|  $N$  |   $N^2$   |     $N^3$     |       $N^4$       |\r\n| :---: | :-------: | :-----------: | :---------------: |\r\n|   2   |     4     |       8       |        16         |\r\n|   5   |    25     |      125      |        625        |\r\n|  10   |    100    |     1,000     |      10,000       |\r\n|  100  |  10,000   |   1,000,000   |    100,000,000    |\r\n| 1,000 | 1,000,000 | 1,000,000,000 | 1,000,000,000,000 |\r\n\r\n요소 $N$의 갯수가 100일 때, $N^4$와 $N^3$은 $N$의 값인 100배 차이가 난다. $N^4$ 입장에서는 $N^3$ 작업 한 사이클이 발생해도, 자신의 작업량의 1%밖에 되지 않는다. 차수가 높아질 수록 작업량의 차이가 기하급수적으로 벌어지기 때문에 무시하는 것이다.\r\n\r\n지금까지 버블, 선택, 삽입 정렬 세 가지를 다뤄봤다. 각 알고리즘의 시간 복잡도를 정리하면 아래와 같다.\r\n\r\n|       구분        | 버블 정렬 |    선택 정렬    |     삽입 정렬     |\r\n| :---------------: | :-------: | :-------------: | :---------------: |\r\n|   빅 오 표기법    | $O(N^2)$  |    $O(N^2)$     |     $O(N^2)$      |\r\n| 실제 빅 오 표기법 | $O(N^2)$  | $O(N^2 \\div 2)$ | $O(N^2 + 2N - 2)$ |\r\n\r\n4장 부터 6장까지 오면서, 우리는 각 정렬의 빅 오 표기법과 실제 나타나는 빅 오 표기법에 대해 알고있다. 위 표를 토대로 본다면, 세 정렬 기법 중 선택 정렬이 가장 빠르다고 할 수 있을 것이다. 단, 누누히 말했듯이 최악의 경우에 가깝다는 전제가 수반된다.\r\n\r\n그렇다면 평균적인 경우는 어떨까?\r\n\r\n## 6-5. 평균적인 경우\r\n\r\n데이터가 1억, 1조가 넘어간다면 모를까, 대부분의 일반적인 환경에선 그리 많은 데이터를 처리하지 않는다. 즉, 대부분의 경우 최악의 케이스에 도달하지 않는다는 뜻이기도 하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834185-4dfa70f6-0a15-4069-a7a4-7f3ed43809f4.png\" width=\"600px\" />\r\n</p>\r\n\r\n대부분의 케이스는 위와 같은 정규 분포도를 따른다. 좌측으로 수렴할 수록 최악의 케이스, 우측으로 수렴할 수록 최선의 케이스, 정 가운데로 수렴할 수록 평균적인 케이스다. <span class=\"green-400\">대다수는 평균적인 영역에 포함</span>되며, 양 옆의 극단적인 케이스는 상대적으로 양이 적다.\r\n\r\n지금까지 다룬 정렬 알고리즘의 대부분은 역순으로 정렬될 경우가 최악의 케이스였다. 완전 무작위의 배열이 입력된다고 가정할 때, 정확히 역순으로 나열된 배열이 나올 확률이 얼마나 될지 생각해보자. 대부분의 배열은 어떠한 규칙도 없이 무작위로 나열됐을 것이다. 굳이 위 같은 정규 분포도가 아니더라도 일상 생활에서 비슷한 사례는 많이 있다. 여러 케이스 중 발생하는 특이 케이스는 다른 대다수의 케이스와는 어떠한 방향으로든 다르다는 뜻이다. 최선, 최악의 케이스는 어찌 보면 이러한 특이 케이스의 범주에 속한다.\r\n\r\n우리가 이번 장에서 다룬 삽입 정렬을 토대로 확인해보자.\r\n\r\n* 최악의 경우, $O(N^2 + 2N - 2)$. 즉, $O(N^2)$를 가진다.\r\n* 최선의 경우, $O(3(N - 1))$. 즉, $O(N)$를 가진다.\r\n* 일반적인 경우, $O(N^2 \\div 2)$. 즉, $O(N^2)$를 가진다.\r\n\r\n이를 표로 나타내면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126834196-63471f0e-41df-4715-ac15-8c79fd606fae.png\" width=\"600px\" />\r\n</p>\r\n\r\n삽입 정렬은 케이스에 따라 유의미한 성능의 차이가 존재한다. 반대로 선택 정렬의 경우 꽤 난감한데, 선택 정렬은 어떠한 케이스에서든 $O(N^2)$의 시간 복잡도를 가진다.\r\n\r\n``` java\r\n/**\r\n * 선택 정렬 함수\r\n *\r\n * @param array : [int[]] 대상 배열\r\n *\r\n * @return [int[]] 작업 갯수 배열\r\n */\r\nprivate static int[] selectionSort(int[] array)\r\n{\r\n\tint compareCount = 0;\r\n\tint swapCount = 0;\r\n\t\r\n\tfor (int i = 0; i < array.length; i++)\r\n\t{\r\n\t\t// 패스스루의 최소값 인덱스\r\n\t\tint min = i;\r\n\t\t\r\n\t\tfor (int j = i + 1; j < array.length; j++)\r\n\t\t{\r\n\t\t\tcompareCount++;\r\n\t\t\t\r\n\t\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\t\tif (array[j] < array[min])\r\n\t\t\t{\r\n\t\t\t\tmin = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 최소 인덱스에 변화가 있었을 경우\r\n\t\tif (min != i)\r\n\t\t{\r\n\t\t\tint temp = array[min];\r\n\t\t\t\r\n\t\t\tarray[min] = array[i];\r\n\t\t\tarray[i] = temp;\r\n\t\t\t\r\n\t\t\tswapCount++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn new int[] { compareCount, swapCount };\r\n}\r\n```\r\n\r\n위 소스는 5장에서 다룬 선택 정렬 소스다. 보시다시피 `for`문이 2개나 존재함으로 $O(N^2)$의 시간 복잡도를 가진다는 것을 어렵지 않게 유추할 수 있다. 더군다나 소스를 자세히 보자. 중간에 반복문을 종료할 수 있는 `break` 또한 존재하지 않는다. 좋든 싫든 항상 $N^2$의 작업을 수행한다는 뜻이다. 실제로 5장의 소스를 구동하면 케이스별로 작업량의 차이가 그리 크지 않다.\r\n\r\n만약 사용할 데이터의 대부분이 어느정도 정렬되어있을 경우, 삽입 정렬이 훨씬 유리하다고 판단할 수 있다. 만약 데이터가 완전히 무작위라면 선택 정렬이나 삽입 정렬이나 크게 차이가 없다고 볼 수 있다.\r\n\r\n## 6-6. 실제 예제\r\n\r\n두 배열이 존재하며, 각 배열에 공통으로 존재하는 요소를 추출하여 반환하는 교집합 알고리즘을 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 25\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n이중 `for` 구조이므로 시간 복잡도는 당연히 $O(N^2)$일 것이다. 두 배열의 요소의 크기가 완전히 동일할 때, 나타날 수 있는 최악의 케이스는 $O(N^2 + N)$이다. 간략히 $O(N^2)$라고 할 수 있다.\r\n\r\n위 알고리즘의 경우 불필요한 연산을 수행하기도 한다. 이를 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\">긍정적인 시나리오 최적화</a>\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class ImproveIntersection\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 24\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n차이점은 `for`문 안의 `if` 구문에 있다.\r\n\r\n``` java\r\n// 두 배열의 요소가 같을 경우\r\nif (item1 == item2)\r\n{\r\n\tinsertCount++;\r\n\t\r\n\tlist.add(item1);\r\n\t\r\n\tbreak;\r\n}\r\n```\r\n\r\n이처럼 동일한 요소가 탐색되었을 경우, `break`를 통해 패스스루 강제 종료 기능을 추가했다. 최악의 시나리오에선 $O(N^2)$로 동일하지만, 최선의 시나리오에선 $O(N)$으로 동작할 것이다. 이전의 알고리즘이 항상 $O(N^2)$임을 감안한다면 적절한 최적화라 할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서 주로 얘기한 내용은 아래와 같다.\r\n\r\n* 알고리즘을 꼭 비관적으로만 바라보는 것은 아니다.\r\n* 오히려 대부분의 케이스는 평균의 범주에 속한다.\r\n* 알고리즘의 로직에 따라 케이스의 양에 따라시간 복잡도가 유의미하게 달라지기도 한다.\r\n\r\n이 장에서는 알고리즘의 또 다른 관점에 대해 알아봤다. 대부분의 케이스가 평균의 범주에 속하므로, 평균 시간 복잡도 역시 성능을 측정함에 있어서 중요한 요소 중 하나일 것이다.\r\n\r\n다음 장에서는 새로운 개념인 해시 테이블에 대해 알아본다.","url":["2021-07-24-about-algorithm-chapter06","2021","07","24","about-algorithm-chapter06"]},{"header":{"title":"빅 오를 사용하거나 사용하지 않는 코드 최적화","excerpt":"지금까지 알고리즘의 퍼포먼스를 비교하면서 빅 오 표기법을 통해 수치화했다. 하지만 빅 오 표기법도 알고리즘의 퍼포먼스를 측정함에 있어서 완벽함을 보여주진 않는다. 이전 장에서 N(O^2)이나 N(N^2 - N) 모두 빅 오 표기법에선 N(O^2)로 간주한다고 설명했다. 이러한 특성으로 인해, 실제로는 명백한 차이를 보이는 알고리즘임에도 불구하고 빅 오 표기법으론 성능이 거의 동일하게 측정되기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-23T23:42:33","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","선택 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-23-about-algorithm-chapter05.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 5장 빅 오를 사용하거나 사용하지 않는 코드 최적화\r\n\r\n지금까지 알고리즘의 퍼포먼스를 비교하면서 <span class=\"primary\">빅 오 표기법</span>을 통해 수치화했다. 하지만 빅 오 표기법도 알고리즘의 퍼포먼스를 측정함에 있어서 완벽함을 보여주진 않는다.\r\n\r\n이전 장에서 $N(O^2)$이나 $N(N^2 - N)$ 모두 빅 오 표기법에선 $N(O^2)$로 간주한다고 설명했다. 이러한 특성으로 인해, 실제로는 명백한 차이를 보이는 알고리즘임에도 불구하고 빅 오 표기법으론 성능이 거의 동일하게 측정되기도 한다.\r\n\r\n알고리즘의 속도는 알고리즘을 선택하는 데 있어서 매우 중요한 척도이므로, 이를 정확비 측정하는 것은 매우 중요하다. 이 장에서는 앞서 설명한 것과 같이 대체로 성능이 <span class=\"pink-400\">비슷해</span>보이는 알고리즘을 구별하여 더욱 빠른 알고리즘을 판별해본다.\r\n\r\n## 5-1. 선택 정렬\r\n\r\n이전 장에서는 <span class=\"orange-400\">버블 정렬</span> 알고리즘을 통해 내용을 서술했다. 이번 장에서는 다른 정렬 알고리즘인 <span class=\"orange-400\">선택 정렬</span> 알고리즘을 통해 서술해본다.\r\n\r\n선택 정렬 알고리즘은 패스스루마다 요소를 탐색하여 최소값을 탐지하고, 이를 앞으로 보내어 정렬하는 방식이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793171-d9677021-0ff9-414c-b83b-165dc037222f.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬에 사용할 배열은 위와 같으며, 과정은 아래의 순서대로 진행된다.\r\n\r\n1. 맨 첫 번째 값을 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793179-854c05e3-04cc-420a-8a42-22fe0145c4cb.png\" width=\"600px\" />\r\n</p>\r\n\r\n한 패스스루에서 가장 작은 요소를 찾는 것이 핵심이다. 아직 첫 단계이므로, 첫 요소는 그 자체로 최소값이 된다.\r\n\r\n2. 탐색 포인터를 한 칸 이동하여 패스스루 최소값과 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793193-d865b162-9c02-44a0-a59c-d2e1674f4e5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 5\r\n* 탐색값: 3\r\n\r\n패스스루 최소값을 3으로 갱신한다.\r\n\r\n3. 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793202-90a4dfc3-d40c-4073-9127-763781156693.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n4. 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793209-88b076db-fe26-4cee-9a0c-1f0540beb0c8.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 2\r\n\r\n패스스루 최소값을 2로 갱신한다.\r\n\r\n5. 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793215-a5a7dde7-8fbf-42a4-b585-5b5778297cc3.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 2\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다. 마지막 요소이므로, 탐색이 종료되고 요소 하나를 정렬한다.\r\n\r\n6. 패스스루 최소값의 요소를 맨 앞으로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793223-3580ae05-867b-464d-9d58-831e93b6142b.png\" width=\"600px\" />\r\n</p>\r\n\r\n맨 앞의 요소 5와 최소값 2의 자리를 서로 교환한다. 2는 완전히 매칭되었으므로, 앞으로의 패스스루에서 제외된다.\r\n\r\n## 5-2. 선택 정렬 실제로 해보기\r\n\r\n이전 문단에서 선택 정렬의 원리에 대해 알았으니, 전체 배열에 대한 선택 정렬을 수행해보자.\r\n\r\n<small class=\"red-A400\">패스스루 1은 이전 문단의 과정과 동일하다.</small>\r\n\r\n1. 패스스루 1: 맨 첫 번째 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793179-854c05e3-04cc-420a-8a42-22fe0145c4cb.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 5\r\n\r\n한 패스스루에서 가장 작은 요소를 찾는 것이 핵심이다. 아직 첫 단계이므로, 첫 요소는 그 자체로 최소값이 된다.\r\n\r\n2. 패스스루 1: 탐색 포인터를 한 칸 이동하여 패스스루 최소값과 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793193-d865b162-9c02-44a0-a59c-d2e1674f4e5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 5\r\n* 탐색값: 3\r\n\r\n패스스루 최소값을 3으로 갱신한다.\r\n\r\n3. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793202-90a4dfc3-d40c-4073-9127-763781156693.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n4. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793209-88b076db-fe26-4cee-9a0c-1f0540beb0c8.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 2\r\n\r\n패스스루 최소값을 2로 갱신한다.\r\n\r\n5. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793215-a5a7dde7-8fbf-42a4-b585-5b5778297cc3.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 2\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다. 마지막 요소이므로, 탐색이 종료되고 요소 하나를 정렬한다.\r\n\r\n6. 패스스루 1: 패스스루 최소값의 요소를 맨 앞으로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793223-3580ae05-867b-464d-9d58-831e93b6142b.png\" width=\"600px\" />\r\n</p>\r\n\r\n맨 앞의 요소 5와 최소값 2의 자리를 서로 교환한다. 2는 완전히 매칭되었으므로, **앞으로의 패스스루에서 제외**된다.\r\n\r\n7. 패스스루 2: 두 번째 요소를 탐색한다.\r\n\r\n* 최소값: -\r\n* 탐색값: 3\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793231-7c8448af-29e1-4d65-9c37-630dcec47e24.png\" width=\"600px\" />\r\n</p>\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n8. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793239-cefccd38-954e-4c49-85be-a007698d072b.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n9. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793255-354bc82f-0c65-4a75-bfde-c192f97344dc.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 5\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n10. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793276-bd4020c4-fcda-4b45-b993-2575ff7c1b69.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 3\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n11. 패스스루 2: 패스스루 최소값의 요소를 두 번째 위치로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793282-277dc152-91d4-47a8-bdcb-3f5280593040.png\" width=\"600px\" />\r\n</p>\r\n\r\n최소값 3이 우연히도 올바른 자리에 위치하고 있어서 자리 교환이 일어나지 않는다. 두 번째 요소까지 정렬되었으므로, 마찬가지로 다음 패스스루부터 제외된다.\r\n\r\n12. 패스스루 3: 세 번째 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793296-8e9c6a9b-8aff-4634-86cc-684338c990dc.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n13. 패스스루 3: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793310-19358a00-e527-405d-8033-1eef2c11060b.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 9\r\n* 탐색값: 5\r\n\r\n패스스루 최소값을 5로 갱신한다.\r\n\r\n14. 패스스루 3: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793315-ca00a872-d867-40e5-95c3-c9de2b7c7851.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 5\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n15. 패스스루 3: 패스스루 최소값의 요소를 세 번째 위치로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793330-af0a7836-5bfd-477c-b614-c8c2fc8f108f.png\" width=\"600px\" />\r\n</p>\r\n\r\n세 번째 요소 9와 최소값 5와의 자리를 서로 교환한다.\r\n\r\n16. 패스스루 4: 네 번째 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793337-f90959c9-c798-46f5-b64a-68807621edad.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n17. 패스스루 4: 2번 과정을 반복한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793345-4f6a2819-4dac-4c81-b9c6-4ca7fd4c8749.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: 9\r\n* 탐색값: 6\r\n\r\n패스스루 최소값을 6으로 갱신한다.\r\n\r\n18. 패스스루 4: 패스스루 최소값의 요소를 네 번째 위치로 정렬한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793357-e0e62399-9d03-48a8-8f23-721e43022a65.png\" width=\"600px\" />\r\n</p>\r\n\r\n네 번째 요소 9와 최소값 6와의 자리를 서로 교환한다.\r\n\r\n19. 패스스루 5: 마지막 요소를 탐색한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793365-b658adfc-df4b-4e56-b130-e78e81826d54.png\" width=\"600px\" />\r\n</p>\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n패스스루 최소값을 9로 갱신한다.\r\n\r\n마지막 요소이므로 그 자체로 정렬된 위치에 있으며, 패스스루가 종료된다.\r\n\r\n이로써 선택 정렬을 통해 최종적으로 정렬된 배열의 형태는 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793370-a6ec0819-47c7-49c6-8f30-b953d9311336.png\" width=\"600px\" />\r\n</p>\r\n\r\n## 5-3. 선택 정렬 구현\r\n\r\n선택 정렬의 과정을 토대로 이를 <span class=\"orange-400\">JAVA</span>로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 선택 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/23/about-algorithm-chapter05/\">빅 오를 사용하거나 사용하지 않는 코드 최적화</a>\r\n * @since 2021.07.23 Fri 01:12:20\r\n */\r\npublic class SelectionSort\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] processes = selectionSort(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[0]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 스왑 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[0] + processes[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 선택 정렬 함수\r\n\t *\r\n\t * @param array : [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 작업 갯수 배열\r\n\t */\r\n\tprivate static int[] selectionSort(int[] array)\r\n\t{\r\n\t\tint compareCount = 0;\r\n\t\tint swapCount = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < array.length; i++)\r\n\t\t{\r\n\t\t\t// 패스스루의 최소값 인덱스\r\n\t\t\tint min = i;\r\n\t\t\t\r\n\t\t\tfor (int j = i + 1; j < array.length; j++)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\t\t\tif (array[j] < array[min])\r\n\t\t\t\t{\r\n\t\t\t\t\tmin = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 최소 인덱스에 변화가 있었을 경우\r\n\t\t\tif (min != i)\r\n\t\t\t{\r\n\t\t\t\tint temp = array[min];\r\n\t\t\t\t\r\n\t\t\t\tarray[min] = array[i];\r\n\t\t\t\tarray[i] = temp;\r\n\t\t\t\t\r\n\t\t\t\tswapCount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { compareCount, swapCount };\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n5 3 4 1 2\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 2, 3, 4, 5]\r\n - 비교 작업량: 10\r\n - 스왑 작업량: 4\r\n - 총 작업량: 14\r\n```\r\n\r\n사용자로부터 공백으로 구분된 숫자 배열을 입력받아 선택 정렬을 수행하고, 작업량을 구분에 따라 표시한다. 핵심 동작은 `selectionSort` 메소드에서 수행한다.\r\n\r\n* 첫 번째 `for`: 패스스루\r\n* 두 번째 `for`: 비교 작업\r\n* `if`문: 스왑 작업\r\n\r\n``` java\r\nfor (int i = 0; i < array.length; i++)\r\n{\r\n\t// 패스스루의 최소값 인덱스\r\n\tint min = i;\r\n\t\r\n\tfor (int j = i + 1; j < array.length; j++)\r\n\t{\r\n\t\tcompareCount++;\r\n\t\t\r\n\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\tif (array[j] < array[min])\r\n\t\t{\r\n\t\t\tmin = j;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 최소 인덱스에 변화가 있었을 경우\r\n\tif (min != i)\r\n\t{\r\n\t\tint temp = array[min];\r\n\t\t\r\n\t\tarray[min] = array[i];\r\n\t\tarray[i] = temp;\r\n\t\t\r\n\t\tswapCount++;\r\n\t}\r\n}\r\n```\r\n\r\n패스스루마다 첫 요소를 최소값 `min`에 할당한다. 이후 다음 요소부터 마지막 요소까지 순차적으로 `min`과 비교한다.\r\n\r\n`min`보다 더 작은 요소가 탐색될 경우 이를 교체한다. 최종적으로 `min`에는 검색한 요소들 중 가장 최소값이 할당된다.\r\n\r\n`if`문에서 `min`에 변화가 있었는지를 확인한다. 패스스루의 첫 요소의 인덱스가 아닐 경우, `min`이 변경된 것이므로 스왑을 진행한다.\r\n\r\n\r\n## 5-4. 선택 정렬의 효율성\r\n\r\n선택 정렬의 효율성을 따져보자. 위에서 언급했듯이, 선택 정렬은 <span class=\"blue-400\">비교</span>, <span class=\"blue-400\">교환</span> 작업으로 이루어진다. 비교는 항상 일어나고, 교환의 경우 조건부로 일어난다.\r\n\r\n요소가 5개인 배열을 선택 정렬할 경우 발생하는 비교 작업량은 아래와 같다.\r\n\r\n| 패스스루 | 작업량 |\r\n| :------: | :----: |\r\n|    1     |   4    |\r\n|    2     |   3    |\r\n|    3     |   2    |\r\n|    4     |   1    |\r\n\r\n$4 + 3 + 2 + 1 = 10$으로 총 10번의 비교 작업이 수행된다. 일반화하면 $(N - 1) + (N - 2) + \\dots + 1$와 같이 정의할 수 있다.\r\n\r\n교환의 경우, 비교와 달리 패스스루 당 최대 한 번만 발생하며, 이 또한 조건에 따라 아예 일어나지 않기도 한다.\r\n\r\n가장 최악의 경우, 각 패스스루마다 교환이 발생하므로 요소가 5개 일 때, 최대 4번의 교환 작업을 예상할 수 있다.\r\n\r\n예시로, $[ 5, 3, 4, 1, 2 ]$의 경우 모든 패스스루에서 스왑이 일어난다.\r\n\r\n> **책에서는 역순일 때가 최악의 경우라는데요??**  \r\n> 역순 배열일 경우 오히려 교환이 두 번 밖에 일어나지 않는다. 반만 정렬하면 나머지 뒤쪽은 알아서 정렬하기 때문.\r\n\r\n버블 정렬과 선택 정렬을 비교하면 아래와 같다.\r\n\r\n|  $N$  | 버블 정렬 | 선택 정렬 | 차이  |\r\n| :---: | :-------: | :-------: | :---: |\r\n|   5   |    20     |    14     |  30%  |\r\n|  10   |    90     |    54     |  40%  |\r\n|  20   |    380    |    199    | 52.4% |\r\n|  40   |   1560    |    819    | 52.5% |\r\n|  80   |   6320    |   3229    | 51.1% |\r\n|  100  |   9900    |   5049    |  51%  |\r\n\r\n버블 정렬 대비 선택 정렬의 속도가 50%로 수렴한다. 즉, 최악의 경우에도 선택 정렬이 두 배 가량 빠르다는 걸 알 수 있다.\r\n\r\n## 5-5. 상수 무시하기\r\n\r\n이전 문단에서의 디테일한 비교로 버블 정렬과 선택 정렬 간의 유의미한 차이가 있음을 확인했다. 선택 정렬을 빅 오 표기법으로 나타내면 $O(N^2 / 2)$가 된다.\r\n\r\n|  $N$  | $N^2 / 2$ | 선택 정렬의 작업량 |\r\n| :---: | :-------: | :----------------: |\r\n|   5   |   12.5    |         14         |\r\n|  10   |    50     |         54         |\r\n|  20   |    200    |        199         |\r\n|  40   |    800    |        819         |\r\n|  80   |   3200    |        3229        |\r\n|  100  |   5000    |        5049        |\r\n\r\n위 표가 이를 뒷받침해준다. 하지만 실제 버블 정렬과 선택 정렬의 빅 오 표기법은 둘 다 동일하게 $O(N^2)$이다. 실제로 선택 정렬 또한 <span class=\"red-400\">반복문이 두 번 중첩</span>되어있다. $O(N^2)$의 특징이 그대로 나타나있는 것이다. 이는 빅 오 표기법이 처음 소개된 3장부터 꾸준히 언급되었던 특징으로, <span class=\"teal-400\">빅 오 표기법은 상수를 무시</span>한다.\r\n\r\n분명히 상수도 유의미한 수인데, 명색이 **성능**을 측정한다는 기법이 왜 이렇게 느슨한 형태를 가지는 걸까?\r\n\r\n## 5-6. 빅 오의 역할\r\n\r\n빅 오 표기법은 왜 상수를 무시할까? 이는 빅 오 표기법이 가지는 관점 때문이라고 설명할 수 있다. $O(N)$과 $O(N^2)$, $O(100N)$과 $O(N^2)$의 작업량을 비교하면서 빅 오 표기법이 알고리즘을 어떤 관점으로 바라보는지 확인해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/126793374-db4248af-daf1-4e02-8622-c16d2a2c9f69.png\" width=\"800px\" />\r\n</p>\r\n\r\n$O(N^2)$의 경우, 어떠한 경우에든 $O(N)$보다 같거나 느리다. 하지만 $O(100N)$의 경우는 살짝 다르다. 데이터가 적은 앞 구간에선 오히려 $O(N^2)$이 더 빠르지만, 충분히 데이터가 많아진 이후로는 $O(100N)$이 더 빠르다.\r\n\r\n빅 오 표기법이 상수에 크게 미련을 갖지 않는 이유다. $O(N)$, $O(N^2)$과 같이 구간이 완전히 다를 경우 항상 빠르거나, 반대로 느리다.\r\n\r\n그러나 $O(100N)$, $O(N^2)$의 경우 데이터의 양에 따라 상대적으로 빠르기도 하고, 느리기도 하다. 이런 경우의 알고리즘을 서로 구분하기 위해 빅 오 표기법은 상수를 무시한다. 어차피 $O(N)$이나 $O(100N)$이나 장기적으론 $O(N^2)$보다는 빨라지기 때문이다.\r\n\r\n빅 오 표기법은 여전히 구간이 전혀 다른 알고리즘을 상대로는 유효한 성능 판단의 척도다. 시간 복잡도가 동일하더라도, 실제로 보여주는 알고리즘의 성능은 차이가 있을 수 있다는 점을 감안하자.\r\n\r\n## 5-7. 실제 예제\r\n\r\n요소 $N$개를 가진 배열에서 두 요소 중 하나만 선택하여 $N \\div 2$의 요소를 가지는 새로운 배열을 만드는 알고리즘을 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 선택 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/23/about-algorithm-chapter05/\">빅 오를 사용하거나 사용하지 않는 코드 최적화</a>\r\n * @since 2021.07.23 Fri 22:32:54\r\n */\r\npublic class HalfArray\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = solve(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 결과 배열\r\n\t */\r\n\tprivate static int[] solve(int[] array)\r\n\t{\r\n\t\tint length = (int) Math.ceil(array.length / 2D);\r\n\t\t\r\n\t\tint[] result = new int[length];\r\n\t\t\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < array.length; i++)\r\n\t\t{\r\n\t\t\t// 인덱스가 짝수일 경우\r\n\t\t\tif (i % 2 == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[count] = array[i];\r\n\t\t\t\t\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[0, 2, 4, 6, 8]\r\n```\r\n\r\n위 알고리즘은 배열의 모든 원소를 순회하며, 인덱스가 짝수일 경우 해당 값을 추출하여 새로운 배열로 만들어 반환한다.\r\n\r\n해당 알고리즘은 <span class=\"orange-400\">탐색</span>과 <span class=\"orange-400\">삽입</span>으로 이루어져있다.\r\n\r\n* 탐색: $N$개\r\n* 삽입: $N / 2$개\r\n\r\n즉, 위 알고리즘의 정확한 시간 복잡도는 $O(1.5N)$이며, 위에서 언급했듯이 상수를 무시하므로 $O(N)$으로 표기한다.\r\n\r\n위 알고리즘을 조금 더 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 배열 선택 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/23/about-algorithm-chapter05/\">빅 오를 사용하거나 사용하지 않는 코드 최적화</a>\r\n * @since 2021.07.23 Fri 22:51:52\r\n */\r\npublic class ImproveHalfArray\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"요소의 갯수가 짝수개인 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = solve(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 결과 배열\r\n\t */\r\n\tprivate static int[] solve(int[] array)\r\n\t{\r\n\t\tint length = (int) Math.ceil(array.length / 2D);\r\n\t\t\r\n\t\tint[] result = new int[length];\r\n\t\t\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < array.length; i += 2)\r\n\t\t{\r\n\t\t\tresult[count] = array[i];\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[0, 2, 4, 6, 8]\r\n```\r\n\r\n위 알고리즘은 `solve` 메소드의 `for`부분을 향상시킨 알고리즘이다.\r\n\r\n``` java\r\nfor (int i = 0; i < array.length; i += 2)\r\n{\r\n\tresult[count] = array[i];\r\n\t\r\n\tcount++;\r\n}\r\n```\r\n\r\n요소를 하나한 탐색하여 그 중 짝수인 인덱스를 판별하는 것이 아니라, 애초에 짝수 인덱스만을 탐색하여 삽입한다. 즉, 탐색의 작업이 50% 감소했다.\r\n\r\n* 탐색: $N / 2$개\r\n* 삽입: $N / 2$개\r\n\r\n이 알고리즘은 정직하게 $O(N)$의 시간 복잡도를 가진다. 엄밀히 따지면 아래의 알고리즘이 더 우수한 성능을 가지지만, 시간 복잡도의 관점에서는 둘 다 동일하다.\r\n\r\n같은 시간 복잡도를 가진다고 해도, 데이터의 양이 무수히 많을 경우 아래의 알고리즘이 더 적합할 것이다.\r\n\r\n# 마무리\r\n\r\n이 장에서 주로 얘기한 내용은 아래와 같다.\r\n\r\n* 빅 오 표기법은 비관적인 관점을 가지므로 시간 복잡도의 상수를 무시한다.\r\n* 시간 복잡도가 같아도, 실제 성능은 유의미하게 차이날 수 있다.\r\n\r\n간혹 여러 사람을 만나다보면 인생을 항상 부정적인 관점으로 바라보는 사람이 더러 있다. 아마 빅 오 표기법이 의인화된다면 이런 사람이 되지 않을까 싶다.\r\n\r\n부정적으로 보는 것이 좋을 때도 있겠지만, **언제나**라는 말이 통용되진 않는다. 세상엔 수 많은 관점이 존재하고, 이는 알고리즘도 예외는 아니다. 다행히, 현실에서 대부분의 일은 평범의 범주 안에서 일어난다.\r\n\r\n다음 장에서는 부정적인 관점에서 벗어나, 평균적인 관점으로 바라보는 시간을 가져보자.","url":["2021-07-23-about-algorithm-chapter05","2021","07","23","about-algorithm-chapter05"]},{"header":{"title":"빅 오로 코드 속도 올리기","excerpt":"이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-16T21:39:54","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","버블 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-16-about-algorithm-chapter04.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 4장 빅 오로 코드 속도 올리기\r\n\r\n이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.\r\n\r\n## 4-1 버블 정렬\r\n\r\n배열을 효과적으로 다루기 위해 <span class=\"primary\">정렬</span> 기법이 폭넓게 이용된다. <span class=\"orange-A400\">이진 검색</span>에서도 겪었듯이, 정렬된 배열은 배열의 요소를 어느정도 **예측**할 수 있도록 규칙성을 부여한다. 이러한 이유로 배열을 정렬하는 다양한 기법이 고안되었으며, 이 문단에서는 정렬 중 가장 기본적이면서 상대적으로 비효율적인 <span class=\"orange-A400\">버블 정렬</span>에 대해 알아본다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947608-e434441d-f735-44d6-8634-32431c152333.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같은 배열이 존재할 때, 버블 정렬은 이를 어떻게 오름차순으로 정렬하는 지 알아보자.\r\n\r\n1. 우선 맨 첫 요소와 그 다음 요소를 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\" />\r\n</p>\r\n\r\n2. 앞의 요소가 뒤의 요소보다 클 경우 서로 교환(swap)한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\" />\r\n</p>\r\n\r\n3. 각각 한 칸씩 이동하여 다음 요소를 비교한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\" />\r\n</p>\r\n\r\n4. 1 ~ 3의 과정을 반복한다.\r\n\r\n더 이상 교환이 이루어지지 않을 때까지 1 ~ 3의 과정을 반복한다. 이러한 반복을 <span class=\"primary\">패스스루(passthrough)</span>라 명칭한다.\r\n\r\n## 4-2. 버블 정렬 실제로 해보기\r\n\r\n이전 문단에서 <span class=\"orange-A400\">버블 정렬</span>의 원리를 알았으니 실제로 적용하여 배열을 완전히 정렬해보자.\r\n\r\n대상 배열은 이전 문단에서 사용된 배열과 동일하다.\r\n\r\n1. 패스스루 1: 8과 4 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 4를 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\" />\r\n</p>\r\n\r\n2. 패스스루 1: 8과 6 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 6을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947635-b30df0e3-2b2b-4bee-b727-8bf070c82c73.png\" width=\"600px\" />\r\n</p>\r\n\r\n3. 패스스루 1: 8과 7 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947646-ce35e2d1-0428-4e84-b8da-c2b17a13485c.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 7을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947652-f53b26ef-f291-4c64-9719-e4886aff91b6.png\" width=\"600px\" />\r\n</p>\r\n\r\n4. 패스스루 1: 8과 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947657-a374227c-855e-4b88-aba0-a8eb9ee881ca.png\" width=\"600px\" />\r\n</p>\r\n\r\n8과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947666-5574d74d-9d9a-4ff3-b145-9e9b341df0c3.png\" width=\"600px\" />\r\n</p>\r\n\r\n가장 마지막 배열의 요소까지 도달했으므로, 가장 마지막 요소인 8은 올바른 위치에 정렬되어 있다. 오름차순에서 배열의 가장 마지막 요소에는 가장 큰 값이 와야하므로, 배열의 요소 중 가장 큰 값인 8이 오는 것이 적절하다.\r\n\r\n이미 정렬되어있으므로, 다음 패스스루에선 마지막 요소는 비교하지 않아도 된다. 즉, <span class=\"teal-400\">패스스루가 진행될 수록 비교할 요소의 범위가 작아진다.</span>\r\n\r\n정렬이 완료된 요소는 <span class=\"yellow-400\">노란색</span>으로 표시한다.\r\n\r\n5. 패스스루 2: 4와 6 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947681-5b8ec91b-9da1-41da-9906-6d9e99c4fdd8.png\" width=\"600px\" />\r\n</p>\r\n\r\n4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n6. 패스스루 2: 6과 7 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947698-af6eae59-b9e5-4075-a7e5-e433c8888a6b.png\" width=\"600px\" />\r\n</p>\r\n\r\n6과 7을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n7. 패스스루 2: 7과 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947709-19eefa54-e834-41cc-9ba2-f57d23424e9c.png\" width=\"600px\" />\r\n</p>\r\n\r\n7과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947720-2fca7b88-3f84-422b-af78-77e57779270f.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소 7이 완전히 정렬됐다. 다음 패스스루를 시작한다.\r\n\r\n8. 패스스루 3: 4와 6 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947722-d73f88f3-3c12-4c19-9c85-0feb6bd4b3a9.png\" width=\"600px\" />\r\n</p>\r\n\r\n4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n9. 패스스루 3: 6과 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947729-b420b29e-3c9b-42c2-8fe2-88d509da6b91.png\" width=\"600px\" />\r\n</p>\r\n\r\n6과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947744-2d71db3b-e35b-457f-ba35-84d05e2a6088.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소 6이 완전히 정렬됐다. 다음 패스스루를 시작한다.\r\n\r\n10. 패스스루 4: 4와 3 비교\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947755-4833cd65-a86e-48c7-8413-d5e8df9c624c.png\" width=\"600px\" />\r\n</p>\r\n\r\n4와 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947767-d8163c94-8fbc-43ec-9b17-5567b9714eb5.png\" width=\"600px\" />\r\n</p>\r\n\r\n가장 마지막 패스스루이므로, 모든 요소가 정렬됐다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947774-a376dc47-0102-4ff1-8b08-d65cb8175cf0.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬된 배열은 위와 같으며, 총 10번의 작업이 이루어졌다.\r\n\r\n## 4-3. 버블 정렬 구현\r\n\r\n<span class=\"orange-A400\">버블 정렬</span>을 직접 코드로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 버블 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/\">빅 오로 코드 속도 올리기</a>\r\n * @since 2021.07.16 Fri 19:11:19\r\n */\r\npublic class BubbleSort\r\n{\r\n\t// 배열\r\n\tprivate static int[] array;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"버블 정렬할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tarray = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] count = bubbleSort();\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(count[0]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 스왑 작업량: \");\r\n\t\twriter.write(String.valueOf(count[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(count[0] + count[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 버블 정렬 및 작업량 반환 함수\r\n\t *\r\n\t * @return [int[]] 비교 작업량과 스왑 작업량\r\n\t */\r\n\tprivate static int[] bubbleSort()\r\n\t{\r\n\t\t// 비교 작업량\r\n\t\tint compareCount = 0;\r\n\t\t\r\n\t\t// 스왑 작업량\r\n\t\tint swapCount = 0;\r\n\t\t\r\n\t\t// 스왑 여부\r\n\t\tboolean isSwaped = true;\r\n\t\t\r\n\t\t// 비교 인덱스\r\n\t\tint index = array.length - 1;\r\n\t\t\r\n\t\t// 스왑이 일어나지 않을 때까지\r\n\t\twhile (isSwaped)\r\n\t\t{\r\n\t\t\tisSwaped = false;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < index; i++)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소가 다음 요소보다 클 경우\r\n\t\t\t\tif (array[i] > array[i + 1])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 스왑 발생\r\n\t\t\t\t\tisSwaped = true;\r\n\t\t\t\t\tswapCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint temp = array[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[i] = array[i + 1];\r\n\t\t\t\t\tarray[i + 1] = temp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tindex--;\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { compareCount, swapCount };\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 사용자로부터 공백으로 구분된 숫자를 입력받아 버블 정렬을 수행하는 알고리즘이다.\r\n\r\n* 입력\r\n\r\n``` tc\r\n5 4 12 6 77 32 1 9 11 59\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 4, 5, 6, 9, 11, 12, 32, 59, 77]\r\n\r\n - 읽기 작업량: 42\r\n - 스왑 작업량: 16\r\n - 총 작업량: 58\r\n```\r\n\r\n실제 버블 정렬이 수행되는 알고리즘은 아래와 같다.\r\n\r\n``` java\r\n/**\r\n * 버블 정렬 및 작업량 반환 함수\r\n *\r\n * @return [int[]] 비교 작업량과 스왑 작업량\r\n */\r\nprivate static int[] bubbleSort()\r\n{\r\n\t// 비교 작업량\r\n\tint compareCount = 0;\r\n\t\r\n\t// 스왑 작업량\r\n\tint swapCount = 0;\r\n\t\r\n\t// 스왑 여부\r\n\tboolean isSwaped = true;\r\n\t\r\n\t// 비교 인덱스\r\n\tint index = array.length - 1;\r\n\t\r\n\t// 스왑이 일어나지 않을 때까지\r\n\twhile (isSwaped)\r\n\t{\r\n\t\tisSwaped = false;\r\n\t\t\r\n\t\tfor (int i = 0; i < index; i++)\r\n\t\t{\r\n\t\t\tcompareCount++;\r\n\t\t\t\r\n\t\t\t// 현재 요소가 다음 요소보다 클 경우\r\n\t\t\tif (array[i] > array[i + 1])\r\n\t\t\t{\r\n\t\t\t\t// 스왑 발생\r\n\t\t\t\tisSwaped = true;\r\n\t\t\t\tswapCount++;\r\n\t\t\t\t\r\n\t\t\t\tint temp = array[i];\r\n\t\t\t\t\r\n\t\t\t\tarray[i] = array[i + 1];\r\n\t\t\t\tarray[i + 1] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tindex--;\r\n\t}\r\n\t\r\n\treturn new int[] { compareCount, swapCount };\r\n}\r\n```\r\n\r\n* `compareCount`: 비겨 작업량 카운트\r\n* `swapCount`: 스왑 작업량 카운트\r\n* `isSwaped`: 스왑 여부\r\n* `index`: 정렬 인덱스\r\n\r\n`index`는 정렬을 하기위한 배열의 최대 인덱스다. 1을 빼주는 이유는 버블 정렬의 특성 때문이다. $[0, 1, 2]$와 같은 배열의 최대 인덱스는 3이다. 배열의 최대 인덱스가 3일 때 첫 패스스루의 작업 갯수는 0과 1, 1과 2로 2번 일어난다. 최대 인덱스를 하나 빼주지 않으면 0과 1, 1과 2, 2와 무엇인가를 비교하려 하기 때문에 배열 초과 예외인 `ArrayIndexOutOfBoundsException`가 발생한다.\r\n\r\n`while`문을 통해 스왑이 일어나지 않을 때까지 반복한다. <span class=\"pink-A400\">패스스루 내에서 스왑이 한 번도 일어나지 않으면 정렬이 완료</span>된 것으로 간주하여 종료한다.\r\n\r\n`for`문을 통해 인덱스 크기까지 비교하여 현재 배열보다 다음 배열이 더 클 경우 스왑한다. 이 과정에서 `isSwaped`이 `true`로 할당된다. `isSwaped`가 `true`이므로 다음 프로세스가 패스스루가 진행될 것이다.\r\n\r\n해당하는 각 과정은 카운팅된다.\r\n\r\n## 4-4. 버블 정렬의 효율성\r\n\r\n버블 정렬은 두 가지 작업으로 이루어진다.\r\n\r\n* **비교**: 더 큰 수를 찾기위해 비교한다.\r\n* **교환**: 정렬하기 위해 스왑한다.\r\n\r\n요소 5개가 있을 때, 아래와 같은 <span class=\"blue-400\">비교</span>작업이 이루어진다.\r\n\r\n* 패스스루 1: 총 4번의 비교\r\n* 패스스루 2: 총 3번의 비교\r\n* 패스스루 3: 총 2번의 비교\r\n* 패스스루 4: 총 1번의 비교\r\n* 패스스루 5: 비교 없음 (정렬 완료)\r\n\r\n즉, 4 + 3 + 2 + 1로 총 10번의 비교가 일어난다.\r\n\r\n그렇다면 <span class=\"blue-400\">스왑</span>작업은 어떨까? 스왑은 상황에 따라 일어날 수도, 일어나지 않을 수도 있다.\r\n\r\n이전 장에서 <span class=\"red-400\">알고리즘은 언제나 비관적인 관점</span>으로 접근한다고 했으니, 스왑이 언제나 일어날 경우를 가정하자.\r\n\r\n> 가장 최악의 버블 정렬 케이스  \r\n> 버블 정렬은 하나의 요소와 다음 요소를 비교하여 정렬하는 알고리즘이다. 만약 오름차순으로 정렬할 경우, 내림차순으로 정렬된 배열을 입력할 때 가장 최악의 케이스가 된다. 이 경우 모든 요소에 비교와 스왑이 일어난다.\r\n\r\n최악의 케이스인 내림차순으로 정렬된 요소 5개가 있을 때, 아래와 같은 <span class=\"blue-400\">스왑</span>작업이 이루어진다.\r\n\r\n* 패스스루 1: 총 4번의 스왑\r\n* 패스스루 2: 총 3번의 스왑\r\n* 패스스루 3: 총 2번의 스왑\r\n* 패스스루 4: 총 1번의 스왑\r\n* 패스스루 5: 스왑 없음 (정렬 완료)\r\n\r\n비교와 동일한 작업량이 발생한다. 이를 표로 정리하면 아래와 같다.\r\n\r\n|  $N$  | 작업 수 | $N^2$ |\r\n| :---: | :-----: | :---: |\r\n|   5   |   20    |  25   |\r\n|  10   |   90    |  100  |\r\n|  20   |   380   |  400  |\r\n|  40   |  1560   | 1600  |\r\n|  80   |  6320   | 6400  |\r\n|  100  |  9900   | 10000 |\r\n\r\n요소 $N$개 배열에서 버블 정렬의 최대 작업량은 $N(N - 1)$이다. 이전 장에서도 언급했 듯이, 알고리즘은 $O(N^2)$와 $O(N^2 - N)$과 크게 차이를 두지 않는다. 즉, 버블 정렬의 시간 복잡도는 $O(N^2)$가 된다.\r\n\r\n$O(N^2)$은 $O(N)$ 보다도 작업량이 급격히 증가한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947786-fb410c06-799f-4041-8827-9a946a8d076e.png\" width=\"600px\" />\r\n</p>\r\n\r\n이를 비교하면 더욱 한눈에 알 수 있다. 이 $O(N^2)$을 <span class=\"orange-A400\">이차 시간</span>이라고 명칭한다.\r\n\r\n## 4-5. 이차 문제\r\n\r\n위에서 버블 정렬에 대한 알고리즘을 설계했다. 시간 복잡도는 무려 $O(N^2)$을 가진다. 이전 장에서 선형 검색과 이진 검색을 비교하며 최대한 시간 복잡도를 줄이는게 좋다고 손아프게 적은게 무색할 정도로, 이 알고리즘의 효율은 지면을 뜷고 추락하고있다.\r\n\r\n여기 비슷한 이차 시간 알고리즘이 있다. 입력한 요소의 중복 여부를 판별하는 알고리즘이다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 중복 확인 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/\">빅 오로 코드 속도 올리기</a>\r\n * @since 2021.07.16 Fri 20:46:15\r\n */\r\npublic class DuplicateCheck\r\n{\r\n\tprivate static int count = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tboolean result = isDuplicated(array);\r\n\t\t\r\n\t\t// 중복된 요소가 있을 경우\r\n\t\tif (result)\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재합니다.\");\r\n\t\t}\r\n\t\t\r\n\t\t// 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재하지 않습니다.\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\"작업량: \");\r\n\t\twriter.write(String.valueOf(count));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소의 중복 여부 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t *\r\n\t * @return [boolean] 중복 여부\r\n\t */\r\n\tprivate static boolean isDuplicated(int[] array)\r\n\t{\r\n\t\tfor (int i = 0; i < array.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < array.length; j++)\r\n\t\t\t{\r\n\t\t\t\tcount++;\r\n\t\t\t\t\r\n\t\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\t\tif (i != j && array[i] == array[j])\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력\r\n\r\n``` java\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` java\r\n중복된 요소가 존재하지 않습니다.\r\n작업량: 100\r\n```\r\n\r\n위 알고리즘도 마찬가지로 $N = 10$일 때 최악의 경우 $O(N^2)$의 시간 복잡도를 가진다.\r\n\r\n중복을 판별하는 핵심 동작을 보자.\r\n\r\n``` java\r\n/**\r\n * 요소의 중복 여부 반환 함수\r\n *\r\n * @param array: [int[]] 배열\r\n *\r\n * @return [boolean] 중복 여부\r\n */\r\nprivate static boolean isDuplicated(int[] array)\r\n{\r\n\tfor (int i = 0; i < array.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < array.length; j++)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\tif (i != j && array[i] == array[j])\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n버블 정렬과 마찬가지로 중첩 반복문이 존재한다. 중첩 반복문이 있을 경우, 반복문의 갯수만큼 시간 복잡도가 급격히 올라간다.\r\n\r\n중첩 반복문은 $N$개의 요소를 $N$번 만큼 작업한다. 반복문의 중첩이 심해지면 심해질 수록 $N$번의 $N$번의 $N$번의... 와 같은 작업을 반복할 것이다. 물론 시간 복잡도의 크기가 하늘 높은줄 모르고 치솟는 것도 포함된다.\r\n\r\n즉, 어디가서 중첩 반복문을 사용하는 알고리즘을 봤다면 그 알고리즘의 시간 복잡도는 최소 $O(N^2)$임을 바로 유추할 수 있다.\r\n\r\n## 4-6. 선형 해결법\r\n\r\n이전 장에서, 선형 검색과 이진 검색의 시간복잡도를 비교하며 $O(N)$이 $O(\\log N)$보다 얼마나 비효율적인지 손가락이 아플 정도로 설명했던 걸로 기억한다. 그런데 방금의 두 알고리즘은 아픈 손가락이 무색해질 정도로 미칠듯한 비효율을 선사하고 있다.\r\n\r\n<i align=\"center\">아니, 니가 알고리즘을 많이 안 짜봐서 그런가본데, 그렇게 설계할 수 밖에 없는 알고리즘도 있거든??</i>\r\n\r\n물론 맞는 말이다. 백준만 해도 로직이 복잡해서 중첩 반복문을 사용하기도 한다. 실무에서도 마찬가지다. 로직이 복잡하거나, 소스 최적화의 비용이 너무 높거나 혹은 효율이 극악이거나. 아니면 컴퓨터 성능이 충분히 좋아서 굳이 그렇게 머리 아픈일에 투자할 필요를 못 느낄 수도 있다.\r\n\r\n여담으로, 실제로 큰 기업은 이런 최적화 보다도 컴퓨팅 성능을 극대화시키는 방법을 많이 선택한다고 한다. 로직이야 어차피 한정적으로 적용되고, 차라리 컴퓨터 성능을 올리는게 오히려 싸게 먹히기도 한다. 로직과 달리 컴퓨팅 자원은 다른 곳에 써먹을 수도 있으니 이쪽이 더 범용적이다.\r\n\r\n필자의 컴퓨터도 작성일 기준으로 그리 못난 편은 아니지만, 안타깝게도 위에 작성한 중복 판별 알고리즘은 최적화의 비용이 매우 저렴한 편이다. 우리는 공부를 목적으로 하니 한 번 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 중복 확인 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/\">빅 오로 코드 속도 올리기</a>\r\n * @since 2021.07.16 Fri 21:18:05\r\n */\r\npublic class ImproveDuplicateCheck\r\n{\r\n\tprivate static int count = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tboolean result = isDuplicated(array);\r\n\t\t\r\n\t\t// 중복된 요소가 있을 경우\r\n\t\tif (result)\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재합니다.\");\r\n\t\t}\r\n\t\t\r\n\t\t// 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재하지 않습니다.\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\"작업량: \");\r\n\t\twriter.write(String.valueOf(count));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소의 중복 여부 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t *\r\n\t * @return [boolean] 중복 여부\r\n\t */\r\n\tprivate static boolean isDuplicated(int[] array)\r\n\t{\r\n\t\tArrayList<Integer> list = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int item : array)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 중복되지 않았을 경우\r\n\t\t\tif (!list.contains(item))\r\n\t\t\t{\r\n\t\t\t\tlist.add(item);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 중복된 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력\r\n\r\n``` java\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` java\r\n중복된 요소가 존재하지 않습니다.\r\n작업량: 10\r\n```\r\n\r\nJAVA의 가변 배열 `ArrayList` 클래스를 활용하여 구현했다. 요소가 한 번도 나오지 않았을 경우, `list`에 존재하지 않을 것이므로 넣어준다. 이후 동작 중에 이미 `list`에 존재하는 숫자가 발견될 경우, 중복된 요소이므로 종료하고 결과를 반환한다.\r\n\r\n$N = 10$일 때 $O(N)$의 시간 복잡도로 대폭 개선됨을 확인할 수 있다. 이전의 결과와 비교하면 무려 <span class=\"lightBlue-A400\">10배의 차이</span>로, 산술적으로 이전 알고리즘이 1번 동작할 동안 개선된 알고리즘은 10번 동작할 수 있다.\r\n\r\n지금은 $N = 10$으로 요소 자체가 작아서 체감이 되지 않을 수도 있지만, $N = 10,000$일 경우 무려 <span class=\"lightBlue-A400\">10,000배의 차이</span>가 발생한다.\r\n\r\n알고리즘의 최적화가 중요한 이유가 여기에 있다. 처리하는 데이터가 빅데이터에 가까워질수록 그 효율이 미친듯이 상승하기 때문.\r\n\r\n# 마무리\r\n\r\n이 장에서 배운 점을 정리하면 아래와 같다.\r\n\r\n* 반복문의 중첩 여부, 갯수를 통해 시간 복잡도를 유추할 수 있다.\r\n* 시간 복잡도를 통해 알고리즘의 성능 향상을 수치상으로 비교, 표시할 수 있다.\r\n\r\n사실 정리해놓고 보니 뭐 별 거 아닌, 당연한 얘기를 가지고 광활하게 설명했나 싶기도 하다. 난 이 당연한 걸 제대로 몰랐던 거고.\r\n\r\n이런 알고리즘도 있다. 속도가 비슷해서 빅 오 표기로는 그 차이가 보이지 않을 경우. 하지만 그럼에도 확실히 어떠한 요인으로든 차이가 발생할 것이다. 다음 장에서는 이러한 알고리즘에 대한 최적화에 대해 알아본다.","url":["2021-07-16-about-algorithm-chapter04","2021","07","16","about-algorithm-chapter04"]},{"header":{"title":"빅 오 표기법","excerpt":"하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 문제를 해결하는 효율성의 차이 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-14T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","빅 오 표기법"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-14-about-algorithm-chapter03.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 3장 빅 오 표기법\r\n\r\n하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 <span class=\"orange-A400\">문제를 해결하는 효율성의 차이</span> 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.\r\n\r\n이러한 알고리즘의 성능을 하나의 규칙으로 표기한 것이 <span class=\"primary\">빅 오 표기법</span>이다. 이 장에서는 알고리즘의 빅 오 표기법에 대해 설명한다.\r\n\r\n## 3-1. 빅 오: 단계 수 계산\r\n\r\n보통 알고리즘의 성능을 측정한다고 하면 소요시간을 생각하겠지만, 의외로 소요시간은 객관적인 성능 지표가 되지 못 한다. 그 이유는 컴퓨터마다 성능이 제각각이기 때문. 똑같은 게임을 구동해도 어떤 컴퓨터는 울트라옵으로 165 프레임을 뽑는다고 하면, 다른 컴퓨터는 최하옵으로도 버벅일 수 있다. <span class=\"teal-400\">동일한 작업을 수행해도 컴퓨터의 성능에 따라 그 소요시간이 천차만별</span>로 달라진다.\r\n\r\n때문에 <span class=\"green-A400\">알고리즘의 성능을 측정하는 적절한 지표는 처리 단계</span>라 할 수 있다. 이전 장의 <span class=\"primary\">읽기 연산</span>과 <span class=\"primary\">선형 검색</span>을 통해 예를 들어보자.\r\n\r\n읽기 연산의 경우, 배열이 10개가 있던 1억개가 있던 관계없이 인덱스 i의 요소를 읽는데 필요한 단계는 하나다. 반대로 선형 검색의 경우, 요소가 많아지면 많아질 수록 연산에 요구되는 단계가 늘어난다. 배열 $N$개가 있을 때, 찾는 요소가 배열 맨 끝에 있는 최악의 경우 $N$개의 단계가 필요하다.\r\n\r\n즉, 읽기 연산의 경우 언제나 한 단계만 필요하므로 $O(1)$로 표기할 수 있으머, 선형 검색의 경우 $O(N)$으로 표기할 수 있다. 이러한 표기를 <span class=\"amber-400\">시간 복잡도</span>라 한다.\r\n\r\n## 3-2. 상수 시간과 선형 시간\r\n\r\n읽기 연산처럼 요소의 갯수에 상관없이 일정한 단계만을 필요로하는 연산이 있는가 하면, 선형 검색처럼 요소의 크기에 따라 단계가 가변하는 연산도 존재한다. 이전 문단에서 언급했듯이 읽기 연산의 시간 복잡도는 $O(1)$, 선형 검색의 시간 복잡도는 $O(N)$으로 표기할 수 있다. 이를 그래프로 비교하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599099-db099ea5-e3e9-4b79-ad19-700870b07891.png\" width=\"600px\" />\r\n</p>\r\n\r\n$O(N)$의 경우 우리가 흔히 접한 1차원 그래프 $y = x$와 패턴이 동일하다. 요소의 수가 1씩 증가할 수록 단계 또한 1씩 정직하게 증가한다. 이러한 패턴을 <span class=\"primary\">선형 시간</span>이라고 표현한다. 그러나 $O(1)$의 경우 단계에 관계없이 일정한 상수 그래프 $y = 1$와 패턴이 동일하다. 이러한 패턴을 <span class=\"primary\">상수 시간</span>이라고 표현한다.\r\n\r\n$O(1)$의 경우 조금 특이한데, 아래의 모든 그래프는 $O(1)$의 시간 복잡도를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599889-72b5cbb9-ca20-4b19-9f49-6d363b8ebec5.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 수에 관계 없이 두 단계를 요구하면 $O(2)$, 100 단계를 요구하면 $O(100)$일 것 같지만, 빅 오 표기법은 단계가 일정할 경우 이를 크게 신경쓰지 않는다. 즉, 설령 단계가 1억개가 된다 하더라도 시간 복잡도는 $O(1)$이 된다.\r\n\r\n<span class=\"red-400\">상수 시간의 경우 기본적으로 선형 시간보다 효율적</span>이라고 판단한다. 그 이유는 아래 그래프와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599827-0f58c448-9ab5-44dc-9bca-80d3ffd49d64.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n깊게 생각하지 않더라도, 선형적으로 증가하는 그래프는 언젠가 상수 그래프를 넘어서게 된다. 즉, 요소가 무수히 많아지는 거시적 관점으로 보면 <span class=\"red-400\">언젠가 선형 시간의 효율이 상수 시간보다 떨어지는 시점에 도달</span>한다. 예제를 보면 요소가 10개 이상일 경우 선형 시간의 효율성이 점점 떨어진다.\r\n\r\n그런데 선형 시간의 경우를 생각해보자. 분명히 단계가 최대 $N$개가 소요될 수 있다는 뜻이지, 항상 $N$개가 소요된다는 것은 아니다. 예를 들어, 1부터 오름차순으로 정렬된 1억개의 배열에서 5를 검색한다고 가정하면, 필요한 단계는 5밖에 안 된다. 그럼에도 책에서는 선형 시간보다 상수 시간이 비교적 효율적이라고 설명하고 있다. 그 이유는 뭘까? 다음 문단에서 그 해답을 찾을 수 있다.\r\n\r\n## 3-3. 같은 알고리즘, 다른 시나리오\r\n\r\n선형 검색은 검색하려는 요소의 위치에 따라서 생각보다 많은 시간이 소요되지 않을 수도 있다. 최선의 경우 요소가 맨 앞에 있으므로 단계가 하나만 필요하여 $O(1)$과 동일한 시간 복잡도를 가질 수도 있다. 그러나 최악의 경우 요소가 맨 끝에 있으므로 온전히 $N$개의 단계가 필요하여 $O(N)$의 시간 복잡도를 가진다.\r\n\r\n통상 알고리즘이 어떤 데이터를 얼마나 많이 처리할지 미리 알 수 없다. $O(N)$의 시간 복잡도를 가지는 임의의 알고리즘에 최선의 케이스를 적용하여 처리하면 $O(1)$에 가깝게 동작할 것이고, 최악의 케이스를 적용하여 처리하면 $O(N)$에 가깝게 동작할 것이다. <span class=\"orange-A400\">알고리즘은 기본적으로 가장 비관적인 접근</span>으로 바라본다.\r\n\r\n우리가 어떤 물건을 온라인으로 주문한다고 생각해보자. 내가 원하는 물건을 여러 업체에서 동일한 가격에 팔고 있지만, 택배 도착에 걸리는 시간이 다르다. 이는 업체의 페이지에 각각 아래와 같이 써있으며, 택배 도착은 이 시간을 절대로 벗어나지 않는다고 가정하자.\r\n\r\n* A업체: 빠르면 오늘, 늦으면 일주일 뒤\r\n* B업체: 빠르면 내일, 늦으면 3일 뒤\r\n* C업체: 빠르면 3일, 늦으면 5일 뒤\r\n\r\n우리가 3일 안으로 물건을 반드시 받아야 한다면 B업체가 가장 안전할 것이다. 물론 A업체에 주문하면 오늘 당장이라도 올 가능성이 있지만, 최악의 경우 일주일을 꼬박 기다려야 받게 될 수도 있기 때문에 3일을 넘어버릴 가능성 또한 무시할 수 없다. 빠르게 오면 단순히 좋은 정도지만, 3일을 넘어서면 안 되므로 A업체 또한 적절하지 않은 것이다. C업체는 말할 필요도 없고.\r\n\r\n알고리즘도 이러한 관점과 동일하다. $N$이 최대 100인 $O(N)$ 알고리즘이 있을 때, 성능 상의 이유로 단계가 50이 넘어가면 크래쉬를 유발할 경우 이 알고리즘은 적절하지 않다. 이와 같이 최악의 상황을 알아야 장애를 대비할 수 있다. 이러한 이유로 알고리즘의 성능은 항상 최악을 기준으로 표시한다.\r\n\r\n## 3-4 세 번째 유형의 알고리즘\r\n\r\n물론 시간 복잡도가 $O(1)$, $O(N)$만 있는 것은 아니다. 우리가 2장에서 다뤘던 이진 검색의 경우, 요소에 따라 단계가 증가하긴 하지만 $O(N)$과 같이 선형적으로 증가하지는 않는다. 즉, $O(1)$도 아니고, $O(N)$도 아닌 그 사이의 시간 복잡도를 가진다.\r\n\r\n이진 검색의 시간 복잡도는 기본적으로 $O(\\log_2N)$을 가진다. $O(1)$, $O(\\log_2N)$, $O(N)$가 요구하는 단계를 표로 표현하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125602081-0cc6075b-ba14-43c5-8aa6-52d8561559a3.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$, $O(\\log N)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n## 로가리즘\r\n\r\n우리가 흔히 부르는 $\\log$. 즉, 로그는 로가리즘(Logarithm)의 줄임말이다. $x^n = y$가 성립할 경우, 이를 로그로 표현하면 $\\log_xy = n$과 같다.\r\n\r\n예를 들어, $3^2 = 9$가 성립한다. 이를 로그로 표현하면 $\\log_39 =  2$가 된다. 이렇게 로그를 통해 수의 제곱수를 구할 수 있다.\r\n\r\n## $O(\\log N)$의 해석\r\n\r\n위 문단에서 로그에 대해 어느정도 이해를 했으니, $O(\\log N)$에 대해 논의해보자. 통상 수학에선 $\\log_{10}x$을 간략화하여 $\\log$로 표현했지만, 빅 오 표기법에서는 $\\log_2x$의 간략화다. <span class=\"orange-A400\">현실에선 십진법이 통용</span>되지만, <span class=\"orange-A400\">컴퓨터는 이진법을 사용</span>하기 때문.\r\n\r\n$O(N)$과 $O(\\log N)$를 비교하면 아래와 같다.\r\n\r\n|    $N$    |  $O(N)$   | $O(\\log N)$ |\r\n| :-------: | :-------: | :---------: |\r\n|     2     |     2     |      1      |\r\n|     4     |     4     |      2      |\r\n|     8     |     8     |      3      |\r\n|    16     |    16     |      4      |\r\n|    32     |    32     |      5      |\r\n|    64     |    64     |      6      |\r\n|    128    |    128    |      7      |\r\n|    256    |    256    |      8      |\r\n|    512    |    512    |      9      |\r\n|   1024    |   1024    |     10      |\r\n| $2^{100}$ | $2^{100}$ |     100     |\r\n\r\n$O(N)$는 $N$이 증가함에 따라 정직하게 같이 증가하지만, $O(\\log N)$은 $N$이 정확히 두 배가 될 때 1씩 증가한다.\r\n\r\n여담으로, 천문학같은 거시세계에서 로그가 중요한 이유가 위 표만으로도 쉽게 확인할 수 있다. $2^{100}$은 126,7650,6002,2822,9401,4967,0320,5376이다. 약 100양에 육박하는 수치로, 양은 수의 단위인 조를 아득히 뛰어넘는 단위다.\r\n\r\n> 거시적 수의 단위  \r\n> 일반적으로 사람이 접할 수 있는 의미 있는 단위는 조 단위로, 1억씩 천 번을 모아야 만들어지는 수치다.  \r\n> 조 단위 뒤로는 경, 해, 자, 양 순으로 나열되며, 현실에서 경 이후로는 그 수의 크기를 논하는게 의미가 없는 정도\r\n\r\n현실세계와 달리 수학이나 천문학과 같은 경우 우리에게 의미가 없을 정도로 큰 수를 다루기도 하는데, 이를 로그로 표현하면 이를 효과적으로 다룰 수 있다.\r\n\r\n## 3-7. 실제 예제\r\n\r\n지금까지 기술한 내용을 토대로 실제 코드에 적용해보자. 4개의 요소를 가진 배열이 있고, 배열의 값을 하나씩 출력하는 알고리즘이 있다고 가정해보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:40:00\r\n */\r\npublic class BigO\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열\r\n\t\tString[] things = { \"apples\", \"baboons\", \"cribs\", \"delcimers\" };\r\n\t\t\r\n\t\t// 배열마다 하나씩 순회\r\n\t\tfor (String thing : things)\r\n\t\t{\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(\"Here's a thing: \");\r\n\t\t\tbuilder.append(thing);\r\n\t\t\t\r\n\t\t\twriter.write(builder.toString());\r\n\t\t\twriter.newLine();\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHere's a thing: apples\r\nHere's a thing: baboons\r\nHere's a thing: cribs\r\nHere's a thing: delcimers\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n요소마다 하나씩 읽어 요소의 내용을 출력한다. 즉, <span class=\"blue-400\">요소가 많아지면 많아질 수록 같이 선형적으로 증가</span>하므로, 이 알고리즘의 시간 복잡도는 $O(N)$으로 표현할 수 있다.\r\n\r\n반대로 가장 기본적인 문자열 하나를 출력하는 알고리즘을 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:56:49\r\n */\r\npublic class BigO2\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"Hello world!\");\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHello world!\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n알고리즘이라 부르기는 조금 뭐하지만, 어쨌든 이 알고리즘을 수행하는 데 <span class=\"blue-400\">필요한 단계는 무조건 하나</span>다. 즉 시간 복잡도는 $O(1)$이다.\r\n\r\n좀 더 실속있는 예제를 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 소수 판별 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 18:01:20\r\n */\r\npublic class CheckPrime\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"소수를 판별할 값 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 입력값\r\n\t\tint target = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 소수일 경우\r\n\t\tif (isPrime(target))\r\n\t\t{\r\n\t\t\twriter.write(\"소수로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"소수가 아닌 것으로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 함수\r\n\t *\r\n\t * @param num: [int] 대상 값\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate static boolean isPrime(int num)\r\n\t{\r\n\t\tfor (int i = 2; i < num; i++)\r\n\t\t{\r\n\t\t\t// 나누어 떨어지는 수가 있을 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력값\r\n\r\n``` tc\r\n156842101\r\n```\r\n\r\n* 출력값\r\n\r\n``` tc\r\n소수가 아닌 것으로 판별됨\r\n```\r\n\r\n이 소스는 임의의 값을 입력받아 소수인지 아닌지를 판별하는 알고리즘이다. 이 알고리즘을 통해 156842101은 소수가 아님을 쉽게 알 수 있다.\r\n\r\n해당 알고리즘은 가장 작은 소수인 2부터 입력값 `target`까지 하나씩 증가시킨 값을 `target`과 나눠서 정확히 나눠떨어지는지 아닌지를 통해 소수를 판별하는 매우 기초적인 알고리즘이다.\r\n\r\n최악의 케이스는 판별값이 소수일 경우로,  2부터 `target - 1`까지의 작업 전체를 요구하므로 총 `target - 2`의 작업이 발생한다. $N = target$일 때, -2는 그렇게 의미있는 값이 아니므로 위 알고리즘의 시간 복잡도는 $O(N)$으로 봐도 무방하다.\r\n\r\n# 마무리\r\n\r\n알고리즘을 정석적으로 공부하지 않아서, 빅 오 표기법과 같은 시간 복잡도를 제대로 이해하지 않았었다. 시간 복잡도의 개념과 그 계산 방식을 알 수 있었던 매우 의미있는 장이였다.\r\n\r\n다음 장에선 이 빅 오 표기법을 활용하여 알고리즘을 개선하는 방법에 대해 설명한다.","url":["2021-07-14-about-algorithm-chapter03","2021","07","14","about-algorithm-chapter03"]},{"header":{"title":"알고리즘이 중요한 까닭","excerpt":"IT영역에서의 알고리즘이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. 개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구된다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열","정렬","이진 검색"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-10-about-algorithm-chapter02.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 2장 알고리즘이 중요한 까닭\r\n\r\nIT영역에서의 <span class=\"primary\">알고리즘</span>이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. <span class=\"teal-400\">개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구</span>된다.\r\n\r\n이러한 특징으로 알고리즘은 뛰어난 문제 해결력과 수학적 사고 능력을 요한다. 때문에 많은 사람들이 어려워하는 분야 중 하나지만, 그 강력함과 효율로 인해 개발 역량의 척도를 확인하는데 사용하기도 한다. 흔히 기업에서 보는 <span class=\"teal-400\">코딩 테스트</span>가 좋은 예시다.\r\n\r\n이 장에서는 <span class=\"primary\">알고리즘</span>을 통해 검색 연산을 더욱 효과적으로 개선하는 방법에 대해 설명한다. 이전 장에서 언급했듯이, 검색 연산은 무수히 많은 읽기 연산의 모음이나 다름없다. 알고리즘이 어떻게 읽기 연산을 최적화시키는지 알아보자.\r\n\r\n## 2-1. 정렬된 배열\r\n\r\n<span class=\"primary\">정렬된 배열</span>이란, 기존의 배열에서 요소들이 특정 조건으로 정렬된 배열을 의미한다. 정렬된 배열은 그 요소들이 항상 정해진 조건에 따라 순서대로 배치된다. 이는 삽입을 할 때도 동일하다. 정렬된 배열이 항상 정렬된 상태를 유지하기 위해선 <span class=\"red-A400\">삽입 시에도 요소의 정렬에 따라 정렬을 훼손하지 않는 올바른 자리에 삽입</span>되어야 한다.\r\n\r\n기존의 배열이라면 배열의 크기가 허락하는 한, 원하는 위치 어디에서나 삽입이 가능하다. 배열에 55를 삽입할 때, 일반적인 배열은 아래처럼 삽입에 제한이 없다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144062-a3b6c280-e157-11eb-88d6-20689d8f05b1.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 정렬된 배열이라면 어떨까? 이번엔 배열이 오름차순으로 정렬된 배열이라고 가정해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144070-aa453a00-e157-11eb-9390-1550623a57bd.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬된 위 배열에서 55를 삽입한다면 어떨까?\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144072-aca79400-e157-11eb-8939-cc0beb583b9b.png\" width=\"600px\" />\r\n</p>\r\n\r\n반드시 44와 94의 사이에 삽입되어야 오름차순 정렬을 유지할 수 있다. 그렇다면 우리는 여기서 정렬된 배열의 삽입은 기존의 삽입 연산에 비해 로직이 추가됨을 유추할 수 있다. 원리는 간단하다. 요소를 순차적으로 읽어서 55보다 큰 수가 나올 때까지 반복한다. 배열이 정렬되어 있으므로, 55보다 큰 수를 만나게 되면 이전의 요소는 모두 55보다 작을 것이다. 이 위치를 기준으로 삽입을 진행하면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144075-ae715780-e157-11eb-92ed-71ee06140c5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 그림과 같이 순차적으로 요소를 검색하여 55보다 큰 요소를 찾는다. 94는 배열에서 55보다 큰 가장 작은 수다.\r\n\r\n94의 인덱스인 4번째 요소에 55를 삽입하고, 94를 한 칸 뒤로 미룬다. 이 과정을 통해 정렬된 배열의 연산을 수행할 수 있다.\r\n\r\n그렇다면 이 고생을 뭐하러 사서하는 것일까? 그 이유는 검색의 최적화에 있다. <span class=\"orange-A400\">정렬된 배열은 그 자체로 순서라는 규칙성을 지니기 때문에 이를 활용한 알고리즘 적용이 가능</span>하기 때문이다. 이를 통해 검색의 작업량을 효과적으로 줄여 더욱 빠른 검색이 가능하다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 정렬된 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 02:41:14\r\n */\r\npublic class SortedArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 9, 14, 43, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tint result = run(item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(result);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 및 삽입된 인덱스 반환 함수\r\n\t *\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [int] 삽입된 인덱스\r\n\t */\r\n\tprivate static int run(int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\tinsert(result, item);\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자보다 배열의 값이 클 경우\r\n\t\t\tif (target < ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 인덱스에 55 삽입: [6, 9, 14, 43, 55, 94, -1, -1, -1, -1]\r\n```\r\n\r\n`insert` 함수는 이전 장에 나왔던 함수와 동일하지만, `find`의 경우 조금 달라졌다. `target == ARRAY[i]`로 동일한 값을 찾는 것이 아니라, `target < ARRAY[i]`로 삽입할 요소보다 큰 값을 찾도록 변경됐다. `run` 함수는 이를 적절히 구동하여 삽입된 인덱스를 반환한다.\r\n\r\n> **JAVA의 정렬 함수**  \r\n> 자바는 `Arrays.sort()`라는 함수가 제공되며, 인수로 정렬할 배열을 전달한다. 기본적으로 오름차순으로 정렬되며, 본인이 직접 정렬 함수를 오버라이딩함으로써 자신만의 조건으로 정렬되도록 설계할 수도 있다.\r\n\r\n## 2-3. 이진 검색\r\n\r\n우리가 앞에서 배열을 정렬한 이유가 바로 이 것이다. <span class=\"primary\">이진 검색</span>이라는 알고리즘을 적용하면 검색의 속도를 상당부분 개선할 수 있다. 심지어 이진 검색은 알고리즘 축에서는 매우 쉬운 편에 속한다. 심지어 우리는 이미 다른 형태로 이진 검색이라는 알고리즘을 접한 적이 있다.\r\n\r\n어렸을 때나, 혹은 술자리에서 Up & Down이라는 게임을 해본적이 있을 것이다. 진행자가 임의의 구간에 해당하는 임의의 수 하나를 머릿속으로 생각하면, 참가자들이 이 수를 맞추는 것이다. 참가자가 수를 말하면 진행자는 그 수가 자신의 수보다 큰 지, 작은 지 알려준다. 이걸 누군가 맞출 때까지 반복한다. 이진 검색의 원리는 이와 정확히 일치한다.\r\n\r\n<span class=\"red-A400\">이진 검색은 그 특성 상 정렬된 배열에서만 가능</span>하다. 1 ~ 100의 구간으로 순차적으로 정렬된 배열이 있다고 가정해보자. 찾아야 할 수가 68일 때, 이진 검색은 아래와 같이 이루어진다.\r\n\r\n1. 1과 100의 중간인 50과 비교한다. (작업 +1)\r\n2. 50은 68보다 작으로 51 ~ 100의 구간을 검색한다.\r\n3. 51과 100의 중간인 75와 비교한다. (작업 +1)\r\n4. 75는 68보다 크므로 51 ~ 74의 구간을 검색한다.\r\n5. 51과 74의 중간인 62와 비교한다. (작업 +1)\r\n6. 62는 68보다 작으므로 63 ~ 74의 구간을 검색한다.\r\n7. 63과 74의 중간인 68과 비교한다. (작업 +1)\r\n8. 검색이 종료된다.\r\n\r\n만약 순차적으로 검색했다면 1 부터 68까지 총 68번의 작업이 발생할 것을 단 4번의 작업으로 검색을 완료했다. 간단한 알고리즘을 적용하는 것으로도 작업량이 17배 줄어든 것이다. 지금은 구간이 작지만, 구간의 끝이 만 단위가 넘어간다면 검색하려는 숫자의 위치에 따라 작업량이 기하급수적으로 감소한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색을 구현한 소스는 위와 같다. 눈여겨 볼 부분은 `binarySearch` 함수다. 시작값 `start`는 1로 초기화되고, 끝값 `max`는 배열의 크기와 동일하다.\r\n\r\n`mid`를 계산하여 `target`과 크기비교를 한다. `target`이 더 클 경우, 중간값을 기준으로 윗 구간이므로 `start`를 `mid + 1`로 보정한다. 반대로 `target`이 더 작을 경우, 중간값을 기준으로 아랫 구간이므로 `end`를 `mid - 1`로 보정한다. 검색 대상값인 `target`과 중간값 `mid`가 동일할 때까지 알고리즘을 반복한다.\r\n\r\n1 ~ 100까지 차례대로 배치되어 있으므로, 1은 `ARRAY[0]`, 43은 `ARRAY[42]`로 값 자체로 인덱스나 다름없기 때문에 인덱스는 따로 구하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색의 단점이 있는데, 1 ~ 100의 구간이 있다고 가정하면, 1이나 100과 같은 <span class=\"orange-A400\">구간의 시작과 끝을 검색하는데 시간이 매우 오래 걸린다.</span> 이는 이진 검색이 중간값을 기준으로 검색한다는 특징으로 인한 단점이다. 위의 소스는 구간의 시작과 끝도 비교함으로써 이진 검색을 강화한 소스다.\r\n\r\n``` java\r\n// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\nif (target == start || target == end)\r\n{\r\n\tbreak;\r\n}\r\n```\r\n\r\n눈여겨 볼 부분은 `binarySearch` 함수의 해당 부분이다. 기존에 없던 `start`와 `end`의 비교 로직이 추가되어, <span class=\"orange-A400\">구간의 시작과 끝이 목표일 경우 더욱 빠르게 검색</span>할 수 있도록 보정한 것이다.\r\n\r\n| 구분  | 보정 전 | 보정 후 |\r\n| :---: | :-----: | :-----: |\r\n|   1   |    6    |    1    |\r\n|  51   |    6    |    2    |\r\n|  100  |    7    |    1    |\r\n\r\n## 2-4. 이진 검색 대 선형 검색\r\n\r\n1부터 순차적으로 하나하나 검색하는 알고리즘을 <span class=\"primary\">선형 검색</span>, 구간의 중간값을 기준으로 검색하는 알고리즘을 <span class=\"primary\">이진 검색</span>이라 한다. 우리가 2장까지 진행하면서, 배열의 일반적인 검색과 이진 검색에 대해 설계하고 차이점을 비교했다.\r\n\r\n선형 검색의 경우 요소의 갯수 $N$이 늘어나면 늘어날수록 예상되는 최대 작업량도 $N$개로 비례하여 늘어난다. 이에 비해 이진 검색의 경우 $N = 10,000$일 때, 책에 의하면 최대 작업량이 13이라고 한다. $N = 1,000,000$이면 작업량은 20으로, 선형 검색의 작업량이 1,000,000임을 감안하면 <span class=\"green-A400\">데이터가 많아질 수록 이진 검색으로 절약할 수 있는 기대 비용이 더욱 큼</span>을 알 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 검색 퍼포먼스 비교 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 04:21:37\r\n */\r\npublic class SearchCompare\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100000000;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 86421478;\r\n\t\t\r\n\t\tlong tic = System.nanoTime();\r\n\t\t\r\n\t\tint linearResult = find(target);\r\n\t\t\r\n\t\tlong toc1 = System.nanoTime() - tic;\r\n\t\t\r\n\t\ttic = System.nanoTime();\r\n\t\t\r\n\t\tint binaryResult = binarySearch(target);\r\n\t\t\r\n\t\tlong toc2 = System.nanoTime() - tic;\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 선형 검색 프로세스: \");\r\n\t\tbuilder.append(linearResult);\r\n\t\tbuilder.append(\"(\").append(toc1).append(\"ns)\\n\");\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 이진 검색 프로세스: \");\r\n\t\tbuilder.append(binaryResult);\r\n\t\tbuilder.append(\"(\").append(toc2).append(\"ns)\\n\\n\");\r\n\t\tbuilder.append(\"이진 검색이 약 \").append(toc1 / toc2).append(\"배 더 빠릅니다.\");\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n86421478을 탐색하는데 소요된 선형 검색 프로세스: 86421477(26936600ns)\r\n86421478을 탐색하는데 소요된 이진 검색 프로세스: 26(5100ns)\r\n\r\n이진 검색이 약 5281배 더 빠릅니다.\r\n```\r\n\r\n위 소스는 선형 검색과 이진 검색을 통합해 퍼포먼스를 비교할 수 있는 소스다. 100,000,000(1억)의 구간에서 임의의 수 `target`을 검색한다. 해당 소스에서는 86,421,478으로 지정했다.\r\n\r\n|    구분     | 선형 검색  | 이진 검색 |    차이    |\r\n| :---------: | :--------: | :-------: | :--------: |\r\n| 프로세스 수 | 86,421,477 |    26     |     -      |\r\n|  테스트 1   | $2.442ms$  |  $5.2us$  | 약 4,699배 |\r\n|  테스트 2   | $2.463ms$  |  $5.3us$  | 약 4,648배 |\r\n|  테스트 3   | $2.434ms$  |  $5.5us$  | 약 4,424배 |\r\n|  테스트 4   | $2.536ms$  |  $5.3us$  | 약 4,785배 |\r\n|  테스트 5   | $2.383ms$  |   $5us$   | 약 4,766배 |\r\n|  테스트 6   | $2.509ms$  |  $5.1us$  | 약 4,919배 |\r\n|  테스트 7   | $2.487ms$  |  $5.4us$  | 약 4,605배 |\r\n|  테스트 8   | $2.394ms$  |  $4.5us$  | 약 5,320배 |\r\n|  테스트 9   | $2.666ms$  |  $5.3us$  | 약 5,030배 |\r\n|  테스트 10  | $2.352ms$  |  $5.3us$  | 약 4,438배 |\r\n\r\n<small class=\"red-400\">※ 위 테스트는 CPU i7-10700K, RAM 32GB에서 테스트한 결과물로, 구동 환경에 따라 연산 결과가 달라질 수 있음</small>\r\n\r\n이진검색이 선형검색에 비해 약 5000배 까지도 차이가 남을 확인할 수 있다. 단위가 $ms$, $us$니까 사람 입장에선 그게 그거지만, 기계 입장에선 이진 검색으로 5000번 수행할 동안 선형 검색은 한 번 수행하는 셈이니 실로 어마어마한 차이다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 알고리즘을 적용한 이진 검색을 구현하고 이를 기존의 선형 검색과 비교함으로써 알고리즘의 강력함을 체감할 수 있었다.\r\n\r\n현업에서 일하면서 알고리즘이 강력하다는 건 알고있었지만, 이렇게 간단하게 구현해서 직접 비교해보니 역시나 알고리즘이 중요한 이유를 알 것 같다.\r\n\r\n원래 오늘같이 내일 쉬는 날이면 새벽 네 다섯시까지 공부하긴 하는데, 포스팅 때문에 풀타임으로 집중하다 보니 유난히 더 피곤하다....","url":["2021-07-10-about-algorithm-chapter02","2021","07","10","about-algorithm-chapter02"]},{"header":{"title":"자료구조가 중요한 까닭","excerpt":"혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T01:30:56","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-10-about-algorithm-chapter01.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 개요\r\n\r\n혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다.\r\n\r\n마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.\r\n\r\n비전공자가 자료구조같은 기초지식이 항상 아킬레스건이였다. 특히 백준 풀 때 뼈저리게 느끼지만. 이 스터디가 끝나면 자료구조에 대해 기초정도는 알 수 있었음 한다.\r\n\r\n언어는 가급적 <span class=\"orange-400\">JAVA</span>로 진행한다.\r\n\r\n# 1장 자료 구조가 중요한 까닭\r\n\r\n이 장에서는 배열의 기초와 그에 해당하는 연산들에 대한 내용을 소개하면서 사용자에게 배열에 관한 러프한 개념을 설명해준다.\r\n\r\n배열과 <span class=\"primary\">집합</span>이라는 개념에 대한 내용을 기술한다. 저자에 의하면 챕터가 진행될 수록 연산 성능에 대한 점진적인 비교를 한다고 하니, 알고리즘 적용에 따른 성능 향상의 차이를 확인해 볼 수 있을 것이다.\r\n\r\n## 1-1. 배열: 기초 자료 구조\r\n\r\n<span class=\"primary\">배열</span>은 거의 모든 언어에 존재하는 매우 기초적인 자료구조다.\r\n\r\nJAVA에는 `int`, `boolean`과 같은 <span class=\"green-A400\">기본형 타입(Primitive Type)</span>과 `String`, `HashMap`과 같은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>으로 구분된다.\r\n\r\n이와 같은 데이터들은 각각 단일로 사용할 수도 있지만, 다수의 데이터를 동시에 다뤄야하는 경우가 심심치않게 발생한다. 이러한 데이터들이 모여 하나의 배열이 될 수 있다.\r\n\r\n`String` 데이터가 모여 `String[]`이라는 <span class=\"primary\">문자열 배열</span>이 되며, `int` 데이터가 모여 `int[]`라는 <span class=\"primary\">정수 배열</span>이 된다.\r\n\r\nJAVA에서의 배열은 이처럼 특정한 데이터가 여러개 모인 자료 구조이며, 반드시 <span class=\"red-A400\">지정된 데이터만을 요소로 받아들일 수 있다.</span>\r\n\r\n예를 들어, `boolean`은 `true`, `false`로 이루어진 데이터 형식이다. `boolean[]`은 `boolean` 데이터가 여러개 모인 배열이며, 이렇게 선언된 배열은 `boolean`에 해당하는 `true`, `false`만 받아들일 수 있다. 즉, 1이나 \"A\"와 같은 문자열은 배열에 삽입할 수 없다.\r\n\r\n또한 <span class=\"red-A400\">배열은 고정 길이를 가진다.</span> 한 번 할당된 배열의 길이는 재할당되지 않는 이상 절대로 길이가 변경되지 않는다.\r\n\r\n> **⚠잠깐! 이건 어디까지나 JAVA 얘기에요!**  \r\n> 지금 설명하는 배열의 특징은 JAVA에 국한되는 예시다. 당장 JavaScript만 봐도, 배열에 별다른 제약이 존재하지 않는다. 길이는 필요에 따라 증축할 수 있으며, 요소에 아무 데이터 타입이나 할당 가능하다.\r\n\r\nJAVA에서 배열은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>에 해당한다.\r\n\r\n배열에서 수행 가능한 연산에는 4가지가 존재한다.\r\n\r\n* 읽기\r\n* 검색\r\n* 삽입\r\n* 삭제\r\n\r\n위 4가지 연산은 배열의 가장 기초적인 연산이다. 이 4가지 연산을 JAVA로 직접 구현하며 어떤 단계를 거치는지 확인해보자.\r\n\r\n## 1-2 읽기\r\n\r\n<span class=\"primary\">읽기</span>연산은 배열의 특정 인덱스에 어떠한 값이 있는지 읽는 연산이다.\r\n\r\n대부분 모든 언어의 런타임에서 할당되는 데이터들은 메모리에 기록된다. 많은 양의 데이터가 할당될수록 프로그램이 요구하는 메모리, 즉 RAM의 요구사항이 높아진다. 배틀그라운드나, 스타크래프트2와 같은 게임들은 많은 양의 메모리를 요구한다. 그 만큼 기록되고 처리되는 데이터의 양이 매우 방대하기 때문이다.\r\n\r\n데이터가 메모리에 할당될 때, 가용한 임의의 메모리 주소에 저장된다. 해당 메모리 주소에 원하는 값이 존재할 것이므로, 값을 호출하기 위해선 해당 값이 저장된 메모리 주소에 접근하여 값을 조회한다. JAVA를 포함한 대부분의 언어들은 이러한 과정이 개발자에게까지 노출되지 않는 내부의 영역에 존재한다. 이걸 직접 다루는 것이 C언어의 그 악명높은 포인터다.\r\n\r\nJAVA의 메모리는 JVM(Java Virtual Machine, 자바 가상머신)이 관리한다. JVM의 메모리 구조부터 시작하면 한도끝도 없이 브랜치가 뻗어나가니, 핵심만 찝어보자.\r\n\r\n위에서 언급했듯이, 배열은 참조형 타입이며, 이 참조형 타입은 JVM의 Heap 영역에서 관리한다. 메모리를 간략하게 도식화하면 아래와 같이 표현할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111131-7dc1fb80-e120-11eb-8a75-0cf615c9c020.png\" width=\"600px\" />\r\n</p>\r\n\r\n네모 한 칸에 하나의 데이터를 할당할 수 있다고 해보자. 만약 6, 43, 14, 9, 94 5개의 정수로 이루어진 정수형 배열을 메모리에 할당한다고 가정하자. JVM이 해당 배열의 크기를 메모리에 기록할 수 있는지 확인하고, 가능하다면 기록한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111294-b2ce4e00-e120-11eb-8a6e-d5fc241db0ee.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 처럼 메모리 상의 적절한 위치에 배열이 기록될 것이다. 여기서 배열의 4번째 데이터를 읽어보자.\r\n\r\n프로그램은 해당 배열의 주소를 알고있다. 자기가 직접 할당했으니 당연하다. 배열의 주소를 0x0404라고 가정하면 아래와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n0x0404에서 4번째 데이터를 호출하므로 0x0407의 데이터를 조회하면 된다.\r\n\r\n> **😒아니 4번째 데이터라면서요...**  \r\n> 거의 대부분의 컴퓨터 언어는 시작 인덱스를 0으로 지정한다. 그 이유는 메모리에 있는데, 메모리를 기준으로 배열의 첫 번째 데이터는 주소의 이동이 없다.  \r\n> 만약 주소가 0x0101이라면, 첫 번째 데이터는 0x0101이 되기 때문에 주소의 이동이 없으므로 0번째 데이터라고 정의하는 것이다. 이는 관점의 차이로, 초대 프로그램의 언어가 이와 같은 방식을 차용했다. 이후 이를 기반으로 생겨난 수 많은 언어들이 이 영향을 받았다.\r\n\r\n이처럼 배열의 주소에서 해당 인덱스만큼 주소에 더해 데이터를 읽는 것이므로, 동작은 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111156-887c9080-e120-11eb-94db-46545b8a5e9c.png\" width=\"600px\" />\r\n</p>\r\n\r\n주소 0x0404를 시작으로 4번째 데이터인 0x0407인 주소에 접근한다. 배열의 주소와 배열의 인덱스를 알고 있으므로 별도의 연산 없이 바로 접근 가능하다. 이로써 0x0407의 값 9에 접근할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 읽기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 22:53:39\r\n */\r\npublic class ArrayRead\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 읽을 인덱스\r\n\t\tint index = 4;\r\n\t\t\r\n\t\tint result = read(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(\"4번 째 아이템: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 읽기 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t *\r\n\t * @return [int] 인덱스에 해당하는 값\r\n\t */\r\n\tprivate static int read(int index)\r\n\t{\r\n\t\treturn ARRAY[index];\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 아이템: 9\r\n```\r\n\r\nJAVA 소스는 위와 같다. 배열 `array`을 선언하고, `array[3]`을 호출하면 배열의 4번째 값인 94가 변수 `four`에 할당된다. 목표에 바로 접근하므로 작업에 필요한 단계는 단 하나다.\r\n\r\n## 1-3. 검색\r\n\r\n이처럼 주소의 값이나 인덱스를 정확히 알고 있다면, 별도의 연산 없이 바로 해당하는 값을 갖고올 수 있다. 하지만 실제로 배열을 다루다보면 꼭 이렇게 간단한 케이스만 있지는 않다.\r\n\r\n우리가 구조를 알지 못하는 배열이 있다고 가정할 때, 해당 배열에서 우리가 원하는 값을 찾아야할 경우가 적지않게 발생한다. 이 경우 원하는 값의 인덱스를 가지고 있지도 않으며, 심지어 배열 내부에 원하는 값이 존재하는지조차 알 수 없다. 이 경우 <span class=\"primary\">검색</span>연산을 통해 배열의 값을 찾아야 한다.\r\n\r\n위에서 선언했던 배열을 다시 가져와보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n이번엔 우리가 이 배열에 대한 정확한 정보를 가지고있지 않다고 가정해보자. 현재 우리는 이 배열의 어떤 인덱스에 어떤 값이 있는지 전혀 모르는 상태다.\r\n\r\n이 상황에서 14라는 값을 검색해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111164-8a465400-e120-11eb-9432-8c127bfed9b2.png\" width=\"600px\" />\r\n</p>\r\n\r\n검색은 읽기 작업의 반복이라고 봐도 무방하다. 위 그림은 이러한 검색의 특성을 여실히 보여준다. 목표값인 14를 찾기 위해 `array[0]` 부터 순차적으로 읽음으로써 14를 찾는다.\r\n\r\n만약 어떠한 방법으로든 읽기과정을 줄이면서도 정상적인 검색이 가능하다면 소요시간이 효과적으로 감소할 것이다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 23:47:03\r\n */\r\npublic class ArrayFind\r\n{\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 목표 숫자\r\n\t\tint target = 14;\r\n\t\t\r\n\t\tint result = find(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"이 포함된 인덱스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n14이 포함된 인덱스: 2\r\n```\r\n\r\n하지만 위는 가장 기초적인 검색 알고리즘을 적용한 것이다. 3번째 요소를 찾기 위해선 3개 과정이 필요하고, 5484번째 요소를 찾기 위해선 5484개 과정이 필요하다.\r\n\r\n그러나, 요소가 맨 끝에 있거나, 불행히도 배열 내에 존재하지 않을 경우 배열 전체를 검색해야할 수도 있다. 즉 배열에 $N$개의 요소가 있다면, 검색의 최대 작업 갯수는 $N$개가 된다.\r\n\r\n## 1-4. 삽입\r\n\r\n배열에 새로운 요소를 넣는 작업을 <span class=\"primary\">삽입</span> 연산이라 한다. 배열에서 55를 삽입하는 과정을 통해 삽입 연산에 대해 알아보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111179-8d414480-e120-11eb-9c36-965d4506fd8c.png\" width=\"600px\" />\r\n</p>\r\n\r\n런타임 시 배열을 할당했다면 우리는 배열의 주소를 알고 있을 것이다. 배열의 맨 끝에 요소를 추가한다면 그냥 이어붙이면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111188-8fa39e80-e120-11eb-8576-aee6d30ae3a7.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간에 삽입한다면 이야기가 조금 달라진다. 삽입하려는 위치 이후의 요소를 한 칸씩 뒤로 미루고, 해당 위치에 값을 삽입하게 된다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치에 요소를 삽입한다면 모든 배열의 요소를 한 칸씩 뒤로 미룬뒤 55를 삽입해야한다. 즉, 배열에 $N$개의 요소가 있을 경우 삽입에 필요한 작업량은 $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $N + 1$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:27:47\r\n */\r\npublic class ArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tinsert(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 요소에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 요소에 55 삽입: [6, 43, 55, 14, 9, 94, -1, -1, -1, -1]\r\n```\r\n\r\n삽입 소스는 위와 같다.\r\n\r\n> **@SuppressWarnings는 뭔가요?**  \r\n> Eclipse, IntelliJ와 같은 IDE는 코드를 분석하는 과정에서 오류 또는 경고를 개발자에게 알려줌으로써 잠재적 위험을 제거할 수 있도록 유도한다. 간혹 의도된 동작임에도, IDE의 최적화 설정과 맞지 않아 경고를 띄우기도 한다. 이 경우 @SuppressWarnings 애노테이션을 쓰면 해당 경고를 무시할 수 있다. @@SuppressWarnings를 지워도 소스 동작엔 아무런 문제가 없다.\r\n\r\n위에서도 언급했지만, JAVA의 배열은 고정길이를 가진다. 삽입 연산을 하기 위해선 필연적으로 현재 배열의 크기보다 하나 이상 커야하므로, 이전과 달이 총 길이가 10인 배열을 선언했다. 배열의 요소가 -1일 경우, 해당 요소는 아직 할당되지 않은 빈 요소로 간주한다.\r\n\r\n> **가변 길이를 가지는 List**  \r\n> JAVA에서도 얼마든지 가변길이 배열이 필요한 경우가 생긴다. 이 경우 `ArrayList`와 같은 `List` 데이터를 활용하면 된다. `List`는 가변길이를 가짐으로써 비정형화된 배열 데이터를 다루는데 유리하다.\r\n\r\n배열의 가장 끝 요소부터 삽입하려는 인덱스 이전까지 순차적으로 내려오며 현재 요소의 값을 이전 요소의 값으로 할당하여 요소를 이동시킨다. 이후 삽입하려는 인덱스에 요소를 할당함으로써 삽입이 완료된다.\r\n\r\n## 1-5. 삭제\r\n\r\n삽입을 했으니, 반대로 <span class=\"primary\">삭제</span>도 필요할 수 있다. 삭제 연산은 원하는 인덱스의 요소를 삭제하는 것이다. 간단히 말하자면, 삽입과 정 반대의 프로세스를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111198-93372580-e120-11eb-9949-aa21aef11dfa.png\" width=\"600px\" />\r\n</p>\r\n\r\n마찬가지로, 배열의 맨 끝에 요소를 삭제한다면 그냥 끝의 요소를 삭제하면 그만이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111204-9500e900-e120-11eb-8c44-c45faeb459fd.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간을 삭제한다면 동일한 작업이 필요하다. 삭제하려는 위치의 요소를 삭제하고, 요소를 한 칸씩 당겨야 한다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치의 요소를 삭제한다면 해당 요소를 삭제한 뒤 모든 배열의 요소를 한 칸씩 앞으로 당길 것이다. 즉, 배열에 $N$개의 요소가 있을 경우 삭제에 필요한 작업량은 해당 인덱스의 요소를 삭제하는 작업 1개, $N - 1$개의 요소를 하나씩 이동하는 작업 $N - 1$개로 최대 $N$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삭제 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:59:02\r\n */\r\npublic class ArrayDelete\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삭제할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\tremove(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번째 요소 삭제 \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삭제 함수\r\n\t *\r\n\t * @param index: [int] 삭제 위치\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void remove(int index)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = index; i < ARRAY.length - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i + 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tARRAY[ARRAY.length - 1] = -1;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번째 요소 삭제 [6, 43, 9, 94, -1, -1, -1, -1, -1, -1]\r\n```\r\n\r\n삭제 소스는 위와 같다.\r\n\r\n삭제는 삽입과 달리 배열의 크기가 증가할 필요가 없다. 마찬가지로 배열의 요소가 -1일 경우, 해당 요소는 삭제된 빈 요소로 간주한다.\r\n\r\n삽입과는 반대로, 삭제하려는 인덱스부터 배열의 끝까지 순차적으로 올라가며 현재 요소의 값을 이후 요소의 값으로 할당하여 요소를 이동시킨다. 이후 배열의 끝 요소를 제거함으로써 삭제가 완료된다.\r\n\r\n## 1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다\r\n\r\n배열의 경우 요소의 타입만 맞다면 별다른 신경을 쓰지 않는다. 이말인즉슨, 중복되는 요소에 대한 처리도 이루어지지 않는다. 하지만 종종 중복되는 값을 허용하지 않는 배열의 필요성이 생기기도 한다. 책에서는 이를 <span class=\"primary\">집합</span>이라는 개념으로 설명한다.\r\n\r\n배열에 요소를 삽입할 때, 중복여부를 확인하기 위해선 검색 작업이 선행되어야 한다. 검색을 통해 집합에 해당 요소가 없는 것이 확인될 경우에만 삽입이 이루어지는 방식이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111212-97634300-e120-11eb-8d2e-c024761e23ff.png\" width=\"600px\" />\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111220-992d0680-e120-11eb-97a2-3e1e8eda7518.png\" width=\"600px\" />\r\n</p>\r\n\r\n위의 두 그림은 집합 개념이 적용된 배열에서 존재하지 않는 값 55와, 존재하는 값 14를 삽입했을 때 나타나는 결과를 도식화한 것이다.\r\n\r\n55의 경우 기존에 존재하지 않았으므로 삽입이 가능하지만, 14의 경우 이미 2번 째 인덱스에 동일한 값이 있으므로 삽입이 불가능하다.\r\n\r\n검증이 완료된 이후의 삽입 과정은 기존의 삽입 과정과 동일하다. 단, 작업량은 달라진다. 기존의 삽입 작업량에서 검색의 작업량이 추가되기 때문이다.\r\n\r\n가장 최악의 케이스는 중복되지 않는 임의의 값을 배열의 0번 째 인덱스에 삽입하는 것이다. $N$개의 요소를 가진 배열에서 $N$개 요소를 검색하는 작업량 $N$개, $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $2N + 1$개의 작업량이 발생한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 집합 배열 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 01:30:56\r\n */\r\npublic class UniqueArray\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tboolean result = hasInserted(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입 결과: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [boolean] 삽입 결과\r\n\t */\r\n\tprivate static boolean hasInserted(int index, int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\t// 중복되지 않을 경우\r\n\t\tif (result == -1)\r\n\t\t{\r\n\t\t\tinsert(index, item);\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 중복될 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 인덱스에 55 삽입 결과: true\r\n```\r\n\r\n집합 배열의 삽입 소스는 위와 같다.\r\n\r\n`find`와 `insert` 함수는 검색과 삽입 파트에서 사용한 로직과 동일한 로직이다. 집합 배열은 반드시 고유한 요소만을 삽입해야 하므로, `hasInserted` 함수를 구성하여 중복 여부를 검증한 뒤 삽입을 진행한다.\r\n\r\n`find` 함수는 검색되는 요소가 없을 경우 -1을 반환한다. 즉, -1을 반환하는 숫자는 고유한 숫자다. `find`가 -1을 반환할 경우 `insert` 함수로 삽입을 진행한다.\r\n\r\n> **Set 객체는 중복을 허용하지 않아요**  \r\n> JAVA의 배열은 기본적으로 요소의 중복같은건 신경쓰지 않는다. 때문에, 요소의 중복을 감지하기 위해선 별도의 검증 로직을 구성해야한다.  \r\n> 하지만 `HashSet`과 같은 `Set` 객체를 활용하면 항상 고유한 값만 삽입할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 최대한 개념 위주로 설명하며, 설명에 어떠한 알고리즘 지식이 들어가지 않은 것으로 보인다. 이러한 저자의 의도를 최대한 반영하여, 내 로직 역시 가능한 기본 데이터 타입을 사용했으며, 복잡한 로직을 최대한 지양했다. 철저히 연산이 동작하는 기본 원리에 입각하도록 소스를 구성했다.\r\n\r\n다음 장에서는 알고리즘에 대한 본격적인 내용이 기술될 것이다.","url":["2021-07-10-about-algorithm-chapter01","2021","07","10","about-algorithm-chapter01"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1019번 책 페이지","excerpt":"지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1페이지이고, 마지막 페이지는 N페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-28T12:28:50","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-28-A1019.md","content":"\r\n# 책 페이지\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1019번 문제](https://www.acmicpc.net/problem/1019)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 전체 페이지의 수가 $N$인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 $N$페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$이 주어진다. $N$은 $1,000,000,000$보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 4 1 1 1 1 1 1 1 1\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 명확하고 직관적이다. 1페이지부터 $N$페이지까지 나열할 때, <span class=\"green-400\">숫자가 사용된 수를 각 숫자별로 나타내는 문제</span>.\r\n\r\n165라는 숫자를 표기하기 위해선 $[ 1, 5, 6 ]$이 사용된다. 이렇게 <span class=\"green-400\">1부터 해당 숫자까지의 모든 숫자를 표현하기 위해 사용한 숫자의 수를 0부터 오름차순으로 출력</span>하면 된다. \r\n\r\n즉, $N = 5$라고 가정하면, 페이지 배열은 $[ 1, 2, 3, 4, 5 ]$까지 나열된다. 각 숫자가 사용된 수를 표로 나타내면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n1부터 5까지 나열하는데, 각각 숫자 하나씩 사용했으니 위 처럼 표시할 수 있다. 그렇다면 예제의 11은 어떨까?\r\n\r\n$[ 1, 2, 3, \\dots, 10, 11 ]$까지 나열된다. \r\n\r\n1부터 9까지는 각각 숫자가 하나씩 사용되며, 10은 1과 0이 사용되고, 11은 1이 두 개 사용된다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n위의 표만큼 숫자가 사용됐다. 이해를 위해 $N = 13$일 경우를 하나 더 해보자.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n$12 = [ 1, 2 ]$, $13 = [ 1, 3 ]$이 된다. 1 ~ 13에는 11도 포함되기 때문에, 11의 결과에 12, 13의 값을 각각 더해줘도 상관없다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n이 정도면 알고리즘이 원하는 게 무엇인지 이해했으리라 생각한다.\r\n\r\n## 🔎규칙 찾아보기\r\n\r\n사실 무식하게 접근하면, 그리 어려운 문제는 아니다. 하나하나 반복문 돌려가며 숫자 분해해서 해당하는 숫자의 배열에 집어넣으면 그만이니. 하지만 안타깝게도, 변수 $N$의 최대값은 10억 ~~(다행히 int의 최대값은 넘지 않는다.)~~ 에 육박한다. 그 말인즉는 무식하게 접근하면 안 된다는 의미.\r\n\r\n그렇다면 어딘가에 존재하는 규칙성을 발견해서 일반식을 설계해야한다는 뜻인데, 이럴땐 하나하나 나열해보면 알 수 있을 것이다.\r\n\r\n|   N   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   0   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   2   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   3   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   4   |   0   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |\r\n|   5   |   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   6   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |\r\n|   7   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |\r\n|   8   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |\r\n|   9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  10   |   1   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  11   |   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  12   |   1   |   5   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  13   |   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  14   |   1   |   7   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |\r\n|  15   |   1   |   8   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |\r\n|  16   |   1   |   9   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |\r\n|  17   |   1   |  10   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |\r\n|  18   |   1   |  11   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |\r\n|  19   |   1   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  20   |   2   |  12   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  21   |   2   |  13   |   4   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  22   |   2   |  13   |   6   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  23   |   2   |  13   |   7   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n\r\n규칙성을 찾아보기 위해 20 받고 살짝 더 얹어서 사용된 숫자를 나열해보았다. 어떤 패턴이 보이는 것 같긴 하다.\r\n\r\n1. 0은 10의 배수마다 1씩 증가한다.\r\n2. 각 1의 자리마다 해당하는 숫자가 1씩 증가하며, 값은 10의 자릿수 + 1이다.\r\n3. 10의 자릿수는 해당하는 숫자를 1씩 증가시킨다.\r\n\r\n그냥 쳐다보면 규칙성을 찾기 좀 어려울 수 있다. 해답은 <span class=\"red-400\">*0 ~ *9</span> 구간에 있다. 예를 들어, 10 ~ 29까지 나열해보자. 1부터 시작하는 것이 아니라, 임의의 구간 $A ~ B$를 기준으로 알고리즘을 계산한다고 가정하는 것이다.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>10</td>\r\n\t\t\t<td>11</td>\r\n\t\t\t<td>12</td>\r\n\t\t\t<td>13</td>\r\n\t\t\t<td>14</td>\r\n\t\t\t<td>15</td>\r\n\t\t\t<td>16</td>\r\n\t\t\t<td>17</td>\r\n\t\t\t<td>18</td>\r\n\t\t\t<td>19</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>20</td>\r\n\t\t\t<td>21</td>\r\n\t\t\t<td>22</td>\r\n\t\t\t<td>23</td>\r\n\t\t\t<td>24</td>\r\n\t\t\t<td>25</td>\r\n\t\t\t<td>26</td>\r\n\t\t\t<td>27</td>\r\n\t\t\t<td>28</td>\r\n\t\t\t<td>29</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n위 표의 숫자들을 잘 보면, 1의 자리 숫자는 각각 하나씩 사용하는 것을 확인할 수 있다.\r\n\r\n## 1의 자리에서의 규칙\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>1<span class=\"red-A400\">0</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">1</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">2</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">3</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">4</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">5</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">6</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">7</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">8</span></td>\r\n\t\t\t<td>1<span class=\"red-A400\">9</span></td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>2<span class=\"red-A400\">0</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">1</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">2</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">3</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">4</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">5</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">6</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">7</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">8</span></td>\r\n\t\t\t<td>2<span class=\"red-A400\">9</span></td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n이제 좀 규칙성이 눈에 띄기 시작한다. 20 ~ 39와 같은 <span class=\"red-400\">*0 ~ *9</span> 형태의 범위에선 1의 자리에 해당하는 모든 숫자가 동일하게 사용된다. 10 ~ 19, 20 ~ 29 두 구간이 있으므로 각 구간별로 1씩 모든 숫자가 두 번 사용됐다.\r\n\r\n시작 페이지를 $n$, 마지막 페이지를 $N$이라고 가정할 때, 위 규칙을 일반식으로 표현하면 아래와 같다.\r\n\r\n$$\r\n(N \\div 10) - (n \\div 10) + 1 = \\text{1의 자리에 사용된 각각의 숫자 갯수}\r\n$$\r\n\r\n따라서 10 ~ 29 범위에서 모든 숫자는 두 번 사용된 것임을 알 수 있다.\r\n\r\n## p의 자리에서의 규칙\r\n\r\n문제는 위 식은 <span class=\"orange-400\">1의 자리에서만 적용되는 수식</span>이다. 페이지는 최대 10의 자리까지 존재할 수 있다. 즉, 통용되는 일반식을 구해야한다.\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td><span class=\"red-A400\">1</span>0</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>1</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>2</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>3</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>4</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>5</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>6</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>7</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>8</td>\r\n\t\t\t<td><span class=\"red-A400\">1</span>9</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td><span class=\"red-A400\">2</span>0</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>1</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>2</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>3</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>4</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>5</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>6</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>7</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>8</td>\r\n\t\t\t<td><span class=\"red-A400\">2</span>9</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n반대로 10의 자리수를 자세히 보자. 1이 10번 사용된다. 만약 100 ~ 199 구간이라면 1은 100개가 사용될 것이고, 1000 ~ 1999 구간이라면 1은 1000개가 사용될 것이다.\r\n\r\n쉽게 설명하기 위해 10 ~ 19, 100 ~ 199, 1000 ~ 1999 등 $n0* ~ n9*$ 같은 형태의 구간을 단위 구간이라고 정의하자. 이 때, 해당 구간에서 $n$이 사용되는 갯수는 아래와 같이 정의할 수 있다.\r\n\r\n$$\r\n((N \\div 10) - (n \\div 10) + 1) \\times \\text{p} = \\text{각각의 숫자 갯수}\r\n$$\r\n\r\n* $n$: 구간 시작 값\r\n* $N$: 구간 끝 값\r\n* $p$: 자릿수\r\n\r\n## 구간 보정하기\r\n\r\n이제 구간만 맞으면 호출되는 숫자를 구할 수는 있지만, 아직 제한적이다.\r\n\r\n우선, 본 알고리즘에서 시작 값은 1로 고정이다. 끝 값인 $N$ 역시 반드시 199와 같은 단위 구간의 형태로 들어오지도 않는다. 만약 $N = 35$라면 우리는 1 ~ 35 구간에 알고리즘을 적용해야 한다. 구간이 10 ~ 39라면 모를까, 형태가 전혀 다른 구간에는 위 일반식이 적용되지 않는다.\r\n\r\n해결 방법은 간단하다. 가늠좌 클리크 조정하듯이 구간에 맞게 값을 더하고 빼서 조정해주면 된다.\r\n\r\n1 ~ 35 구간에서, 1의 경우, 1보다 크며 0을 포함한 수 중 가장 가까운 값은 10이다. 따라서, 시작 값은 10까지 증가시키며, 증가시킨 숫자를 카운팅한다. 1부터 9까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n35의 경우 35보다 작으며 9를 포함한 수 중 가장 가까운 수는 29다. 마찬가지로 마지막 값은 29까지 감소시키며, 감소한 숫자를 카운팅한다. 35부터 30까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n즉, 초기값은 위 보정값을 더한 배열이며, 이후 계산은 계산된 초기값에 누적한다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| **1** | **2** | **2** | **8** | **2** | **2** | **1** | **1** | **1** | **1** |\r\n\r\n## 자릿수 보정하기\r\n\r\n$N = 1999$, $n = 1000$일 때, 1의 자리에 사용된 숫자의 갯수를 구하면 아래와 같다.\r\n\r\n$$\r\n((1999 / 10) - (1000 / 10) + 1) \\times 1 = 100\r\n$$\r\n\r\n1의 자리에서 각 숫자는 100개씩 사용됐다. 10의 자리에서는 어떨까?\r\n\r\n$N$, $n$을 각각 10으로 나누면 10의 자리에 대한 구간을 얻을 수 있다. 나눠진 숫자를 위의 일반식에 적용하면 된다.\r\n\r\n$$\r\n((199 / 10) - (100 / 10) + 1) \\times 10 = 100\r\n$$\r\n\r\n100의 자리는 $N$, $n$을 각각 100으로 나누어 계산하면 된다.\r\n\r\n$$\r\n((19 / 10) - (10 / 10) + 1) \\times 100 = 100\r\n$$\r\n\r\n1000의 자리는 $N$, $n$을 각각 1000으로 나누어 계산하면 된다. 그러나 $N = n = 1$이므로, 1에만 1000개가 사용된다.\r\n\r\n|  $p$  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  10   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n| 1000  |   0   | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|       |  300  | 1300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n따라서 1000 ~ 1999 구간은 위와 같이 계산된다.\r\n\r\n## 📃일반식 적용하기\r\n\r\n완벽한 이해를 위해, 위 개념을 토대로 $N = 4153$일 경우의 알고리즘을 계산해보자.\r\n\r\n$N = 4153$이므로, 구간은 1 ~ 4153이다.\r\n\r\n### 시작 페이지 구간 보정하기\r\n\r\n1보다 큰 수 중 1의 자리가 0인 가장 가까운 수 10까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n1부터 9까지 이동하여 10에 도착하므로, 1 ~ 9를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n### 마지막 페이지 구간 보정하기\r\n\r\n4153보다 작은 수 중 1의 자리가 9인 가장 가까운 수 4149까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n4153부터 4150까지 이동하여 4149까지 도착하므로, 이를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 4153  |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4152  |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4151  |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4150  |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n### 1의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 4149을 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((4149 / 10) - (10 / 10) + 1) \\times 1 = 414 - 1 + 1 = 414\r\n$$\r\n\r\n|   구분   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1의 자리 |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n\r\n### 10의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 1의 자리 일반식 구간 4149, 10을 각각 10으로 나눈다.\r\n\r\n10의 자리에 대한 구간은 $1 ~ 414$가 된다. 마찬가지로 일반식 적용을 위해 구간을 보정한다. 10의 자리이므로, <span class=\"red-400\">1 -> 2로의 이동은 실제로 10 -> 20으로의 이동임에 주의</span>하자.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  414  |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|  413  |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  412  |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  411  |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  410  |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 10의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 409를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((409 / 10) - (10 / 10) + 1) \\times 10 = (40 - 1 + 1) \\times 10 = 400\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n\r\n### 100의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 10의 자리 일반식 구간 409, 10을 각각 10으로 나눈다.\r\n\r\n100의 자리에 대한 구간은 $1 ~ 40$이 된다. 나머지는 10의 자리 프로세스와 동일하다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  40   |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 100의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 39를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((39 / 10) - (10 / 10) + 1) \\times 100 = (3 - 1 + 1) \\times 100 = 300\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n### 1000의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 100의 자리 일반식 구간 39, 10을 각각 10으로 나눈다.\r\n\r\n1000의 자리에 대한 구간은 $1 ~ 3$이 된다.\r\n\r\n여기서 문제가 하나 있는데, 마지막 구간에서 일의 자리가 9인 가장 작은 수는 -9다. 음수가 올 수 없으므로, 더 이상의 일반식 연산은 불가능하며, 개별적으로 더해주면 된다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 3 |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 총합 계산하기\r\n\r\n단계별로 구한 숫자를 정리하여 총합을 표로 나타낸다.\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1 ~ 9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   4153    |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4152    |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4151    |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4150    |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 1의 자리  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n|   1 ~ 9   |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n|    414    |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|    413    |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    412    |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    411    |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    410    |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n|   1 ~ 9   |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|    40     |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n|   1 ~ 3   |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   총합    | 1225  | 2290  | 2236  | 2236  | 1389  | 1229  | 1225  | 1225  | 1225  | 1225  |\r\n\r\n구간 1 ~ 4153에 대한 알고리즘 결과는 위와 같다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 백준 전체 1019 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/28/A1019/\">1019 풀이</a>\r\n * @since 2021.06.28 Mon 12:28:50\r\n */\r\npublic class Main\r\n{\r\n\t// 숫자 카운트 배열\r\n\tprivate static final int[] counter = new int[10];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 마지막 페이지\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tsolve(N);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int item : counter)\r\n\t\t{\r\n\t\t\tbuilder.append(item).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(builder.toString().trim());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\treader.close();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 동작 함수\r\n\t *\r\n\t * @param num: [int] 마지막 페이지\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\t// 시작 페이지\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 자릿수\r\n\t\tint digit = 1;\r\n\t\t\r\n\t\twhile (start <= num)\r\n\t\t{\r\n\t\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\t\tcount(num, digit);\r\n\t\t\t\t\r\n\t\t\t\tnum--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\t\tif (num < start)\r\n\t\t\t{\r\n\t\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\t\tcount(start, digit);\r\n\t\t\t\t\r\n\t\t\t\tstart++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstart /= 10;\r\n\t\t\tnum /= 10;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 10; i++)\r\n\t\t\t{\r\n\t\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 자릿수 증가\r\n\t\t\tdigit *= 10;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 카운트 함수\r\n\t *\r\n\t * @param num: [int] 대상 숫자\r\n\t * @param digit: [int] 자릿수\r\n\t */\r\n\tprivate static void count(int num, int digit)\r\n\t{\r\n\t\twhile (num > 0)\r\n\t\t{\r\n\t\t\tcounter[num % 10] += digit;\r\n\t\t\tnum /= 10;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$N = 4153$일 때, 구간을 보정하는 과정에서 4153, 4152와 같은 수를 별도로 카운팅해야한다.\r\n\r\n``` java\r\n/**\r\n * 카운트 함수\r\n *\r\n * @param num: [int] 대상 숫자\r\n * @param digit: [int] 자릿수\r\n */\r\nprivate static void count(int num, int digit)\r\n{\r\n\twhile (num > 0)\r\n\t{\r\n\t\tcounter[num % 10] += digit;\r\n\t\tnum /= 10;\r\n\t}\r\n}\r\n```\r\n\r\n로직은 어렵지 않다. 4152의 경우 $[ 4, 1, 5, 2 ]$로 이루어져있으므로, 해당하는 숫자에 자릿수만큼 카운팅(1이면 1개, 10이면 10개)하면 된다.\r\n\r\n1의 자리는 $4152 \\,\\,\\, \\% \\,\\,\\, 10 = 2$와 같이 구할 수 있다. 10의 자리는 4152를 10으로 한 번 나누고 방금의 연산을 다시 진행하면 된다.  \r\n100, 1000 등 자릿수만큼 반복하여 계산하면 된다.\r\n\r\n``` java\r\n/**\r\n * 알고리즘 동작 함수\r\n *\r\n * @param num: [int] 마지막 페이지\r\n */\r\nprivate static void solve(int num)\r\n{\r\n\t// 시작 페이지\r\n\tint start = 1;\r\n\t\r\n\t// 자릿수\r\n\tint digit = 1;\r\n\t\r\n\twhile (start <= num)\r\n\t{\r\n\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t{\r\n\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\tcount(num, digit);\r\n\t\t\t\r\n\t\t\tnum--;\r\n\t\t}\r\n\t\t\r\n\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\tif (num < start)\r\n\t\t{\r\n\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t{\r\n\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\tcount(start, digit);\r\n\t\t\t\r\n\t\t\tstart++;\r\n\t\t}\r\n\t\t\r\n\t\tstart /= 10;\r\n\t\tnum /= 10;\r\n\t\t\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t}\r\n\t\t\r\n\t\t// 자릿수 증가\r\n\t\tdigit *= 10;\r\n\t}\r\n}\r\n```\r\n\r\n시작 페이지는 무조건 1로 고정이다. 시작 페이지가 마지막 페이지보다 커질 때까지 반복한다.\r\n\r\n첫 번째 `while`문에서 마지막 페이지를 1씩 감소시켜 9로 끝나는 구간으로 보정한다. 중간에 조건문이 있는데, 이 처리를 해주지 않으면 `num`이 9보다 작을 경우 연산 과정에서 `start`가 `num`을 초과하지 못해 무한루프를 타게 된다.\r\n\r\n두 번째 `while`문은 1페이지를 1씩 증가시켜 0으로 끝나는 구간으로 보정한다. 보정된 모든 값은 `count` 메소드를 통해 별도로 카운팅된다.\r\n\r\n위 과정을 통해 구간을 맞췄으니, 나머지는 위에 언급한 수식을 적용하고, 이를 반복한다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-28-A1019","2021","06","28","A1019"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1018번 체스판 다시 칠하기","excerpt":"지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8*8 크기의 체스판으로 만들려고 한다. 체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다. 보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8 X 8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-26T16:46:20","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER V","Brute Force(무차별 대입 공격)"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-26-A1018.md","content":"\r\n# 체스판 다시 칠하기\r\n\r\n# h1\r\n## h2\r\n\r\n\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1018번 문제](https://www.acmicpc.net/problem/1018)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 $M \\times N$ 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 $8 \\times 8$ 크기의 체스판으로 만들려고 한다.\r\n\r\n체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.\r\n\r\n보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 $8 \\times 8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 $8 \\times 8$ 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$과 $M$이 주어진다. $N$과 $M$은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 $N$개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n8 8\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBBBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n10 13\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nBBBBBBBBWBWBW\r\nBBBBBBBBBWBWB\r\nWWWWWWWWWWBWB\r\nWWWWWWWWWWBWB\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n12\r\n```\r\n\r\n# 풀이\r\n\r\n각 칸이 흰색 또는 검은색으로 칠해진 커다란 판에서 임의의 위치부터 $8 \\times 8$ 크기로 잘라 체스판을 만든다. 그 중 가장 적은 칸을 칠하여 체스판을 만들고자 할 때, 칠해야하는 최소값을 구하는 문제. 주어진 변수의 범위가 적어 그냥 무식하게 하나하나 비교하면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507886-2430ea00-d6a7-11eb-8c98-eecd7655f352.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 처럼 $N \\times M$의 배열에서 무작위 $8 \\times 8$ 크기의 배열을 뽑아내야한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507891-2c892500-d6a7-11eb-85b3-eb4d7803450d.png\" width=\"800px\" />\r\n</p>\r\n\r\n$10 \\times 10$짜리 배열을 기준으로, 해당 판에서 $8 \\times 8$ 배열을 선택하는 경우의 수는 총 9가지이며, 이를 도식화하면 위 그림과 같다. 이처럼 전체 배열에서 $8 \\times 8$만큼 한 칸씩 이동하며 비교하면 된다.\r\n\r\n``` java\r\nfor (int n = 0; n < N - 7; n++)\r\n{\r\n\tfor (int m = 0; m < M - 7; m++)\r\n\t{\r\n\t\t// TODO\r\n\t}\r\n}\r\n```\r\n\r\n위 코드와 같이 기술하면 가로부터 한 칸씩 이동하며, 끝에 도달할 경우 세로로 한 칸 이동한 뒤 다시 가로부터 한 칸씩 이동할 것이다. `n < N - 7`인 이유는 비교할 배열의 세로 길이가 8이기 때문. 살짝 헷갈린다면 `n <= N - 8`으로 대체해도 무방하다.\r\n\r\n체스판에는 두 가지 경우의 수가 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123507898-33179c80-d6a7-11eb-9f2e-71a4829134df.png\" width=\"700px\" />\r\n</p>\r\n\r\n체스판의 상단 좌측을 기준으로 하얀색으로 시작하는 판과, 검은색으로 시작하는 판으로 두 가지가 존재한다. 하얀색을 `true`, 검은색을 `false`로 치환하여 하얀색 체스판과 검은색 체스판을 만들어 비교할 것이다.\r\n\r\n``` java\r\n// 상단 좌측이 하얀색으로 시작하는 체스판\r\nprivate static final boolean[][] WHITE = {\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n};\r\n\r\n// 상단 좌측이 검은색으로 시작하는 체스판\r\nprivate static final boolean[][] BLACK = {\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t{ true, false, true, false, true, false, true, false },\r\n};\r\n```\r\n\r\n코드는 위와 같다. 흑백과 같이 이지선다일 경우 `boolean`을 사용하는 것을 더 선호하므로 위와 같이 설계했다. `String` 배열로 \"W\", \"B\"를 넣어 만들어도 비교만 잘 해준다면 크게 상관없다. 이를 $8 \\times 8$의 모든 경우의 수와 비교하여 가장 작은 수를 출력하면 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1018 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/26/A1018/\">1018 풀이</a>\r\n * @since 2021.06.26 Sat 16:46:20\r\n */\r\npublic class Main\r\n{\r\n\t// 상단 좌측이 하얀색으로 시작하는 체스판\r\n\tprivate static final boolean[][] WHITE = {\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t};\r\n\t\r\n\t// 상단 좌측이 검은색으로 시작하는 체스판\r\n\tprivate static final boolean[][] BLACK = {\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t\t\t{ false, true, false, true, false, true, false, true },\r\n\t\t\t{ true, false, true, false, true, false, true, false },\r\n\t};\r\n\t\r\n\t// 체스판\r\n\tprivate static boolean[][] board;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tint[] temp = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 세로 길이\r\n\t\tint N = temp[0];\r\n\t\t\r\n\t\t// 가로 길이\r\n\t\tint M = temp[1];\r\n\t\t\r\n\t\tboard = new boolean[N][M];\r\n\t\t\r\n\t\tfor (int n = 0; n < N; n++)\r\n\t\t{\r\n\t\t\tString[] line = reader.readLine().split(\"\");\r\n\t\t\t\r\n\t\t\tfor (int m = 0; m < M; m++)\r\n\t\t\t{\r\n\t\t\t\tboard[n][m] = line[m].equals(\"W\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 결과\r\n\t\tint result = Integer.MAX_VALUE;\r\n\t\t\r\n\t\t// 0 ~ 7까지 총 8칸을 전달하므로 최대값에서 7을 뺀다.\r\n\t\tfor (int n = 0; n < N - 7; n++)\r\n\t\t{\r\n\t\t\tfor (int m = 0; m < M - 7; m++)\r\n\t\t\t{\r\n\t\t\t\tint count = solve(n, m);\r\n\t\t\t\t\r\n\t\t\t\t// 현재 결과보다 더 작은 수일 경우\r\n\t\t\t\tif (result > count)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = count;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(Integer.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 새로 덧칠할 칸의 갯수 반환 함수\r\n\t *\r\n\t * @param x: [int] x의 시작좌표\r\n\t * @param y: [int] y의 시작좌표\r\n\t *\r\n\t * @return [int] 새로 덧칠할 칸의 갯수\r\n\t */\r\n\tprivate static int solve(int x, int y)\r\n\t{\r\n\t\tint white = 0;\r\n\t\tint black = 0;\r\n\t\t\r\n\t\tfor (int n = x; n < x + 8; n++)\r\n\t\t{\r\n\t\t\tfor (int m = y; m < y + 8; m++)\r\n\t\t\t{\r\n\t\t\t\t// 하얀색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\t\tif (board[n][m] != WHITE[n - x][m - y])\r\n\t\t\t\t{\r\n\t\t\t\t\twhite++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 검은색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\t\tif (board[n][m] != BLACK[n - x][m - y])\r\n\t\t\t\t{\r\n\t\t\t\t\tblack++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 둘 중 더 적게 칠할 수 있는 체스판의 값을 반환\r\n\t\treturn Math.min(white, black);\r\n\t}\r\n}\r\n```\r\n\r\n처음에 설계했을 땐, 잘라낸 $8 \\times 8$ 배열 `board`의 좌측 상단값인 `board[x][y]`의 색을 찾아서, 하얀색(true)일 경우 `WHITE`를, 검은색(false)일 경우 `BLACK`을 갖고 비교했는데 계속 틀렸다. 아래 케이스를 보면 이해가 쉽다.\r\n\r\n+ 입력\r\n\r\n``` tc\r\n8 8\r\nBBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\nWBWBWBWB\r\nBWBWBWBW\r\n```\r\n\r\n+ 출력\r\n\r\n```\r\n1\r\n```\r\n\r\n전체 판 자체가 $8 \\times 8$이므로 경우의 수는 판 자체로 하나다. 만약 처음 설계한대로 동작한다면 위 케이스에서 문제가 발생한다.\r\n\r\n위 케이스의 $board[0][0] = false$이므로 `BLACK`과 비교하게 된다. 이러면 $board[0][0]$를 제외한 나머지 63개의 칸을 전부 칠해야한다. 그런데 저 케이스, 자세히 한 번 보자. 사실 $board[0][0]$만 하얀색(true)로 칠해주면 그만이다. 즉, `BLACK`이 아닌 `WHITE`와 비교하면 값이 1인 것이다.\r\n\r\n``` java\r\n/**\r\n * 새로 덧칠할 칸의 갯수 반환 함수\r\n *\r\n * @param x: [int] x의 시작좌표\r\n * @param y: [int] y의 시작좌표\r\n *\r\n * @return [int] 새로 덧칠할 칸의 갯수\r\n */\r\nprivate static int solve(int x, int y)\r\n{\r\n\tint white = 0;\r\n\tint black = 0;\r\n\t\r\n\tfor (int n = x; n < x + 8; n++)\r\n\t{\r\n\t\tfor (int m = y; m < y + 8; m++)\r\n\t\t{\r\n\t\t\t// 하얀색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\tif (board[n][m] != WHITE[n - x][m - y])\r\n\t\t\t{\r\n\t\t\t\twhite++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 검은색으로 시작하는 체스판과 색이 다를 경우\r\n\t\t\tif (board[n][m] != BLACK[n - x][m - y])\r\n\t\t\t{\r\n\t\t\t\tblack++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 둘 중 더 적게 칠할 수 있는 체스판의 값을 반환\r\n\treturn Math.min(white, black);\r\n}\r\n```\r\n\r\n`solve()` 메소드는 알고리즘의 핵심 동작이다. `WHITE`와 `BLACK`을 전부 비교하는 이유가 여기에 있는데, 현재 배열에서 `WHITE`와 `BLACK`을 만드는데 필요한 칸의 숫자를 각각 구해서, 그 중 더 작은 수를 반환해야 올바르게 동작한다.\r\n\r\n## 분류\r\n\r\n* 브루트포스 알고리즘","url":["2021-06-26-A1018","2021","06","26","A1018"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1017번 소수 쌍","excerpt":"지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, {1, 4, 7, 10, 11, 12}가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다. 1 + 4 = $, 7 + 10 = 17$, $11 + 12 = 23 또는 1 + 10 = 11, 4 + 7 = 11, 11 + 12 = 23 수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 1 + 12 = 13으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-26T03:19:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM III","에라토스 테네스의 체","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-26-A1017.md","content":"\r\n# 소수 쌍\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1017번 문제](https://www.acmicpc.net/problem/1017)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, ${1, 4, 7, 10, 11, 12}$가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다.\r\n\r\n$1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$  \r\n또는  \r\n$1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$\r\n\r\n수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 $1 + 12 = 13$으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 리스트의 크기 $N$이 주어진다. N은 50보다 작거나 같은 자연수이며, 짝수이다. 둘째 줄에 리스트에 들어있는 수가 주어진다. 리스트에 들어있는 수는 1,000보다 작거나 같은 자연수이며, 중복되지 않는다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 정답을 출력한다. 없으면 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n6\r\n1 4 7 10 11 12\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4 10\r\n```\r\n\r\n# 풀이\r\n\r\n[1014번 컨닝](/posts/2021/06/23/A1014/)문제를 통해 <span class=\"primary\">이분 매칭</span>을 접한 덕분인지, 지금까지 푼 <span class=\"teal-A400\">플래티넘</span> 중에서는 그나마 좀 이해되는 문제였다.\r\n\r\n역시 내용이 다소 난해한데, 알고리즘이 요구하는 동작은 다음과 같이 정리할 수 있다. 입력된 6개의 숫자 배열 ${ 1, 4, 7, 10, 11, 12 }$이 있다고 가정하자. 배열의 숫자를 한 쌍씩 짝지어 더하면 총 3개의 수가 나온다. 이렇게 <span class=\"red-A400\">짝지어 더한 수가 모두 소수일 경우, 입력의 첫 번째 숫자와 매칭된 숫자들을 오름차순으로 정렬하여 출력</span>하는 문제다.\r\n\r\n예제에서도 설명해주듯이, 짝지은 수가 모두 소수인 경우는 $1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$과 $1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$가 된다. 입력의 가장 첫 번째 숫자가 1이므로, 1와 매칭된 4, 10이 정답이 된다.\r\n\r\n## 소수 판별하기🍳\r\n\r\n이제 좀 더 세부적인 내용을 살펴보자. 문제 해결의 핵심은 <span class=\"primary\">소수</span>다. 이 알고리즘에선 소수 판별이 필요하다. 많은 판별방법이 있지만, 가장 대표적인 <span class=\"primary\">에라토스 테네스의 체</span>를 활용하면 어렵지 않게 해결할 수 있다.\r\n\r\n## 요소 한 쌍씩 그룹화하기\r\n\r\n소수 판별 방법도 마련했겠다, 입력된 숫자 배열을 적절히 짝지어야한다. <span class=\"lightBlue-A400\">핵심은 짝지은 수의 합이 소수</span>가 되는 것. 요소를 한번씩 다 더해보는 방법도 있겠지만, 배열의 크기가 커질 수록 요구되는 연산량 또한 높아지므로 적절하지 않다. 즉, 가능성 있는 조합으로만 그룹화해야한다.\r\n\r\n소수에 대해 생각해보자. <span class=\"green-A400\">소수는 1과 자기 자신으로만 나눠지는 수</span>다. 즉, 반드시 **소수는 홀수**여야 한다. 이 전제를 확장하면 <span class=\"green-A400\">짝지은 수의 합이 홀수</span>여야한다. 두 수를 더했을 때 홀수가 나오는 경우는 **홀수 + 짝수**로 한 가지 경우의 수만 존재한다.\r\n\r\n따라서 우리는 입력값을 홀수와 짝수 그룹으로 나누어 각 그룹끼리만 더하면 결과는 모두 홀수일 것이므로, 해당 수는 소수일 가능성이 있다. 두 개의 그룹을 겹치지 않게 조합해야하므로 <span class=\"primary\">이분 매칭</span>이 적절한 해답이 될 수 있다. 각 그룹은 홀수와 짝수로 나누고, 더했을 때 소수가 되는 쌍을 노드로 연결하면 <span class=\"primary\">이분 매칭</span>으로 접근 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 그림은 예제 1을 홀수와 짝수 그룹으로 나눠 이분매칭으로 표시한 그림이다. 위 숫자를 6개의 숫자를 매칭하면 3개의 노드가 나올 것이다. 각 숫자를 더하기 위해선 반드시 하나의 쌍을 이뤄야하므로, <span class=\"primary\">이분 매칭</span>의 결과는 반드시 $N \\div 2$가 되어야 한다.\r\n\r\n예제의 가장 첫 번째 수는 1이다. 즉, 우리는 <span class=\"green-A400\">모든 요소쌍의 합이 모두 소수가 되는 조합을 찾고 해당 조합들에서 각각 1과 매칭되는 숫자</span>를 구해야한다. 이를 확장시키면, 1과 짝을 이루는 수를 더한 값이 소수가 아닐 경우 애초에 비교할 필요가 없다.\r\n\r\n위 그림의 매칭 결과가 3이 나온다면, 모든 요소를 적절히 짝지어 더한 값이 모두 소수가 되는 조합이 있다는 뜻이다. 해당 조합을 저장하여 1과 짝지은 값을 찾으면 될 것이다.  \r\n만약, 홀수와 짝수의 갯수가 일치하지 않을 경우, 매칭이 불가능하므로 문제에 제시한 조건에 따라 -1을 반환해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png\" width=\"600px\" />\r\n</p>\r\n\r\n1과 더했을 때 소수가 되는 요소는 4, 10, 12 모두 해당하므로 이를 모두 노드로 연결할 수 있다. 1과 매칭 가능한 요소 중 하나를 연결하면, 나머지 4개 요소에 대해서만 <span class=\"primary\">이분 매칭</span>을 진행할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501823-9216ea80-d682-11eb-96de-8c01b66677bb.png\" width=\"600px\" />\r\n</p>\r\n\r\n만약, 1과 4를 매칭했다면 나머지 4개 요소에 대한 소수 매칭은 그림과 같이 표현할 수 있다. $[ 7, 10 ]$, $[ 11, 12 ]$ 조합의 합이 모두 소수이므로, $[ 1, 4 ]$, $[ 7, 10 ]$, $[ 11, 12 ]$ 조합은 알고리즘의 조건에 부합한다. 따라서 4는 정답에 포함된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501853-c8546a00-d682-11eb-86e2-6eef5c65ef69.png\" width=\"600px\" />\r\n</p>\r\n\r\n만약, 1과 12가 매칭된다면 어떨까? 이는 위 그림과 같이 표시할 수 있다. 7의 경우 4와 10 중 어떤걸 조합해도 소수지만, 11의 경우 4와 10 모두 소수가 아니므로 어떤식으로 매칭해도 4개 요소의 매칭 결과는 1이 된다. 즉, 1과 매칭된 조합 하나를 더한 최종 매칭 수는 2이므로 $N / 2$의 값에 부합하지 않으므로 해당 조합은 정답이 될 수 없다.  \r\n따라서 예제의 결과는 출력과 같이 `4 10`이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\n\r\n/**\r\n * 백준 전체 1017 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/26/A1017/\">1017 풀이</a>\r\n * @since 2021.06.26 Sat 03:19:32\r\n */\r\npublic class Main\r\n{\r\n\t// 에라토스 테네스의 체 배열 (소수 판별용)\r\n\tprivate static final boolean[] IS_NOT_PRIME = eratosthenes();\r\n\t\r\n\t// 왼쪽 배열 (이분매칭의 기준)\r\n\tprivate static int[] left;\r\n\t\r\n\t// 오른쪽 배열\r\n\tprivate static int[] right;\r\n\t\r\n\t// 노드 연결 여부\r\n\tprivate static boolean[][] hasNode;\r\n\t\r\n\t// 방문 여부\r\n\tprivate static boolean[] isVisit;\r\n\t\r\n\t// 매칭된 수\r\n\tprivate static int[] matched;\r\n\t\r\n\t// 현재 선택 중인 수\r\n\tprivate static int selected;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 입력값 갯수\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 입력값 배열\r\n\t\tint[] numbers = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 첫 번째 수가 홀수일 경우\r\n\t\tif (numbers[0] % 2 != 0)\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 홀수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 첫 번째 수가 짝수일 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 짝수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일할 경우 (이분매칭 가능)\r\n\t\tif (left.length == right.length)\r\n\t\t{\r\n\t\t\thasNode = new boolean[left.length][right.length];\r\n\t\t\t\r\n\t\t\t// left의 첫 번째 행은 기준 매칭이므로 이분 매칭에서 제외한다.\r\n\t\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t\t{\r\n\t\t\t\tfor (int j = 0; j < right.length; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint ref = left[i] + right[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// left[i] + right[j]의 값이 소수일 경우\r\n\t\t\t\t\tif (!IS_NOT_PRIME[ref])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 노드를 연결한다.\r\n\t\t\t\t\t\thasNode[i][j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tLinkedList<Integer> list = new LinkedList<>();\r\n\t\t\t\r\n\t\t\t// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\n\t\t\tfor (int i = 0; i < N / 2; i++)\r\n\t\t\t{\r\n\t\t\t\t// left[0]와 right[i]의 합이 소수일 경우\r\n\t\t\t\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\tselected = i;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint size = bipartite();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 모든 요소가 매칭될 경우\r\n\t\t\t\t\tif (size == N / 2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlist.add(right[selected]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 하나도 매칭되지 않은 경우\r\n\t\t\tif (list.size() == 0)\r\n\t\t\t{\r\n\t\t\t\twriter.write(\"-1\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 매칭이 하나 이상 있을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 오름차순으로 정렬\r\n\t\t\t\tlist.sort(Integer::compareTo);\r\n\t\t\t\t\r\n\t\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\t\t\r\n\t\t\t\tfor (int item : list)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuilder.append(item).append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\twriter.write(builder.toString().trim());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일하지 않을 경우 (이분매칭 불가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"-1\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\t\tint size = 1;\r\n\t\t\r\n\t\tmatched = new int[left.length];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t{\r\n\t\t\tisVisit = new boolean[left.length];\r\n\t\t\t\r\n\t\t\t// 매칭 가능할 경우\r\n\t\t\tif (dfs(i))\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static boolean dfs(int num)\r\n\t{\r\n\t\t// 첫 방문일 경우\r\n\t\tif (!isVisit[num])\r\n\t\t{\r\n\t\t\tisVisit[num] = true;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 아레토스 테네스의 체 배열 반환 함수\r\n\t *\r\n\t * @return [boolean[]] 아레토스 테네스의 체\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tboolean[] isNotPrime = new boolean[2000];\r\n\t\t\r\n\t\tisNotPrime[0] = true;\r\n\t\tisNotPrime[1] = true;\r\n\t\t\r\n\t\tint maxPrime = (int) Math.ceil(Math.sqrt(2000));\r\n\t\t\r\n\t\tfor (int i = 2; i < maxPrime; i++)\r\n\t\t{\r\n\t\t\t// 소수일 경우\r\n\t\t\tif (!isNotPrime[i])\r\n\t\t\t{\r\n\t\t\t\tfor (int j = i + i; j < isNotPrime.length; j += i)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 소수가 아님을 표시하지 않았을 경우\r\n\t\t\t\t\tif (!isNotPrime[j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 소수의 배수는 소수가 아니므로 제외함\r\n\t\t\t\t\t\tisNotPrime[j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPrime;\r\n\t}\r\n}\r\n```\r\n\r\n편의상 항상 왼쪽을 기준으로 매칭한다. 올바른 조합 중 첫 번째 수와 매칭되는 수를 찾는 것이 목표인데, 첫 번째 수는 홀수, 짝수 모두 올 수 있다. 따라서 홀수가 먼저오냐, 짝수가 먼저오냐에 따라 해당하는 분류를 기준 배열로 할당한다.\r\n\r\n``` java\r\n// 첫 번째 수가 홀수일 경우\r\nif (numbers[0] % 2 != 0)\r\n{\r\n\t// 왼쪽 배열에 홀수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n}\r\n\r\n// 첫 번째 수가 짝수일 경우\r\nelse\r\n{\r\n\t// 왼쪽 배열에 짝수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n}\r\n```\r\n\r\n해당 소스는 위와 같다. 왼쪽 배열 `left`를 기준으로하여 홀수가 올 경우 `left`에 홀수 배열을, 아닐 경우 짝수 배열을 할당한다.\r\n\r\n소수 판별은 <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘을 통해, 요소로 올 수 있는 최대값인 2,000개 배열에 대한 소수 배열을 준비한다.\r\n\r\n> **잠깐, 문제에서는 요소로 올 수 있는 최대값이 1,000이라는데요?**  \r\n> 홀수와 짝수를 더하므로, 요소의 최대값은 각 요소의 최대값을 더한 999 + 1,000 = 1,999가 됩니다.\r\n\r\n배열이 2000개까지밖에 안 되므로, 연산할 때마다 비교하는 것 보다 미리 배열을 선언해서 비교하는 게 훨씬 효율적이라 판단했다.  \r\n만약 연산할 때마다 비교하려면, 비교할 수의 제곱근을 구하고, 2부터 제곱근까지 나눈다. 중간에 정확히 나누어 떨어지는 수가 있을 경우, 그 수는 소수가 아니다.\r\n\r\n``` java\r\n// 대상 숫자\r\nint number = 1000;\r\n\r\n// 소수 여부\r\nboolean isPrime = true;\r\n\r\n// 가장 작은 소수인 2부터 대상의 제곱근까지 나누기\r\nfor (int i = 2; i <= Math.sqrt(number); i++)\r\n{\r\n\t// 나누어 떨어지는 수가 있을 경우\r\n\tif (number % i == 0)\r\n\t{\r\n\t\tisPrime = false;\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n대충 위 형식처럼 짜면 된다.\r\n\r\n``` java\r\n// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\nfor (int i = 0; i < N / 2; i++)\r\n{\r\n\t// left[0]와 right[i]의 합이 소수일 경우\r\n\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t{\r\n\t\tselected = i;\r\n\t\t\r\n\t\tint size = bipartite();\r\n\t\t\r\n\t\t// 모든 요소가 매칭될 경우\r\n\t\tif (size == N / 2)\r\n\t\t{\r\n\t\t\tlist.add(right[selected]);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n그룹을 나누었으면, 입력값의 첫 번째 수 $left[0]$와 하나씩 매칭하여 기준 매칭을 선정한다. `!IS_NOT_PRIME[left[0] + right[i]]`을 통해 매칭이 소수일 경우에만 진행한다. 소수가 아닐 경우 비교해볼 필요도 없으니. `selected`는 현재 $left[0]$와 매칭된 요소를 의미한다. 이게 왜 필요하냐면, $left[0]$와 매칭된 요소의 경우 다른 요소와 매칭될 수 없으므로 매칭에서 제외해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501834-a3f88d80-d682-11eb-8e27-968a1c71e342.png\" width=\"600px\" />\r\n</p>\r\n\r\n이는 위 그림과 같이 나타낼 수 있다. 이미 1이 10과 매칭되었으므로, 10과 연결된 7, 11의 노드를 제거해야 정상적으로 매칭할 수 있다. 연결된 노드는 `hasNode` 배열에서 관리하고 있다. 예제 1을 기준으로 `hasNode`의 값은 다음과 같다.\r\n\r\n| $N, M$ |   4   |  10   |  12   |\r\n| :----: | :---: | :---: | :---: |\r\n|   1    | true  | true  | true  |\r\n|   7    | true  | true  | true  |\r\n|   11   | false | false | true  |\r\n\r\n만약 여기서, 1과 10을 매칭할 경우 hasNode는 아래와 같다.\r\n\r\n| $N, M$ |     4     |  **10**   |    12     |\r\n| :----: | :-------: | :-------: | :-------: |\r\n| **1**  | **false** | **true**  | **false** |\r\n|   7    |   true    | **false** |   true    |\r\n|   11   |   false   | **false** |   true    |\r\n\r\n1과 10에 연결된 다른 노드를 모두 제거하고, `hasNode[1][10] = true`로 지정해야 한다. 임시 배열을 선언해서 변경하는 경우도 있겠지만, 배열 연산 오버헤드를 줄이기 위해 `selected = 10`으로 지정하여 DFS 알고리즘 수행 시 `selected`와 동일한 인덱스를 false로 인식하게끔 설계했다.\r\n\r\n``` java\r\n/**\r\n * 이분 매칭 갯수 반환 함수\r\n *\r\n * @return [int] 이분 매칭 갯수\r\n */\r\nprivate static int bipartite()\r\n{\r\n\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\tint size = 1;\r\n\t\r\n\tmatched = new int[left.length];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int i = 1; i < left.length; i++)\r\n\t{\r\n\t\tisVisit = new boolean[left.length];\r\n\t\t\r\n\t\t// 매칭 가능할 경우\r\n\t\tif (dfs(i))\r\n\t\t{\r\n\t\t\tsize++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n\r\n/**\r\n * DFS 알고리즘 결과 반환 함수\r\n *\r\n * @param num: [int] 시작점\r\n *\r\n * @return [int] 매칭 갯수\r\n */\r\nprivate static boolean dfs(int num)\r\n{\r\n\t// 첫 방문일 경우\r\n\tif (!isVisit[num])\r\n\t{\r\n\t\tisVisit[num] = true;\r\n\t\t\r\n\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t{\r\n\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t{\r\n\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n<span class=\"primary\">이분 매칭</span> 소스는 위와 같다. `bipartite()`는 기본적인 이분 매칭 알고리즘과 크게 다르지 않다. `size`가 1부터 시작하는 이유는, 이미 입력의 첫 번째 수 `left[0]`과 합이 소수를 만족하는 `right[m]`과 매칭되었기 때문이다.\r\n\r\n`dfs()`에서 조건에 따라 필터링이 진행된다. 조건식은 `hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]]`와 같다.\r\n\r\n* `hasNode[num][i]`: `left[num]`과 `right[i]`가 서로 연결되어 있는지 (소수)\r\n* `i != selected`: `left[num]`이 `right[i]`와 매칭되지 않았는지\r\n* `!IS_NOT_PRIME[left[num] + right[i]]`: `left[num]`과 `right[i]` 소수인지\r\n\r\n위 조건식을 모두 만족할 경우에만 매칭을 수행한다.\r\n\r\n$N$이 반드시 짝수거나, 입력된 숫자의 홀수, 짝수가 반드시 동일하다는 조건이 존재하지 않으므로, 이 경우 -1을 출력해야한다. 또한, 모든 조건이 일치해도 매칭이 하나도 되지 않을 경우 역시 -1을 출력해야한다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 이분 매칭\r\n* 에라토스 테네스의 체","url":["2021-06-26-A1017","2021","06","26","A1017"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1016번 제곱 ㄴㄴ수","excerpt":"어떤 수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-23T00:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I","에라토스 테네스의 체"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-23-A1016.md","content":"\r\n# 제곱 ㄴㄴ수\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1016번 문제](https://www.acmicpc.net/problem/1016)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n어떤 수 $X$가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 두 정수 min과 max가 주어진다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 [min,max]구간에 제곱ㄴㄴ수가 몇 개인지 출력한다.\r\n\r\n## 제한\r\n\r\n* $1 ≤ \\text{min} ≤ 1,000,000,000,000$\r\n* $\\text{min} ≤ \\text{max} ≤ \\text{min} + 1,000,000$\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 10\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n7\r\n```\r\n\r\n# 풀이\r\n\r\n주어진 구간에서 제곱수(4, 9, 16 등)으로 나누어지지 않는 수의 갯수를 구하면 되는 문제.\r\n\r\n개념은 생각보다 간단하다. <span class=\"primary\">에라토스 테네스의 체</span>에 대해 알고있다면 생각보다 쉽게 접근할 수 있기도 하고. 의외로 문제는 다른 쪽에 있다.\r\n\r\n1. min, max의 최대값이 1조 단위다.\r\n2. 구간이 반드시 1부터 시작하지 않는다.\r\n3. 배열의 인덱스는 반드시 `int` 데이터만 가능하다.\r\n\r\n보편적인 정수 데이터인 `int`의 최대값이 약 21억인걸 감안하면 턱없이 큰 수. 때문에 `long` 데이터의 사용이 강제된다. 반면 배열의 인덱스는 `int` 데이터만 사용 가능하므로, `int`와 `long`의 적절한 데이터 선언 및 변환이 필요하다.\r\n\r\n최소값 <span class=\"lightBlue-A400\">min</span>과 최대값 <span class=\"lightBlue-A400\">max</span>는 그 수가 매우 클 수는 있어도, 그 차이는 백만 이하로만 나오므로 배열로 다루는데 무리가 없다.\r\n\r\n만약, min = 1,000,000,000,000(1조)이고, max = 1,000,000,500,000(1조 50만)일 경우, 실제로 비교해야할 구간은 약 50만개밖에 되지 않는다. 이 구간을 배열 $A$로 표시하면 $A[0] = 1,000,000,000,000\\text{(min)}$가 된다. 즉, $A[i] = i + \\text{min}$으로 다뤄야한다.\r\n\r\n**제곱수의 배수를 제외**해야한다는 점에서 소수의 배수를 제외하여 소수를 판별하는 <span class=\"primary\">에라토스 테네스의 체</span>의 개념와 매우 흡사하다. 즉, <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘에서 소수가 아닌 제곱수의 배수를 판별하게끔 살짝 변형시켜주면 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1016 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/23/A1016/\">1016 풀이</a>\r\n * @since 2021.06.23 Fri 00:22:31\r\n */\r\npublic class Main\r\n{\r\n\t// 최소값\r\n\tprivate static long min;\r\n\t\r\n\t// 최대값\r\n\tprivate static long max;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tlong[] temp = Arrays.stream(reader.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\r\n\t\t\r\n\t\tmin = temp[0];\r\n\t\tmax = temp[1];\r\n\t\t\r\n\t\twriter.write(Integer.toString(solve()));\r\n\t\twriter.newLine();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @return [int] 제곱수로 나누어 떨어지지 않는 수의 갯수\r\n\t */\r\n\tprivate static int solve()\r\n\t{\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tboolean[] isNotPow = eratosthenes();\r\n\t\t\r\n\t\tfor (boolean item : isNotPow)\r\n\t\t{\r\n\t\t\t// 제곱수로 나누어 떨어지지 않는 수일 경우\r\n\t\t\tif (!item)\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 에라토스 테네스의 체 배열 반환 함수\r\n\t *\r\n\t * true: 제곱ㄴㄴ수가 아닌 수\r\n\t * false: 제곱ㄴㄴ수\r\n\t *\r\n\t * @return [boolean[]] 에라토스 테네스의 체 배열\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tint length = (int) (max - min + 1);\r\n\t\t\r\n\t\tboolean[] isNotPow = new boolean[length];\r\n\t\t\r\n\t\tfor (long i = 2; i * i <= max; i++)\r\n\t\t{\r\n\t\t\tlong pow = i * i;\r\n\t\t\t\r\n\t\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\t\r\n\t\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t\t{\r\n\t\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPow;\r\n\t}\r\n}\r\n```\r\n\r\n`solve()` 메소드는 단순히 갯수를 파악하는 로직이므로 그 의도만 알면 된다. 가장 핵심인 부분은 <span class=\"primary\">에라토스 테네스의 체</span>를 변형한 아래 코드다.\r\n\r\n``` java\r\n/**\r\n * 에라토스 테네스의 체 배열 반환 함수\r\n *\r\n * true: 제곱ㄴㄴ수가 아닌 수\r\n * false: 제곱ㄴㄴ수\r\n *\r\n * @return [boolean[]] 에라토스 테네스의 체 배열\r\n */\r\nprivate static boolean[] eratosthenes()\r\n{\r\n\tint length = (int) (max - min + 1);\r\n\t\r\n\tboolean[] isNotPow = new boolean[length];\r\n\t\r\n\tfor (long i = 2; i * i <= max; i++)\r\n\t{\r\n\t\tlong pow = i * i;\r\n\t\t\r\n\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\r\n\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t{\r\n\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn isNotPow;\r\n}\r\n```\r\n\r\n총 2개의 반복문이 돌아간다. 인덱스는 각각 $i$, $j$다.\r\n\r\n* $i$: 제곱수의 제곱근\r\n* $j$: 제곱수의 배수를 구하기 위한 인덱스\r\n\r\n1보다 큰 제곱수는 4이므로, 인덱스 $i$의 시작값은 2이며, 제곱수인 $i^2$의 크기가 max 이하일때 까지 반복한다. 만약, 구간이 10부터 30까지라면, $i$는 2<span class=\"grey-500\">(4)</span>부터 5<span class=\"grey-500\">(25)</span>까지 증가할 것이다.\r\n\r\n인덱스 $j$는 약간 복잡한데, 이는 구간의 존재 때문이다. 기본적으로 <span class=\"primary\">에라토스 테네스의 체</span>는 1부터 시작하므로 상관없지만, 해당 문제는 <span class=\"red-500\">시작값이 1이 아닐 경우</span>가 존재한다.\r\n\r\n예를 들어, $i = 2$이고 구간이 10 ~ 20까지라고 가정하자. $i^2 = 4$이므로 제곱수 4의 배수를 제거해야한다. 만약 평상시처럼 곱셈의 인덱스를 1부터 시작해서 $4 \\times 1$, $4 \\times 2$, $\\dots$와 같이 시작한다면 문제가 생긴다. 구간은 10부터인데 비해, 10 이하인 4, 8을 제거하게되니 이를 걸러내야한다. 만약 구간이 1000부터 시작이라면 250개의 쓸모없는 연산이 발생한다. 구간이 최대 1조부터 시작할 수 있음을 생각한다면 구간의 시작에 따라 곱셈 인덱스 $j$를 적절히 계산해야한다.\r\n\r\n$i = 2$일 경우, $i^2 = 4$이다. 구간의 시작이 10일 경우, 10 이하인 수 $4 \\times 1$, $4 \\times 2$는 건너뛰므로 곱셈 인덱스 $j$는 3부터 시작해야한다.\r\n\r\n$$\r\nj_{\\text{min}} = \r\n\\begin{cases}\r\n\t\\text{min} \\div i^2 \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 == 0)\\\\\r\n\t(\\text{min} \\div i^2) + 1 \\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 \\,\\,\\, !=  0)\r\n\\end{cases}\r\n$$\r\n\r\n즉, 곱셈 인덱스 $j$의 시작값의 일반식은 위와 같다.\r\n\r\n$\\text{제곱수의 배수} = j \\times i^2 \\,\\,\\, (j = 1, 2, 3, \\dots)$이므로, 해당값을 모두 제외하면 된다. 단, $j \\times i^2$는 실제 값이므로, 배열의 인덱스는 $(j \\times i^2) - \\text{min}$이다.\r\n\r\n배열에 `true`를 할당하는 이유는 `boolean[]`의 초기값이 `false`이기 때문. `Arrays.fill()` 메소드를 활용하여 `true`로 초기화할 수도 있으나, 의미론적으론 좋지만 불필요한 연산이므로 `false`를 제곱ㄴㄴ수로, `true`를 제곱ㄴㄴ수가 아닌 수로 지칭한다. 배열 이름이 `isNotPow`인 이유도 이때문.\r\n\r\n이후 `isNotPow` 배열을 순회하며, 값이 `false`인 수만 카운팅하면 된다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 에라토스 테네스의 체","url":["2021-06-23-A1016","2021","06","23","A1016"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1015번 수열 정렬","excerpt":"P[0], P[1], ..., P[N - 1]은 0부터 N - 1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다. 적용하는 방법은 B[P[i]] = A[i]이다. 배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-22T01:23:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER IV","정렬"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-22-A1015.md","content":"\r\n# 수열 정렬\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1015번 문제](https://www.acmicpc.net/problem/1015)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n$P[0], P[1], \\, \\dots \\, P[N - 1]$은 $0$부터 $N - 1$까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 $P$를 길이가 $N$인 배열 $A$에 적용하면 길이가 $N$인 배열 $B$가 된다. 적용하는 방법은 $B[P[i]] = A[i]$이다.\r\n\r\n배열 $A$가 주어졌을 때, 수열 $P$를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 배열 $A$의 크기 $N$이 주어진다. 둘째 줄에는 배열 $A$의 원소가 0번부터 차례대로 주어진다. $N$은 50보다 작거나 같은 자연수이고, 배열의 원소는 1,000보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 비내림차순으로 만드는 수열 $P$를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n2 3 1\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 2 0\r\n```\r\n\r\n# 풀이\r\n\r\n정렬에 대해 잘 알고 있다면 쉬어가는 문제. 한 마디로, <span class=\"amber-A400\">배열 속 요소들을 크기별 등수로 바꾸어 동일한 자리에 표시</span>해주면 된다.\r\n\r\n예제의 경우, 배열 $A$가 $[ 2, 3, 1 ]$로 주어졌는데, 이를 오름차순으로 표시하여 배열 $A1$로 만들면 $[ 1, 2, 3 ]$이 된다. 즉 $A1[0] = 1$이 된다. $A1$의 인덱스를 $A$의 요소의 순서에 맞게 출력하는 것이 알고리즘의 최종 동작이다.\r\n\r\n## 배열 A의 순서 기억하기\r\n\r\n첫 번째로, 정수형 배열의 오름차순 정렬은 매우 쉽다. `Arrays.sort(A);`만 적용해주면 될 일이기 때문. 문제는 정렬한 인덱스를 원본 배열 $A$의 순서대로 출력해야 한다는 것.\r\n\r\n이를 기억하는 장치로 배열 $A$를 2차원 배열로 만들어 $A[i][0]$에는 <span class=\"orange-A400\">i번째 입력값의 값</span>, $A[i][1]$에는 순번 인덱스 <span class=\"orange-A400\">i</span>를 입력한다.\r\n\r\n이를 표로 도식화하면 아래와 같다.\r\n\r\n|    $i$    |   0   |   1   |   2   |\r\n| :-------: | :---: | :---: | :---: |\r\n| $A[i][0]$ |   2   |   3   |   1   |\r\n| $A[i][1]$ |   0   |   1   |   2   |\r\n\r\n따라서 배열 $A$를 정렬해도, 순서를 기억할 수 있게 된다.\r\n\r\n|    $i$    |   0   |   1   |   2   |\r\n| :-------: | :---: | :---: | :---: |\r\n| $A[i][0]$ |   1   |   2   |   3   |\r\n| $A[i][1]$ |   2   |   0   |   1   |\r\n\r\n위 표는 오름차순 정렬을 적용한 것으로, $A[i][1]$을 통해 원래의 순서로 되돌릴 수 있을 것이다.\r\n\r\n## 정렬 후 되돌리기\r\n\r\n배열 $A$에 수열 $P$를 적용한 결과인 $B$를 구한다. 위에서 정렬을 통해 크기 순위를 계산했으므로, 이를 <span class=\"green-A400\">위치에 맞게 순서를 되돌려 출력</span>하면 된다.\r\n\r\n원래의 위치값은 $A[i][1]$이 가지고 있으므로, 이 인덱스를 활용하자. 배열 $B$의 식은 $B[A[i][1]] = i$와 같은 형태로 계산할 수 있다. 예를 들어, $i = 1$일 때 정렬된 배열 $A[1][1] = 0$이므로 $B[0] = 1$이 된다. 이를 코드로 구현하면 완성된다.\r\n\r\n## 이차원 배열 정렬하기\r\n\r\n여기서 작은 문제가 하나 생기는데, 바로 정렬이다. 대표적인 정렬 메소드인 `Arrays.sort(A);`의 경우 1차원 배열에서는 의도에 맞게 동작하나, 그 이상인 $n$차원 배열부터는 의도한대로 동작하지 않는다. 또한 `Arrays.sort(A);`는 무조건 오름차순으로만 동작한다.\r\n\r\n이를 해결하기 위해선, `sort()` 메소드를 직접 오버라이딩하면 된다. 물론 아예 구현해도 되지만, 여기서는 기본 API를 최대한 살려 sort 함수를 우리 의도에 맞게 오버라이딩한다.\r\n\r\n``` java\r\nArrays.sort(A, (next, current) -> {\r\n\t// 다음 원소가 현재 원소보다 클 경우\r\n\tif (next[0] < current[0])\r\n\t{\r\n\t\t// 현재 원소를 다음 원소의 뒤로 정렬\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// 다음 원소가 현재 원소보다 작을 경우\r\n\telse if (next[0] > current[0])\r\n\t{\r\n\t\t// 현재 원소를 다음 원소의 앞으로 정렬\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t// 다음 원소가 현재 원소와 동일할 경우\r\n\telse\r\n\t{\r\n\t\t// 현 위치 유지\r\n\t\treturn 0;\r\n\t}\r\n})\r\n```\r\n\r\n`Comparater` 인터페이스를 lambda 함수의 형태로 구현한 코드다. `current`는 <span class=\"blue-400\">현재 요소</span>를, `next`는 <span class=\"blue-400\">다음 요소</span>를 의미하며 <span class=\"blue-400\">반환값이 양수일 경우 현재 요소가 다음 요소보다 뒤로 정렬</span>되며, <span class=\"blue-400\">반환값이 음수일 경우 현재 요소가 다음 요소보다 앞으로 정렬</span>된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1015 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/22/A1015/\">1015 풀이</a>\r\n * @since 2021.06.22 Tue 01:23:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열의 크기\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 원본 배열\r\n\t\tint[][] A = new int[N][2];\r\n\t\t\r\n\t\t// 정렬 배열\r\n\t\tint[] B = new int[N];\r\n\t\t\r\n\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tA[i][0] = Integer.parseInt(temp[i]);\r\n\t\t\tA[i][1] = i;\r\n\t\t}\r\n\t\t\r\n\t\t// 정렬 수행\r\n\t\tsort(A);\r\n\t\t\r\n\t\tfor (int i = 0; i < N; i++)\r\n\t\t{\r\n\t\t\tint index = A[i][1];\r\n\t\t\t\r\n\t\t\tB[index] = i;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int b : B)\r\n\t\t{\r\n\t\t\tbuilder.append(b).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString().trim());\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 정렬 함수\r\n\t *\r\n\t * @param A: [int[][]] 대상 배열\r\n\t */\r\n\tprivate static void sort(int[][] A)\r\n\t{\r\n\t\tArrays.sort(A, (next, current) -> {\r\n\t\t\t// 현재값이 더 클 경우\r\n\t\t\tif (next[0] < current[0])\r\n\t\t\t{\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 다음값이 더 클 경우\r\n\t\t\telse if (next[0] > current[0])\r\n\t\t\t{\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 현재값과 다음값이 같을 경우, 사전순 정렬\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn Integer.compare(next[1], current[1]);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 정렬","url":["2021-06-22-A1015","2021","06","22","A1015"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1014번 컨닝","excerpt":"최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다. 시험은 N행 X M열 크기의 직사각형 교실에서 이루어진다. 교실은 1 X 1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다. 최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-18T16:42:44","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM IV","네트워크 플로우","최소 버텍스 커버","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-18-A1014.md","content":"\r\n# 컨닝\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1014번 문제](https://www.acmicpc.net/problem/1014)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.\r\n\r\n시험은 $N$행 $\\times$ $M$열 크기의 직사각형 교실에서 이루어진다. 교실은 $1 \\times 1$ 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.\r\n\r\n최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122051353-78bea480-ce1f-11eb-92c3-5fa4e3dc96b9.png\" width=\"500px\" />\r\n</p>\r\n\r\n위의 그림을 보자. $A$, $C$, $D$ 혹은 $E$에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, $B$에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.\r\n\r\n위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.\r\n\r\n최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $C$가 주어진다. 각각의 테스트 케이스는 아래와 같이 두 부분으로 이루어진다.\r\n\r\n첫 번째 부분에서는 교실의 세로길이 N과 가로길이 M이 한 줄에 주어진다. $(1 ≤ M ≤ 10, 1 ≤ N ≤ 10)$\r\n\r\n두 번째 부분에서는 정확하게 N줄이 주어진다. 그리고 각 줄은 M개의 문자로 이루어져있다. 모든 문자는 ‘.’(앉을 수 있는 자리) 또는 ‘x’(앉을 수 없는 자리, 소문자)로 구성된다.\r\n\r\n## 출력\r\n\r\n각각의 테스트 케이스에 대해 그 교실에서 시험을 볼 수 있는 최대 학생의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n4\r\n2 3\r\n...\r\n...\r\n2 3\r\nx.x\r\nxxx\r\n2 3\r\nx.x\r\nx.x\r\n10 10\r\n....x.....\r\n..........\r\n..........\r\n..x.......\r\n..........\r\nx...x.x...\r\n.........x\r\n...x......\r\n........x.\r\n.x...x....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4\r\n1\r\n2\r\n46\r\n```\r\n\r\n# 풀이\r\n\r\n또 한번의 <span class=\"teal-A400\">플래티넘</span> 문제. 하....\r\n\r\n문제 이름 그대로 컨닝을 못 참게 만드는 문제다. 문제를 푸는 방식에는 두 가지가 있다. <span class=\"primary\">네트워크 플로우</span>와 <span class=\"primary\">비트마스킹</span>. 본 포스팅에서는 <span class=\"primary\">네트워크 플로우</span> 방식을 차용한다. 이게 정석이라고 하기도 하고, JAVA 풀이는 죄다 <span class=\"primary\">비트마스킹</span> 방식이라서.\r\n\r\n나 같이 전공지식이 전무한 코더에게는 너무나도 가혹한 문제다. 지금까지 살면서 하나 깨달은 게 있다면, 아무리 처음 보는 개념이라도 계속 쳐다보면 언젠가 이해된다. 하루가 됐든 한 달이 됐든. 그 난리를 펴가며 이해한 내용은 아래와 같다.\r\n\r\n## 문제 분석하기\r\n\r\n문제 해결에 영향을 미치는 조건은 아래와 같다.\r\n\r\n1. 임의의 자리를 기준으로 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위 자리를 컨닝할 수 있다.\r\n2. 파손되어 앉을 수 없는 자리가 존재한다.\r\n\r\n임의의 자리가 있다고 가정하고 이를 도식화해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956338-de7cd480-d3bb-11eb-93ce-5c1ea19185af.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진과 같이 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 자신의 주변엔 최대 8개의 <span class=\"indigo-200\">자리</span>가 존재할 수 있다. 1번 규칙에 따라 컨닝이 가능한 자리를 도식하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956398-eccaf080-d3bb-11eb-9d2b-91e4aaa7ea40.png\" width=\"600px\" />\r\n</p>\r\n\r\n<span class=\"red-400\">컨닝 가능한 자리</span>는 위와 같이 6개로 표시된다. 엥? 분명히 1번 규칙에서는 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위만 가능하다고 했다. 해당 규칙에 따르면 4개 자리여야 할텐데, 왼쪽 대각선 아래, 오른쪽 대각선 아래는 왜 해당되는걸까?\r\n\r\n<span class=\"indigo-A400\">특정 자리</span>에서 왼쪽 대각선 아래, 오른쪽 대각선 아래를 컨닝할 순 없지만, 반대로 왼쪽 대각선 아래, 오른쪽 대각선 아래에선 <span class=\"indigo-A400\">특정 자리</span>를 컨닝할 수 있기 때문. <span class=\"lightBlue-A400\">컨닝을 할 수 있는 자리와 당할 수 있는 자리</span> 모두를 고려해야한다.\r\n\r\n반대로 컨닝이 불가능한 자리를 도식하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956442-f7858580-d3bb-11eb-8154-2bfe476ae278.png\" width=\"600px\" />\r\n</p>\r\n\r\n<span class=\"green-A400\">컨닝이 불가능한 자리</span>는 위와 같이 2개로 표시된다. 자신의 앞 뒤는 컨닝할 수 없다. 우리가 설계한 알고리즘이 이와 같은 결과를 계산할 수 있어야 한다. 그렇다면 이를 어떤 방법으로 해결할 수 있을까?\r\n\r\n이 문제를 해결하는 방법은 크게 두 가지가 있다.\r\n\r\n1. 최소 버텍스 커버, 이분 매칭\r\n2. DP, 비트마스킹\r\n\r\n이 중 1번 최소 버텍스 커버와 이분 매칭을 사용하여 풀고자 한다.\r\n\r\n## Miminum Vertex Cover(최소 버텍스 커버)\r\n\r\n<span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>는 모든 노드가 연결된 점(Vertex)의 최소 집합을 의미한다. 예를 들어, 아래와 같은 그림이 있다고 가정하자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956504-05d3a180-d3bc-11eb-8006-7f22037020b9.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진에서의 $A$ ~ $I$에 해당하는 9개 점이 Vertex, 각 점마다 연결된 선이 노드가 된다. 버텍스가 모든 노드를 커버할 수 있다면 <span class=\"amber-A400\">버텍스 커버</span>라 볼 수 있다. 그 중 <span class=\"green-A400\">모든 노드를 커버하는 가작 적은 버텍스의 집합</span>이 <span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>라 할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956549-108e3680-d3bc-11eb-802e-53765cacf3ed.png\" width=\"600px\" />\r\n</p>\r\n\r\n버텍스 $E$의 경우, 대다수의 노드를 포함하고 있지만 $\\overline{AB}$, $\\overline{BC}$, $\\overline{FI}$ 노드를 포함하지 않으므로 버텍스 $E$만으로는 <span class=\"amber-A400\">최소 버텍스 커버</span> 조합이 될 수 없다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956594-1b48cb80-d3bc-11eb-8b48-cf263fd7bcfe.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같이 $B$, $F$ 버텍스를 포함할 경우 존재하는 모든 노드를 포함하는 가장 적은 버텍스의 조합이므로 <span class=\"amber-A400\">최소 버텍스 커버</span>가 된다.\r\n\r\n유의깊게 봐야할 점은, <span class=\"amber-A400\">최소 버텍스 커버</span>를 통해 <span class=\"primary\">최대 독립 집합</span>을 구할 수 있다. <span class=\"amber-A400\">최소 버텍스 커버</span>에 해당하는 버텍스와 모든 노드를 제거해보자. 아래와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956663-2996e780-d3bc-11eb-97f7-d24bd59126fd.png\" width=\"600px\" />\r\n</p>\r\n\r\n이처럼, 전체 그룹에서 <span class=\"amber-A400\">최소 버텍스 커버</span>를 제거하면 <span class=\"orange-A400\">나머지 버텍스들은 그 어떤 버텍스끼리도 연결되지 않는 독립 버텍스</span>다. <span class=\"amber-A400\">최소 버텍스 커버</span>가 모든 노드를 연결한 버텍스의 최소 집함임을 생각한다면, 이를 뺀 나머지는 어떤 버텍스와도 연결되지 않는 버텍스 집합의 최대 조합이라고 할 수 있다. 즉, 최대 독립 집합 $=$ 전체 그룹 $-$ 최소 버텍스 커버로 표현할 수 있다.\r\n\r\n그래, 그건 그렇다 치고, 위 개념이 이 문제와 무슨 연관성이 있길래 이렇게 장황하게 서술할까? 이번엔 조금 다르게 이 문제와 연관지어 예시를 들어본다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956705-33204f80-d3bc-11eb-8e58-c1c96509d4fe.png\" width=\"600px\" />\r\n</p>\r\n\r\n그 어떤 자리도 파손되지 않은 온전한 9개 자리가 있다고 가정하자. 각 자리별로 컨닝이 가능한 자리를 노드로 연결하면 위와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956771-42070200-d3bc-11eb-908c-fc5c5db4f583.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진에서 <span class=\"amber-A400\">최소 버텍스 커버</span>는 $B$, $E$, $H$가 된다. 이 자리 3개로 위 사진의 모든 노드를 포함할 수 있기 때문이다. 이 자리들을 제거하여 <span class=\"primary\">최대 독립 집합</span>을 표현하면 어떻게 될까?\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956808-4cc19700-d3bc-11eb-82ff-dc32d98960c4.png\" width=\"600px\" />\r\n</p>\r\n\r\n나머지 자리인 $A$, $C$, $D$, $F$, $G$, $H$만 남게 되며, 각 자리는 그 어떤 노드와도 연결되어있지 않다. 이 사진에서의 노드는 컨닝 가능한 자리이므로, **노드가 없다는 것은 컨닝할 수 있는 자리가 없다**는 뜻이 된다. 즉, <span class=\"amber-A400\">최소 버텍스 커버</span> 로직을 설계하는 것이 이번 알고리즘의 키 포인트다.\r\n\r\n## 이분 매칭\r\n\r\n자, <span class=\"amber-A400\">최소 버텍스 커버</span>가 알고리즘의 키인 건 알았으니, 이를 구현하기만 하면 된다. 안타깝게도 <span class=\"amber-A400\">최소 버텍스 커버</span>를 코딩으로 계산하는 것은 매우 복잡한 일이다.\r\n\r\n**König's Theorem**(쾨닉의 정리)에 의하면 <span class=\"red-400\">모든 이분 그래프의 최대 매칭은 최소 버텍스 커버와 같다</span>고 증명한다. 즉, 위 그래프를 이분 그래프로 변경하여 최대 매칭을 구하면 <span class=\"amber-A400\">최소 버텍스 커버</span>를 구할 수 있다는 뜻이다.\r\n\r\n결론적으로, <span class=\"amber-A400\">최소 버텍스 커버</span>를 구하기 위해 <span class=\"teal-A400\">이분 매칭</span> 알고리즘을 구현해야 한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>의 연산에 사용하는 **이분 그래프**는 아래와 같은 특징을 가진다.\r\n\r\n* 모든 정점을 두 그룹으로 나눌 수 있다.\r\n* 모든 노드는 한 그룹에서 다른 그룹으로 연결된다.\r\n* 같은 그룹끼리는 연결되지 않는다.\r\n\r\n고등수학을 배웠다면 우리는 이미 이분 그래프를 접한적이 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956906-6367ee00-d3bc-11eb-8612-b27579146961.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진은 임의의 함수 $f(x)$에 대한 식을 도식화한 것이다. 위 함수 도식은 이분 그래프의 적절한 예시가 될 수 있다. 모든 그룹이 $x$ 혹은 $y$그룹으로 나뉘며, 모든 노드가 $x$에서 $y$로 연결된다.\r\n\r\n**이분 그래프의 매칭**은 각 그룹의 버텍스를 매칭하는 노드의 집합이다. 단, 각 노드의 끝 점은 다른 노드와 중복되지 않는다. **이분 그래프의 최대 매칭**은 이분 그래프의 매칭의 노드 수가 최대인 조합이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956970-71b60a00-d3bc-11eb-9019-0ffaef2ac35b.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같이 연결된 이분 그래프가 있다고 가정하자. $1$번 버텍스를 기준으로 $A$와 $B$에 노드가 연결되어있다. $\\overline{A1}$을 선택할 경우, $\\overline{B1}$은 매칭에서 제외된다. 노드의 끝 선이 $1$번 버텍스로 동일하기 때문이다. 각 노드의 끝 점은 다른 노드와 중복되지 않는다는 말의 의미는 이와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957021-7e3a6280-d3bc-11eb-8b24-07a0662def70.png\" width=\"600px\" />\r\n</p>\r\n\r\n1. $A$와 $1$번 버텍스를 잇는 노드 $\\overline{A1}$을 선택한다.\r\n2. $B$와 $1$번 버텍스를 잇는 노드 $\\overline{B1}$은 노드 $\\overline{A1}$이 $1$번 버텍스를 포함하므로 선택할 수 없다.\r\n3. 노드 $\\overline{A1}$의 시작 버텍스인 $A$에부터 다른 노드가 있는지 탐색한다.\r\n4. $A$ 버텍스와 연결된 다른 노드가 없으므로 노드 $\\overline{A1}$의 선택을 유지한다.\r\n5. $C$와 $1$번 버텍스를 잇는 노드 $\\overline{C1}$을 선택한다.\r\n6. 마지막 버텍스이므로 탐색을 종료하고 갯수를 계산한다.\r\n\r\n이와 같은 과정으로 이분 그래프의 최대 매칭의 수는 `2`가 된다. 물론 최대 매칭의 조합은 여러개가 될 수 있겠지만, 이 알고리즘에선 \"조합\"이 아니라 \"수\"가 중요하므로 경우의 수를 구할 필요는 없다.\r\n\r\n> **이분 그래프의 최대 매칭 조합**  \r\n> 위 그래프의 최대 매칭 조합은 $[ \\overline{A1}, \\overline{C2} ]$, $[ \\overline{A1}, \\overline{C3} ]$, $[ \\overline{B1}, \\overline{C2} ]$, $[ \\overline{B1}, \\overline{C3} ]$으로 최대 매칭의 수는 2이며 4가지 경우의 수가 존재한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>을 문제에 적용하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957080-898d8e00-d3bc-11eb-84f6-7b504b2d93b3.png\" width=\"600px\" />\r\n</p>\r\n\r\n이번엔 조금 복합적인 예시다. 버텍스 $A$와 $E$가 파손되어 앉을 수 없는 상황이다. 이러한 조건에서 컨닝 가능한 자리를 노드로 표현하면 위 사진과 같이 표현할 수 있다. 규칙의 특성 상, 한 쪽 열은 양 옆의 열에 영향을 준다. 즉, 홀수열과 짝수열로 그룹을 나눌 수 있다. 열의 홀짝을 기준으로 나눠 이분 그래프를 표시하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957152-9ca05e00-d3bc-11eb-8a63-1c7ae6e5edfb.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 이분 그래프의 최대 매칭은 2가 된다. 즉, 최소 버텍스 커버의 조합은 $B$, $H$고 파손되서 착석이 불가능한 자리는 $A$, $E$가 된다. 따라서 $C$, $D$, $F$, $G$, $I$가 컨닝 불가능한 자리가 된다. 단순히 자리의 \"수\"만 계산하면 되므로 `컨닝 불가능한 자리 = 전체 자리 - 최소 버텍스 커버 수 - 파손된 자리`가 된다. 따라서 위 그래프의 알고리즘 수행 결과는 5가 된다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>은 <span class=\"blue-400\">BFS(Breadth First Search, 너비 우선 탐색)</span> 혹은 <span class=\"blue-400\">DFS(Depth First Search, 깊이 우선 탐색)</span>으로 구현할 수 있다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1014 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/18/A1014/\">1014 풀이</a>\r\n * @since 2021.06.18 Fri 16:42:44\r\n */\r\npublic class Main\r\n{\r\n\t// 교실 세로 길이 (y)\r\n\tprivate static int N;\r\n\t\r\n\t// 교실 가로 길이 (x)\r\n\tprivate static int M;\r\n\t\r\n\t// 자리 번호\r\n\tprivate static int[][] room;\r\n\t\r\n\t// 컨닝 가능한 자리\r\n\tprivate static boolean[][] nodes;\r\n\t\r\n\t// 방문 횟수\r\n\tprivate static int visitCount;\r\n\t\r\n\t// 버텍스별 방문 횟수\r\n\tprivate static int[] visit;\r\n\t\r\n\t// 버텍스 매칭 여부\r\n\tprivate static int[] matched;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 현재 자리에서 컨닝이 가능한 자리의 위치 상대좌표\r\n\t\tint[][] scopes = { { -1, 1 }, { -1, 0 }, { -1, -1 }, { 1, 1 }, { 1, 0 }, { 1, -1 } };\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint C = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\twhile (C-- > 0)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\tM = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 자리의 파손 여부\r\n\t\t\tboolean[][] canSit = new boolean[N][M];\r\n\t\t\t\r\n\t\t\t// 자리의 번호\r\n\t\t\tint numbering = 1;\r\n\t\t\t\r\n\t\t\t// 파손된 자리의 총 갯수\r\n\t\t\tint broken = 0;\r\n\t\t\t\r\n\t\t\troom = new int[N][M];\r\n\t\t\tnodes = new boolean[N * M][N * M];\r\n\t\t\t\r\n\t\t\tvisitCount = 1;\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\"\");\r\n\t\t\t\t\r\n\t\t\t\tfor (int m = 0; m < M; m++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 자리 번호 기록\r\n\t\t\t\t\troom[n][m] = numbering++;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 앉을 수 있는 경우\r\n\t\t\t\t\tif (temp[m].equals(\".\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 파손된 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// 파손 갯수 1 추가\r\n\t\t\t\t\t\tbroken++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\t// 홀수 열만 대상으로 동작함\r\n\t\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 앉을 수 있는 좌석일 경우\r\n\t\t\t\t\tif (canSit[n][m])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int[] scope : scopes)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// 컨닝 가능성 있는 자리의 상대좌표\r\n\t\t\t\t\t\t\tint no = n + scope[1];\r\n\t\t\t\t\t\t\tint mo = m + scope[0];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 상대좌표가 교실을 벗어나지 않으면서, 앉을 수 있을 경우\r\n\t\t\t\t\t\t\tif (no > -1 && mo > -1 && no < N && mo < M && canSit[no][mo])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// 노드 연결 표시\r\n\t\t\t\t\t\t\t\tnodes[room[n][m] - 1][room[no][mo] - 1] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tint result = bipartite();\r\n\t\t\t\r\n\t\t\twriter.write(Integer.toString(N * M - broken - result));\r\n\t\t\twriter.newLine();\r\n\t\t\twriter.flush();\r\n\t\t}\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 매칭 갯수\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tvisit = new int[N * M];\r\n\t\t\r\n\t\tmatched = new int[N * M];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int n = 0; n < N; n++)\r\n\t\t{\r\n\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t{\r\n\t\t\t\tvisitCount++;\r\n\t\t\t\t\r\n\t\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static int dfs(int num)\r\n\t{\r\n\t\t// 같은 버텍스가 아닐 경우\r\n\t\tif (visit[num] != visitCount)\r\n\t\t{\r\n\t\t\tvisit[num] = visitCount;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t\t{\r\n\t\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\t\tif (nodes[num][i])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn 0;\r\n\t}\r\n}\r\n```\r\n\r\n유의깊게 봐야할 코드는 아래와 같다.\r\n\r\n``` java\r\nprivate static int bipartite()\r\n{\r\n\t// 매칭 갯수\r\n\tint size = 0;\r\n\t\r\n\tvisit = new int[N * M];\r\n\t\r\n\tmatched = new int[N * M];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int n = 0; n < N; n++)\r\n\t{\r\n\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t{\r\n\t\t\tvisitCount++;\r\n\t\t\t\r\n\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n```\r\n\r\n위 코드가 이분매칭을 <span class=\"primary\">DFS 알고리즘</span>을 통해 구현한 것이다.  `for`문의 변수 선언 중 `m += 2`인 이유는 홀수열만 체크하기 위함이다.\r\n\r\n``` java\r\nprivate static int dfs(int num)\r\n{\r\n\t// 같은 버텍스가 아닐 경우\r\n\tif (visit[num] != visitCount)\r\n\t{\r\n\t\tvisit[num] = visitCount;\r\n\t\t\r\n\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t{\r\n\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\tif (nodes[num][i])\r\n\t\t\t{\r\n\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n이분매칭을 구현하는 <span class=\"primary\">DFS 알고리즘</span>의 코드는 위와 같다. `matched` 배열은 -1로 초기화되며, 매칭되는 버텍스의 번호를 할당받는다.\r\n\r\n$A$ 버텍스가 $B$ 버텍스와 연결된 노드 $\\overline{AB}$를 가질 경우, 이를 `matched[A] = B`와 같이 표시한다. 만약, $A$ 버텍스가 $B$ 버텍스를 연결하는 와중에 이미 $B$가 $C$와 연결되어있을 경우, $C$ 버텍스에 $B$가 아닌 다른 버텍스와 연결된 노드가 있는지 확인한다. 만약 가능할 경우, $\\overline{BC}$를 제거하고 $C$와 연결할 수 있는 다른 버텍스를 연결한다. 이후 $\\overline{AB}$를 연결한다.\r\n\r\n이 과정을 반복하여 연결을 수립할 수 있을 경우 1, 없을 경우 0을 반환한다. 이는 `boolean` 타입으로도 대체할 수 있으나, `dfs()`연산 결과를 더하기 때문에 편의상 `int`로 반환한다.\r\n\r\n## 비공식 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n10 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n42\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n21\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 8\r\n.X...X..\r\n..X.....\r\nX.......\r\n.X......\r\n..X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n18\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 7\r\nX...X..\r\n.X.....\r\n.......\r\nX......\r\n.X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n17\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 비트마스킹\r\n* 최대 유량\r\n* 비트필드를 이용한 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n[습격자 초라기](/posts/2021/06/06/A1006/)가 매우 복잡한 케이스들을 이해하는데 할애했다면, 이 문제는 케이스가 복잡하다기 보단, 네트워크 플로우를 이해하고 적용하는데 대부분의 시간을 할애했다. 문제 보니까 가면 갈수록 플래티넘이 계속해서 나오는 구간도 있던데, 순서대로 푸는 규칙에 대해 진지하게 생각해봐야하나 싶다.\r\n\r\n## 참고\r\n\r\n* [개발괴발](https://m.blog.naver.com/kelle111/221537563173)\r\n* [Crocus](https://www.crocus.co.kr/814)","url":["2021-06-18-A1014","2021","06","18","A1014"]},{"header":{"title":"IntelliJ(인텔리제이) 시작 시 오류(java.net.BindException: Address already in use: bind)","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/121893356-d6d48480-cd58-11eb-80bb-d4611be3bd40.png","date":"2021-06-14T21:59:16","type":"posts","category":"JAVA","tag":["IntelliJ(인텔리제이)","Hyper-V","오류 해결책"],"comment":true,"publish":true},"name":"2021-06-14-intellij-error-onstart.md","content":"\r\n# 않이 갑자기 왜요ㅠㅠ\r\n\r\n분명히 어제까지만 해도 아무 이상없이 썼던 <span class=\"primary\">IntelliJ</span>를 퇴근 후에 키니 오류를 뱉으며 뻗어버렸다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121893316-c6bca500-cd58-11eb-9c2a-658c604ee6d1.png\" width=\"600px\" />\r\n</p>\r\n\r\n두 개의 오류창이 떴는데, 하나는 위와 같은 <span class=\"red-A400\">java.net.BindException: Address already in use: bind</span>에러였고 다른 하나는 왠 <span class=\"red-A400\">NullPointerException</span>이 떴었다. 하필 <span class=\"red-A400\">NullPointerException</span>이 맨 위에 뜨는 바람에 엉뚱한걸 찾고 있었는데, 창 옮기니까 뒤에 저 오류창이 숨어있었다.\r\n\r\n# 원인?\r\n\r\nWindows의 가상 OS머신인 <span class=\"lightBlue-A400\">Hyper-V</span>와 연관이 있는 모양이다. Windows 부팅 시 <span class=\"lightBlue-A400\">Hyper-V</span>에서 자신이 사용할 포트를 지정하는데, 이게 <span class=\"primary\">IntelliJ</span>와 겹쳐서 생긴다고 한다. 아니 갑자기 이제와서?\r\n\r\n실제로 난 <span class=\"lightBlue-A400\">Hyper-V</span>를 사용한다. CentOS 8과 Windows 10을 구동하고 있다. CentOS 8은 리눅스도 다뤄볼 겸 DB 하나 설치해서, 집에서 코딩할 때 DB 쓸 일 있으면 전부 저기다가 갖다 붙여서 쓰고 있다. Windows 10은 클린 PC가 필요하거나, 내가 극혐해 마지않는 인터넷뱅킹을 할 때 사용 중 ~~(플러그인 ㅂㄷㅂㄷ.....)~~ 이긴 한데, 거의 3개월 가까이 사용한 적이 없다. 간혹 Windows Update가 설정을 지멋대로 변경하기도 한다는데 그 때문인가.. 갑자기 잘 되던게 어떠한 문제로 인해 안 된다고 하는 경우가 왕왕있다. 지금까지 잘 돌아간 이유는 내가 알지 못 하는 어떤 신비의 힘이라도 작용했는 모양이다.\r\n\r\n# 해결방법\r\n\r\n<span class=\"green-A400\">윈도우 콘솔을 관리자 권한으로 실행</span>한다. <span class=\"primary\">cmd</span>, <span class=\"primary\">PowerShell</span> 등 어떠한 콘솔이든 명령어만 보낼 수 있으면 상관없다. 콘솔에 아래의 명령어를 입력한다.\r\n\r\n``` batch\r\n# Hyper-V 비활성화 (윈도우 재부팅 필요)\r\ndism.exe /Online /Disable-Feature:Microsoft-Hyper-V\r\n\r\n# TCPv6 6942 ~ 6952 포트 예약\r\nnetsh int ipv6 add excludedportrange protocol=tcp startport=6942 numberofports=10\r\n\r\n# Hyper-V 활성화 (윈도우 재부팅 필요)\r\ndism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All\r\n```\r\n\r\n<span class=\"lightBlue-A400\">Hyper-V</span> 활성화/비활성화에 각각 재부팅을 요구한다. 이후 <span class=\"primary\">IntelliJ</span>는 정상적으로 켜지는데, <span class=\"lightBlue-A400\">Hyper-V</span>가 제대로 안 되는 거 같았다. OS를 켜도 \"시작하는 중\"에서 넘어가질 않는다. <span class=\"lightBlue-A400\">Hyper-V</span> 기능 재설치하고 재부팅하고 다시 시도했는데 안 된다.... 싶었는데 냅둬놓고 기다리니 잘 되더라. IntelliJ 계열 프로그램 모두에게 발생 가능성이 있다고 한다.\r\n\r\n개운하진 않지만, 어쨌든 잘 해결됐으니 다행.","url":["2021-06-14-intellij-error-onstart","2021","06","14","intellij-error-onstart"]},{"header":{"title":"[JAVA] split vs StringTokenizer","excerpt":"알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.","coverImage":"https://www.textrazor.com/img/letters3.png","date":"2021-06-14T01:56:01","type":"posts","category":"JAVA","tag":["JAVA(자바)","String(문자열)","split","StringTokenizer"],"comment":true,"publish":true},"name":"2021-06-14-split-and-stringtokenizer.md","content":"\r\n# 개요\r\n\r\n알고리즘을 풀다보면, 필연적으로 입력값 처리를 하게된다. 다양한 케이스에 대응하기 위해, 사용자의 값을 직접 입력받아 이를 처리하게 된다. 이 때, 우리는 십중팔구 이와 같은 상황이 발생한다. 데이터셋을 보내기 위해 데이터의 모음을 구분자(공백 혹은 쉼표)를 통해 하나의 문자열로 합쳐 전달한다.\r\n\r\n$$\r\n[ \"A\", \"B\", \"C\", \"D\" ] -> \"A B C D\"\r\n$$\r\n\r\n이를테면, 위와 같이 $[ \"A\", \"B\", \"C\", \"D\" ]$와 같은 배열을 전달하기 위해, 각 요소를 공백으로 구분하여 $\"A B C D\"$와 같이 전달하게 된다. 보통 내 경우 `split` 메소드를 활용하는데, 알고리즘 풀이를 찾아보다보니 `StringTokenizer`이라는 <span class=\"orange-400\">class</span>를 쓰는 코드들이 더러있었다. 처음보는 <span class=\"orange-400\">class</span>인데다, 접근성이 훨씬 뛰어난 `split`를 굳이 대체해서 쓰는 이유가 있을거라 판단. 직접 퍼포먼스를 비교해보기로 했다. 알고리즘은 수행속도 역시 중요한 지표로 작용하기 때문에, 조금이라도 시간을 줄일 필요가 있다. 안타깝게도 나는 코드 최적화 실력이 최악이라, 이런식으로 줄일 수 있는 자잘한 부분은 줄여야한다. 핵심 코드를 최적화할 생각은 안 하고 이런데서 시간을 단축하는게 꼭 다이어트한답시고 피자 먹으면서 제로콜라 마시는 느낌이긴 하나, `StringTokenizer`이 더 성능이 뛰어나다면 앞으로 푸는 알고리즘에 적용할 가치가 있을 것이다.\r\n\r\n## 테스트 환경\r\n\r\n| 구분  |                                                        내용                                                         |\r\n| :---: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| 언어  | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n|  OS   |                                                  Windows 10 64bit                                                   |\r\n|  CPU  |                                                   Intel i7-10700K                                                   |\r\n|  RAM  |                                                        32GB                                                         |\r\n\r\n# split 메소드\r\n\r\n`split` 메소드는 특정 <span class=\"lightBlue-400\">구분자</span>로 문자열을 분리하는 전통적인 메소드다. 굳이 JAVA가 아니더라도 C(++, #), JavaScript, Python 등 여러 언어에 존재하는 키워드라 어떤 언어든 문자열을 구분할 때 제일 먼저 시도하는 방법이다.\r\n\r\nJAVA의 `split`은 문자열 데이터 형식인 `String` <span class=\"orange-400\">class</span>에 포함된 메소드다. 문자열 데이터라면 `split`를 호출하여 문자열을 구분할 수 있다. 반환값은 `String[]` 객체.\r\n\r\n사용법은 아래와 같다.\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.13 Sun 22:50:57\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tString text = \"A B C D\";\r\n\t\t\r\n\t\tString[] splited = text.split(\" \");\r\n\t\t\r\n\t\tSystem.out.println(Arrays.toString(splited));\r\n\t}\r\n}\r\n```\r\n\r\n출력은 아래와 같다.\r\n\r\n``` tc\r\n[A, B, C, D]\r\n```\r\n\r\n문자열 `A B C D`가 공백을 기준으로 `[A, B, C, D]`로 분리된걸 확인할 수 있다. 그 밖에 한 가지 특이한 점이 있는데, JAVA의 `split` 메소드는 <span class=\"red-A400\">구분자에 정규식을 적용</span>할 수 있다. 이를 잘만 이용하면 복합적인 구분자를 사용할 수도 있다.\r\n\r\n# StringTokenizer\r\n\r\n이 포스팅을 쓰게 만든 직접적인 원인. `StringTokenizer` 역시 문자열을 구분하는데 특화된 <span class=\"orange-400\">class</span>의 일종이다. `String[]`을 반환하는 `split`과 달리 그 자체로 하나의 개별적인 <span class=\"orange-400\">class</span>라는 차이가 있다.\r\n\r\n`StringTokenizer tokenizer = new StringTokenizer(\"문자열\");`과 같은 형태로 초기화해서 사용한다. `StringTokenizer` 인스턴스를 사용하는데 알아두면 좋을법한 메소드는 아래와 같다.\r\n\r\n|    메소드     | 반환값  |         내용          |\r\n| :-----------: | :-----: | :-------------------: |\r\n|  countToken   |   int   |      토큰의 갯수      |\r\n|   nextToken   | String  |       다음 토큰       |\r\n| hasMoreTokens | boolean | 다음 토큰의 존재 유무 |\r\n\r\n`StringTokenizer tokenizer = new StringTokenizer(\"문자열\", \"구분자\");`와 같이 생성자의 인수에 구분자를 추가하여 원하는 구분자로 구분하게 할 수도 있다. 별도로 지정하지 않는다면 구분자는 `\\t\\n\\r\\t`로, 줄바꿈, 공백, 탭을 구분한다. 여기서 주의할 점이 하나 있는데, 기본 구분자 `\\t\\n\\r\\t`는 <span class=\"red-A400\">줄바꿈, 공백, 탭을 전부 포함</span>한다. 즉, `A B C D\\nA B C D`와 같이 공백과 줄바꿈이 혼용되어 있을 경우, 공백과 줄바꿈을 전부 구분하여 `[A, B, C, D, A, B, C, D]`와 같이 출력된다. 생성자에 구분자를 강제로 지정해줄 경우, 이를 막을 수 있다. 직접 지정할 경우 공백이나 줄바꿈이 아니더라도 여러 문자열을 사용할 수 있다.\r\n\r\n``` java\r\nimport java.util.Arrays;\r\nimport java.util.StringTokenizer;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.13 Sun 23:48:14\r\n */\r\npublic class Test\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tString text = \"A B C D\";\r\n\t\t\r\n\t\tStringTokenizer tokenizer = new StringTokenizer(text);\r\n\t\t\r\n\t\tString[] splited = new String[tokenizer.countTokens()];\r\n\t\t\r\n\t\tfor (int i = 0; i < splited.length; i++)\r\n\t\t{\r\n\t\t\tsplited[i] = tokenizer.nextToken();\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(Arrays.toString(splited));\r\n\t}\r\n}\r\n```\r\n\r\n출력은 동일하다.\r\n\r\n``` tc\r\n[A, B, C, D]\r\n```\r\n\r\n# 속도 비교\r\n\r\n그렇다면 `split`과 `StringTokenizer`의 성능은 어떨까? 이를 비교하기 위해 간단한 테스트 프로그램을 만들었다.\r\n\r\n1. 반복횟수 `t`가 할당된다.\r\n2. 케이스마다 5 ~ 20자의 랜덤한 문자열을 생성한다. 각 문자 사이엔 공백이 포함된다.\r\n3. 공백을 구분자로 문자열을 구분한다\r\n   1. `split` 사용\r\n   2. `StringTokenizer` 사용\r\n4. 총 소요 시간 및 평균 소요 시간을 계산한다\r\n5. 결과를 표시한다\r\n\r\n소스는 아래와 같다.\r\n\r\n``` java\r\nimport java.text.DecimalFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Random;\r\nimport java.util.StringTokenizer;\r\n\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tint t = 10000;\r\n\t\t\r\n\t\tlong[] timer = { 0, 0 };\r\n\t\t\r\n\t\tint[] sum = { 0, 0 };\r\n\t\t\r\n\t\tfor (int i = 0; i < t; i++)\r\n\t\t{\r\n\t\t\tint random = (int) ((Math.random() * (20 - 5)) + 5);\r\n\t\t\t\r\n\t\t\tString text = getTestString(random);\r\n\t\t\t\r\n\t\t\t// split 로직 ----------------------------------------\r\n\t\t\tlong timeStart = System.nanoTime();\r\n\t\t\t\r\n\t\t\tString[] a1 = useSplit(text);\r\n\t\t\t\r\n\t\t\tlong timeEnd = System.nanoTime() - timeStart;\r\n\t\t\t\r\n\t\t\tsum[0] += a1.length;\r\n\t\t\t\r\n\t\t\ttimer[0] += timeEnd;\r\n\t\t\t\r\n\t\t\tSystem.out.println(Arrays.toString(a1) + \": \" + addComma(timeEnd) + \"ns\");\r\n\t\t\t// split 로직 ----------------------------------------\r\n\t\t\t\r\n\t\t\t// StringTokenizer 로직 ----------------------------------------\r\n\t\t\ttimeStart = System.nanoTime();\r\n\t\t\t\r\n\t\t\tString[] a2 = useStringTokenizer(text);\r\n\t\t\t\r\n\t\t\ttimeEnd = System.nanoTime() - timeStart;\r\n\t\t\t\r\n\t\t\tsum[1] += a2.length;\r\n\t\t\t\r\n\t\t\ttimer[1] += timeEnd;\r\n\t\t\t\r\n\t\t\tSystem.out.println(Arrays.toString(a2) + \": \" + addComma(timeEnd) + \"ns\");\r\n\t\t\t// StringTokenizer 로직 ----------------------------------------\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(addComma(t) + \"개 데이터 그룹 수행\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"split 결과\");\r\n\t\tSystem.out.println(\" * 총 소요: \" + addComma(timer[0]) + \"ns\");\r\n\t\tSystem.out.println(\" * 평균 소요: \" + addComma((timer[0] / t)) + \"ns\");\r\n\t\tSystem.out.println(\" * 분해한 요소: \" + addComma(sum[0]) + \"개\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"StringTokenizer 결과\");\r\n\t\tSystem.out.println(\" * 총 소요: \" + addComma(timer[1]) + \"ns\");\r\n\t\tSystem.out.println(\" * 평균 소요: \" + addComma((timer[1] / t)) + \"ns\");\r\n\t\tSystem.out.println(\" * 분해한 요소: \" + addComma(sum[1]) + \"개\");\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tSystem.out.println(\"split \" + (timer[0] == timer[1] ? \"==\" : (timer[0] > timer[1]) ? \"<\" : \">\") + \" StringTokenizer\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 구분된 문자열 반환 함수 (split)\r\n\t *\r\n\t * @param text: [String] 대상 문자열\r\n\t *\r\n\t * @return [String[]] 구분된 문자열\r\n\t */\r\n\tprivate static String[] useSplit(String text)\r\n\t{\r\n\t\treturn text.split(\" \");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 구분된 문자열 반환 함수 (StringTokenizer)\r\n\t *\r\n\t * @param text: [String] 대상 문자열\r\n\t *\r\n\t * @return [String[]] 구분된 문자열\r\n\t */\r\n\tprivate static String[] useStringTokenizer(String text)\r\n\t{\r\n\t\tStringTokenizer tokenizer = new StringTokenizer(text, \" \");\r\n\t\t\r\n\t\tint count = tokenizer.countTokens();\r\n\t\t\r\n\t\tString[] result = new String[count];\r\n\t\t\r\n\t\tfor (int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tresult[i] = tokenizer.nextToken();\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무작위 문자열 반환 함수\r\n\t *\r\n\t * @param n: [int] 문자 갯수\r\n\t *\r\n\t * @return [String] 무작위 문자\r\n\t */\r\n\tprivate static String getTestString(int n)\r\n\t{\r\n\t\tRandom random = new Random();\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tbuilder.append((char) ((random.nextInt(26)) + 97)).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\treturn builder.toString().trim();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 1000 단위 구분 숫자 반환 함수\r\n\t *\r\n\t * @param num: [long] 대상 숫자\r\n\t *\r\n\t * @return [String] 1000 단위 구분 숫자\r\n\t */\r\n\tprivate static String addComma(long num)\r\n\t{\r\n\t\tDecimalFormat format = new DecimalFormat(\",###\");\r\n\t\t\r\n\t\treturn format.format(num);\r\n\t}\r\n}\r\n```\r\n\r\n횟수별로 10번씩 돌린 결과를 아래의 표로 정리했다.\r\n\r\n* $t = 1$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    80.3us     |         44.8us          | split < StringTokenizer |\r\n|      2      |    83.7us     |         46.2us          | split < StringTokenizer |\r\n|      3      |    136.6us    |         31.8us          | split < StringTokenizer |\r\n|      4      |    111.3us    |         40.4us          | split < StringTokenizer |\r\n|      5      |    93.4us     |         32.2us          | split < StringTokenizer |\r\n|      6      |    104.5us    |         28.7us          | split < StringTokenizer |\r\n|      7      |    40.1us     |         42.7us          | split > StringTokenizer |\r\n|      8      |    40.1us     |         42.7us          | split > StringTokenizer |\r\n|      9      |    104.7us    |         28.3us          | split < StringTokenizer |\r\n|     10      |    38.3us     |         29.2us          | split < StringTokenizer |\r\n\r\n한 번만 반복할 경우, 8:2로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 100$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    1.12ms     |         0.602ms         | split < StringTokenizer |\r\n|      2      |    1.11ms     |         0.612ms         | split < StringTokenizer |\r\n|      3      |    1.06ms     |         0.562ms         | split < StringTokenizer |\r\n|      4      |    1.02ms     |         0.595ms         | split < StringTokenizer |\r\n|      5      |     1.ms      |         0.550ms         | split < StringTokenizer |\r\n|      6      |    1.16ms     |         0.651ms         | split < StringTokenizer |\r\n|      7      |     98ms      |         0.558ms         | split < StringTokenizer |\r\n|      8      |    1.11ms     |         0.627ms         | split < StringTokenizer |\r\n|      9      |    0.981ms    |         0.555ms         | split < StringTokenizer |\r\n|     10      |    1.23ms     |         0.666ms         | split < StringTokenizer |\r\n\r\n100번을 반복할 때 역시 10:0으로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 1,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    3.00ms     |         3.17ms          | split > StringTokenizer |\r\n|      2      |    2.53ms     |         2.71ms          | split > StringTokenizer |\r\n|      3      |    2.79ms     |         2.84ms          | split > StringTokenizer |\r\n|      4      |    2.53ms     |         2.67ms          | split > StringTokenizer |\r\n|      5      |    2.67ms     |         2.97ms          | split > StringTokenizer |\r\n|      6      |    2.58ms     |         2.87ms          | split > StringTokenizer |\r\n|      7      |    2.48ms     |         2.65ms          | split > StringTokenizer |\r\n|      8      |    2.69ms     |         3.01ms          | split > StringTokenizer |\r\n|      9      |    2.50ms     |         2.90ms          | split > StringTokenizer |\r\n|     10      |    2.62ms     |         2.94ms          | split > StringTokenizer |\r\n\r\n$2^1$, $2^3$처럼 끊어가다가 뜬금없이 1000을 넣은 이유는, 이상하게 $t = 1,000$일 땐 `split`이 압승한다.\r\n\r\n* $t = 10,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |    9.91ms     |         9.27ms          | split < StringTokenizer |\r\n|      2      |    9.49ms     |         9.19ms          | split < StringTokenizer |\r\n|      3      |    9.02ms     |         8.61ms          | split < StringTokenizer |\r\n|      4      |    9.95ms     |         9.25ms          | split < StringTokenizer |\r\n|      5      |    9.03ms     |         8.87ms          | split < StringTokenizer |\r\n|      6      |    8.83ms     |         9.08ms          | split > StringTokenizer |\r\n|      7      |    9.14ms     |         8.68ms          | split < StringTokenizer |\r\n|      8      |    9.28ms     |         9.07ms          | split < StringTokenizer |\r\n|      9      |    9.49ms     |         9.66ms          | split > StringTokenizer |\r\n|     10      |    11.79ms    |         11.20ms         | split < StringTokenizer |\r\n\r\n다시 8:2로 `StringTokenizer`이 압승한다.\r\n\r\n* $t = 1,000,000$\r\n\r\n| 테스트 횟수 | split 총 소요 | StringTokenizer 총 소요 |          속도           |\r\n| :---------: | :-----------: | :---------------------: | :---------------------: |\r\n|      1      |   306.86ms    |        373.06ms         | split > StringTokenizer |\r\n|      2      |   287.26ms    |        262.05ms         | split < StringTokenizer |\r\n|      3      |   289.92ms    |        255.51ms         | split < StringTokenizer |\r\n|      4      |   272.43ms    |        267.96ms         | split < StringTokenizer |\r\n|      5      |   278.35ms    |        322.28ms         | split > StringTokenizer |\r\n|      6      |   285.23ms    |        264.57ms         | split < StringTokenizer |\r\n|      7      |   273.37ms    |        268.18ms         | split < StringTokenizer |\r\n|      8      |   278.65ms    |        264.34ms         | split < StringTokenizer |\r\n|      9      |   278.56ms    |        266.62ms         | split < StringTokenizer |\r\n|     10      |   306.00ms    |        256.56ms         | split < StringTokenizer |\r\n\r\n8:2로 `StringTokenizer`이 압승한다.\r\n\r\n$t = 1,000$이라는 특수한 상황을 제외하고는 보편적으로 `StringTokenizer`가 성능이 더 우수하다. 저런 현상이 왜 발생하는지 이해는 잘 안 된다. 물론 통계라는게 숫자가 클 수록 의미가 커지므로 10번이라는 작은 횟수만으로 단정짓긴 어렵다.\r\n\r\n회사 컴퓨터(AMD Ryzen 2700X)에서는 모든 케이스에서 `StringTokenizer`의 속도가 빨랐다. CPU에 따라 연산 결과나 방식에 조금씩 차이가 있을 순 있겠다.\r\n\r\n[JAVA API](https://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html)에 의하면, `StringTokenizer`은 하위 호환성을 보장하기 위한 레거시 클래스라고 한다. JAVA API는 가급적 `StringTokenizer`보다 `split` 내지는 `regex` <span class=\"orange-400\">패키지</span>를 활용하도록 권고하고 있다.\r\n\r\n> **원문**  \r\n> `StringTokenizer` is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the `split` method of String or the `java.util.regex` package instead.\r\n\r\n# 결론\r\n\r\n표의 수치 상 `StringTokenizer`가 `split`에 비해 최대 약 20% 정도 더 빠르다. 하지만 JAVA API에서 가급적 다른 대체제를 사용하도록 권고하고 있고, 백만번의 연산에도 $ms$ 단위에서 움직인다. 상대적으론 차이가 있어도 객관적인 지표로 봤을땐 별다른 차이가 없는 셈. 문자열 분리하자고 새로운 <span class=\"orange-400\">class</span>를 다룰 바에 그냥 문자열 자체를 다루는 `split`을 사용하는 게 더 효율적이라 생각한다.","url":["2021-06-14-split-and-stringtokenizer","2021","06","14","split-and-stringtokenizer"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1013번 Contact","excerpt":"푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다. 이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-13T04:53:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","정규 표현식","GOLD","GOLD V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-13-A1013.md","content":"\r\n# Contact\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1013번 문제](https://www.acmicpc.net/problem/1013)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n> “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”\r\n\r\n푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다.\r\n\r\n이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.\r\n\r\n전파의 기본 단위는 $\\{ 0 , 1 \\}$ 두 가지로 구성되어있으며, $x+ (  )$ 는 임의의 개수(최소 1개) $x$의 반복으로 이루어진 전파의 집합을 나타낸다.\r\n\r\n$(xyx)+ (  )$ 는 괄호 내의 $xyx$의 반복으로 이루어진 전파의 집합을 뜻한다. 아래는 이해를 돕기 위한 예제이다.\r\n\r\n* 1+ = { 1, 11, 111, 1111, 11111, … }\r\n* 10+ = { 10, 100, 1000, 10000, 100000, … }\r\n* (01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }\r\n* (1001)+ = { 1001, 10011001, 100110011001, … }\r\n* 10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }\r\n* (10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }\r\n\r\n반복을 의미하는 + 외에도 or 를 의미하는 $|$ 기호가 있다. $\\{ x | y \\}$ 는 $x$ 혹은 $y$를 의미하는 것으로, $\\{ 0+ | 1+ \\}$ 는 $\\{ 0 , 1 , 00 , 11 , 000 , 111 , \\dotsm \\}$ 의 집합을 의미한다. 아래는 두 기호를 복합적으로 사용한 예이다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n최근 김동혁 박사는 아레시보 전파망원경에서 star Vega(직녀성) 으로부터 수신한 전파 기록의 일부를 조사하여 그 전파들의 패턴을 분석하여 아래와 같이 기록하였다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n김동혁 박사는 다양한 전파 기록 중에서 위의 패턴을 지니는 전파를 가려내는 프로그램을 필요로 한다. 이를 수행할 수 있는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 전파를 표현하는, $\\{ 0, 1 \\}$만으로 이루어진 문자열이 공백 없이 주어진다. 문자열 길이는 $(1 ≤ N ≤ 200)$의 범위를 갖는다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 전파가 문제에서 제시한 패턴이면 “YES”를 그렇지 않은 경우는 “NO”를 출력한다. 출력 문자열은 모두 대문자로 구성되어 있다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n10010111\r\n011000100110001\r\n0110001011001\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\nNO\r\nNO\r\nYES\r\n```\r\n\r\n# 풀이\r\n\r\n정규식을 대강 알고있다면 이게 왜 <span class=\"amber-A400\">GOLD V</span>인지 다소 이해되지 않는 수준의 문제다. 정규식이 어려운 이유는 원하는 패턴에 맞춰 정규식을 설계하는 건데, 그 정규식을 대놓고 준다. 사실상 정규식의 개념을 아냐 모르느냐를 물어보는 문제.\r\n\r\n나의 경우, 일하다가 간간히 쓸 일이 생겨서 몇 번 다뤄본적이 있어 그리 생소하지 않았다. [regexr](https://regexr.com/)에서 정규식을 설계하고 테스트를 할 수 있으니 참고하자. 정규식 관련해서는 유명한 사이트.\r\n\r\n문제에 대놓고 $(100+1+ | 01)+$라는 정규식 자체를 제공하기 때문에, 그냥 문자열 받아서 정규식과 일치하는지 보면 된다.\r\n\r\nJAVA에서는 `Pattern.matches({정규식 문자열}, {문자열});`과 같이 사용하며, 일치여부를 `boolean`으로 반환한다.\r\n\r\n아래 소스를 보면 알겠지만 진짜 간단하다. 정규식을 아는 사람에겐 <span class=\"brown-500\">BRONZE</span> 수준의 문제.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * 백준 전체 1013 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/13/A1013/\">1013 풀이</a>\r\n * @since 2021.06.13 Sun 04:34:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString text = reader.readLine();\r\n\t\t\t\r\n\t\t\t// 정규식 일치 여부\r\n\t\t\tString result = Pattern.matches(\"(100+1+|01)+\", text) ? \"YES\" : \"NO\";\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 문자열\r\n* 정규 표현식\r\n\r\n## 여담\r\n\r\n문제가 생각보다 쉬워서, \"사실 이렇게 하면 안 되는게 아닐까?\"하고 찾아보니 역시나 다른 방식으로 접근하는 방법이 공유되어 있었다. 정규표현식이 아닌 DFA(오토마타 전이 그래프)를 활용하는 방식이다. 정규표현식을 공식적으로 지원해주지 않는 언어라면 대체제로 시도해봄직하다. 백준에선 외부 라이브러리를 사용할 수 없을테니.","url":["2021-06-13-A1013","2021","06","13","A1013"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1012번 유기농 배추","excerpt":"차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-13T01:42:10","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","DFS(깊이 우선 탐색)","BFS(너비 우선 탐색)","SILVER","SILVER II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-13-A1012.md","content":"\r\n# 유기농 배추\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1012번 문제](https://www.acmicpc.net/problem/1012)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)\r\n\r\n한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.\r\n\r\n예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.\r\n\r\n(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">0</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t\t<td align=\"center\">1</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 $M(1 ≤ M ≤ 50)$과 세로길이 $N(1 ≤ N ≤ 50)$, 그리고 배추가 심어져 있는 위치의 개수 $K(1 ≤ K ≤ 2500)$이 주어진다. 그 다음 $K$줄에는 배추의 위치 $X(0 ≤ X ≤ M-1)$, $Y(0 ≤ Y ≤ N-1)$가 주어진다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n10 8 17\r\n0 0\r\n1 0\r\n1 1\r\n4 2\r\n4 3\r\n4 5\r\n2 4\r\n3 4\r\n7 4\r\n8 4\r\n9 4\r\n7 5\r\n8 5\r\n9 5\r\n7 6\r\n8 6\r\n9 6\r\n10 10 1\r\n5 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n5\r\n1\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 3 6\r\n0 2\r\n1 2\r\n2 2\r\n3 2\r\n4 2\r\n4 0\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n2\r\n```\r\n\r\n# 풀이\r\n\r\n<span class=\"primary\">DFS(깊이 우선 탐색)</span> 혹은 <span class=\"primary\">BFS(너비 우선 탐색)</span>을 활용하는 기본적인 알고리즘. 추가적인 연산 없이 두 알고리즘 중 익숙한걸 적용하면 끝난다.\r\n\r\n배추흰지렁이는 배추 위에 놓을 수 있으며, 이 벌레는 <span class=\"green-A400\">배추에서 상하좌우로 인접한 배추로 이동</span>할 수 있다. 즉, 배추가 상하좌우로 연결되어있는 구역들의 갯수가 벌레가 필요한 갯수다.\r\n\r\n문제에 예시로 주어진 테이블을 기준으로 보면 아래와 같이 배추가 심어진 구역을 나눌 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121783894-45e09a80-cbec-11eb-99b4-5ed3f3acecd1.png\" width=\"500px\" />\r\n</p>\r\n\r\n위 그림과 같이 총 5개의 구역이 있으므로 벌레 또한 5마리가 필요하다.\r\n\r\nDFS를 적용하면 아래와 같은 절차로 동작한다.\r\n\r\n1. 현재 구역에 배추가 있는지 확인한다.\r\n   1. 배추가 없을 경우 통과한다.\r\n2. 배추가 있을 경우 현재 구역을 처음 탐색하는지 확인한다.\r\n   1. 이미 탐색한 구역일 경우 통과한다.\r\n3. 현재 구역을 방문처리하고, 벌레의 수를 하나 추가한다.\r\n4. 상하좌우로 인접한 구역에 배추가 있는지 확인한다.\r\n   1. 상: $(x, y - 1)$\r\n   2. 하: $(x, y + 1)$\r\n   3. 좌: $(x - 1, y)$\r\n   4. 우: $(x + 1, y)$\r\n5. 배추가 있고, 처음 탐색하는지 확인한다.\r\n   1. 이미 탐색한 구역일 경우 통과한다.\r\n6. 현재 구역을 방문처리한다. 같은 구역이므로 벌레의 수는 추가하지 않는다.\r\n7. 1 ~ 7과정을 반복한다.\r\n\r\nDFS에서의 깊이는 각 구역의 상하좌우 개념과 동일하다. 상하좌우를 비교할 경우, $x$, $y$값이 정해진 밭의 크기 안에 포함되어야 함을 잊지 말자.\r\n\r\n이를 도식화하면 아래와 같이 나타낼 수 있다. 이미 방문한 구역을 녹색으로 표시한다.\r\n\r\n<b class=\"teal-A400 large\">탐색을 수행한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786679-82b48d80-cbfc-11eb-8360-9dae381cc44d.png\" width=\"500px\" />\r\n</p>\r\n\r\n탐색 중인 위치에 배추가 있는지, 처음 방문한 곳인지 확인한다. 그림의 $(0, 0)$의 경우 배추가 있으며 처음 방문한 구역이므로 조건에 해당된다.\r\n\r\n<b class=\"teal-A400 large\">벌레를 추가하고 방문 표시를 한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786686-94963080-cbfc-11eb-9a6a-722d7e3723f2.png\" width=\"500px\" />\r\n</p>\r\n\r\n새로운 구역이므로 벌레 하나를 추가한다. 방문한 구역은 방문 표시를 함으로써 중복 검색을 방지한다.\r\n\r\n<b class=\"teal-A400 large\">인접구역을 탐색한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786712-a677d380-cbfc-11eb-8150-daf8d827a0eb.png\" width=\"500px\" />\r\n</p>\r\n\r\n인접구역인 상하좌우 구역을 탐색한다. $(0, 0)$을 기준으로 $(0, 1)$, $(0, -1)$, $(-1, 0)$, $(1, 0)$이다. 구역의 좌표는 0 이상이어야 하므로, 유효한 구역은 $(0, 1)$, $(1, 0)$ 두 곳이다.\r\n\r\n<b class=\"teal-A400 large\">인접구역에 대해 방문 표시를 한다.</b>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121786730-c27b7500-cbfc-11eb-822c-1956cfd2b954.png\" width=\"500px\" />\r\n</p>\r\n\r\n$(1, 0)$ 역시 방문 전이며, 배추가 있는 구역이다. 인접구역이므로 벌레는 추가하지 않으며, 방문 표시만 한다. 또 다른 인접구역에 대해 동일한 과정을 반복한다.\r\n\r\n위와 같은 과정을 반복하여 구역의 수를 계산할 수 있다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1012 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/13/A1012/\">1012 풀이</a>\r\n * @since 2021.06.13 Sun 01:30:12\r\n */\r\npublic class Main\r\n{\r\n\t// 배추밭의 가로 길이(x)\r\n\tprivate static int M;\r\n\t\r\n\t// 배추밭의 세로 길이(y)\r\n\tprivate static int N;\r\n\t\r\n\t// 배추밭\r\n\tprivate static int[][] area;\r\n\t\r\n\t// 구역 방문 여부\r\n\tprivate static boolean[][] isVisit;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tM = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\tN = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 배추 갯수\r\n\t\t\tint K = Integer.parseInt(temp[2]);\r\n\t\t\t\r\n\t\t\tarea = new int[M][N];\r\n\t\t\t\r\n\t\t\tisVisit = new boolean[M][N];\r\n\t\t\t\r\n\t\t\t// 필요한 배추흰지렁이 수\r\n\t\t\tint bugs = 0;\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(temp[0]);\r\n\t\t\t\tint y = Integer.parseInt(temp[1]);\r\n\t\t\t\t\r\n\t\t\t\tarea[x][y] = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int y = 0; y < N; y++)\r\n\t\t\t{\r\n\t\t\t\tfor (int x = 0; x < M; x++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 방문하지 않은 구역에 배추가 있을 경우\r\n\t\t\t\t\tif (area[x][y] == 1 && !isVisit[x][y])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbugs++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdfs(x, y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(bugs);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 깊이 우선 탐색 알고리즘\r\n\t *\r\n\t * @param x: [int] x좌표\r\n\t * @param y: [int] y좌표\r\n\t */\r\n\tprivate static void dfs(int x, int y)\r\n\t{\r\n\t\t// x의 상하좌우 이동\r\n\t\tint[] dx = { 0, 0, -1, 1 };\r\n\t\t\r\n\t\t// y의 상하좌우 이동\r\n\t\tint[] dy = { -1, +1, 0, 0 };\r\n\t\t\r\n\t\tisVisit[x][y] = true;\r\n\t\t\r\n\t\tfor (int i = 0; i < 4; i++)\r\n\t\t{\r\n\t\t\tint xn = x + dx[i];\r\n\t\t\tint yn = y + dy[i];\r\n\t\t\t\r\n\t\t\t// x, y좌표가 구역 내부에 있으며, 방문하지 않은 구역에 배추가 있을 경우\r\n\t\t\tif ((xn > -1 && xn < M) && (yn > -1 && yn < N) && area[xn][yn] == 1 && !isVisit[xn][yn])\r\n\t\t\t{\r\n\t\t\t\tdfs(xn, yn);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 그래프 이론\r\n* 그래프 탐색\r\n* 너비 우선 탐색\r\n* 깊이 우선 탐색","url":["2021-06-13-A1012","2021","06","13","A1012"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1011번 Fly me to the Alpha Centauri","excerpt":"우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다. 그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k - 1 , k 혹은 k + 1 광년만을 다시 이동할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-11T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","SILVER","SILVER I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-11-A1011.md","content":"\r\n# 다리 놓기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1011번 문제](https://www.acmicpc.net/problem/1011)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.\r\n\r\n그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 $k$광년을 이동하였을 때는 $k - 1$ , $k$ 혹은 $k + 1$ 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/rlaehdgur.JPG\" width=\"600px\" />\r\n</p>\r\n\r\n김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 $x$지점에서 $y$지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 $y$지점에 도착해서도 공간 이동장치의 안전성을 위하여 $y$지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.\r\n\r\n김우현을 위해 $x$지점부터 정확히 $y$지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $T$가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 $x$와 목표 위치 $y$가 정수로 주어지며, $x$는 항상 $y$보다 작은 값을 갖는다. $(0 ≤ x < y < 2^31)$\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 $x$지점으로부터 $y$지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0 3\r\n1 5\r\n45 50\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n3\r\n4\r\n```\r\n\r\n# 풀이\r\n\r\nFrank Sinatra의 [Fly me to the moon](https://www.youtube.com/embed/ZEcqHA7dbwM)을 오마주한 제목인 거 같다.\r\n\r\n<p align=\"center\">\r\n\t<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZEcqHA7dbwM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\r\n</p>\r\n\r\n시나트라를 Fallout NV의 Blue Moon으로 처음 접했었는데, 그 후에 Come fly with me나 Theme from Newyork Newyork 같이 좋은 곡들이 너무 많아서 자주 듣는 편이다.\r\n\r\n문제로 돌아와서, 러프하게 보면 \"무작정 빨리가면 되지 않나?\"라고 생각할 수 있다. 하지만 아래 두 조건이 발목을 잡는다.\r\n\r\n1. 처음, 끝 구간은 반드시 <span class=\"primary\">한 칸만 워프</span>할 수 있다.\r\n2. $k$만큼 이동할 경우, <span class=\"primary\">$k - 1$ ~ $k + 1$만큼만 이동 가능</span>함\r\n3. 반드시 <span class=\"primary\">정확한 지점에 도착</span>해야함 (통과 X)\r\n\r\n위 조건들 때문에 새벽 2시 강남의 \"과학\"마냥 쏘다니면 안 된다.\r\n\r\n경우의 수는 아니고, 정해진 규칙이 있으니 이를 계산하여 순서대로 나열하면 단서를 발견할 수 있을 것 같다.\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   2   | 1 1           |     2     |\r\n|   3   | 1 1 1         |     3     |\r\n|   4   | 1 2 1         |     3     |\r\n|   5   | 1 2 1 1       |     4     |\r\n|   6   | 1 2 2 1       |     4     |\r\n|   7   | 1 2 2 1 1     |     5     |\r\n|   8   | 1 2 2 2 1     |     5     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  10   | 1 2 3 2 1 1   |     6     |\r\n|  11   | 1 2 3 2 2 1   |     6     |\r\n|  12   | 1 2 3 3 2 1   |     6     |\r\n|  13   | 1 2 3 3 2 1 1 |     7     |\r\n|  14   | 1 2 3 3 2 2 1 |     7     |\r\n|  15   | 1 2 3 3 3 2 1 |     7     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n잘 안 보일 수도 있으나, 규칙성 찾을 때 가장 만만한 제곱수(1, 4, 9...)를 기준으로 규칙을 정의할 수 있다. 특징은 아래와 같다.\r\n\r\n* 제곱수 이후로 가동 횟수가 1 증가한다.\r\n* 현재 제곱수와 다음 제곱수의 중간에서 가동 횟수가 1 증가한다.\r\n\r\n즉, 제곱수 이후로 가시적인 변화가 있으며, 제곱수를 기준으로 구간의 중간에서 가동률이 1 증가한다.\r\n\r\n### 제곱수의 가동 횟수 일반식\r\n\r\n| 거리  | 내용          | 가동 횟수 |\r\n| :---: | :------------ | :-------: |\r\n|   1   | 1             |     1     |\r\n|   4   | 1 2 1         |     3     |\r\n|   9   | 1 2 3 2 1     |     5     |\r\n|  16   | 1 2 3 4 3 2 1 |     7     |\r\n\r\n제곱수의 가동률은 아래와 같다. 제곱수 $n$의 가동 횟수 일반식은 아래와 같다.\r\n\r\n$$\r\n2\\sqrt{n} - 1\r\n$$\r\n\r\n9의 경우 $2 * 3 - 1 = 5$이므로 식이 성립함을 알 수 있다.\r\n\r\n### 제곱수가 아닌 수의 가동 횟수 일반식\r\n\r\n제곱수 사이의 중간에서 가동 횟수가 바뀌므로, 이 중간값을 계산하면 된다. 제곱수가 아닌 일반적인 숫자 $k$가 있다고 가정하자. 이 규칙은 제곱수를 중심으로 돌아가므로, $k$를 통해 제곱수를 구해야 한다. 구해야 할 요소는 아래와 같다.\r\n\r\n* $k$보다 크면서 가장 가까운 제곱수\r\n* $k$가 속한 제곱수 구간의 중간값\r\n\r\n1. $k$에 제곱근 연산을 수행하고 이를 반올림한다. $k$보다 크면서 $k$와 가장 가까운 제곱수의 제곱근 $\\sqrt{n}$이 계산된다.\r\n2. $\\sqrt{n}$을 제곱하여 가장 근접한 제곱수 $n$을 계산한다.\r\n3. $n - \\sqrt{n}$의 식으로 $k$가 속한 제곱수 구간의 중간값$t$을 계산한다.\r\n4. $k > t$일 경우, $n$의 가동 횟수와 동일한 $2\\sqrt{n} - 1$식을 적용한다.\r\n5. $k <= t$일 경우, $n$의 가동 횟수에서 1을 뺀 $2\\sqrt{n} - 2$식을 적용한다.\r\n\r\n위 방법을 토대로 7의 가동 횟수를 계산해보자.\r\n\r\n$\\sqrt{7} \\fallingdotseq 2.646$이므로, 이를 반올림하면 3이 계산된다. 즉, 7보다 크면서 가장 가까운 제곱수는 $3^2 = 9$다.\r\n\r\n$9 - \\sqrt{9} = 9 - 3 = 6$이므로, $k$가 속한 제곱수 구간의 중간값은 6이다. 숫자가 6보다 클 경우 9와 가동 횟수가 동일하다. 주어진 숫자는 7이므로 9의 가동 횟수와 동일하다.\r\n\r\n9의 가동횟수는 $2\\sqrt{9} - 1 = 6 - 1 = 5$이므로 7의 가동 횟수 역시 5가 된다.\r\n\r\n위 절차를 코드로 녹여내면 된다. 코드 구현 난이도는 낮다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1011 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/11/A1011/\">1011 풀이</a>\r\n * @since 2021.06.11 Fri 09:06:34\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 현재 위치\r\n\t\t\tdouble x = Double.parseDouble(temp[0]);\r\n\t\t\t\r\n\t\t\t// 목표 위치\r\n\t\t\tdouble y = Double.parseDouble(temp[1]);\r\n\t\t\t\r\n\t\t\t// x, y 사이의 거리\r\n\t\t\tdouble distance = y - x;\r\n\t\t\t\r\n\t\t\tSystem.out.println(solve(distance));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가동횟수 반환 함수\r\n\t *\r\n\t * @param distance: [double] 거리\r\n\t *\r\n\t * @return [int] 가동횟수\r\n\t */\r\n\tprivate static int solve(double distance)\r\n\t{\r\n\t\tint result;\r\n\t\t\r\n\t\tdouble ref = Math.sqrt(distance);\r\n\t\t\r\n\t\t// 제곱수일 경우\r\n\t\tif (ref % 1 == 0)\r\n\t\t{\r\n\t\t\tresult = (int) (2 * ref - 1);\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tdouble next = Math.ceil(ref);\r\n\t\t\t\r\n\t\t\t// 이전 제곱수와 다음 제곱수의 중간보다 큰 수일 경우\r\n\t\t\tif (distance > Math.pow(next, 2) - next)\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult = (int) (2 * next - 2);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n주의할 점이 하나 있는데, $x$와 $y$의 최대값이 $2^31$이다. int의 최대값은 2,147,483,647이지만, $2^31$은 2,147,483,64<span class=\"red-A200\">8</span>이므로 $x$, $y$의 거리 계산 시 int를 사용하면 안 된다. 결과만 int형으로 출력해야 한다.\r\n\r\n메모이제이션을 적용할까 했지만, 배열을 $2^31$ 크기만큼 초기화해야 하므로 오히려 오버헤드가 더 심하게 발생할 것 같다. 재귀함수도 아니니 메모이제이션을 적용해도 별차이 없을 것 같다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-11-A1011","2021","06","11","A1011"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1010번 다리 놓기","excerpt":"재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Combination(조합)","SILVER","SILVER V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-A1010.md","content":"\r\n# 다리 놓기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1010번 문제](https://www.acmicpc.net/problem/1010)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|  0.5초   |    128MB    |\r\n\r\n## 문제\r\n\r\n재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 <span class=\"primary\">사이트</span>라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 $N$개의 사이트가 있고 동쪽에는 $M$개의 사이트가 있다는 것을 알았다. $(N ≤ M)$\r\n\r\n재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. <span class=\"red-600\">(이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.)</span> 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 ($N$개) 다리를 지으려고 한다. <span class=\"red-600\">다리끼리는 서로 겹쳐질 수 없다</span>고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/pic1.JPG\" width=\"400px\" />\r\n</p>\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 $N$, $M$ $(0 < N ≤ M < 30)$이 주어진다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n2 2\r\n1 5\r\n13 29\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n5\r\n67863915\r\n```\r\n\r\n# 풀이\r\n\r\n규칙을 정리하면 아래와 같다.\r\n\r\n1. $N$구역에서 $M$구역으로 다리를 건설한다.\r\n2. $N <= M$이다.\r\n3. 사이트 당 연결된 다리는 하나다.\r\n4. 다리끼리는 서로 겹쳐서 연결되면 안 된다.\r\n\r\n1000번 부터 문제 풀면서, [1007번 벡터](/posts/2021/06/09/A1007/)로 인해 조합이라는 키워드를 쉽게 연상할 수 있었다. 문제에서 $N$구역에서 $M$구역으로 다리를 건설한다고 서술하므로 $N$을 기준으로 생각하기 쉽다. 반대로 $M$을 기준으로 생각하면 해결의 실마리가 보인다. $M$구역의 사이트에서 $N$구역의 사이트 갯수만큼 연결할 사이트에 대한 조합을 계산하면 되기 때문.\r\n\r\n예를 들어 $N$구역에 3개의 사이트가 있고, $M$구역에 5개의 사이트가 있다고 가정하자.\r\n\r\n| 구분  | $M_1$ | $M_2$ | $M_3$ | $M_4$ | $M_5$ |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   O   |   O   |   O   |       |       |\r\n|   2   |   O   |   O   |       |   O   |       |\r\n|   3   |   O   |   O   |       |       |   O   |\r\n|   4   |   O   |       |   O   |   O   |       |\r\n|   5   |   O   |       |   O   |       |   O   |\r\n|   6   |   O   |       |       |   O   |   O   |\r\n|   7   |       |   O   |   O   |   O   |       |\r\n|   8   |       |   O   |   O   |       |   O   |\r\n|   9   |       |   O   |       |   O   |   O   |\r\n|  10   |       |       |   O   |   O   |   O   |\r\n\r\n총 10개의 경우의 수가 존재한다. 이는 $_5C_3$의 계산 결과와 일치한다.\r\n\r\n$$\r\n_5C_3 = \\frac{5!}{3! \\times 2!} = \\frac{5 \\times 4 \\times 3 \\times 2 \\times 1}{(3 \\times 2 \\times 1) \\times (2 \\times 1)} = \\frac{5 \\times 4}{2 \\times 1} = 10\r\n$$\r\n\r\n> ❓ **숫자가 왜 감탄(!)을 하죠?**  \r\n> Factorial(팩토리얼) 연산자로 $n! = n \\times (n - 1) \\times (n - 2) \\times ... \\times 1$과 같은 형태로 연산한다.\r\n\r\n더도말고 덜도말고 조합 알고리즘을 설계하면 된다. 조합의 요소를 반환할 필요 없이, 조합의 갯수만 구하면 되므로 [1007번 벡터](/posts/2021/06/09/A1007/)문제보다 더 간단하다.\r\n\r\n## Gotta Go FAST!\r\n\r\n무턱대로 위 식으로 조합 알고리즘을 짜면 <span class=\"red-A400\">시간 초과</span> 오류를 볼 수 있다. 그도 그럴 것이, 원리 자체는 쉽지만 시간제한이 0.5s로 매우 짧기 때문. $M$의 값이 최대 30이므로, 최대 $30!$에 대한 연산을 수행해야하기 때문이다. 그러므로 <span class=\"blue-A400\">Memoization(메모이제이션)</span>이라는 최적화를 적용해야 한다.\r\n\r\n> ❓ **Memoization(메모이제이션)이란?**  \r\n> 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장해놓고 필요 시 사용하여 반복적인 연산 작업을 제거하는 기술.\r\n\r\n조합을 재귀적으로 표현하면 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\n_nC_r = _{n-1}C_{r-1} + _{n-1}C_r\r\n$$\r\n\r\n아래의 그림을 보면 이해하기 쉽다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121479130-b036e680-ca04-11eb-96ed-620c4fc3086a.png\" width=\"700px\" />\r\n</p>\r\n\r\n만약, $_5C_3$을 연산한다면 아래와 같이 진행된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121479160-b6c55e00-ca04-11eb-97da-a4708798a715.png\" width=\"700px\" />\r\n</p>\r\n\r\n이 중, $_3C_2$의 경우 $_4C_2$, $_4C_3$을 계산할 때 필요하므로 여러번 호출된다. 만약, 메모이제이션이 적용되지 않았다면, $_3C_2$이 필요할 때마다 1에서부터 다시 연산해야한다. $_{30}C_{14}$와 같이 숫자가 커지면 위 그림의 깊이도 깊어지기 때문에 많은 오버헤드가 발생한다.\r\n\r\n만약 이렇게 연산된 값을 버리지 않고 메모리상에 저장한 뒤 쓸 수 있다면 연산에서 엄청난 이점이 발생한다. $_3C_2$을 이미 저장했다면 $_4C_2$, $_4C_3$을 계산할 때 저장된 $_3C_2$을 즉시 꺼내 사용할 수 있다. 복잡한 연산을 건너뛸 수 있으며, 동일한 값이 여러번 호출되도 상관없다.\r\n\r\n해당 문제의 조합 알고리즘의 연산에서 한 번 연산된 값을 임의의 배열에 저장하여 이를 활용하면 0.5초라는 짧은 시간을 충족할 수 있을 것이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1010 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/A1010/\">1010 풀이</a>\r\n * @since 2021.06.09 Tue 14:14:09\r\n */\r\npublic class Main\r\n{\r\n\t// 다리 건설 경우의 수\r\n\tprivate static final int[][] dp = new int[31][31];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint N = Integer.parseInt(temp[0]);\r\n\t\t\tint M = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\tSystem.out.println(combination(M, N));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 결과 반환 함수\r\n\t *\r\n\t * @param n: 원소 갯수\r\n\t * @param r: 조합 갯수\r\n\t *\r\n\t * @return {int} 조합\r\n\t */\r\n\tprivate static int combination(int n, int r)\r\n\t{\r\n\t\t// 이미 계산된 값일 경우\r\n\t\tif (dp[n][r] > 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r];\r\n\t\t}\r\n\t\t\r\n\t\t// 원소의 갯수가 조합의 갯수와 동일하거나 0일 경우\r\n\t\telse if (n == r || r == 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r] = 1;\r\n\t\t}\r\n\t\t\r\n\t\t// 일반적인 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn dp[n][r] = combination(n - 1, r - 1) + combination(n - 1, r);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$dp[n][r]$는 int형 배열이므로 기본값이 0이다. 즉, $dp[n][r] > 0$일 경우 $_nC_r$가 이미 계산되었다는 뜻이므로, 이미 저장된 값을 반환한다.\r\n\r\n$_5C_0$, $_5C_5$와 같이 $_nC_0$, $_nC_n$일 경우 그 값은 1이다. 해당 케이스의 경우 1을 반환한다. (전체를 선택하거나, 아무것도 선택하지 않는 방법은 하나뿐이다.)\r\n\r\n나머지 일반적인 경우 $_nC_r$의 재귀적 표현 방식인 $_{n-1}C_{r-1} + _{n-1}C_{r}$을 적용하면 된다.\r\n\r\n또한 $dp$ 이차원 배열은 31행렬로 초기화되는데, 그 이유는 $dp$의 행렬이 되는 $N$과 $M$의 최대값이 30이기 때문. 배열은 인덱스가 0부터 시작하므로 1을 더해야 한다.\r\n\r\n또한 케이스별로 $dp$를 초기화하지 않는데, 이는 <span class=\"green-A400\">조합이 범용적이므로 재사용이 가능하기 때문</span>이다. 1번 케이스나 100번 케이스나 $_5C_3$의 값은 10이다. 따라서 초기화를 하지 않으면 오히려 이전 케이스에서 계산했던 내용을 그대로 사용할 수 있어서 이득이다. 만약 첫 번째 케이스에서 $_{30}C_{12}$와 같이 큰 수를 계산했다면, 이후 케이스의 $_{12}C_{5}$와 같은 모든 하위 조합들은 연산을 통째로 건너뛸 수도 있을 것이다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 다이나믹 프로그래밍\r\n* 조합론","url":["2021-06-09-A1010","2021","06","09","A1010"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1009번 분산처리","excerpt":"재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T11:06:38","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","수학","BRONZE","BRONZE IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-A1009.md","content":"\r\n# 분산처리\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1009번 문제](https://www.acmicpc.net/problem/1009)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    128MB    |\r\n\r\n## 문제\r\n\r\n재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.\r\n\r\n1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터 ...\r\n\r\n10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터 ...\r\n\r\n총 데이터의 개수는 항상 $a^b$개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 $a$와 $b$가 주어진다. $(1 ≤ a < 100, 1 ≤ b < 1,000,000)$\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n1 6\r\n3 7\r\n6 2\r\n7 100\r\n9 635\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n7\r\n6\r\n1\r\n9\r\n```\r\n\r\n# 풀이\r\n\r\n문제속에 답이 있다. 1번 컴퓨터부터 10번 컴퓨터까지 데이터를 처리하는데, 가장 마지막에 데이터를 처리하는 컴퓨터의 번호를 반환하면 된다.\r\n\r\n데이터 12개가 주어졌다고 가정해보자\r\n\r\n| 컴퓨터 | 데이터 |\r\n| :----: | :----: |\r\n|   1    |   1    |\r\n|   2    |   2    |\r\n|   3    |   3    |\r\n|   4    |   4    |\r\n|   5    |   5    |\r\n|   6    |   6    |\r\n|   7    |   7    |\r\n|   8    |   8    |\r\n|   9    |   9    |\r\n|   10   |   10   |\r\n|   1    |   11   |\r\n|   2    |   12   |\r\n\r\n위 표를 통해 어렵지않게 규칙을 찾을 수 있다. <span class=\"green-A400\">데이터를 처리하는 컴퓨터의 번호는 데이터의 1의 자릿수가 가진 값과 동일</span>하다.\r\n\r\n즉, 789235번째 테이터는 5번 컴퓨터가 처리한다는 것이다. 789235에서 1의 자릿수가 5이기 때문.\r\n\r\n따라서 <span class=\"green-A400\">우리는 주어진 데이터 번호에서 1의 자릿수를 추출</span>하면 된다. 고맙게도 컴퓨터의 갯수가 10으로 고정이다. <span class=\"green-A400\">데이터의 번호를 10으로 나누면 1의 자리가 나머지로 남으므로, 이를 활용</span>하면 된다.\r\n\r\n즉 $a^b \\% 10$을 사용하면 된다.\r\n\r\n단, 몇가지 주의할 사항이 있다. 첫 번째로, $a^b$의 값이 너무 커지게 되면 연산 퍼포먼스에도 영향을 미치게된다. 그 전에 값이 너무 커지게되면 약간의 오차도 발생한다.\r\n\r\n어차피 우리는 1의 자리만 필요하므로 이를 나름 센스있게 우회할 수 있다.\r\n\r\n| $a^b$ |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n| $7^3$ |   7   |  49   |  343  |\r\n\r\n위 표는 7의 3제곱을 차례로 계산한 표다. 어차피 우리는 1의 자리만 필요하므로, 굳이 <span class=\"orange-A400\">전체를 계산할 필요 없이, 1의 자리를 기준으로 계산</span>해도 상관없다. 아래의 식을 보면 더욱 명확하다.\r\n\r\n$$\r\n7^3\\text{의 1의 자리} = 49 * 7 \\, \\% \\, 10 = 3\r\n$$\r\n\r\n$$\r\n7^3\\text{의 1의 자리} = (49 \\, \\% \\, 10) * 7 \\% 10 = 9 * 7 \\, \\% \\, 10 = 3\r\n$$\r\n\r\n49에서 7을 곱하는게 아니라 <span class=\"green-A400\">일의 자리 9만 구하여 곱함</span>에 주목하자. 두 번째 식과 같이 <span class=\"green-A400\">수의 일의 자리만 계산하는 방법</span>으로 연산의 오버헤드를 줄일 수 있다.\r\n\r\n두 번째는 10번 째 컴퓨터에 대한 처리다. 예시로, 30번 째 데이터에 대한 처리 공식은 $30 \\, \\% \\, 10 = 0$과 같다. <span class=\"orange-A400\">계산 결과가 0일 경우 10으로 치환</span>해야 한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1009 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/A1009/\">1009 풀이</a>\r\n * @since 2021.06.09 Tue 11:06:38\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint a = Integer.parseInt(temp[0]);\r\n\t\t\tint b = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\tint result = 1;\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j <= b; j++)\r\n\t\t\t{\r\n\t\t\t\tresult = result * a % 10;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 0일 경우 10으로 처리\r\n\t\t\tresult = result == 0 ? 10 : result;\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현","url":["2021-06-09-A1009","2021","06","09","A1009"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1008번 A / B","excerpt":"두 정수 A와 B를 입력받은 다음, A / B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T10:25:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-A1008.md","content":"\r\n# A / B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1008번 문제](https://www.acmicpc.net/problem/1008)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 $A$와 $B$를 입력받은 다음, $A / B$를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $A$와 $B$가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 $A / B$를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 $10^{-9}$ 이하이면 정답이다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 3\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.33333333333333333333333333333333\r\n```\r\n\r\n$10^{-9}$ 이하의 오차를 허용한다는 말은 꼭 소수 9번째 자리까지만 출력하라는 뜻이 아니다.\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n4 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.8\r\n```\r\n\r\n# 풀이\r\n\r\n[백준 1000 A + B](/posts/2021/05/21/A1000/), [백준 1001 A - B](/posts/2021/05/21/A1001/)에 이은 사칙연산 문제. 틀리기도 어렵다.\r\n\r\nJAVA의 경우, <span class=\"deepOrange-A400\">int</span>로 나누면 정수 부분만 반환하기 때문에, 반드시 <span class=\"deepOrange-A400\">double</span> 같은 실수형 데이터로 선언하여 나눠야 한다는 점만 주의하자.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1008 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/A1008/\">1008 풀이</a>\r\n * @since 2021.06.09 Tue 10:23:59\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tString[] line = reader.readLine().split(\" \");\r\n\t\t\r\n\t\tdouble a = Double.parseDouble(line[0]);\r\n\t\tdouble b = Double.parseDouble(line[1]);\r\n\t\t\r\n\t\tSystem.out.println(a / b);\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-06-09-A1008","2021","06","09","A1008"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1007번 벡터","excerpt":"평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다. V에 있는 벡터의 갯수는 P에 있는 점의 절반이다. 평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T00:50:26","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Brute Force(무차별 대입 공격)","Combination(조합)","GOLD","GOLD II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-A1007.md","content":"\r\n# 습격자 초라기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1007번 문제](https://www.acmicpc.net/problem/1007)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n평면 상에 $N$개의 점이 찍혀있고, 그 점을 집합 $P$라고 하자. 집합 $P$의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 $P$의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, $P$에 속하는 모든 점은 한 번씩 쓰여야 한다.\r\n\r\n$V$에 있는 벡터의 갯수는 $P$에 있는 점의 절반이다.\r\n\r\n평면 상의 점이 주어졌을 때, 집합 $P$의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n테스트 케이스의 첫째 줄에 점의 갯수 $N$이 주어진다. $N$은 짝수이다. 둘째 줄부터 $N$개의 줄에 점의 좌표가 주어진다. $N$은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4\r\n5 5\r\n5 -5\r\n-5 5\r\n-5 -5\r\n2\r\n-100000 -100000\r\n100000 100000\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.000000000000\r\n282842.712474619038\r\n```\r\n\r\n# 풀이\r\n\r\n두 개의 점으로 하나의 벡터를 만들 수 있다. $N <= 20$이므로 주어지는 점의 최대 갯수는 20개다. $N = 20$이라고 가정하면, 만들 수 있는 벡터의 수는 그 절반인 10개다. 20개의 점을 어떻게 잇느냐에 따라서 벡터 10개를 만드는 수 많은 경우의 수가 발생한다. 이 경우의 수에서 <span class=\"red-A400\">벡터의 총합이 가장 작은 값을 계산</span>하는 게 이 알고리즘의 결과다.(10개의 벡터 중 가장 짧은 벡터를 계산하는 것이 아님에 유의하자.)\r\n\r\n이 알고리즘의 핵심은 <span class=\"green-A400\">$N$개의 원소에서 $N / 2$개의 벡터를 만들 수 있는 경우를 계산해서 최소값을 계산</span>하면 된다. $N$의 최대값이 20으로 매우 작으므로 하나하나 비교하는 것이 가능하다. 애초에 알고리즘 자체가 Brute Force(무차별 대입 공격)으로 분류돼있기도 하고.\r\n\r\n좌표 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$가 있으며, 이 좌표에서 두 벡터인 $v_1$, $v_2$를 만든다고 가정하자.(조건은 알고리즘 문제와 동일) $v_1$이 $(x_1, y_1), (x_2, y_2)$으로 이루어져 있으며, $v_2$는 $(x_3, y_3), (x_4, y_4)$로 이루어져있다고 가정하자. 각 벡터를 좌표를 통해 표현하면 아래와 같다.\r\n\r\n$$\r\nv_1 = (x_2 - x_1, y_2 - y_1)\r\n$$\r\n\r\n$$\r\nv_2 = (x_4 - x_3, y_4 - y_3)\r\n$$\r\n\r\n벡터의 합은 벡터 좌표의 단순합으로 이루어진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/121457485-b4520c80-c9e2-11eb-8de4-660f9a86a7a1.png\" width=\"700px\" />\r\n</p>\r\n\r\n즉, 벡터의 총합 $v$는 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\nv = v_1 + v_2 = (x_2 + x_4 - x_1 - x_3, y_2 + y_4 - y_1 - y_3)\r\n$$\r\n\r\n$$\r\n||v|| = \\sqrt{(x_2 + x_4 - x_1 - x_3)^2 + (y_2 + y_4 - y_1 - y_3)^2}\r\n$$\r\n\r\n위 식으로 계산한 값의 최소값이 알고리즘의 해답이 된다. 즉, 우리는 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$을 조건에 맞게 조합해야한다. 각 조합의 $||v||$를 계산한 뒤, 이 중 최소값을 반환하면 될 것 같다.\r\n\r\n무턱대고 10개의 벡터를 for문 돌려가며 하나하나 만드는 방법은 안 된다. 좀 더 효율적으로 벡터를 계산하는 방법을 생각해보자.\r\n\r\n$v$식을 자세히 보면 쓸만한 특징일 하나 찾을 수 있는데, 각각의 좌표 $x$, $y$를 계산할 때 좌표의 절반은 더해지고, 절반은 빼진다. 좌표가 4개일 경우 2개는 더해지고, 나머지 2개는 빼진다. 만약 10개라면? 5개는 더해지고, 5개는 빼질 것이다.\r\n\r\n이를 활용하면 전체 좌표 $N$의 절반인 $N / 2$만큼의 좌표 조합을 구한다면 어떨까? 반은 더해지는 좌표, 나머지 반은 빼지는 좌표로 구분할 수 있다. 이후 각 좌표를 더하고 빼주면 손쉽게 $||v||$를 계산할 수 있을 것이다.\r\n\r\n따라서, 점을 반으로 나누어 <span class=\"green-A400\">양의 연산에 사용할 점과 음의 연산에 사용될 점의 경우의 수를 구하는 것이 이번 알고리즘의 핵심</span>이다. $_nC_r$(조합, Combination)을 사용하면 이를 쉽게 구할 수 있을 겻이다. $_nC_{(n / 2)}$를 계산하여, 선택된 좌표는 더하고, 선택되지 않은 좌표는 뺀다.\r\n\r\n예제 1의 $_4C_2$의 경우의 수는 아래와 같다.\r\n\r\n|     양의 좌표     |     음의 좌표     |   $v$    | $\\Vert v \\Vert$ |\r\n| :---------------: | :---------------: | :------: | :-------------: |\r\n|  (5, 5), (5, -5)  | (-5, 5), (-5, -5) | (20, 0)  |       20        |\r\n|  (5, 5), (-5, 5)  | (5, -5), (-5, -5) | (0, 20)  |       20        |\r\n| (5, 5), (-5, -5)  | (5, -5), (-5, 5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, 5)  | (5, 5), (-5, -5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, -5) |  (5, 5), (-5, 5)  | (0, -20) |       20        |\r\n| (-5, 5), (-5, -5) |  (5, 5), (5, -5)  | (-20, 0) |       20        |\r\n\r\n위와 같은 이유로 예제 1에서 벡터 총합의 최소값은 0이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1007 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/09/A1007/\">1007 풀이</a>\r\n * @since 2021.06.09 Tue 00:50:26\r\n */\r\npublic class Main\r\n{\r\n\t// 결과\r\n\tprivate static double result;\r\n\t\r\n\t// 조합 선택 여부\r\n\tprivate static boolean[] isChecked;\r\n\t\r\n\t// 점의 배열\r\n\tprivate static int[][] P;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 점의 갯수\r\n\t\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\t\r\n\t\t\tresult = Double.MAX_VALUE;\r\n\t\t\t\r\n\t\t\tisChecked = new boolean[N];\r\n\t\t\t\r\n\t\t\tP = new int[N][2];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < N; j++)\r\n\t\t\t{\r\n\t\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tP[j][0] = Integer.parseInt(temp[0]);\r\n\t\t\t\tP[j][1] = Integer.parseInt(temp[1]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcombination(0, N / 2);\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t * @param count: [int] 조합할 원소 갯수\r\n\t */\r\n\tprivate static void combination(int index, int count)\r\n\t{\r\n\t\t// 조합할 원소 갯수가 더 이상 없을 경우\r\n\t\tif (count == 0)\r\n\t\t{\r\n\t\t\tresult = Math.min(result, getVector());\r\n\t\t}\r\n\t\t\r\n\t\t// 조합할 원소 갯수가 아직 남아있을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = index; i < P.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisChecked[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(i + 1, count - 1);\r\n\t\t\t\t\r\n\t\t\t\tisChecked[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 벡터 계산 함수\r\n\t *\r\n\t * @return [double] 벡터 크기\r\n\t */\r\n\tprivate static double getVector()\r\n\t{\r\n\t\tint x = 0;\r\n\t\tint y = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < P.length; i++)\r\n\t\t{\r\n\t\t\t// 양수로 선택된 점일 경우\r\n\t\t\tif (isChecked[i])\r\n\t\t\t{\r\n\t\t\t\tx += P[i][0];\r\n\t\t\t\ty += P[i][1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 음수로 선택된 점일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx -= P[i][0];\r\n\t\t\t\ty -= P[i][1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 브루트포스 알고리즘","url":["2021-06-09-A1007","2021","06","09","A1007"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 4. Jekyll 쇼핑하기","excerpt":"GitHub는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 Git을 이용하여 관리할 수 있다. GitHub 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 Git을 활용하는 것이 권장된다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-07T23:42:11","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-07-jekyll-blog-jekyll-shopping.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">GitHub Pages</span>는 꼭 <span class=\"primary\">Jekyll</span>로만 호스팅해야하는 것은 아니다. 해당 Repository에 전통적인 HTML, CSS, JavaScript 파일을 저장해도 호스팅엔 무리가 없다. 하지만 이 경우, 자신이 직접 모든 페이지를 디자인해야하고, 코딩 이상의 깊은 미적 감각이 요구된다. 디자인은 상황에 따라 코딩보다도 더욱 고난이도의 지식과 정교한 작업을 요구하기 때문.\r\n\r\n다행히 <span class=\"primary\">Jekyll</span> 기반 테마를 사용하면 이러한 문제를 해소할 수 있다.\r\n\r\n# Jekyll 쇼핑\r\n\r\n아래의 사이트들에서 <span class=\"primary\">Jekyll</span> 테마를 다운로드 받거나 데모 페이지를 확인해볼 수 있다. 기본적으로 무료이며, 테마에 따라 일부는 비용 청구를 통해 더욱 향상된 테마를 제공해주기도 한다.\r\n\r\n* [Jekyll Themes](http://jekyllthemes.org/)\r\n* [Free Jekyll Themes](https://jekyllthemes.io/free)\r\n* [Jekyllrc](http://themes.jekyllrc.org/)\r\n\r\n찾아보면 이 밖에도 여러 사이트가 존재한다. [Jekyll Themes](http://jekyllthemes.org/)를 예시로 확인해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90974202-ec778400-e563-11ea-83c6-b3456a678e27.png\" width=\"820px\" />\r\n</p>\r\n\r\n이렇게 수 많은 테마들이 준비되어있다. 테마별로 적합한 용도가 있기 때문에, 제공하는 기능을 잘 확인해야한다. 오로지 디자이너 개인의 의도와 가치관이 담겨있기 때문에, 내가 원하는 블로그와 테마의 방향이 일치한지 확인하자.\r\n\r\n> 어떤 테마는 블로그에 적합하고, 어떤 테마는 포트폴리오에 적합하다.\r\n\r\n내가 <span class=\"primary\">Jekyll</span> 시절 사용했던 테마는 [Moon Theme](http://taylantatli.github.io/Moon/)다. 깔끔하면서도 편안한 느낌이라 마음에 들었다. 대부분의 테마는 위와 같이 직접 체험이 가능한 데모 페이지를 제공하고 있으므로, 이를 활용하면 테마 선택에 도움이 된다.\r\n\r\n원하는 테마를 선택했다면, `clone` 작업을 진행하자. 거의 모든 테마는 해당하는 Repository URL을 제공한다. `cline` 작업을 위해 테마 Repository의 URL를 알아야 한다. URL은 아래와 같이 확인할 수 있다.\r\n\r\n> clone은 공개된 GitHub Repository를 내 로컬 PC에 복사하는 작업이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90974184-b4704100-e563-11ea-8463-54495387cd70.png\" width=\"820px\" />\r\n</p>\r\n\r\n해당 Repository의 주소나 사진처럼 <span class=\"primary\">Code</span> 버튼을 클릭하여 URL을 확인할 수 있다.\r\n\r\n프로젝트를 복사할 폴더에서 Git Bash를 띄우자. 콘솔에 아래의 명령어를 입력한다.\r\n\r\n`git clone {Theme URL} {username}.github.io`\r\n\r\n위 명령어는 입력한 URL의 소스를 대상 경로의 {username}.github.io 폴더로 복사하는 명령어다. 명령어가 정상적으로 실행되면 대상 경로에 {username}.github.io 폴더가 생기고, 소스를 직접 확인할 수 있다.\r\n\r\n하지만 아직 소스를 받았을 뿐, 내가 만든 Repository와 연동하지 못 했다. 아래의 작업을 통해 연동을 진행하자.\r\n\r\n1. clone된 프로젝트 폴더로 들어가서 Git Bash를 띄운다.\r\n2. `git remote set-url origin https://github.com:{username}/{username}.github.io.git` 명령어를 실행한다.\r\n3. `git push`를 통해 변경사항을 기록한다.\r\n\r\n이 과정을 끝마치고 <span class=\"primary\">GitHub</span>의 Repository를 보면, 텅 비어있던 예전과 달리 테마 소스들이 들어가있음을 확인할 수 있다.\r\n\r\n빌드에 약간의 시간이 걸리므로(~ 1분) 조금 기다렸다가 **https://{username}.github.io** 주소로 접속해보자. 테마가 적용되어있다면 성공이다. 물론 아직 어떠한 커스터마이징도 이루어지지 않았으므로, 데모 페이지와 큰 차이는 없다. 앞으로 여기다가 게시글을 작성하고 블로그를 꾸미면 된다.","url":["2021-06-07-jekyll-blog-jekyll-shopping","2021","06","07","jekyll-blog-jekyll-shopping"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 3. Git 설치하기","excerpt":"GitHub는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 Git을 이용하여 관리할 수 있다. GitHub 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 Git을 활용하는 것이 권장된다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-06T23:42:11","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)","Git"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-06-jekyll-blog-prepare-git.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">GitHub</span>는 각 프로젝트를 하나의 Repository로 관리한다. 생성한 Repository는 <span class=\"orange-A400\">Git</span>을 이용하여 관리할 수 있다. <span class=\"primary\">GitHub</span> 페이지 자체로도 Repository 내부의 파일 생성, 수정, 삭제가 가능하지만 매우 번거로우므로 대부분 <span class=\"orange-A400\">Git</span>을 활용하는 것이 권장된다.\r\n\r\n# GitHub Repository 생성하기\r\n\r\n이전 장에서 <span class=\"primary\">GitHub</span> 계정을 만들었다. <a href=\"https://github.com\">GitHub 홈페이지</a>로 이동하여 로그인을 해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412420-0b9b8f00-e0e8-11ea-80a5-d28ff329a020.png\" width=\"820px\" />\r\n</p>\r\n\r\n해당 계정에서 관리하는 Repository의 전체 리스트를 보여준다. 아직 별다른 활동을 하지 않았다면 위 사진처럼 심플하게 보여준다. <span class=\"lightBlue-A400\">Create Repository</span> 버튼을 눌러 새로운 Repository를 생성하자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90422505-eada3600-e0f5-11ea-92f1-695a58f7f783.png\" width=\"820px\" />\r\n</p>\r\n\r\n* Owner: 소유주. 본인이 기본으로 지정되어 있다.\r\n* Repository name: Repository 이름. 블로그 호스팅을 위해 **{username}.github.io로 설정**하자.\r\n* Public / Private: Repository의 공개여부. 호스팅용 Repository는 반드시 **Public**이어야 한다.\r\n\r\n이 때, 주의할 점이 한가지 있는데, <span class=\"red-A400\">Repository의 이름을 {username}.github.io</span>으로 지정한다. 만약, username이 <span class=\"teal-A400\">test</span>라면, Repository의 이름은 <span class=\"teal-A400\">test</span>.github.io이 된다. 아이디가 아닌 username임에 주의하자. username은 프로필에서 확인할 수 있다.\r\n\r\n> GitHub Pages는 {username}.github.io 형식의 Repository를 Root(/)로 호스팅해준다. 즉, https://{username}.github.io가 된다. 만약 이와 같은 형식이 아닌 일반적인 Repository의 경우 https://{username}.github.io/{Repository Name}과 같이 하위 경로로 호스팅한다.\r\n\r\n한 계정이 관리하는 Repository의 이름은 중복될 수 없으므로, Root 경로의 호스팅은 계정 당 하나만 가능하다. 계정을 많이 만들어서 운용하면 어느정도 해소할 수 있긴 하다.\r\n\r\n나머지 옵션은 호스팅에 영향을 미치지 않으므로 무시하고 넘어가도 된다. 입력한 내용을 확인한 뒤 <span class=\"lightBlue-A400\">Create Repository</span>를 클릭하여 생성한다. Repository 목록에 생성한 Repository가 추가됐음을 확인할 수 있다.\r\n\r\n앞으로 이 Repository에 Jekyll 블로그 소스를 올릴 것이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90917728-6bfb3b00-e41e-11ea-8313-0251fba0659f.png\" width=\"820px\" />\r\n</p>\r\n\r\n생성된 저장소로 접근하면 위와 같은 화면이 나온다. 위 내용은 <span class=\"orange-A400\">Git</span> 명령어를 이용하여 사용자의 PC에 저장소를 생성하고, 이를 <span class=\"primary\">GitHub</span>의 원격 저장소와 연결하여 소스관리를 하는 절차를 안내하는 내용이다.\r\n\r\n# Git 설치하기\r\n\r\n이제 생성한 Repository를 관리할 <span class=\"orange-A400\">Git</span>을 설치해보자. <span class=\"orange-A400\">Git</span>은 소스코드를 효율적으로 관리할 수 있는 강력한 형상관리 툴로, Linux의 아버지 리누스 토르발스(Linus Benedict Torvalds)가 개발했다. 넓은 의미로 우리가 흔히 하는 복사 및 백업과 동일하지만, <span class=\"orange-A400\">Git</span>은 그것 보다는 더욱 강력하다.\r\n\r\n* 명령어 입력만으로 소스코드 백업이 가능하다.\r\n* <span class=\"orange-A400\">Git</span> 저장소와 통신이 가능한 환경이면 어디서나 저장된 소스코드를 받아오거나, 수정, 반영할 수 있다.\r\n* 커밋 시 해당 내역이 관리되며, 원할 경우 해당 커밋 이전으로 되돌릴 수 있다.\r\n* 커밋 별로 변경점을 비교할 수 있다.\r\n\r\n> Commit(커밋): Git의 변경사항(파일 생성, 수정, 삭제)을 저장소에 기록하는 작업\r\n\r\nJekyll 블로그는 <span class=\"primary\">GitHub</span>를 통해 관리하므로, 이와 연계된 <span class=\"orange-A400\">Git</span>의 사용은 필수다. 물론 <span class=\"orange-A400\">Git</span>을 사용하지 않고 <span class=\"primary\">GitHub</span>의 Repository에서 파일 추가, 삭제, 수정이 가능하다. 그러나 이 방법은 다수의 파일을 관리하는데 매우 비효율적이며, 파일 갱신 즉시 블로그에 내용이 반영되므로 오류가 있을 경우에도 블로그에 그대로 반영된다. 또한, 어찌됐든 Jekyll 사용하면서 코드를 만지게 될텐데, VSCode같은 에디터라도 쓰는게 개발환경에 여러모로 도움이 된다.\r\n\r\n## 설치파일 다운로드\r\n\r\n<a href=\"https://git-scm.com/\">Git 홈페이지</a>에서 Git를 설치하자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90918409-90a3e280-e41f-11ea-846f-68332ffecdbe.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span> 홈페이지는 위와 같다. 놀랍게도 홈페이지에서 자체적으로 **접속한 OS의 정보를 확인하고 해당 OS에 가장 적합한 Git을 추천**한다. 페이지 우측 상단의 모니터 그림에서 적합한 버전을 제공받을 수 있다.\r\n\r\n## 라이센스 동의\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90949816-b0222600-e486-11ea-95d7-7ee7150d4f4f.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span> 사용 라이센스에 동의한다. 당연하게도 동의 안 하면 설치가 불가능하다.\r\n\r\n## 설치경로 선택\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90949836-f6778500-e486-11ea-8568-94fd7e13f358.png\" width=\"820px\" />\r\n</p>\r\n\r\n특별한 문제가 없다면 설치경로는 기본값으로 지정한다.\r\n\r\n## 설치 옵션\r\n\r\n설치 시 적용할 옵션을 선택한다.\r\n\r\n* On the Desktop: 바탕화면 바로가기 생성\r\n* <span class=\"primary\">Git Bash Here</span>: 바탕화면에서 오른쪽 마우스 클릭 시 Git Bash 실행 메뉴 추가\r\n* Git GUI Here: 바탕화면에서 오른쪽 마우스 클릭 시 Git GUI 실행 메뉴 추가\r\n* Git LFS: 대용량 파일 지원\r\n* Associate .git* configuration files with the default text editor: git 설정파일을 기본 텍스트 편집기와 연결\r\n* Associate .sh files to be run with Bash: [.sh] 파일을 Bash로 실행함.\r\n* Use a TrueType font in console windows: 콘솔창의 폰트를 TrueType으로 사용\r\n* Check daily for Git for Windows updates: 매일 Git 업데이트 확인\r\n\r\n원하는 옵션을 추가/제외하고 다음으로 넘어간다. 파란색으로 하이라이팅된 옵션은 반드시 추가하는 것이 좋다.\r\n\r\n## 시작 프로그램 추가\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952465-b6240100-e49e-11ea-9784-cb5a1695ffeb.png\" width=\"820px\" />\r\n</p>\r\n\r\n시작 프로그램에 추가할 이름을 지정한다.\r\n\r\n* Don't create a Start Menu folder: 시작 메뉴를 생성하지 않는다.\r\n\r\n## Git 편집기 선택(Choosing the default editor used by Git)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952499-f97e6f80-e49e-11ea-95a0-818471fd3417.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span>을 사용하기 위한 기본 편집기를 선택한다. 기본 권장옵션은 Vim이며, 원하는 편집기로 변경이 가능하다. 지원하는 편집기는 아래와 같다.\r\n\r\n* Nano Editor\r\n* <span class=\"primary\">Vim</span>\r\n* Notepad++\r\n* Visual Studio Code\r\n* Visual Studio Code Insider\r\n* Sublime\r\n* Atom\r\n* other\r\n\r\n## 환경변수 지정(Adjusting your PATH environment)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952606-f6d04a00-e49f-11ea-85d0-204d305f8f9b.png\" width=\"820px\" />\r\n</p>\r\n\r\n환경변수를 지정하는 옵션을 선택한다.\r\n\r\n* Use Git from Git Bash Only: Bash 환경에서만 Git 사용 가능 (환경변수 미변경)\r\n* <span class=\"primary\">Use Git from Windows Command Prompt</span>: 윈도우 프롬프트에서 Git 사용 가능\r\n* Use Git abnd optional Unix tools from the Windows Command Prompt: 윈도우 프롬프트에 Git 및 Linux 명령어 사용 가능\r\n\r\n## HTTPS 전송 방법 설정(Choosing HTTPS tranport backend)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90952734-0e5c0280-e4a1-11ea-8a9f-08a164f05b5e.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span> 사용 시 HTTPS 전송 방법을 선택한다.\r\n\r\n* <span class=\"primary\">Use The OpenSSH library</span>: OpenSSH 라이브러리 사용\r\n* Use The native Windows Secure Channel library: Windows 인증서 저장소 사용\r\n\r\n## 개행문자 처리방식 지정(Configuring the line ending conversions)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90953593-a4932700-e4a7-11ea-95dd-5c6cb50662ea.png\" width=\"820px\" />\r\n</p>\r\n\r\nCheckout, Commit 작업 시 파일의 개행문자 처리 방식을 선택한다.\r\n\r\n* <span class=\"primary\">Checkout Windows-style, commit Unix-style line endings</span>: Checkout 시엔 Windows방식(CRLF), commit 시엔 Unix방식(LF)로 지정\r\n* Checkout as-is, commit Unix-style line endings: Checkout 시엔 변환 없음, commit시엔 Unix방식(LF)로 지정\r\n* Checkout as-is, commit as-is: Checkout, commit 둘 다 변환 없음\r\n\r\n## Git Bash 선택(Configuring the terminal emulator to use with Git Bash)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90953681-ba551c00-e4a8-11ea-9fc4-fe1c43e2ef28.png\" width=\"820px\" />\r\n</p>\r\n\r\nGit Bash 실행 시 사용할 터미널을 선택한다.\r\n\r\n* <span class=\"primary\">Use MinTTY</span>: MinTTY 터미널 사용\r\n* Use Windows default console window: Windows 기본 터미널 사용\r\n\r\n## Pull 기본동작 지정 (Choose the default behavior of 'git pull')\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90953682-bc1edf80-e4a8-11ea-9d0c-d9c0d71afbaf.png\" width=\"820px\" />\r\n</p>\r\n\r\n`git pull` 명령어 실행 시 수행할 동작을 지정한다.\r\n\r\n* <span class=\"primary\">Default (fast-forward or merge)</span>: fast-forward 혹은 merge를 이용한 병합\r\n* Rebase: rebase를 이용항 병합\r\n* Only ever fast-forward: fast-forward를 이용한 병합\r\n\r\n## Credential helper 지정(Choose a credential helper)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90954457-53873100-e4af-11ea-9a98-ef5131c4ab1a.png\" width=\"820px\" />\r\n</p>\r\n\r\nCredential helper를 지정한다.\r\n\r\n> Credential은 데이터 통신에 HTTP 프로토콜을 사용 시, 매번 입력해야하는 인증정보를 저장하고 자동으로 입력해주는 시스템을 제공한다.\r\n\r\n* None: 사용하지 않음\r\n* <span class=\"primary\">Git Credential Manager</span>: Windows 전용 Credential Manager 사용\r\n* Git Credential Manager Core: Cross-Platform을 지원하는 Credential Manager 사용\r\n\r\n## 실험 옵션 지정(Configuring experimental options)\r\n\r\n<p class=\"red-A400 center small\">※ Git을 처음 접하시는 분들은 해당 설정을 기본값으로 지정하시길 권장합니다.</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90954553-225b3080-e4b0-11ea-8930-6b461f966b4c.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"orange-A400\">Git</span>에서 제공하는 실험적인 옵션을 선택한다. 해당 옵션은 업데이트에 따라 정식으로 지원되거나, 제외될 수 있다.\r\n\r\n* Enable experimental support for pseudo consoles: 가상 터미널 지원\r\n\r\n## 설치 완료\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90957778-03b66300-e4cb-11ea-9927-a0efbfc1e921.png\" width=\"820px\" />\r\n</p>\r\n\r\n컴퓨터의 사양에 따라 약간의 시간이 소요될 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90957782-0618bd00-e4cb-11ea-9972-7bd3fe1aa45b.png\" width=\"820px\" />\r\n</p>\r\n\r\n설치가 완료됐다. <span class=\"primary\">Launch Git Bash</span>를 체크하면 Git 명령어를 입력할 수 있는 Git Bash가 즉시 실행된다.\r\n\r\n## Git Bash 실행하기\r\n\r\n설치 후 바탕화면이나 폴더에서 오른쪽 마우스를 클릭해서 컨텍스트 메뉴를 띄우자. [설치 옵션](#설치-옵션)에서 선택했던 내용에 따라 <span class=\"primary\">Git Bash Here</span>, <span class=\"primary\">Git GUI Here</span>가 생성됨을 확인할 수 있다. 해당 메뉴를 클릭하면 Bash 혹은 GUI를 실행할 수 있다. Bash는 콘솔 형태이며, GUI는 UI가 있는 흔한 프로그램이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90957788-0913ad80-e4cb-11ea-8627-6ceba19d58b4.png\" width=\"820px\" />\r\n</p>\r\n\r\n위 사진은 Bash의 사진으로, 본 시리즈에서는 Git Bash를 통한 명령어 입력을 기준으로 서술한다.\r\n\r\n> Git GUI는 Git Desktop으로 인해 잘 쓰이지 않는다.\r\n\r\n# Git 설정하기\r\n\r\nGit Bash를 실행한다. 자신이 만든 Repository와 통신하기 위해서, 내가 나임을 인증할 수 있는 정보를 사전에 입력해야 한다. 아래의 명령어를 통해 인증 정보를 입력하자.\r\n\r\n`git config --global user.name \"사용자 username\"`\r\n`git config --global user.email \"사용자 email\"`\r\n\r\nusername과 email은 회원가입시 입력한 정보로 입력해야한다.","url":["2021-06-06-jekyll-blog-prepare-git","2021","06","06","jekyll-blog-prepare-git"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 2. GitHub와 친해지기","excerpt":"Jekyll은 GitHub를 통해 호스팅한다. 즉, Jekyll로 블로그를 만들기 위해선 GitHub를 조금이나마 알고 있어야 한다. 본문에서는 GitHub의 여러 기능은 제쳐두고, Jekyll 호스팅을 목적을 기준으로 설명한다.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-06T23:29:32","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)","GitHub(깃허브)"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-06-jekyll-blog-github.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n<span class=\"primary\">Jekyll</span>은 <span class=\"primary\">GitHub</span>를 통해 호스팅한다. 즉, <span class=\"primary\">Jekyll</span>로 블로그를 만들기 위해선 <span class=\"primary\">GitHub</span>를 조금이나마 알고 있어야 한다. 본문에서는 <span class=\"primary\">GitHub</span>의 여러 기능은 제쳐두고, <span class=\"primary\">Jekyll</span> 호스팅을 목적을 기준으로 설명한다.\r\n\r\n# GitHub 속으로!\r\n\r\n<span class=\"primary\">GitHub</span>는 개발자들을 위한 소스코드 형상관리 서비스를 제공해준다. Git을 저장하고 관리하는 대표적인 저장소로, 수 많은 오픈, 개인 소스가 존재한다. Git과 <span class=\"primary\">GitHub</span>는 그 자체만으로도 커다란 주제가 여러개 튀어나오니, 일단은 우리의 목표인 호스팅만을 알아보자.\r\n\r\n<a href=\"https://github.com/\">GitHub 바로가기</a>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90389062-d2512800-e0c3-11ea-8a59-f4980afab7b5.png\" width=\"820px\" />\r\n</p>\r\n\r\n접속하면 위와 같은 화면을 볼 수 있는데, 상단 우측의 <span class=\"lightBlue-A400\">Sign Up</span>을 클릭하여 회원가입을 진행한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90411265-777cf800-e0e6-11ea-95d5-372388b32bd2.png\" width=\"820px\" />\r\n</p>\r\n\r\n* username: 닉네임\r\n* Email address: 이메일 주소\r\n* Password: 비밀번호\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412061-96c85500-e0e7-11ea-9a7b-8f71fa52f776.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정을 생성하면 나오는 설문조사. 무시해도 무방하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412232-d42ce280-e0e7-11ea-92e9-dc637cb2c8a9.png\" width=\"820px\" />\r\n</p>\r\n\r\n계정 생성이 완료되면 회원가입 시 작성한 이메일로 인증 코드를 전송하니 메일을 확인한다.\r\n\r\n만약, 이메일이 제대로 오지 않는다면, <span class=\"lightBlue-A400\">Resend verification email</span>을 통해 메일을 재발송할 수 있다. 혹은 이메일 주소를 잘못 입력했다면, <span class=\"lightBlue-A400\">Change your email settings</span>를 클릭하여 인증할 이메일 주소를 변경한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412375-fde60980-e0e7-11ea-805b-7d4c58ab0b4d.png\" width=\"820px\" />\r\n</p>\r\n\r\n인증 이메일을 확인하고 <span class=\"lightBlue-A400\">Verify email address</span>를 클릭하여 인증을 완료한다. 계정 생성 과정이 끝난다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90412420-0b9b8f00-e0e8-11ea-80a5-d28ff329a020.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"primary\">GitHub</span>에 접속하여 로그인을한다. 회원가입시 입력한 username이나 email 둘 중 아무거나 사용해도 상관없다. 위 화면이 뜨면 회원가입이 완료된 것이다.","url":["2021-06-06-jekyll-blog-github","2021","06","06","jekyll-blog-github"]},{"header":{"title":"[Jekyll] GitHub Pages를 이용해 나만의 블로그 만들기 - 1. Jekyll이란?","excerpt":"대형 포탈이나 크고 작은 플랫폼을 통해 자신만의 블로그를 만들 수 있다. 이러한 플랫폼을 통한 블로그는 연동된 계정과 버튼 클릭 몇 번으로 만들 수 있을 정도로 쉽고 간편하다. 하지만 이와 같은 블로그는 페이지의 기본 프레임이 정해져있고, 자유로운 커스터마이징이 제한된 편이다. 자신만의 색이나 가치관을 담은 블로그를 만들기 위해선 소위 \"기성품\"이 아닌 방법을 찾아야하는데, 이는 곧 자신이 직접 웹 페이지를 제작하고 퍼블리싱, 호스팅까지 전반적인 웹 서비스 자체를 구축해야하는 큰 작업으로 이어진다. 어찌어찌 페이지를 제작한다 하더라도, CSS를 통한 디자인이나 JavaScript같은 부가기능은 프레임 제작 이상으로 어렵다. 여기까지는 어떻게 자력으로 했다고 하더라도, 호스팅은 돈이 든다. DB까지 연동한다면 금액은 더욱 커지게 된다. 내가 원한건 단순한 블로그였는데.","coverImage":"https://user-images.githubusercontent.com/50317129/90983201-582f1080-e5a7-11ea-970b-8d7d82cb2084.png","date":"2021-06-06T23:18:25","type":"posts","category":"Jekyll","tag":["GitHub Pages(깃허브 페이지)","Jekyll(지킬)","Blog(블로그)"],"group":"Jekyll Blog","comment":true,"publish":true},"name":"2021-06-06-jekyll-blog-start.md","content":"\r\n<p class=\"red-A400 center\">※ 본 게시물은 Jekyll 시절의 게시글을 토대로 복원한 게시물입니다.</p>\r\n\r\n# 개요\r\n\r\n대형 포탈이나 크고 작은 플랫폼을 통해 자신만의 블로그를 만들 수 있다. 이러한 플랫폼을 통한 블로그는 연동된 계정과 버튼 클릭 몇 번으로 만들 수 있을 정도로 쉽고 간편하다. 하지만 이와 같은 블로그는 페이지의 기본 프레임이 정해져있고, 자유로운 커스터마이징이 제한된 편이다. 자신만의 색이나 가치관을 담은 블로그를 만들기 위해선 소위 \"기성품\"이 아닌 방법을 찾아야하는데, 이는 곧 자신이 직접 <span class=\"green-A400\">웹 페이지를 제작하고 퍼블리싱, 호스팅까지 전반적인 웹 서비스 자체를 구축해야하는 큰 작업</span>으로 이어진다. 어찌어찌 페이지를 제작한다 하더라도, <span class=\"purple-A400\">CSS</span>를 통한 디자인이나 <span class=\"orange-A400\">JavaScript</span>같은 부가기능은 프레임 제작 이상으로 어렵다. 여기까지는 어떻게 자력으로 했다고 하더라도, 호스팅은 돈이 든다. DB까지 연동한다면 금액은 더욱 커지게 된다. 내가 원한건 단순한 블로그였는데.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90330531-5d5cf000-dfe8-11ea-8a25-c5c89fa05a42.png\" width=\"820px\" />\r\n</p>\r\n\r\n<span class=\"primary\">GitHub Pages</span>를 활용하면 위와같은 문제의 대부분을 해결할 수 있다. <span class=\"primary\">GitHub</span>는 <span class=\"primary\">GitHub Pages</span> 프로젝트를 통해 특정한 이름을 가진 Repository 내부의 파일들을 <span class=\"primary\">github.io</span> 도메인으로 퍼블리싱해준다. 즉, 무료로 웹 호스팅을 제공받을 수 있는 셈이다. <span class=\"primary\">GitHub Pages</span>가 제시하는 방법에 따라 Repository를 만드는 것만으로도 유일하게 비용이 필요한 호스팅이라는 큰 산이 하나 사라진다.\r\n\r\n> Repository: GitHub에서 관리하는 프로젝트의 단위로, 각 계정마다 여러개의 Repository를 마음대로 생성, 수정, 삭제할 수 있다.\r\n\r\n안타깝게도 이는 호스팅과정을 라이트하게 만들어준 것일 뿐, 실제 페이지를 퍼블리싱하기 위해선 어쩔수 없이 웹 코딩 지식이 필요하다. 이를 위해 <span class=\"primary\">GitHub</span>는 <b class=\"primary\">Jekyll(지킬)</b>이라는 프레임워크를 통해 사용자들이 블로그 테마를 쉽게 만들고 이를 활용할 수 있는 환경을 제공하고 있다.\r\n\r\n필자는 어느정도 웹 관련 지식이 있음에도 불구하고 <span class=\"red-A400\">Ruby</span>와 <span class=\"primary\">Jekyll</span>이라는 다소 생소한 환경때문에 이를 이해하는데 다소 시간이 소요됐다. 이번 주제를 통해 웹에 있어서 나와 비슷하거나, 전무한 지식을 가진 사람들에게 내 블로그 구축기를 공유하고자 한다. 이 글은 <span class=\"primary\">Jekyll</span>이라는 개념을 처음 접하는 이들이 가급적 쉽게 이해함에 초점을 맞춘다.\r\n\r\n# Jekyll(지킬)이란?\r\n\r\n지킬 앤 하이드의 그 지킬 맞다. <span class=\"primary\">Jekyll</span>은 <span class=\"primary\">GitHub</span>의 설립자 중 하나인 Tom Preston-Werner가 <span class=\"red-A400\">Ruby</span>언어를 통해 개발한 프레임워크다. <span class=\"primary\">GitHub</span> 자체적으로 <span class=\"primary\">Jekyll</span> CMS(Contents Management System)을 내장하고 있어서 <span class=\"primary\">Jekyll</span> 호스팅에 매우 적합하다.(물론 굳이 Jekyll 기반이 아니여도 호스팅엔 문제가 없다.)\r\n\r\n웹을 나누는 구분 중에 정적(Static) 웹과 동적(Dynamic) 웹이 있다. <span class=\"primary\">Jekyll</span> 정적(Static) 웹 환경을 위한 프레임워크다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90335406-cdcb3780-e00f-11ea-87e2-b8c8ba8f576c.png\" width=\"820px\" />\r\n</p>\r\n\r\n**정적 웹**\r\n\r\n* 요청에 따라 미리 저장된 페이지를 응답\r\n* 웹 서버가 필요하지 않으므로, 서버 사양에 대한 영향이 적음\r\n* Back-end 코드가 없어 제작이 간편함\r\n* 속도가 빠름\r\n* 복잡한 로직이 필요 없는 소규모 사이트(블로그 등)에 적합함\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/90335405-cb68dd80-e00f-11ea-9b08-7a9ec21c5eee.png\" width=\"820px\" />\r\n</p>\r\n\r\n**동적 웹**\r\n\r\n* 요청에 따라 웹 서버가 데이터를 가공하여 전달\r\n* DB연동을 통한 데이터 CRUD가 가능\r\n* 동일한 페이지도 요청에 따라 다양한 내용을 응답\r\n* 웹 서버 사양에 따라 속도 저하의 우려 있음\r\n* 복잡한 로직이 필요한 비즈니스 사이트(쇼핑몰 등)에 적합함\r\n\r\n우리가 사용하는 대부분의 사이트는 동적 웹의 형태가 대부분이다. 자체적인 회원가입 시스템, 간단한 게시판 등이 존재한다면 대부분 동적 웹으로 봐도 무방하다. 회원가입이나 게시판에는 반드시 DB가 필요하고, 이는 곧 DB와 사이트 간의 동작을 제어할 서버가 필요하다는 의미이기 때문. DB의 존재로 인해 실시간 데이터 CRUD가 가능하다. <span class=\"green-A400\">사용자가 페이지에서 무언가 의미있는 컨텐츠 활동을 할 수 있다면 동적 웹</span>이다.\r\n\r\n반대로, 정적 웹은 단순히 저장된 파일을 요청에 맞게 보여만 주므로, 사용자는 단순 사이트 관광객 그 이상 그 이하도 아니다. 블로그의 경우 로그인 같은 사용자 인증이 전혀 필요 없으며, 소유자외의 작성자가 필요하지 않기 때문에 정적 웹 형태로도 얼마든지 서비스를 제공할 수 있다. <span class=\"primary\">Jekyll</span>은 사용자가 작성한 코드를 하나의 웹 프로젝트 형태로 빌드한다. <span class=\"primary\">Jekyll</span>은 이러한 정적 웹 방식을 채택함으로써 빠른 속도를 확보하고 백엔드 코드에 대한 부담감을 없앴다.\r\n\r\n사용하기에 앞서, <span class=\"primary\">Jekyll</span>은 <span class=\"red-A400\">블로그 퍼블리싱의 주체가 자기 자신</span>에게 있다. 즉, 페이지 하나하나를 세세하게 컨트롤 할 수 있으며, 그래야만 한다. 이러한 자유도는 누군가에겐 강력한 장점이지만, 누군가에겐 없는게 나은 단점이 되기도 한다.\r\n\r\n<span class=\"green-A400\">Jekyll은 이런 분들께 적합해요!</span>\r\n\r\n* 판에 찍힌 블로그보다 자신만의 감각이 들어간 블로그를 만들고 싶은 사람\r\n* 웹에 대한 기초적인 지식이나 그에 준하는 센스를 가진 사람\r\n* 다양한 기능을 구현하고 싶은 사람\r\n* 위의 모든 사항을 재미로 느낄 수 있는 사람\r\n\r\n<span class=\"red-A400\">Jekyll은 이런 분들께 나빠요...</span>\r\n\r\n* 어찌됐든 안정적인 블로그를 얻고싶은 사람\r\n* 이런저런 난잡한 일에 시간을 투자하기 어려운 사람\r\n* 지금 당장 블로그를 시작하고 싶은 사람\r\n* 복잡한 것을 지양하는 사람\r\n\r\n<span class=\"primary\">Jekyll</span>은 하나부터 열까지 본인이 직접 구성해야한다. 그 흔한 댓글 기능조차 플러그인을 사용해서 구성해야한다. 즉, 통상 사이트 혹은 블로그라면 응당 존재해야할 기능조차 본인이 스스로 구성하지 않으면 안 된다. 원한다면 내 블로그에 무엇이든 구현할 수 있지만, 반대로 아무것도 구현하지 않은 단순한 페이지조각에 그친다. 기타 카테고리나 태그를 만들 때도 마찬가지. 이런걸 하면서 재미를 느끼지 못 한다면 개인적으로 별로 권하고 싶지 않다.\r\n\r\n물론 아름다운 테마를 적용할 수 있는건 독보적인 강점이지만, 이미 Tistory 정도만 가도 플랫폼 형태이면서 강력한 커스터마이징을 제공하기도 한다. 그럼에도 불구하고 <span class=\"primary\">Jekyll</span>을 선택한다면, <span class=\"primary\">Jekyll</span>은 당신에게 그 어떤 블로그에서도 접해보지 못한 색다른 경험을 제공해줄 것이다.","url":["2021-06-06-jekyll-blog-start","2021","06","06","jekyll-blog-start"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1006번 습격자 초라기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-06T22:42:02","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","PLATINUM","PLATINUM III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-06-A1006.md","content":"\r\n# 습격자 초라기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1006번 문제](https://www.acmicpc.net/problem/1006)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg\" width=\"400px\" />\r\n</p>\r\n\r\n초라기는 각각 $W$명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.\r\n\r\n1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.\r\n2. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.\r\n3. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 $W$ 보다 작거나 같아야 한다.\r\n\r\n이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n첫째 줄에는 (구역의 개수)/2 값 $N$과 특수 소대원의 수 $W$가 주어진다. ($1 ≤ N ≤ 10000$, $1 ≤ W ≤ 10000$).\r\n\r\n둘째 줄에는 $1 ~ N$번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 $N + 1 ~ 2N$번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ $W$)\r\n\r\n## 출력\r\n\r\n각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n8 100\r\n70 60 55 43 57 60 44 50\r\n58 40 47 90 45 52 80 40\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n## 힌트\r\n\r\n하나의 특수 소대로 인접한 두 영역을 커버할 수 있는 배치는 (2,10), (9,16), (4,5), (7,8), (13,14) 이다. 그리고 나머지 6개 구역은 각각 하나의 특수 소대로 커버할 수 있다. 그러므로 최소 11개 특수 소대를 침투시켜야 한다.\r\n\r\n# 풀이\r\n\r\n백준 알고리즘을 순서대로 푸는 나 같은 초심자들에게 <span class=\"red-A400\">힘의 차이</span>를 느끼게 해주는 문제라고 한다. [solved.ac](https://solved.ac/)에 의하면 문제 등급이 무려 <span class=\"teal-A400\">PLATINUM III</span> 수준. 지금까지 푼 문제 중 가장 높은 등급이 [ACM Craft](/posts/2021/06/01/A1005/) (<span class=\"amber-A400\">GOLD III</span>) 수준임을 감안하면 월등히 높은 수준의 문제. 실제로 풀면서도 혼자서는 도저히 방법이 안 떠오르는데다, 풀이를 봐도 이해가 잘 안 됐다.\r\n\r\n해당 문제에 주어지는 <span class=\"primary\">구역</span>은 원형이다. 문제를 쉽게 접근하기 위해선 이 원형을 임의로 잘라 직사각형 형태로 전개해야 한다. 즉, <span class=\"error\">풀 때는 직사각형 형태지만, 실제로는 원형이므로 직사각형의 잘린 양 끝부분까지 염두하여 계산</span>을 해야한다. 난이도를 상승시키는 요인 중 하나.\r\n\r\n케이스에 제시된 예제를 기준으로 구역을 사각형으로 도식화하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n위 사진과 같이 8x8 배열로 표현할 수 있다. 여기서 여기서 6번째 행까지 특수소대로 채울 수 있는 최소값은 어떻게 구할 수 있을까?\r\n\r\n역으로 한번 생각해보자. 우리 특수소대는 너무나 유능해서 항상 최소의 팀만으로 목표 구역을 점령한다고 해보자. 작전 보고서엔 아래와 같이 점령한 구역을 표시하며, 이를 <span class=\"yellow-a500\">노란색</span> 영역으로 마킹해서 보여준다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926996-378d0d00-c71a-11eb-9b0f-baacb8da1647.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, <span class=\"yellow-a500\">노란색</span> 영역은 최소의 특수소대팀이 투입된 것이며, 우리가 실제로 구현할 알고리즘의 결과물이기도 하다.\r\n\r\n문제의 설정 상, 특수소대는 반드시 한 팀이 온전히 투입되어야 하며, 최소로 투입 가능한 인원 역시 한 팀이다. 그렇다면 위 사진에서 특수소대 한 팀이 커버할 수 있는 영역을 제외해보면 아래와 같이 세 케이스 $a$, $b$, $c$로 나눌 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927024-568b9f00-c71a-11eb-9309-7e4ef2f06ac2.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, 우리가 저 세 케이스에 대한 특수소대팀의 최소값을 계산할 수 있다면, 결과적으로 6번째 행 전체를 커버하는 특수소대팀의 수를 구할 수 있다. 이미 최소 인원이 나머지 구역을 점령한 상황에서, 투입할 수 있는 최소 인원인 한 팀만 투입할 수 있기 때문.\r\n\r\n여러 블로그에서 위 세 그림을 많이 봤을 텐데, 뜬금없이 저런 그림이 등장함에는 이와같은 배경이 있는 것이다.\r\n\r\n## 변수\r\n\r\n알고리즘 설계에 사용할 변수는 아래와 같다.\r\n\r\n* $T$: 케이스 수\r\n* $N$: 구역의 행 수\r\n* $e$: 구역별 적의 수\r\n* $a_i$: 첫 번째 케이스의 특수소대 최소 투입 수\r\n* $b_i$: 두 번째 케이스의 특수소대 최소 투입 수\r\n* $c_i$: 세 번째 케이스의 특수소대 최소 투입 수\r\n\r\n## a 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927050-77ec8b00-c71a-11eb-8034-5b02a6c04246.png\" width=\"512px\" />\r\n</p>\r\n\r\n첫번째 케이스로 $a_5$의 최소값 공식을 설계하자.\r\n\r\n위에서 했던 방식과 마찬가지로 추론하면 $a_5$에서 한팀을 뺀 $a_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927077-90f53c00-c71a-11eb-96cd-38edba684b10.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = c_5$ 이므로 $a_5 = c_5 + 1$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{05} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927092-9c486780-c71a-11eb-91c7-1922f98a1b01.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = b_4$ 이므로 $a_5 = b_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $a_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $a_5 = c_5 + 1$ -> $a_{i+1} = c_{i+1} + 1$\r\n* $a_5 = b_4 + 1$ -> $a_{i+1} = b_i + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## b 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927110-ac604700-c71a-11eb-989a-3d97d8e6a3ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5$의 최소값 공식을 설계하자.\r\n\r\n$b_5$에서 한팀을 뺀 $b_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927135-c0a44400-c71a-11eb-9c22-4e1303799b3b.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = c_5$ 이므로 $b_5 = c_5 + 1$\r\n\r\n$a_5$의 식과 동일하다.\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{14} + e_{15} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927154-d285e700-c71a-11eb-8b25-14fd85e1b1b0.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = a_4$ 이므로 $b_5 = a_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $b_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $b_5 = c_5 + 1$ -> $b_{n+1} = c_{n+1} + 1$\r\n* $b_5 = a_4 + 1$ -> $b_{n+1} = a_n + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## c 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927173-e3365d00-c71a-11eb-9c1b-dfb34ab3b444.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5$의 최소값 공식을 설계하자. ($c_5$는 4행까지 채워짐에 유의하자)\r\n\r\n$c_5$에서 한팀을 뺀 $c_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 여러 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927189-f47f6980-c71a-11eb-8c17-2120a82b4b6e.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 - 1 = a_4$ 이므로 $c_5 = a_4 + 1$\r\n\r\n$c_5 - 1 = b_4$ 이므로 $c_5 = b_4 + 1$\r\n\r\n두 케이스 중 더 작은 케이스가 $c_5$이므로 아래의 식으로 귀결된다.\r\n\r\n$c_5 = min(a_4 + 1, b_4 + 1)$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927199-ff39fe80-c71a-11eb-8b45-bb4f13aadf08.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 한팀이 네개의 구역을 커버할 수 있을 경우\r\n\r\n$c_i$의 경우 한 가지 특이 케이스가 발생한다. $a_i$, $b_i$의 경우 최소 투입인원인 1을 뺀 값만을 계산했다. $c_i$의 경우 직사각형이라는 특징 때문에 최대 4개 구역을 2팀이 점령할 수 있다.\r\n\r\n$e_{03} + e_{04} ≤ W$ 이고 $e_{13} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927226-11b43800-c71b-11eb-8845-7597a3a502b8.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_3 + 2$\r\n\r\n모든 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $c_{i+1} = min(a_{i} + 1, b_{i} + 1)$\r\n* $c_{i+1} = c_{i} + 1$\r\n* $c_{i+1} = c_{i-1} + 2$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 최종 일반식\r\n\r\n구한 일반식을 정리하면 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 원형 구조 적용을 위한 초기값 지정하기\r\n\r\n위 수식을 코드로 녹여내면 되지만, 완벽한 건 아니다. 왜냐하면 이 구역이 <span class=\"red-A400\">선형이 아닌 원형 구조</span>이기 때문.\r\n\r\n지금까지 우리는 원리 이해 및 수식 도출의 편의를 위해 원타곤을 임의로 잘라 표타곤으로 전개하여 수식을 계산했다. 이러한 <span class=\"green-A700\">선형 구조는 시작점과 도착점이 있지만 원형은 순환 구조</span>이므로 이에 맞춰 조건식을 작성해야 한다. 즉, <span class=\"red-A400\">원형 구조에 호환되도록 일부 케이스에 초기값을 지정</span>해야 최종적으로 원하는 알고리즘을 작성할 수 있다.\r\n\r\n아래의 사진은 원타곤과 표타곤을 비교한 것이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927246-2b557f80-c71b-11eb-92bf-fe5f92cf5504.png\" width=\"512px\" />\r\n</p>\r\n\r\n이 처럼, 원형 구조는 $e_{00}, e_{07}$끼리도 연결이 가능하지만, 선형 구조는 구조상 불가능하다. 때문에 이러한 케이스들의 초기값을 지정해줘야한다.\r\n\r\n대충 감이 오겠지만, 걸친 모양에 따라 총 4가지 케이스가 존재한다.\r\n\r\n### 걸치지 않을 경우 (기본)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$ 혹은 $e_{10}, e_{17}$과 같이 영역이 겹치지 않을 경우. 선형 구조에서도 적용 가능한 기본적인 케이스다. $a_i, b_i, c_i$의 모양과 연관지어 생각하면 아래와 같이 도식이 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927267-4a541180-c71b-11eb-8596-497ba12219e4.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_i$는 $i$열의 윗 칸만 채우므로 $e_{00}$만 점령한 상태이므로 1\r\n\r\n$b_i$는 $i$열의 아래 칸만 채우므로 $e_{01}$만 점령한 상태이므로 1\r\n\r\n$c_i$는 $i - 1$열을 채우는데, $c_{-1}$은 논리상 불가능하므로 0\r\n\r\n즉 초기값은 아래와 같다.\r\n\r\n$$\r\na_0 = 1\r\n$$\r\n\r\n$$\r\nb_0 = 1\r\n$$\r\n\r\n$$\r\nc_0 = 0\r\n$$\r\n\r\n$i = 0$일 때의 초기값을 지정한다.\r\n\r\n이 케이스일 경우 $c_N$이 알고리즘의 답이 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_8$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927320-88e9cc00-c71b-11eb-8ae4-3dfb03d4e0f0.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 윗 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927336-9bfc9c00-c71b-11eb-837d-77c000661702.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$을 점령할 경우. 원형 구조에서만 가능한 케이스다. **걸치지 않는 경우**를 제외한 나머지 케이스는 전부 원형 구조에서만 가능한 케이스이니 참고할 것. $i = 0$일 때는 영향을 받지 않아 **걸치지 않는 경우**와 동일하다. 걸치기 위해선 반드시 두 행 이상이 필요하기 때문에, $N > 1$을 충족해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927372-a880f480-c71b-11eb-84cc-689658a3a89c.png\" width=\"512px\" />\r\n</p>\r\n\r\n연결된 부분을 체크패턴으로 하이라이팅 했다. 이 둘이 서로 연결되기 때문에, 다른 구역의 특수소대가 점령할 수 없다. 따라서 <b class=\"red-A400\">해당 부분은 초기값 계산 시 없는 영역으로 생각하면 된다.</b> 이러한 특징을 감안하면 아래와 같이 초기값을 지정할 수 있다.\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 2\r\n$$\r\n\r\n$$\r\nb_1 = \r\n\\begin{cases}\r\n\t1, & (e_{10} + e_{11} ≤ W)\\\\\r\n\t2, & (e_{10} + e_{11} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $b_{N-1} + 1$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927427-b767a700-c71b-11eb-9306-0931ede25cba.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 아래 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927442-c6e6f000-c71b-11eb-8f51-2fab907fbcc2.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927459-d1a18500-c71b-11eb-9c6c-07919e9f4f8d.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = \r\n\\begin{cases}\r\n\t1, & (e_{00} + e_{01} ≤ W)\\\\\r\n\t2, & (e_{00} + e_{01} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_1 = 2\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $a_{N-1} + 1$이 알고리즘의 답이 된다. $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927475-e120ce00-c71b-11eb-8bd6-c44d4137fae8.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 두 행 모두 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927491-ee3dbd00-c71b-11eb-98b9-f0d4209ec965.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$, $e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927507-fd246f80-c71b-11eb-8e78-f08c15922ad8.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$, $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 1\r\n$$\r\n\r\n$$\r\nb_1 = 1\r\n$$\r\n\r\n$$\r\nc_1 = 0\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $c_{N-1} + 2$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$, $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_{N-1} + 2$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927519-07df0480-c71c-11eb-9fdf-c8f05858b72d.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 최종 케이스\r\n\r\n* 기본\r\n  * $a_0 = 1$\r\n  * $b_0 = 1$\r\n  * $c_0 = 0$\r\n\r\n<br />\r\n\r\n* 윗 행만 걸칠 경우 $(e_{00} + e_{0(N-1))} ≤ W)$\r\n  * $a_1 = 2$\r\n  * $b_1 = \\begin{cases} 1, & (e_{10} + e_{11} ≤ W)\\\\ 2, & (e_{10} + e_{11} > W) \\end{cases}$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 아래 행만 걸칠 경우 $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = \\begin{cases} 1, & (e_{00} + e_{01} ≤ W)\\\\ 2, & (e_{00} + e_{01} > W) \\end{cases}$\r\n  * $b_1 = 2$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 두 행 모두 걸칠 경우 $(e_{00} + e_{0(N-1)} ≤ W)$, $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = 1$\r\n  * $b_1 = 1$\r\n  * $c_1 = 0$\r\n\r\n비로소 알고리즘을 구현하기 위한 모든 준비물이 갖춰졌다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1006 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/06/A1006/\">1006 풀이</a>\r\n * @since 2021.06.06 Sun 22:44:45\r\n */\r\npublic class Main\r\n{\r\n\tprivate static int N;\r\n\tprivate static int W;\r\n\t\r\n\tprivate static int[][] e;\r\n\t\r\n\tprivate static int[] a;\r\n\tprivate static int[] b;\r\n\tprivate static int[] c;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tint result = 2147483647;\r\n\t\t\t\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 행 수\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\t// 특수소대원 수\r\n\t\t\tW = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 구역별 적 배열\r\n\t\t\te = new int[2][N];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < 2; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tfor (int k = 0; k < N; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\te[j][k] = Integer.parseInt(temp[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ta = new int[N];\r\n\t\t\tb = new int[N];\r\n\t\t\tc = new int[N + 1];\r\n\t\t\t\r\n\t\t\ta[0] = 1;\r\n\t\t\tb[0] = 1;\r\n\t\t\tc[0] = 0;\r\n\t\t\t\r\n\t\t\t// 인덱스 0부터 시작\r\n\t\t\tsolve(0);\r\n\t\t\t\r\n\t\t\tresult = Math.min(result, c[N]);\r\n\t\t\t\r\n\t\t\t// 두 행 이상일 경우\r\n\t\t\tif (N > 1)\r\n\t\t\t{\r\n\t\t\t\t// 두 행 모두 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W && e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 1;\r\n\t\t\t\t\tb[1] = 1;\r\n\t\t\t\t\tc[1] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, c[N - 1] + 2);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 윗 행만 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 2;\r\n\t\t\t\t\tb[1] = e[1][0] + e[1][1] > W ? 2 : 1;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, b[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아래 행만 걸칠 경우\r\n\t\t\t\tif (e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = e[0][0] + e[0][1] > W ? 2 : 1;\r\n\t\t\t\t\tb[1] = 2;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, a[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 함수\r\n\t *\r\n\t * @param num: [int] 시작 인덱스\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\tfor (int i = num; i < N; i++)\r\n\t\t{\r\n\t\t\tc[i + 1] = Math.min(a[i] + 1, b[i] + 1);\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\tif (e[0][i] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i] + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두개의 구역 2개를 점령할 수 있을 경우\r\n\t\t\tif (i > 0 && e[0][i - 1] + e[0][i] <= W && e[1][i - 1] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i - 1] + 2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// a, b팀의 인덱스 보정 (c팀은 인덱스가 하나 더 많음)\r\n\t\t\tif (i < N - 1)\r\n\t\t\t{\r\n\t\t\t\ta[i + 1] = c[i + 1] + 1;\r\n\t\t\t\tb[i + 1] = c[i + 1] + 1;\r\n\t\t\t\t\r\n\t\t\t\t// a팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[0][i] + e[0][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[i + 1] = Math.min(a[i + 1], b[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// b팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[1][i] + e[1][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\tb[i + 1] = Math.min(b[i + 1], a[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n6월 1일부터 풀기 시작해서 이 문제를 완전히 이해하는데 근 일주일 가까이 걸렸다. 나름의 풀이를 작성해야하는데, 남의 풀이가 아닌 내 풀이를 작성하기 위해선 해당 문제를 온전히 이해할 필요가 있었다. 내가 다른 사람들의 풀이를 보면서 이해하지 못해서 내 스스로 생각하고 이해한 걸 나름대로 녹여냈다. 다른 사람이 내 글을 보고 이 어려운 문제를 쉽게 이해할 수 있었으면 좋겠다.\r\n\r\n이해하고 봐도 다소 난해한데, 이걸 원리부터 코드까지 이끌어내어 풀어내는 사람은 정말 대단한 거 같다. 아님 내가 실력이 없는건가.\r\n\r\n## 참고\r\n\r\n* [The Casterian](https://casterian.net/archives/1356)\r\n* [굳건하게](https://travelbeeee.tistory.com/354)\r\n* [테스트 케이스](https://www.acmicpc.net/board/view/11381)","url":["2021-06-06-A1006","2021","06","06","A1006"]},{"header":{"title":"Compiler(컴파일러) & Interpreter(인터프리터)","excerpt":"천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다. 하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 컴퓨터가 알아먹을 수 있어야 실행된다는 얘기다. 글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 컴퓨터는 개발 이래로 초지일관 기계어만을 고집한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.","coverImage":"https://user-images.githubusercontent.com/50317129/120613280-0a79f980-c491-11eb-81a9-15e63062db75.png","date":"2021-06-03T17:25:23","type":"posts","category":"CS","tag":["Compiler(컴파일러)","Interpreter(인터프리터)"],"comment":true,"publish":true},"name":"2021-06-03-compiler-interpreter.md","content":"\r\n# 컴파일러와 인터프리터\r\n\r\n천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다.\r\n\r\n하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 <span class=\"blue-500\">컴퓨터가 알아먹을 수 있어야 실행된다</span>는 얘기다.\r\n\r\n글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 <span class=\"blue-500\">컴퓨터는 개발 이래로 초지일관 기계어만을 고집</span>한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.\r\n\r\n우리가 일상생활에서 외국어를 접할 때, 번역기라는 걸 사용해서 한글로 번역하면 우리가 비교적 쉽게 이해할 수 있다. 그렇다면 이 프로그래밍 언어들을 컴퓨터가 이해할 수 있는 기계어로 번역해준다면, 컴퓨터는 우리가 짠 코드를 이해하고 코드를 실행시킬 수 있을 것이다. 이를 위해 <span class=\"blue-500\">모든 언어는 해당 언어를 기계어로 번역할 수 있는 도구를 사용하여 기계어로 번역</span>한다. 이 번역기들은 방식에 따라 크게 두 가지로 구분할 수 있는데, <span class=\"green-500\">컴파일러</span>와 <span class=\"pink-500\">인터프리터</span>다.\r\n\r\n# Compiler(컴파일러)\r\n\r\n<span class=\"green-500\">컴파일러</span>는 소스코드 전체를 기계어로 번역해주는 도구다. 기계어로 번역된 결과물이 생성되고, 프로그램 실행 시 번역한 결과물을 실행한다. 굳이 기계어가 아니더라도, 원래의 원시코드(소스코드) 전체를 목적코드(기계어 등)로 번역한다면 <span class=\"green-500\">컴파일러</span>라 할 수 있다. 핵심은 전체 원시코드를 다른 코드로 변환함에 있다. <span class=\"green-500\">컴파일러</span> 아래와 같은 특징을 가지고 있다.\r\n\r\n1. <b class=\"primary\">소스코드 전체 번역</b>  \r\n   이러한 특징으로 별도의 컴파일 시간이 요구되며, 코드 한 글짜만 변경하더라도 재컴파일을 수행해야 한다. 코드의 규모가 클 수록 컴파일에 요구되는 시간 또한 늘어난다.\r\n\r\n2. <b class=\"primary\">빠른 속도</b>  \r\n   이미 컴파일을 수행하여 기계어로 번역했기 때문에, 프로그램 실행 시점엔 컴퓨터가 별다른 작업 없이 해당 프로그램을 이해할 수 있다. 즉, 실행 속도가 <span class=\"pink-500\">인터프리터</span>에 비해 대체적으로 빠르다.\r\n\r\n3. <b class=\"primary\">플랫폼 의존성</b>  \r\n   <span class=\"green-500\">컴파일러</span>는 컴파일한 컴퓨터의 CPU, OS에 해당하는 기계어로 번역한다. 즉, CPU나 OS의 구조가 다른 컴퓨터에선 정상적인 동작을 보증할 수 없다. 이와 더불어, 특정 PC에 맞게 컴파일하려면 특정 PC의 CPU와 OS를 가진 컴퓨터가 필요하다.\r\n\r\n4. <b class=\"primary\">강한 보안</b>  \r\n   소스코드의 결과물이 기계어로 번역된 실행 파일이므로 보안이 상대적으로 우수하다. 단, 이는 어디까지나 상대적인 것으로, 실행 파일의 암호화나 소스코드의 난독화가 되어있지 않을 경우, 디컴파일, 해킹같은 분석기법을 통해 코드를 역설계할 수도 있다. 물론 이 자체로도 큰 분야이므로 많은 기술력을 요한다.\r\n\r\n<span class=\"green-500\">컴파일러</span>를 차용하는 언어는 아래와 같다.\r\n\r\n* C계열 (C, C++, C#)\r\n* FORTRAN\r\n* Go\r\n* JAVA (기본적으론 컴파일러 방식)\r\n* Pascal\r\n* Rust\r\n* Visual Basic\r\n\r\n대체적으로 초창기에 출시된, 역사가 깊은 언어가 대부분이다.\r\n\r\n지금의 컴퓨터와 달리, 초창기 컴퓨터들은 사양이 그리 좋지 못 했다. VGA대란을 무시하고 보편적인 하이엔드급 컴퓨터 본체가 대략 200만원 선임을 감안할 때, 동일한 가격으로 90년대 컴퓨터는 CPU가 Intel Pentium 100, RAM은 8MB, HDD는 1GB였다. RAM의 경우 단위를 GB로 바꿔도 다소 부족함을 감안한다면 실로 엄청난 차이.\r\n\r\n이러한 점으로 미루어보아 컴퓨터 자원을 낭비할 수 없었음이 당연할 것이다. 때문에 선처리 과정이 얼마나 걸리든 관계없이, 컴퓨터에서 가능한한 빠르고 가볍게 실행하는 것이 최우선 과제였을 것이다. 이러한 상황에서 초창기 언어들이 <span class=\"green-500\">컴파일러</span>를 차용한 것은 당연한 것이다.\r\n\r\n# Interpreter(인터프리터)\r\n\r\n<span class=\"pink-500\">인터프리터</span>는 실행 시 코드를 한 줄씩 읽어서 기계어로 번역하는 도구다. 한 줄씩 읽어서 실행하므로 별도의 결과물이 생성되지 않아 소스코드 자체가 실행 파일이 된다. 마찬가지로 굳이 기계어가 아니더라도 원래의 코드를 한 줄씩 읽어서 중간코드(기계어 등)으로 변환하여 실행한다면 <span class=\"pink-500\">인터프리터</span>라 할 수 있다. 핵심은 <span class=\"blue-500\">원시코드를 한 줄씩 읽어서 변환함</span>에 있다. <span class=\"pink-500\">인터프리터</span>는 아래와 같은 특징을 가지고 있다.\r\n\r\n1. <b class=\"primary\">소스코드 한줄 씩 변경</b>  \r\n   실행할 때마다 코드를 읽어서 번역하므로 컴파일이라는 작업 자체가 존재하지 않는다. 때문에 생산성이 매우 높다.\r\n\r\n2. <b class=\"primary\">느린 속도</b>  \r\n   컴파일 작업이 없는 대신, 프로그램 실행 시 코드 한 줄마다 작은 컴파일 작업이 이루어진다고 생각하면 된다. 때문에 <span class=\"green-500\">컴파일러</span>에 비해 상대적으로 실행 속도가 느리다.\r\n\r\n3. <b class=\"primary\">플랫폼 독립성</b>  \r\n   소스코드를 통해 프로그램을 실행하므로 컴퓨터의 CPU, OS의 영향을 받지 않는다. 해당 소스코드를 실행할 환경만 구축한다면, 어디서나 동일한 동작을 보증한다.\r\n\r\n4. <b class=\"primary\">약한 보안</b>  \r\n   소스코드 자체가 실행 파일이므로 코드가 유출되기 매우 쉽다. 중요한 동작이나 정보를 다룰 경우 난독화나 암호화를 반드시 해야한다. 이러한 보안작업은 오히려 프로그램의 실행 속도를 더욱 낮추기도 한다.(복호화 등의 작업 추가됨)\r\n\r\n<span class=\"pink-500\">인터프리터</span>를 차용하는 언어는 아래와 같다.\r\n\r\n* HTML\r\n* JavaScript\r\n* PHP\r\n* Python\r\n* Ruby\r\n\r\n<span class=\"green-500\">컴파일러</span>와 달리 비교적 젊은 언어들이 차지하고 있다. 현대에 들어서면서 컴퓨터의 성능이 급격히 좋아짐에 따라 연산 속도도 증가했다. 이와 더불어 시간이 지나면서 인터프리터의 속도 이슈를 해결할 여러 기술들이 개발되기도 했다. 이와 같은 노력들이 <span class=\"pink-500\">인터프리터</span>의 단점을 상쇄시켜줌에 따라 <span class=\"pink-500\">인터프리터</span>의 장점인 높은 생산성이 부각됐다. 이러한 이유로 <span class=\"pink-500\">인터프리터</span>의 언어는 비교적 최신 언어에 많이 적용되어있다.","url":["2021-06-03-compiler-interpreter","2021","06","03","compiler-interpreter"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1005번 ACM Craft","excerpt":"서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-01T01:27:56","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","위상 정렬","GOLD","GOLD III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-01-A1005.md","content":"\r\n# ACM Craft\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1005번 문제](https://www.acmicpc.net/problem/1005)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다.\r\n\r\n이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219763-b1cf1480-c276-11eb-8131-a3471db1cfc4.png\" width=\"1024px\" />\r\n</p>\r\n\r\n위의 예시를 보자.\r\n\r\n이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할 수 있다. (동시에 진행이 가능하다.) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번 건물의 건설을 시작할 수 있다.\r\n\r\n따라서 4번 건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물와 3번 건물을 동시에 건설하기 시작하면 2번은 1초 뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을 수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.\r\n\r\n프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM Craft 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정 건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정 건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.\r\n\r\n## 입력\r\n\r\n첫째 줄에는 테스트케이스의 갯수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다, 첫째 줄에 건물의 갯수 $N$과 건물 간의 건설순서 규칙의 총 갯수 $K$가 주어진다.(전물의 번호는 1번 부터 $N$번 까지 존재한다.)\r\n\r\n둘째 줄에는 각 건물 당 건설에 걸리는 시간 $D$가 공백을 사이로 주어진다. 셋째 줄부터 $K + 2$줄 까지 건설순서 $X$ $Y$가 주어진다.(이는 건물 X를 지은 다음에 건물 $Y$를 짓는 것이 가능하다는 의미이다.)\r\n\r\n마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 $W$가 주어진다.\r\n\r\n## 출력\r\n\r\n건물 $W$를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.  \r\n건설순서는 모든 건물이 건설 가능하도록 주어진다.\r\n\r\n## 제한\r\n\r\n* $2 ≤ N ≤ 1,000$\r\n* $1 ≤ K ≤ 100,000$\r\n* $1 ≤ X, Y, W ≤ N$\r\n* $0 ≤ D ≤ 100,000)$ $D$는 정수\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4 4\r\n10 1 100 10\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4\r\n8 8\r\n10 20 1 5 8 7 1 43\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n5 7\r\n6 7\r\n7 8\r\n7\r\n```\r\n+ 출력\r\n\r\n``` tc\r\n120\r\n39\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n3 2\r\n1 2 3\r\n3 2\r\n2 1\r\n1\r\n4 3\r\n5 5 5 5\r\n1 2\r\n1 3\r\n2 3\r\n4\r\n5 10\r\n100000 99999 99997 99994 99990\r\n4 5\r\n3 5\r\n3 4\r\n2 5\r\n2 4\r\n2 3\r\n1 5\r\n1 4\r\n1 3\r\n1 2\r\n4\r\n4 3\r\n1 1 1 1\r\n1 2\r\n3 2\r\n1 4\r\n4\r\n7 8\r\n0 0 0 0 0 0 0\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4 5\r\n4 6\r\n5 7\r\n6 7\r\n7\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n6\r\n5\r\n399990\r\n2\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 이해가 되는데, 이를 코딩으로 풀어내기가 어려웠던 알고리즘. <span class=\"primary\">위상정렬</span> 알고리즘에 대한 이해가 있어야한다.  \r\n문제의 경우, 스타크래프트의 건물 테크트리랑 비슷한 개념으로 접근하면 된다. 군수공장을 짓기 위해선 병영을 지어야하는 것처럼, 요구 트리가 있는 건물의 경우 해당 건물을 반드시 완료해야 하며, 하나의 건물이 여러 요구 트리를 가질 경우도 존재한다. 물론 이 경우 요구하는 건물들을 **모두** 건설한 뒤에 건설 가능하다. 요구하는 건물들 중 하나만 건설하면 충족되는게 아니다.\r\n\r\n<span class=\"primary\">위상정렬</span>은 <span class=\"green-A400\">순서가 정해진 작업을 수행할 때, 이 순서를 결정하는 알고리즘</span>이다. <span class=\"primary\">위상정렬</span>은 반드시 DAG(Directed Acyclic Graph, 유향 비순환 그래프) 형태여야 한다. 즉, 순서를 도식화했을 때 반드시 <span class=\"red-A400\">시작/도착점이 존재</span>해야 한다. 시작/도착점이 구분되지 않는 순환 형태일 경우 위상정렬을 적용할 수 없다.\r\n\r\n위상정렬은 순서를 정하는 알고리즘이고, 순서도의 형태에 따라 여러가지의 답이 나올 수 있다. 이 문제는 최적의 답을 도출하기 위해 각 **건물을 건설하는데 필요한 요구 건물**과 **건설 시간**을 적용했다.\r\n\r\n다음 건물을 건설하기 위해선 요구 건물을 모두 건설해야하므로 요구 건물의 건설시간이 가장 많은 건물이 다음 순서가 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219453-3b321700-c276-11eb-9029-ec105c694854.png\" width=\"1024px\" />\r\n</p>\r\n\r\n예시 1번의 두 번째 케이스를 예시로 하여 위상정렬을 도식화하면 위 사진과 같다.\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   0   |   1   |   1   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n위 표는 도식를 수치화하여 정리한 것이다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">1. 순서의 시작점(진입선이 없는 점)을 찾는다. 시작점이 여러개일 경우 시작점 중 무작위로 하나를 선택해도 무방하다. (위 예시는 시작점이 하나)</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219469-4127f800-c276-11eb-91c8-db36e543c217.png\" width=\"1024px\" />\r\n</p>\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">2. 시작점 1을 큐에 넣고, 시작점에 연결된 진출선을 전부 제거한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219471-438a5200-c276-11eb-9cd3-ca5f31dfb19b.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   0   |   0   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |\r\n| :---: | :---: |\r\n\r\n이 과정에서 2와 3이 새로운 시작점이 된 것을 확인할 수 있다.\r\n\r\n1을 건설하는데 걸리는 시간은 1초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">3. 2에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219484-45ecac00-c276-11eb-8114-a6c4c8b17036.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   0   |   0   |   0   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |\r\n| :---: | :---: | :---: |\r\n\r\n4와 5의 진입선이 0이 된다. 즉, 4와 5를 건설할 수 있게 된다.\r\n\r\n2를 건설하는데는 $10(1) + 20(2)$로 총 30초가 소요된다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">4. 3에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219493-48e79c80-c276-11eb-8f48-cf132cab8f5c.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   0   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n\r\n6의 진입선이 0이 된다. 6을 건설할 수 있게 된다.\r\n\r\n3의 건설시간은 $10(1) + 1(3)$으로 총 11초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">5. 4에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219504-4be28d00-c276-11eb-9b40-07c5ea51cbd9.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |\r\n| :---: | :---: | :---: | :---: | :---: |\r\n\r\n4는 진출선이 없으므로 큐에만 추가된다.\r\n\r\n4의 건설시간은 $10(1) + 20(2) + 5(4)$로 총 35초\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">6. 5에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219509-4edd7d80-c276-11eb-9c5f-fc17d373bf50.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   0   |   1   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7이 5와 6에 연결되어 있으므로, 7의 진입선은 1이 된다. 아직 7을 건설할 수 없다.\r\n\r\n5의 건설시간은 $10(1) + 20(2) + 8(5)$로 총 38초\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">7. 6에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219520-53099b00-c276-11eb-9c99-060dcd2039d8.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   0   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7의 진입선이 0이 된다. 7을 건설할 수 있게 된다.\r\n\r\n6의 건설시간은 $10(1) + 1(3) + 7(6)$으로 총 18초.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">8. 7에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219527-56048b80-c276-11eb-866b-9b411445b22b.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   0   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n8의 진입선이 0이 된다.\r\n\r\n1 ~ 6까지는 요구 건물이 하나였지만, 7은 두개이다. 앞서 언급했듯이, 5와 6 중 건설시간이 더 긴 것을 기준으로 계산해야한다.\r\n\r\n즉, 7의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7)$로 총 39초\r\n\r\n5번을 기준으로 계산하므로, <span class=\"red-A400\">6번과 중간인 3번은 계산에서 제외</span>된다. 만약, 3의 건설시간을 1초에서 4초로 증가시켜도 결과에 영향을 미치지 않는다. 3의 건설시간을 무시하기 때문이다. 단, 3의 건설시간이 너무 커지게되면 5보다 6의 건설시간이 같이 커지게 되어 결과에 영향을 미치게 된다.\r\n\r\n<br />\r\n\r\n<span class=\"large orange-A400\">9. 8에 대해 2번 과정을 적용한다.</span>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120219535-58ff7c00-c276-11eb-907c-2a90cc84c596.png\" width=\"1024px\" />\r\n</p>\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n문제는 7에 대한 건설시간을 요구하고 있으므로 8은 무시해도 무방하다. \r\n8의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7) + 43(8)$로 총 82초\r\n\r\n## 전체 소스\r\n\r\n`time`, `matrix`, `link`의 배열 크기가 $N + 1$이다. 별다른 이유는 아니고, 건물은 1번부터 시작하는데 배열은 0번부터 시작한다. 이러한 차이에서 오는 혼란을 방지하기 위해 건물이 총 4개면 배열의 크기를 5로(0, 1, 2, 3, 4, 5)로 지정하여 0을 제외하고 1부터 사용한다.\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1005 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.05.31 Mon 19:11:58\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\t// 케이스 갯수\r\n\t\tint T = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 건물 갯수\r\n\t\t\tint N = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 규칙(건설시간) 갯수\r\n\t\t\tint K = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 건물별 건설시간 배열\r\n\t\t\tint[] time = new int[N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결여부 배열\r\n\t\t\tboolean[][] maxtrix = new boolean[N + 1][N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결 갯수 배열\r\n\t\t\tint[] link = new int[N + 1];\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j < N + 1; j++)\r\n\t\t\t{\r\n\t\t\t\ttime[j] = scanner.nextInt();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물\r\n\t\t\t\tint X = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\t// 상위 건물\r\n\t\t\t\tint Y = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\tmaxtrix[X][Y] = true;\r\n\t\t\t\tlink[Y]++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표 건물\r\n\t\t\tint W = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tbuilder.append(calcTopologicalSort(time, maxtrix, link)[W]).append(\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString());\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위상정렬 결과 반환 함수\r\n\t *\r\n\t * @param time: [int[]] 건물별 건설시간\r\n\t * @param matrix: [boolean[][]] 건물별 연결여부\r\n\t * @param link: [int[]] 건물별 연결 갯수\r\n\t *\r\n\t * @return [int[]] 건물별 종 건설시간 배열\r\n\t */\r\n\tprivate static int[] calcTopologicalSort(int[] time, boolean[][] matrix, int[] link)\r\n\t{\r\n\t\tQueue<Integer> queue = new LinkedList<>();\r\n\t\t\r\n\t\tint[] result = new int[link.length];\r\n\t\t\r\n\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t{\r\n\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\tif (link[i] == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = time[i];\r\n\t\t\t\tqueue.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\t// 하위 건물\r\n\t\t\tint prev = queue.poll();\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물 건설을 요구 하는 건물일 경우\r\n\t\t\t\tif (matrix[prev][i])\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = Math.max(result[i], result[prev] + time[i]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 해당 건물의 요구 건물 갯수 1 감소\r\n\t\t\t\t\t--link[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\t\t\tif (link[i] == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tqueue.add(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 그래프 이론\r\n* 위상 정렬","url":["2021-06-01-A1005","2021","06","01","A1005"]},{"header":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true},"name":"2021-05-30-unsupported-version-error.md","content":"\r\n# Unsupported major.minor version\r\n\r\n간혹 JAVA 프로그램을 실행하다보면 <span class=\"error\">Unsupported major.minor version 52</span>(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다.  \r\n<span class=\"error\">Unsupported major.minor version</span> 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.\r\n\r\n# 원인\r\n\r\nJAVA는 컴파일 언어로, 개발자가 작성한 코드는 `.java` 파일이다. 이를 컴파일하면 JVM(Java Virtual Machine, 자바 가상머신)이 읽을 수 있는 `.class` 파일로 번역한다. 코딩은 사람이 이해할 수 있는 언어로 작성하고, 실제 동작은 컴파일을 통해 컴퓨터가 이해할 수 있는 언어를 사용하는 셈이다.  \r\nJAVA는 작성일 기준으로 16까지 릴리즈됐다. JAVA의 역사가 짧지 않고, 이 시간동안 크고작은 버전 업데이트가 지속적으로 이루어졌다.  \r\n문제는 이 과정에서 생긴 호환성 문제다. 1.5 버전으로 컴파일한 `.class` 파일을 1.8 버전의 환경에서 구동한다거나, 그 반대의 경우가 그 예시다. 다행스럽게도, JAVA는 하위 버전에 대한 호환성을 보장한다. 1.8 버전의 환경에서는 1.8 이하로 컴파일된 `.class` 파일의 실행을 보장한다. 하지만 반대로 상위 버전에 대한 호환성은 제공하지 않는다. 그도 그럴 것이, 호환성을 지키기 위해선, 각 버전 간의 구성을 알맞게 변환해야 하는데, 아직 개발되지 않은 미래 버전의 구성을 알 순 없는 노릇이니...\r\n\r\n| 프로그램 JAVA 버전 | PC JAVA 버전 | Unsupported 오류 발생여부 |              해결책              |\r\n| :----------------: | :----------: | :-----------------------: | :------------------------------: |\r\n|         14         |     1.8      |             O             | JAVA 14 버전 이상으로 업그레이드 |\r\n|        1.6         |     1.7      |             X             |              칼퇴근              |\r\n\r\n즉, <span class=\"green-A400\">Unsupported major.minor version 오류는 내가 실행하려는 JAVA 코드가 내 PC의 JAVA 환경보다 높은 버전에서 컴파일된 경우 발생</span>한다.\r\n\r\n# 해결\r\n\r\n결과적으로, JAVA 버전을 동등 혹은 그 이상의 상위버전으로 업그레이드하면 된다. 크게 두 가지 방법이 있다.\r\n\r\n## 프로그램 코드의 버전 다운그레이드\r\n\r\n만약 본인이 온전한 프로그램 코드를 갖고 있을 경우, 시도해볼 수 있는 방법이다.  \r\n<span class=\"green-A400\">JAVA 버전을 다운그레이드하고 컴파일을 진행</span>하면, 프로그램의 JAVA 버전이 낮아져 기존의 버전보다 훨씬 낮은 버전의 환경에서 구동이 가능하다.\r\n\r\n단, 조건이 있다. JAVA 버전이 업그레이드됨에 따라 여러 신규 패턴, 문법 등이 추가됐다. 만약 <span class=\"red-A400\">1.8 버전부터 새로 생긴 기능을 적극적으로 활용했다면, 1.7 이하의 버전에선 컴파일 오류가 발생</span>한다.  \r\n그도 그럴것이, 1.8 부터 생긴 기능은 1.7에서는 구현되지 않은 기능이기 때문.\r\n\r\n이 경우 프로그램의 코드를 좀더 범용적인 방식으로 리팩토링해야한다.\r\n\r\n## PC의 버전 업그레이드\r\n\r\n만약 본인이 `.class` 파일만 갖고있다거나, 상기한 문제로 다운그레이드가 어려울 경우 혹은 간단한 방법을 찾을 경우 시도해볼 수 있는 방법이다.\r\n<span class=\"green-A400\">PC의 JAVA 버전을 업그레이드하고 프로그램을 실행</span>하면 된다.\r\n\r\nJAVA는 하위 호환성을 지키기 때문에, 별다른 조건이 존재하지 않는다.\r\n\r\n# 아니 버전 맞췄다고 아ㅋㅋ\r\n\r\n톰캣을 사용하다보면, 이 오류가 뜨는 경우가 있다. 그런데 간혹 PC에 설치된 JAVA 버전에 맞게 컴파일을 해줬음에도 오류가 사라지지 않는 현상이 발생하기도 한다.  \r\n이 경우 동반되는 증상이, Servlet Context에 접근할 경우, 첫 접속시 500 에러(Unsupported major.minor version 오류로 인해 발생)가 발생하고, 이후부터는 404 에러만 발생한다. 이러한 현상을 겪어보지 않았거나, 경험이 적은 개발자가 이러한 문제에 부딪히면 십중팔구 고생한다. 원인인 Unsupported major.minor version 오류가 보이지 않아 Servlet 동작의 404 오류와 관련된 정보를 검색하거나 질문하기 때문. 당연히 이러한 사정을 모르는 다른 사람들은 404 오류에 관한 답변을 줄 수 밖에 없다. 이런 경우 정말 난감하기 그지없다. 절대 경험담이라서가 아니다.\r\n\r\n혹시 위 처럼 정상적인 Servlet(서블릿)임에도 불구하고 404 오류가 뜰 경우 아래의 환경변수에서 JRE_HOME이 설정돼있는지 확인해보자.  \r\n간혹 개발 프로그램 중 임의로 JRE_HOME을 설정해버리는 프로그램이 존재한다. 문제는 여기서 발생하는데, JAVA_HOME과 JRE_HOME 환경변수가 둘 다 설정되어있을 경우, <span class=\"red-A400\">톰캣은 JRE_HOME을 우선</span>한다. 즉 JRE의 버전이 적용된다.\r\n\r\n예를 들어, JAVA_HOME이 1.8 버전, JRE_HOME이 1.6 버전이라 가정하자. 컴파일은 반드시 JDK가 필요하므로 JAVA_HOME의 버전인 1.8로 컴파일이 수행된다. 그러나 톰캣 실행 시, JRE_HOME을 우선하는 특징으로 인해 1.6 버전으로 실행된다. 결과적으로 **1.8 버전으로 컴파일된 코드를 1.6으로 실행하는 셈**이니, 버전이 맞지 않아 오류가 발생한다.","url":["2021-05-30-unsupported-version-error","2021","05","30","unsupported-version-error"]},{"header":{"title":"URI? URL? URN? 리소스 식별자 구분하기","excerpt":"우리가 인터넷 상에서 특정한 데이터에 접근할 때 URL이라는 것을 활용하여 접근한다. 원하는 자료의 URL을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 URL을 호출하여 응답을 얻는 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028437-a63ddc80-c02f-11eb-9d41-7c50d7002a42.png","date":"2021-05-29T03:30:17","type":"posts","category":"WEB","tag":["WEB(웹)","URI","URL","URN"],"comment":true,"publish":true},"name":"2021-05-29-uri-url-urn.md","content":"\r\n# URL! URI... URN??\r\n\r\n우리가 인터넷 상에서 **특정한 데이터**에 접근할 때 <span class=\"primary\">URL</span>이라는 것을 활용하여 접근한다.  \r\n원하는 자료의 <span class=\"primary\">URL</span>을 얻으면, 브라우저 같은 HTTP 통신 프로그램에 해당 <span class=\"primary\">URL</span>을 호출하여 응답을 얻는 것이다.\r\n\r\n개발자나, 굳이 개발자가 아니더라도 관련 정보를 찾다보면 심심치않게 <span class=\"primary\">URI</span>라는 용어를 접하게 된다.  \r\nI와 L의 오묘한 유사성 때문에 아예 <span class=\"primary\">URI</span>를 <span class=\"primary\">URL</span>로 오독하는가 하면, 오타라고 생각하는 사람도 더러 있을 것이다.  \r\n하지만 <span class=\"primary\">URL</span>과 <span class=\"primary\">URI</span>는 그 의미가 비슷하면서도 살짝 다르다.\r\n\r\n누구나 알고있는 <span class=\"primary\">URL</span>과 아리까리한 <span class=\"primary\">URI</span>, 생소한 <span class=\"primary\">URN</span>. 이들에 대해 알아보자\r\n\r\n# UR* 톱아보기\r\n\r\n<span class=\"primary\">URI</span>, <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>은 구조상 서로 연관이 있다.\r\n\r\n## URI(Uniform Resource Identifier, 통합 자원 식별자)\r\n\r\n<span class=\"primary\">URI</span>는 우리말로 **통합 자원 식별자**라고 한다. <span class=\"primary\">URI</span>는 앞서 말한 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>을 포함하는 상위 개념으로, <span class=\"orange-400\">인터넷 상에 존재하는 **자원을 구분**하는 식별자</span>라 할 수 있다. 웹 상에서 자원을 식별하는 모든 수단이 곧 <span class=\"primary\">URI</span>이라 할 수 있다.\r\n\r\n## URL(Uniform Resource Locater, 통합 자원 지시자)\r\n\r\n<span class=\"primary\">URL</span>은 굳이 우리말로 하자면 **통합 자원 지시자**라고 할 수 있겠지만, 흔히 인터넷 상에서 **주소**라 함은 99% 이 <span class=\"primary\">URL</span>을 의미한다. 1994년 **RFC-1738**에 정의되어있다.  \r\n<span class=\"primary\">URL</span>은 **Locater**라는 키워드에 걸맞게 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 **위치**를 나타내는 식별자</span>라 할 수 있다. 여기서 **위치**라는 키워드에 주목하자. <span class=\"primary\">URL</span>은 자원의 위치정보를 가지므로, 어떠한 이유로든 자원의 위치가 변경되면 <span class=\"primary\">URL</span>은 자원을 찾을 수 없으며, 변경된 위치를 추적할 수도 없다. 이 때 맞이하게 되는 HTTP 오류가 누구나 알고있는 404 Not Found다.  \r\n당장 내가 이 게시물의 이름을 한 글자만 변경해도, 지금까지의 <span class=\"primary\">URL</span>은 아무 쓸모가 없어지며, 사용자들 또한 해당 <span class=\"primary\">URL</span>로 이 게시물에 접근할 수 없다. 또한, 이 <span class=\"primary\">URL</span>을 통해 원래 있던 게시물의 <span class=\"primary\">URL</span>을 논리적으로 유추할 수도 없다.\r\n\r\n## URN(Uniform Resource Name, 통합 자원 이름)\r\n\r\n<span class=\"primary\">URN</span>은 **통합 자원 이름**이다. 눈치가 빠른 분들은 아시겠지만, <span class=\"primary\">URN</span>은 <span class=\"orange-400\">인터넷 상에 존재하는 자원의 **이름**을 나타내는 식별자</span>다. 자원의 이름은 고유한 값을 가지므로, 인터넷 상의 수 많은 자원들 중 특정 자원을 식별할 수 있는 것이다.  \r\n<span class=\"primary\">URN</span>은 대부분 위에 언급한 두 개념에 비해 생소할 것이다. 그도 그럴 것이, <span class=\"primary\">URN</span>은 위 두 개념보다 훨씬 뒤에 나온 개념이기 때문이다. 1997년 **RFC-2141**에 정의되어있다. <span class=\"primary\">URL</span>보다 3년 뒤에 출범하여 그 역사가 상대적으로 짧다.  \r\n\r\n<span class=\"primary\">URL</span>의 치명적인 단점은 **위치**정보 외에 다른 정보를 저장하지 않는다. 이 상황에서 해당 자원을 찾아야 한다면? 안타깝게도 <span class=\"primary\">URL</span>만으로는 찾아낼 수 없다. 구글링해서 운 좋게 찾아낸다면 모를까.  \r\n반면 <span class=\"primary\">URN</span>을 사용한다면 어떨까? 위치가 아무리 변경된다 하더라도, 자원의 고유한 이름을 통해 찾기 때문에 자원이 웹 상에서 완전히 삭제된 게 아니라면 손쉽게 찾아낼 수 있을 것이다.\r\n\r\n## 정리\r\n\r\n난 어려운 개념을 이해할 때 현실세계와 연관지어 이해하는 걸 좋아한다. 위 세 개념을 현실에서 특정 사람의 신원을 확인하는 과정과 접목해서 정리하면 아래와 같이 정리할 수 있을 것 같다.\r\n\r\n| 구분  |              현실               |         값          |\r\n| :---: | :-----------------------------: | :-----------------: |\r\n| 자원  |             나 자신             |         나          |\r\n|  URI  | 나를 식별할 수 있는 모든 식별자 |          -          |\r\n|  URL  |         내가 사는 주소          | 서울특별시 A구 가동 |\r\n|  URN  |         내 주민등록번호         |   000000-0000000    |\r\n\r\n<span class=\"small red-A400\">※ URN은 모든 자원의 고유값이므로, 사람과 연관지었을 때, 중복 가능성이 있는 이름 보다는 고유값인 주민등록번호가 더 적합하다.</span>\r\n\r\n예를 들어, 내 정보가 위와 같다고 가정해보자. 내가 사는 주소 및 내 주민등록번호 모두 내 신원을 확인할 수 있는 방식(<span class=\"primary\">URI</span>)이므로, 나를 찾기에 적합하다.  \r\n만약 내 주소(<span class=\"primary\">URL</span>)를 통해 확인할 경우, 내가 이사(자원의 이동)를 가게 되면 해당 주소엔 아무것도 없으며, 날 찾을 수도 없다(404 HTTP 에러). 또한, 내가 예전에 살던 주소만으로 내가 이사간 주소를 유추해낼 수도 없을 것이다.\r\n\r\n반면, 내 주민등록번호(<span class=\"primary\">URN</span>)을 통해 확인할 경우, 내 주민등록번호와 매칭되는 사람을 찾는 것으로 나를 식별할 수 있다. 이 과정에서 내가 어디에 있는지는 전혀 중요치 않은 것이다. 주민등록번호 자체가 말소(자원 삭제)되지 않는 한, 내가 어디에서 무엇을 하고있든 내 신원을 확인할 수 있다.\r\n\r\n# 구조\r\n\r\n그렇다면 이들은 어떻게 생겼는지 알아보자. <span class=\"primary\">URI</span>는 자원의 식별자를 포괄하여 지칭하는 개념 그 자체이므로, 구조라고 할 건 없다. 하위 개념인 <span class=\"primary\">URL</span>, <span class=\"primary\">URN</span>에 대해 알아보자.\r\n\r\n## URL 구조\r\n\r\n<span class=\"primary\">URL</span>은 아래와 같은 구조로 이루어진다. 매우 익숙할 것이다.\r\n\r\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">https</span>://<span class=\"green-400\">rwb0104</span>.<span class=\"yellow-400\">github</span>.<span class=\"pink-400\">com</span>:<span class=\"amber-400\">443</span>/<span class=\"cyan-400\">posts</span><span class=\"teal-400\">?category=WEB&page=1</span></p>\r\n\r\n구조별로 색상을 입혔으며, 순서대로 기술한다.\r\n\r\n### Protocol(프로토콜)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"lightBlue-400\">https</span> 부분.\r\n\r\n통신규약을 의미한다. 작성일 기준으로, 이 규약엔 계층별로 많은 <span class=\"lightBlue-400\">프로토콜</span>이 존재하는데, 웹 통신을 수행할 땐 크게 두 가지로 나뉜다.\r\n\r\n| 구분  |              내용              |\r\n| :---: | :----------------------------: |\r\n| HTTP  | W3 상에서의 HTML 문서 통신규약 |\r\n| HTTPS |    암호화된 HTTP 통신 규약     |\r\n\r\n현재는 포털, 쇼핑몰같은 대형 비즈니스 사이트나 블로그, 카페 등 중소규모의 개인 사이트까지 <span class=\"red-A400\">HTTPS의 사용이 반 강제적으로 권장</span>되어 있다. 특히 전자상거래가 접목된 비즈니스 사이트의 경우 필수로 적용해야 한다. 더군다나 <span class=\"red-A400\">HTTPS가 적용되지 않는 사이트(localhost 제외)에 접근할 경우 브라우저 측에서 보안 관련 경고 메시지</span>를 띄우니, 규모에 관계없이 웹 사이트를 운영할 경우 HTTPS는 필수로 적용하는 편이다.\r\n\r\n### SLD(Second Level Domain, 서브도메인, 호스트)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"green-400\">rwb0104</span> 부분.\r\n\r\n도메인 앞에 붙으며, <span class=\"green-400\">서브도메인</span>을 통해 하나의 <span class=\"yellow-400\">도메인</span>으로 다중 서비스를 제공할 수 있다. 하나의 <span class=\"yellow-400\">도메인</span>에 여러 <span class=\"green-400\">서브도메인</span>을 생성할 수 있으며, 우리가 흔히 아는 `www` 외에도 `dev`, `admin`, `m` 용도에 따라 다양한 문자열을 지정할 수 있다.\r\n\r\n|                  URL                   |                                          내용                                          |\r\n| :------------------------------------: | :------------------------------------------------------------------------------------: |\r\n|     [naver.com](https://naver.com)     | 기본 네이버 홈페이지. 각 플랫폼(데스크탑, 모바일 등)에 가장 적합한 사이트로 리다이렉트 |\r\n| [www.naver.com](https://www.naver.com) |                               데스크탑용 네이버 홈페이지                               |\r\n|   [m.naver.com](https://m.naver.com)   |                                모바일용 네이버 홈페이지                                |\r\n| [map.naver.com](https://map.naver.com) |                                      네이버 지도                                       |\r\n\r\n위는 네이버 서비스의 <span class=\"green-400\">서브도메인</span>으로, `naver.com` <span class=\"yellow-400\">도메인</span>을 중심으로 각기 다른 서비스를 제공하는 것을 확인할 수 있다.\r\n\r\n### Domain(도메인)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"yellow-400\">github</span> 부분.\r\n\r\nURL의 중심이 되는 부분으로, 제공하는 웹 서비스의 아이덴티티 역할을 겸한다. 때문에 <span class=\"yellow-400\">도메인</span>에는 대부분 해당 웹 서비스의 이름이 들어간다.\r\n\r\n|  서비스   |                  URL                   |\r\n| :-------: | :------------------------------------: |\r\n|  네이버   |     [naver.com](https://naver.com)     |\r\n|   다음    |  [www.daum.com](https://www.daum.com)  |\r\n|  GitHub   |    [github.com](https://github.com)    |\r\n| Instagram | [instagram.com](https://instagram.com) |\r\n\r\n대부분의 서비스가 <span class=\"yellow-400\">도메인</span>으로 서비스의 이름을 사용하고 있다.\r\n\r\n### TLD(Top Level Domain, 최상위 도메인)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"pink-400\">com</span> 부분.\r\n\r\n<span class=\"pink-400\">최상위 도메인</span>이란, 앞서 언급한 <span class=\"green-400\">서브도메인</span>, <span class=\"yellow-400\">도메인</span>을 관리하는 업체 혹은 기관이라고 볼 수 있다.  \r\n앞서 언급한 개념의 경우, 중복되지 않는 선에서 사용자가 임의로 지정할 수 있다. 하지만 <span class=\"pink-400\">최상위 도메인</span>의 경우 현재 운영 중인 업체나 기관 중 하나를 **선택**해서 등록해야 한다. <span class=\"pink-400\">최상위 도메인</span>을 선택할 경우, 당신의 도메인은 해당 <span class=\"pink-400\">최상위 도메인</span>을 운영하는 곳에서 관리하게 된다.  \r\n\r\n<span class=\"pink-400\">최상위 도메인</span>은 운영 주체에 따라 두 가지로 나뉜다.\r\n\r\n#### ccTLD(country code TLD, 국가 코드 최상위 도메인)\r\n\r\n국가를 나타내는 <span class=\"pink-400\">최상위 도메인</span>이다.\r\n\r\n| ccTLD |     내용      |\r\n| :---: | :-----------: |\r\n|  .kr  |  한국(KISA)   |\r\n|  .us  |   미국(LLC)   |\r\n|  .jp  |     일본      |\r\n|  .io  | 영국령 인도양 |\r\n\r\n<span class=\"pink-400\">ccTLD</span>는 위 표와 같이 국가 코드 형태이며, 각 국가기관이 직접 관리한다. 즉, `.kr`을 가진 모든 도메인은 **한국의 KISA(한국 인터넷 진흥원)에서 관리**한다.\r\n\r\n#### gTLD(generic TLD, 일반 최상위 도메인)\r\n\r\n사이트 혹은 사이트를 소유한 조직, 기관의 특성에 따라 사용하는 <span class=\"pink-400\">최상위 도메인</span>이다.\r\n\r\n| gTLD  |       내용        |\r\n| :---: | :---------------: |\r\n| .com  | 영리 단체 및 기관 |\r\n| .net  | 네트워크 관리기관 |\r\n| .org  |    비영리 기관    |\r\n| .gov  |     정부 기관     |\r\n\r\n<span class=\"pink-400\">gTLD</span>는 위 표와 같이 다양한 종류가 있으며, 그 중 몇몇은 자주 접했을 것이다. 정부기관이 왜 여기있나 생각할 수도 있는데, <span class=\"pink-400\">ccTLD</span>는 **국가 코드**만 해당된다. 국가 예하의 정부기관, 군사조직 등은 구분 상 <span class=\"pink-400\">gTLD</span>로 분류된다.  \r\n마찬가지로, 각 <span class=\"pink-400\">최상위 도메인</span>은 **해당 <span class=\"pink-400\">최상위 도메인</span>을 소유한 기관 혹은 기업에서 관리**한다.\r\n\r\n> 현재 운영 중인 <span class=\"pink-400\">최상위 도메인</span>은 [IANA](https://www.iana.org/domains/root/db)에서 확인할 수 있다.\r\n\r\n여담으로, <span class=\"pink-400\">최상위 도메인</span>에 중복된 <span class=\"yellow-400\">도메인</span>을 등록할 수 없다. 예를 들어, 내가 `aaa.com` URL을 등록한다고 가정해보자.  \r\n우선 제일 먼저 `.com`을 관리하는 업체에 `aaa`라는 <span class=\"yellow-400\">도메인</span>을 등록해야 한다. 하지만, 이미 누군가가 `aaa.com`을 등록했다면 해당 소유주가 <span class=\"yellow-400\">도메인</span>의 소유권을 포기하기 전까진 `aaa.com` <span class=\"yellow-400\">도메인</span>을 소유할 수 없다.  \r\n물론 `.com`이 아닌 `.kr`이나 `.net`에는 등록할 수 있다. 하지만 `socket.io` 처럼 <span class=\"yellow-400\">도메인</span>과 <span class=\"pink-400\">최상위 도메인</span>까지 의미론적으로 구성했다면, 이러한 상황이 달갑지 않을 것이다. 때문에 일전에 이슈됐던 <span class=\"primary\">덮죽 상표권 선점</span>과 비슷한 일이 일어나기도 한다.\r\n\r\n## Port(포트)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"amber-400\">443</span> 부분. 앞에 반드시 `:`이 붙는다.\r\n\r\n인터넷에 연결된 모든 디바이스는 사용하는 네트워크의 IP를 할당받는다. 할당받은 IP 내에서 해당 디바이스가 수행 중인 모든 프로세스의 통신이 이루어진다. <span class=\"amber-400\">포트</span>는 프로세스의 데이터가 IO되는 통로다. 작업 시, 각 프로세스 별로 고유한 <span class=\"amber-400\">포트</span>를 할당받으며, 하나의 <span class=\"amber-400\">포트</span>는 반드시 하나의 프로세스와 1:1 매칭된다. 반면, 하나의 프로세스는 여러 <span class=\"amber-400\">포트</span>를 할당받을 수 있다.  \r\n**특정 프로세스와 통신하기 위해선 반드시 해당 프로세스가 할당받은 <span class=\"amber-400\">포트</span>에 데이터를 전송**해야 한다. 때문에 <span class=\"amber-400\">포트</span> 통신은 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 크게 중요하지 않으며, 어떤 <span class=\"amber-400\">포트</span>로 보내는지가 중요하다.\r\n\r\n웹 통신에서의 기본<span class=\"amber-400\">포트</span>는 아래와 같다.\r\n\r\n| 포트  |      내용       |\r\n| :---: | :-------------: |\r\n|  80   | HTTP 기본 포트  |\r\n|  443  | HTTPS 기본 포트 |\r\n\r\n아마 이러한 숫자를 처음 볼 수도 있는데, 대부분의 웹 사이트 <span class=\"primary\">URL</span>에는 <span class=\"amber-400\">포트</span>를 확인할 수 없다. 사이트가 **각 프로토콜의 기본 <span class=\"amber-400\">포트</span>로 서비스될 경우, <span class=\"primary\">URL</span>에서 <span class=\"amber-400\">포트</span>를 생략**할 수 있다. 즉, `https://naver.com`의 <span class=\"amber-400\">포트</span>번호는 `443`이지만, `443`은 HTTPS의 기본 <span class=\"amber-400\">포트</span>이므로 생략된다. 만약, `443`이 아닌 `8080`, `9200`과 같은 **임의의 <span class=\"amber-400\">포트</span>로 서비스를 제공할 경우, <span class=\"amber-400\">포트</span>를 반드시 명시해야하므로 생략이 불가능**하다. 이 경우 <span class=\"primary\">URL</span>은 `https://naver.com:8080`이 될 것이다.  \r\n위와 같은 이유로, 대부분의 웹 사이트는 서비스하는 프로토콜에 맞는 기본 <span class=\"amber-400\">포트</span>를 사용한다.\r\n\r\n<span class=\"amber-400\">포트</span>는 **0 ~ 65535**의 범위를 가지며, 크게 세 가지로 구분할 수 있다.\r\n\r\n### 잘 알려진 포트(well-known Port)\r\n\r\n**0 ~ 1023**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터에서 기본적으로 사용되는 주요 프로세스에 기본적으로 할당되는 포트로, ICANN(Internet Corporation for Assigned Names and Numbers, 국제 인터넷주소 관리기구)에 의해 통제된다.\r\n\r\n|  포트  |  기능  |        용도        |\r\n| :----: | :----: | :----------------: |\r\n| 20, 21 |  FTP   |    파일 송수신     |\r\n|   22   |  SFTP  | 파일 암호화 송수신 |\r\n|   23   | Telnet |    터미널 통신     |\r\n|   25   |  SMTP  |     메일 전송      |\r\n|   53   |  DNS   |      DNS 통신      |\r\n|   67   |  DHCP  |     DHCP 통신      |\r\n|   80   |  HTTP  |     HTML 통신      |\r\n|  443   | HTTPS  |  HTML 암호화 통신  |\r\n\r\n어디까지나 초기에 지정되는 <span class=\"amber-400\">포트</span>이므로, 추후 **사용자의 의도에 따라 비어있는 다른 포트로 변경**할 수도 있다. 즉, 초기값일뿐, 강제는 아니다.\r\n\r\n### 등록된 포트(registered Port)\r\n\r\n**1024 ~ 49151**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 이 <span class=\"amber-400\">포트</span>들은 컴퓨터의 기본 프로세스는 아니지만, 주요 프로그램들이 기본으로 사용하고자 ICANN에 등록한 <span class=\"amber-400\">포트</span>다. <span class=\"amber-400\">잘 알려진 포트</span>와 마찬가지로 프로그램의 설정을 통해 **사용자의 의도에 따라 비어있는 다른 포트로 변경**할 수 있다.\r\n\r\n| 포트  |         기능         |             용도             |\r\n| :---: | :------------------: | :--------------------------: |\r\n| 1433  |        MSSQL         |        MSSQL DB 통신         |\r\n| 3306  |        MySQL         |        MySQL DB 통신         |\r\n| 3389  |         RDP          | 원격 데스크톱 접근 (Windows) |\r\n| 5432  |      PostgreSQL      |      PostgreSQL DB 통신      |\r\n| 8080  | HTTP 통신(Tomcat 등) |   HTTP 통신 (80포트 대용)    |\r\n| 27017 |       MongoDB        |         MongoDB 통신         |\r\n\r\n주로 <span class=\"primary\">DB</span>같은 개발 관련 프로그램들이 많이 등록돼있다.\r\n\r\n#### 왜? 하필 개발 관련 프로그램들만?\r\n\r\n개발 관련 프로그램들은 그 특성 상 통신의 방식이 **항상 일정**해야 한다. 만약 DB의 <span class=\"amber-400\">포트</span>가 기동할 때마다 수시로 변경된다면 어떨까? 이유를 막론하고 DB가 재기동될 경우, 개발자는 DB가 사용 중인 임의의 <span class=\"amber-400\">포트</span>를 추적하여 프로그램의 DB 통신 코드를 변경해야하는 매우 불합리한 상황이 발생하게 된다.  \r\n\r\n이에 비해 게임이나 IDE 같은 일반적인 프로그램들은 굳이 통신의 방식이 일정할 필요는 없다. 어찌됐든 **서버에 정보를 요청하는 순간, 서버는 자연스레 내 통신 정보를 알게되기 때문**이다. 서버는 요청했던 경로로 다시 데이터를 반환해주면 된다. 어떤 <span class=\"amber-400\">포트</span>가 보내는지는 별로 중요하지 않는 이유가 여기에 있다.\r\n\r\n### 동적 포트(dynamic Port)\r\n\r\n**49152 ~ 65535**의 범위에 해당하는 <span class=\"amber-400\">포트</span>. 대다수의 프로그램들은 <span class=\"amber-400\">포트</span> 기본값이 지정되지 않는 경우가 대부분이다. 이러한 프로그램들은 <span class=\"amber-400\">동적 포트</span> 중 사용 가능한 임의의 빈 <span class=\"amber-400\">포트</span>를 자동으로 점유한다. 때문에 ICANN이 관리하지도 않으며, 특정 프로그램이 고유한 <span class=\"amber-400\">포트</span>로 등록되어있지도 않다. 자유석을 생각하면 편하다.\r\n\r\n### Path(경로)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"cyan-400\">posts</span> 부분. 웹 사이트의 하위 경로를 의미한다. <span class=\"cyan-400\">경로</span>는 `/`로 구분하며, 경로 입력을 통해 서버 내의 원하는 자원에 접근할 수 있다.\r\n\r\n* https://rwb0104.github.io\r\n  * posts\r\n    * index.html\r\n    * A1000\r\n      * index.html\r\n    * A1001\r\n      * index.html\r\n    * uri-url-urn\r\n      * index.html\r\n  * project\r\n    * index.html\r\n  * index.html\r\n\r\n위 트리는 이 블로그의 단편적인 디렉토리 예시다. 이 중 해당 게시물에 접근하려면 <span class=\"cyan-400\">경로</span>는 `/posts/uri-url-urn/index.html`와 같이 구성할 수 있다. <span class=\"primary\">index.html은 생략이 가능</span>하므로 `/posts/uri-url-urn`로 접근해도 무방하다.\r\n\r\n> **아시나요?**  \r\n> **index.html** 경로의 기본 HTML을 의미함. 더이상의 하위 경로를 표시하지 않을 경우, 해당 경로의 index.html를 응답한다.\r\n\r\n<span class=\"cyan-400\">경로</span>는 서버의 구조에 따라 결정되므로, 사이트마다 천차만별이다.\r\n\r\n### Query String(쿼리 문자열)\r\n\r\n<span class=\"primary\">URL</span>상의 <span class=\"teal-400\">?category=WEB&page=1</span> 부분. 해당 <span class=\"cyan-400\">경로</span>에 임의의 데이터를 같이 전송할 때 사용한다.  \r\n<span class=\"primary\">key=value</span> 형태로 이루어지며, 각 `key`는 <span class=\"purple-400\">Parameter(파라미터)</span>라 칭한다. 첫 <span class=\"purple-400\">파라미터</span>는 `?`로 시작하며, 이후 각 <span class=\"purple-400\">파라미터</span>들은 `&`으로 구분된다. 즉 `?key1=value1&key2=value2&key3=value3`과 같은 양식으로 전개된다.\r\n\r\n임의의 키워드를 전달하여 페이지의 동작을 제어할 수 있다. <span class=\"primary\">URL</span> 중 **사용자의 니즈가 가장 활발하게 반영**되는 부분. <span class=\"teal-400\">쿼리 문자열</span>은 각각의 `key`에 대한 역할을 정의해야 하므로, 개발자가 각 <span class=\"purple-400\">파라미터</span>의 `key`가 동작하는 로직을 작성했을 때 그 의미가 있다.\r\n\r\n## URN 구조\r\n\r\n지금까지 <span class=\"primary\">URL</span>에 대해선 상당히 장황하게 설명했지만, <span class=\"primary\">URN</span>의 경우 <span class=\"primary\">URL</span>보다 역사가 짧다. 이미 3년이라는 시간 사이에 <span class=\"primary\">URL</span>이 표준으로 자리매김한 탓에, 현재까지도 비주류를 면치 못 해 구현된 예시도 그리 많지 않은게 현실이다.  \r\n<span class=\"primary\">URL</span>이 위치만 바뀌어도 찾을 수 없다는 단점은, 오히려 제공중인 데이터를 은닉하는 측면 등 상황에 따라 오히려 유용하게 사용할 여지도 있다. 즉, <span class=\"primary\">URL</span>의 단점이 마냥 나쁜것만은 아닌 셈이다. 이는 곳 <span class=\"primary\">URN</span>의 장점이 현재 구축된 <span class=\"primary\">URL</span>체계를 갈아 엎을 정도로 매력적이지 않다는 주장을 뒷받침한다.\r\n\r\n<span class=\"primary\">URN</span>은 아래와 같은 구조로 이루어진다. 각 요소는 `:`으로 구분한다.\r\n\r\n<p class=\"large\" align=\"center\"><span class=\"lightBlue-400\">urn</span>:<span class=\"green-400\">isbn</span>:<span class=\"yellow-400\">1234567890</span></p>\r\n\r\n### Protocol(프로토콜)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"lightBlue-400\">urn</span> 부분. `urn`으로 시작하면 <span class=\"primary\">URN</span>체계로 보면 된다.\r\n\r\n### NID(Namespace Identifier, 네임스페이스 지시자)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"green-400\">isbn</span> 부분. **자원이 저장된 저장소**를 표시한다.  \r\n`isbn`은 서지정보유통지원시스템으로 도서 일련번호에 대한 정보를 저장하는 저장소이다. 즉, `isbn`을 <span class=\"green-400\">NID</span>로 지정하면 도서 관련 자원을 식별할 수 있다.\r\n\r\n### NSS(Namespace Specific String, 네임스페이스 특정 문자)\r\n\r\n<span class=\"primary\">URN</span>상의 <span class=\"yellow-400\">1234567890</span> 부분. **자원을 식별할 수 있는 고유값**이다.  \r\n<span class=\"green-400\">NID</span>가 `isbn`으로 지정되어 있으므로, ISBN의 일련번호가 1234567890인 도서를 식별하는 <span class=\"primary\">URN</span>이라 볼 수 있다.","url":["2021-05-29-uri-url-urn","2021","05","29","uri-url-urn"]},{"header":{"title":"Tomcat(톰캣) 현재 콘솔창에서 구동하기","excerpt":"오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-26T16:32:16","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-26-tomcat-current-window.md","content":"\r\n# 왜 자꾸 꺼지는거야!\r\n\r\n오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?\r\n\r\n# 왜?\r\n\r\n톰캣이 콘솔 형태로 실행되는 것은 맞지만, 실행되는 프로세스를 보면 살짝 다르다. `startup.bat`을 실행하면 cmd창이 뜬 뒤 꺼지면서 곧바로 Tomcat 창이 표시된다. <span class=\"primary\">톰캣을 구동하면 항상 새로운 창이 뜨기 때문에, 톰캣이 오류로 인해 동작이 중지되면 창이 곧바로 닫히게 된다.</span>\r\n\r\n# 해결책?\r\n\r\n그렇다고 해결책이 없는 건 아니고, `startup.bat`의 간단한 수정을 통해 톰캣이 <span class=\"primary\">현재 창에서 동작</span>하도록 수정할 수 있다. \r\n\r\n`startup.bat`을 메모장으로 열면, 맨 아래에 `call \"%EXECUTABLE%\" run %CMD_LINE_ARGS%` 구문이 존재한다. 여기서 가운데 `run`을 `start`로 변경한다.\r\n\r\n즉 `call \"%EXECUTABLE%\" start %CMD_LINE_ARGS%`로 구문을 변경하고 저장하면 된다.\r\n\r\n이후 `startup.bat`을 클릭하여 실행하지 말고, `cmd`창 하나를 킨 다음에, 해당 콘솔에서 `startup.bat`을 호출하면 새 창이 뜨지 않고 호출한 콘솔에서 톰캣이 구동된다.  \r\n톰캣이 종료돼도 콘솔창이 꺼지지 않으므로, 편하게 메시지를 확인할 수 있다.","url":["2021-05-26-tomcat-current-window","2021","05","26","tomcat-current-window"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1004번 어린 왕자","excerpt":"어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-22T21:42:23","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","기하학","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-22-A1004.md","content":"\r\n# 어린 왕자\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1004번 문제](https://www.acmicpc.net/problem/1004)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfcmhrjj_113gw6bcng2_b.gif\" width=\"512px\" />\r\n</p>\r\n\r\n빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.\r\n\r\n위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. (행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다고 가정한다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.)\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 $(x_1, y_1)$과 도착점 $(x_2, y_2)$이 주어진다. 두 번째 줄에는 행성계의 개수 $n$이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 $(c_x, c_y, r)$이 주어진다. 입력제한은 다음과 같다. $(-1000 ≤ x_1, y_1, x_2, y_2, c_x, c_y ≤ 1000, 1 ≤ r ≤ 1000, 1 ≤ n ≤ 50)$\r\n\r\n좌표와 반지름은 모두 정수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n-5 1 12 1\r\n7\r\n1 1 8\r\n-3 -1 1\r\n2 2 2\r\n5 5 1\r\n-4 5 1\r\n12 1 1\r\n12 1 2\r\n-5 1 5 1\r\n1\r\n0 0 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n1002번째 알고리즘의 내용을 응용하면 쉽게 풀 수 있는 문제인 것 같다. 실제로 별다른 레퍼런스를 찾지도 않고 풀 수 있었으니.\r\n\r\n문제를 풀기 전에 몇 가지 집고 넘아갈 게 있다.  \r\n숫자들 때문에 입력의 한 세트를 착각하기 쉽다.\r\n\r\n위 예제를 기준으로 설명하면, 첫 번째 숫자는 세트의 갯수. 본문에서는 `2`이므로, 두 세트를 테스트하므로 결과는 두 줄이 출력된다.  \r\n이후 테스트에 필요한 데이터가 출력된다.\r\n\r\n-5 1 12 1 <= $x_1, y_1, x_2, y_2$  \r\n7 <= 행성 갯수  \r\n1 1 8 <= $c_{x1}, c_{y1}, r_1$  \r\n-3 -1 1  \r\n2 2 2  \r\n5 5 1  \r\n-4 5 1  \r\n12 1 1  \r\n12 1 2 <= 행성 갯수만큼 출력됨\r\n\r\n또한, 결과는 행성계의 진입/이탈 횟수를 통틀어서 출력하므로 굳이 진입/이탈을 구분하여 저장할 필요는 없다.\r\n\r\n문제에서 **출발점에서 도착점까지 가는데 통과해야하는 행성계(이하 원, circle)의 최소**를 목적으로 두기 때문에, 반드시 통과해야하는 원만 계산하면 된다.  \r\n출발/도착점이 임의의 원 안에 포함될 경우 반드시 진입/이탈이 일어난다. 따라서, 출발/도착점을 온전히 포함하는 원의 갯수를 계산하면 진입/이탈의 횟수를 구할 수 있다.  \r\n주의할 점이 있는데, **한 원이 출발/도착점을 모두 포함할 경우 계산에서 제외**시켜야 한다.  \r\n하나의 원이 출발/도착점을 전부 포함할 경우, 원 안에서 이동하기 때문에 진입/이탈이 일어나지 않기 때문.  \r\n\r\n![example](https://user-images.githubusercontent.com/50317129/120758690-188d5000-c54d-11eb-917c-f910eb7b3199.png)\r\n\r\n원리는 간단하다. 원점과 점의 거리를 계산한다. 계산한 거리가 원의 반지름보다 짧을 경우, 해당 원은 점을 포함하는 셈이다.  \r\n이를 식으로 정리하면 아래와 같다.\r\n\r\n|     변수     |      의미      |\r\n| :----------: | :------------: |\r\n|   $x$, $y$   |   원점 좌표    |\r\n| $x_o$, $y_o$ | 원의 원점 좌표 |\r\n|     $r$      |  원의 반지름   |\r\n\r\n변수는 위 표와 같이 정의하고 <span class=\"green-A700\">한 원이 원점을 포함하는 식</span>을 전개한다.\r\n\r\n$$\r\n\\sqrt{(x_0 - x)^2 + (y_0 - y)^2} < r\r\n$$\r\n\r\n위 식을 코드로 표현하면 되는 비교적 간단한 알고리즘이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1004 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.24 Sat 02:15:31\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tint length = scanner.nextInt();\r\n\t\tscanner.nextLine();\r\n\t\t\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tString base = scanner.nextLine();\r\n\t\t\t\r\n\t\t\tint x_start = Integer.parseInt(base.split(\" \")[0]);\r\n\t\t\tint y_start = Integer.parseInt(base.split(\" \")[1]);\r\n\t\t\t\r\n\t\t\tint x_end = Integer.parseInt(base.split(\" \")[2]);\r\n\t\t\tint y_end = Integer.parseInt(base.split(\" \")[3]);\r\n\t\t\t\r\n\t\t\tint through = 0;\r\n\t\t\t\r\n\t\t\tint count = scanner.nextInt();\r\n\t\t\tscanner.nextLine();\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < count; j++)\r\n\t\t\t{\r\n\t\t\t\tString circle = scanner.nextLine();\r\n\t\t\t\t\r\n\t\t\t\tint x = Integer.parseInt(circle.split(\" \")[0]);\r\n\t\t\t\tint y = Integer.parseInt(circle.split(\" \")[1]);\r\n\t\t\t\tint r = Integer.parseInt(circle.split(\" \")[2]);\r\n\t\t\t\t\r\n\t\t\t\tboolean hasStartContain = hasContain(x_start, y_start, x, y, r);\r\n\t\t\t\tboolean hasEndContain = hasContain(x_end, y_end, x, y, r);\r\n\t\t\t\t\r\n\t\t\t\t// 해당 행성이 출발 혹은 도착점 중 하나만을 포함할 경우\r\n\t\t\t\tif (!(hasStartContain && hasEndContain) && (hasStartContain || hasEndContain))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrough++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(through);\r\n\t\t}\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 출발/도착점 포함 여부 반환 함수\r\n\t *\r\n\t * @param xo: [int] 출발/도착점의 x좌표\r\n\t * @param yo: [int] 출발/도착점의 y좌표\r\n\t * @param x: [int] 행성의 x좌표\r\n\t * @param y: [int] 행성의 y좌표\r\n\t * @param r: [int] 행성의 반지름\r\n\t *\r\n\t * @return [boolean] 출발/도착점 포함 여부\r\n\t */\r\n\tprivate static boolean hasContain(int xo, int yo, int x, int y, int r)\r\n\t{\r\n\t\treturn Math.sqrt(Math.pow(xo - x, 2) + Math.pow(yo - y, 2)) < r;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 기하학","url":["2021-05-22-A1004","2021","05","22","A1004"]},{"header":{"title":"Tomcat(톰캣) 콘솔창 한글 인코딩 깨짐 현상 해결하기","excerpt":"톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상. Windows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-22T12:52:51","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-22-tomcat-encoding-euckr.md","content":"\r\n# 와장창!\r\n\r\n![Encoding Broken](https://user-images.githubusercontent.com/50317129/119212087-342a3c80-baf1-11eb-89bc-06829a5f7c16.png)\r\n\r\n톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상.  \r\nWindows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.\r\n\r\n# 도대체 왜?\r\n\r\n실력 좋은 개발자가 아니더라도, 컴퓨터와 친분이 있다면 언어가 깨짐은 곧 인코딩의 불일치라는 걸 개괄적으로 이해하고 있다. 이러한 현상이 일어나는 이유는 아래와 같은데,\r\n\r\n* <span class=\"primary\">Windows Console</span>: Windows OS 설정 언어의 기본 인코딩 (한국어는 **EUC-KR**)\r\n* <span class=\"primary\">Tomcat Console</span>: 설정파일의 인코딩 (**기본 UTF-8**)\r\n\r\n이 처럼, 기본 인코딩이 서로 다르다.\r\n\r\n# 해결책\r\n\r\n이를 해결하는 방법은 크게 두 가지가 존재한다. 개인적으로 <span class=\"red-300\">두 번째 방법을 추천</span>한다.\r\n\r\n### Windows Console 인코딩 변경하기\r\n\r\n첫 번째로, Windows Console의 인코딩을 변경한다. Windows 10 기준으로 OS의 기본 콘솔은 <span class=\"green-500\">cmd</span>와 <span class=\"green-500\">PowerShell</span> 두 가지다. **사용할 콘솔의 기본 인코딩을 EUC-KR에서 UTF-8로 변경**해주면 된다.\r\n\r\n애석하게도, 두 콘솔 모두 인코딩을 변경하는 옵션을 제공하지 않는다. 그렇다고 방법이 없는 건 아니고, 레지스트리 수정을 통해 문제를 해결할 수 있다.\r\n\r\n<br />\r\n\r\n1. 작업표시줄에서 `regedit`을 입력하여 <span class=\"blue-500\">레지스트리 편집기</span>를 띄운다.\r\n2. `HKEY_CURRENT_USER\\Console` 경로에 접근한다. 사용자 계정에 설치된 콘솔들이 출력된다. (cmd, PowerShell, Git 등)\r\n\r\n![Registry](https://user-images.githubusercontent.com/50317129/119212160-83706d00-baf1-11eb-92c8-b41458950f20.png)\r\n\r\n3. 인코딩을 변경하려는 콘솔의 폴더를 클릭한다.\r\n   * **%SystemRoot%_system32_cmd.exe**: cmd\r\n   * **%SystemRoot%_System32_WindowsPowerShell_v1.0_powershell.exe**: 32비트 PowerShell\r\n   * **%SystemRoot%_SysWOW64_WindowsPowerShell_v1.0_powershell.exe**: 64비트 PowerShell\r\n4. `CodePage` 키를 더블클릭하여 편집을 수행한다.\r\n   `CodePage`가 없을 경우, 오른쪽 마우스 버튼을 클릭하여 새 DWORD(32비트) 키를 동일한 이름으로 생성한다.\r\n5. 값 데이터를 10진수 `65001`로 변경한다.\r\n\r\n![Registry](https://user-images.githubusercontent.com/50317129/119212198-ab5fd080-baf1-11eb-981b-82599148c8f8.png)\r\n\r\n6. 앞으로 실행되는 Windows Console은 해당 인코딩이 적용된다.\r\n\r\n이렇게 하면 Windows Console과 Tomcat의 기본 인코딩이 UTF-8로 서로 일치하므로, 한글이 정상적으로 출력된다.  \r\n하지만 이 방법은 Windows Console의 인코딩을 바꾸므로, 차후 해당 <span class=\"red-500\">콘솔을 통해 다른 작업이나 프로그램이 실행될 경우 엉뚱한 프로그램의 한글이 깨질 우려</span>가 있다.  \r\n(대부분은 OS 언어의 기본 인코딩을 따라가도록 설계함)\r\n\r\nWindows Console은 범용적으로 사용되는 프로그램이므로, 다른 작업에 영향을 줄 수 있다. 내가 이 방법을 굳이 추천하지 않는 이유이기도 하다.  \r\n\r\n### Tomcat Console 인코딩 변경하기\r\n\r\n두 번째로, Tomcat Console의 인코딩을 변경한다. 첫 번째 방법보다 이 방법이 나은 이유는, Tomcat이라는 제한적인 용도의 콘솔에만 영향을 미치기 때문. 어차피 Tomcat Console의 인코딩이 불일치해서 생기는 문제이므로, 이쪽을 바꾸는게 상식적으로도 맞다.\r\n\r\n대부분 마찬가지로 위 방법처럼 레지스트리를 수정하라고 안내할텐데, Tomcat은 굳이 그렇게 바꿔줄 필요 없다.\r\n\r\n1. `%TOMCAT_HOME%\\conf\\logging.properties`을 연다.\r\n2. **java.util.logging.ConsoleHandler.encoding**의 값을 **EUC-KR**로 변경한다.\r\n   별다른 설정이 없었다면, UTF-8이 기본으로 설정되어 있다.\r\n3. 앞으로 실행되는 Tomcat은 해당 인코딩이 적용된다.\r\n\r\nTomcat을 실행하면 한글이 정상적으로 출력된다.","url":["2021-05-22-tomcat-encoding-euckr","2021","05","22","tomcat-encoding-euckr"]},{"header":{"title":"도메인이란?","excerpt":"도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다. 인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 고유한 12자리 숫자로 구성된 IP주소를 가진다. IP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다. 유동 IP: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨. 고정 IP: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함. 우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, 특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요하다.","coverImage":"https://user-images.githubusercontent.com/50317129/120056028-b2985880-c074-11eb-8cc3-39f5f10a2c7f.png","date":"2021-05-22T12:52:51","type":"posts","category":"WEB","tag":["WEB(웹)","Domain(도메인)"],"comment":true,"publish":true},"name":"2021-05-22-about-domain.md","content":"\r\n# Domain(도메인)이란?\r\n\r\n도메인을 이해하기 위해선, IP에 대해 짚고 넘어가야 한다.  \r\n인터넷에 연결된 모든 디바이스(컴퓨터, 스마트폰, 공유기 등)는 <span class=\"blue-500\">고유한 12자리 숫자로 구성된 IP주소</span>를 가진다.  \r\nIP를 유동성으로 나누면 크게 유동 IP, 고정 IP로 분류할 수 있다.\r\n\r\n* <span class=\"primary\">유동 IP</span>: 임의의 시점마다 IP주소가 갱신되는 IP. 갱신 주기는 일정하지 않음. 대부분의 인터넷 회선에 적용됨.\r\n* <span class=\"primary\">고정 IP</span>: 회선에 고정된 IP를 부여하며, 해당 회선의 IP는 갱신되지 않음. 부가서비스 형태로 제공되며, 쇼핑몰이나 회사 등 지속적으로 시스템을 운영해야 할 경우 적합함.\r\n\r\n우리가 원하는 장소에 방문하기 위해 주소를 찾듯이, <span class=\"green-500\">특정 서버에서 운영하는 웹 사이트를 방문하기 위해선 해당 서버의 주소인 IP가 필요</span>하다.  \r\n불행히도, IP는 불규칙적인 숫자로 이루어져있어, 사람이 쉽게 기억하기 다소 어렵다. 이러한 불편함을 해소하기 위한 것이 Domain(도메인)이다.\r\n\r\n도메인은 <span class=\"pink-400\">SLD(서브도메인)</span>, <span class=\"pink-400\">도메인</span>, <span class=\"pink-400\">TLD(최상위 도메인)</span>으로 구분되며, 해당 도메인의 정보는 1차적으로 각 로컬 DNS 서버가 관리하며, 최종적으로는 TLD를 관리하는 Root DNS에서 관리한다.\r\n\r\n> 도메인에 대한 자세한 내용은 이전에 작성된 [URI? URL? URN? 리소스 식별자 구분하기](/posts/uri-url-urn)를 참조한다.\r\n\r\n# 그래서 도메인을 왜 쓰는데?\r\n\r\n우리가 흔히 <span class=\"green-A700\">네이버</span>라고 부르는 사이트의 실제 IP는 [125.209.222.141](http://125.209.222.141)이다. 하지만 우리들 중 그 누구도 저런 IP로 <span class=\"green-A700\">네이버</span>에 접속하지 않는다. 대신 우리는 [https://www.naver.com](https://www.naver.com)이라는 도메인으로 접속한다. 이유는 간단하다. 주소 자체에 <span class=\"green-A700\">naver</span>라는 키워드가 포함되어 있으므로 기억하기 쉽기 때문이다.\r\n\r\n<span class=\"pink-400\">도메인</span>은 숫자가 아닌, 문자 형태로 이루어진 주소다. 문자이므로, 주소에 의미를 부여하기 용이하다. 사용자가 주소를 기억하기 쉬워 주소에 대한 접근성을 높여준다.  \r\n생성한 <span class=\"pink-400\">도메인</span>에 원하는 IP를 연결하면 <span class=\"pink-400\">도메인</span> 주소를 통해서도 해당 IP에 접근할 수 있다.\r\n<span class=\"pink-400\">도메인</span> 제공 업체에 따라, 영숫자 뿐만 아니라 한글과 같은 유니코드 문자도 지원하므로, 딱딱한 IP 대신 개성있는 주소를 사용할 수 있는 것이다.\r\n\r\n# 도메인의 원리\r\n\r\n여기서 의문점이 한 가지 생긴다. IP [125.209.222.141](http://125.209.222.141)와 <span class=\"pink-400\">도메인</span> [https://www.naver.com](https://www.naver.com)가 <span class=\"green-A700\">네이버</span>를 가리키는 주소인건 알겠는데, 인터넷은 과연 두 주소의 연결고리를 어떻게 아는 걸까?\r\n\r\n이는 <span class=\"pink-400\">도메인</span>의 동작 원리를 보면 알 수 있다. `rwb0104.github.io` <span class=\"pink-400\">도메인</span>에 접근하는 과정을 예시로 보자.\r\n\r\n1. HTTP 통신을 통해 `rwb0104.github.io`에 접근을 시도한다.\r\n2. 네트워크에 지정된 로컬 DNS에게 `rwb0104.github.io`의 정보를 요청한다.\r\n   * 만약 로컬 DNS가 해당 도메인의 정보를 보유하고 있을 경우, 즉시 정보를 제공한다.\r\n3. `rwb0104.github.io`에 대한 정보가 없을 경우, 근접한 Root DNS에 해당 도메인의 정보를 요청한다.\r\n4. Root DNS가 `.io` TLD를 관리하는 DNS 서버의 정보를 로컬 DNS에 제공한다.\r\n5. 로컬 DNS가 `rwb0104.github.io`를 관리하는 TLD의 DNS 서버에 해당 정보를 요청한다.\r\n6. TLD DNS 서버가 `rwb0104.github.io`에 대한 정보(IP 등)을 제공한다.\r\n7. 로컬 DNS가 `rwb0104.github.io`의 IP를 알고 있으므로, 이를 통해 해당 사이트에 접근할 수 있다.\r\n\r\n기본적으로 <span class=\"pink-400\">도메인</span>은 반드시 하나의 IP와 연결된다. 이런 특징 덕분에 <span class=\"pink-400\">도메인</span>은 항상 특정한 하나의 IP만을 반환한다.","url":["2021-05-22-about-domain","2021","05","22","about-domain"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1003번 피보나치 함수","excerpt":"다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T23:29:03","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","피보나치 수열","Dynamic Programming(동적 프로그래밍)","SILVER","SILVER III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-A1003.md","content":"\r\n# 피보나치 함수\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1003번 문제](https://www.acmicpc.net/problem/1003)\r\n\r\n## 조건\r\n\r\n|        시간제한         | 메모리 제한 |\r\n| :---------------------: | :---------: |\r\n| 0.25초 (추가 시간 없음) |    128MB    |\r\n\r\n## 문제\r\n\r\n다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.\r\n\r\n``` cpp\r\nint fibonacci(int n) {\r\n    if (n == 0) {\r\n        printf(\"0\");\r\n        return 0;\r\n    } else if (n == 1) {\r\n        printf(\"1\");\r\n        return 1;\r\n    } else {\r\n        return fibonacci(n‐1) + fibonacci(n‐2);\r\n    }\r\n}\r\n```\r\n\r\n$fibonacci(3)$을 호출하면 다음과 같은 일이 일어난다.\r\n\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$ (첫 번째 호출)을 호출한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$ (두 번째 호출)과 $fibonacci(0)$을 호출한다.\r\n* 두 번째 호출한 $fibonacci(1)$은 1을 출력하고 1을 리턴한다.\r\n* $fibonacci(0)$은 0을 출력하고 0을 리턴한다.\r\n* $fibonacci(2)$는 $fibonacci(1)$과 $fibonacci(0)$의 결과를 얻고, 1을 리턴한다.\r\n* 첫 번째 호출한 $fibonacci(1)$은 1을 출력하고, 1을 리턴한다.\r\n* $fibonacci(3)$은 $fibonacci(2)$와 $fibonacci(1)$의 결과를 얻고, 2를 리턴한다.\r\n\r\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, $fibonacci(N)$을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 적성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.  \r\n각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0\r\n1\r\n3\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 0\r\n0 1\r\n1 2\r\n```\r\n\r\n# 풀이\r\n\r\n알고리즘 풀면서 느끼는 거지만, 문제가 뭘 말하는 지 이해가 안 되는 경우가 많은 것 같다. 내가 멍청해서 그런건가.\r\n\r\n이 문제를 풀기 위해선, 피보나치 수열에 대한 식을 이해하고 있어야 한다.  \r\n피보나치 수열이 $f()$일 때, $n$번째 피보나치 수열의 식은 $f(n) = f(n - 1) + f(n - 2)$로 정의할 수 있다.\r\n\r\n$n = 0, 1$일 때의 초기값이 정해져있다. (식의 특성 상 초기값이 없으면 계산할 수가 없다.)  \r\n$f(0) = 0$  \r\n$f(1) = 1$  \r\n초기값은 위와 같으며, 실질적으로 $n >= 2$ 부터 의미있는 연산이 수행된다.\r\n\r\n다시 문제로 돌아가서, 임의의 수 N이 주어질 경우 $f(N)$을 수행하면서 $f(0)$, $f(1)$이 몇 번 호출되는지를 구하면 된다.  \r\n예를 들어, $N = 4$라고 가정하고 식을 전개하면 아래와 같다.  \r\n$f(4) = f(3) + f(2)$  \r\n위 식에서 $f(3)$은 $f(2) + f(1)$로 치환할 수 있으며, 같은 이유로 $f(2)$ 역시 $f(1) + f(0)$으로 치환 가능하다.  \r\n$f(4) = f(2) + f(1) + f(1) + f(0)$  \r\n$= f(1) + f(0) + f(1) + f(1) + f(0)$\r\n\r\n결과적으로 $f(4) = 2(f0) + 3f(1)$로 정리할 수 있다.  \r\n따라서 이 문제의 알고리즘은 $N = 4$일 경우 `2 3`이 출력되어야 한다.\r\n\r\n우선 식을 정리하여 한 눈에 보면 문제 해결에 도움이 될 것 같다.  \r\n피보나치 수열을 쭉 정리하면 아래와 같다.\r\n\r\n|  $n$  | $f(0)$의 갯수 | $f(1)$의 갯수 | $f(n)$ |\r\n| :---: | :-----------: | :-----------: | :----: |\r\n|   0   |       1       |       0       |   0    |\r\n|   1   |       0       |       1       |   1    |\r\n|   2   |       1       |       1       |   1    |\r\n|   3   |       1       |       2       |   2    |\r\n|   4   |       2       |       3       |   3    |\r\n|   5   |       3       |       5       |   5    |\r\n|   6   |       5       |       8       |   8    |\r\n|   7   |       8       |      13       |   13   |\r\n|   8   |      13       |      21       |   21   |\r\n|   9   |      21       |      34       |   34   |\r\n\r\n표로 정리하니 어느정도 규칙성이 눈에 보이기 시작한다.\r\n\r\n* N의 $f(1)$ 출력 갯수는 $f(N)$과 동일하다.  \r\n* N의 $f(0)$ 출력 갯수는 $f(N - 1)$과 동일하다.\r\n\r\n즉, $N = 4$일 경우 알고리즘은 $f(3)$ $f(4)$가 출력되면 된다.\r\n\r\n여기서 단순하게 생각하면 아래와 같이 코드를 짤 수 있다.\r\n\r\n## 완성....?\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[][] arr = new Integer[41][2];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// N = 0일 때, 0이 호출되는 횟수\r\n\t\tarr[0][0] = 1;\r\n\r\n\t\t// N = 0일 때, 1이 호출되는 횟수\r\n\t\tarr[0][1] = 0;\r\n\r\n\t\t// N = 1일 때, 0이 호출되는 횟수\r\n\t\tarr[1][0] = 0;\r\n\r\n\t\t// N = 1일 때, 1이 호출되는 횟수\r\n\t\tarr[1][1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tint f0 = fibonacci(n - 1);\r\n\t\t\tint f1 = fibonacci(n);\r\n\r\n\t\t\tSystem.out.println(f0 + \" \" + f1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 인덱스가 0일 경우\r\n\t\tif (n == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 1일 경우\r\n\t\telse if (n == 1)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// 인덱스가 2 이상일 경우 (연산 가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위 코드는 크게 두 가지 문제가 있는데, 우선 $n = 0, 1$일 때의 처리가 정상적으로 이루어지지 않고 있다.  \r\n$f(1) = f(0) + f(-1)$  \r\nN이 문제되기 이전에 이 코드는 런타임 시간 초과로 실패한다. 왜일까?\r\n\r\n위 코드는 **불필요한 연산을 너무 많이 수행한다.** 피보나치 수열의 특성 상 $f(N)$을 계산할 경우, $f(N - 1)$, $f(N - 2)$ ... 등과 같이 N 이하의 피보나치 값까지 전부 계산하게 된다.  \r\n다시 말하면, $f(6)$을 연산할 경우 계산 과정에서 자연스레 $f(4)$, $f(2)$ 등의 피보나치 값을 구할 수 있다.\r\n\r\n위 이론을 알고리즘에 적용하면 아래와 같이 응용할 수 있다.  \r\nN을 총 3번 입력한다고 가정하면 $N_1$, $N_2$, $N_3$으로 구분할 수 있다.\r\n\r\n$N_2 = 8$ -> $f(8)$ 부터 $f(0)$까지의 값을 구할 수 있음.  \r\n$N_3 = 4$ -> $f(4)$ 부터 $f(0)$까지의 값을 구할 수 있음.\r\n\r\n피보나치 연산값을 저장하면 $N_n > N_n+1$일 경우 굳이 **추가적인 연산을 진행하지 않고 이미 저장된 값을 출력**만 함으로써, 런타임 리소스를 줄일 수 있다.\r\n\r\n클래스의 멤버변수로 **Integer 배열을 선언**하여 피보나치 수열값을 저장하고, 알고리즘 연산에 이를 활용하면 될 것 같다.\r\n\r\n> int는 Primitive(자료형) 데이터고, Integer는 Wrapper 클래스다. Wrapper 클래스는 null 입력이 가능하다는 특징이 있으므로, Integer 역시 숫자 이외에 null값을 입력할 수 있다.  \r\nInteger 배열의 초기값은 null로 지정되므로, 배열의 값이 null인 인덱스는 아직 피보나치 수열 계산이 이루어지지 않은 인덱스라고 판단할 수 있다.\r\n\r\n다행히 문제에서 주어진 $N$의 조건은 $0 <= N <= 40$이므로, 배열의 인덱스는 최대 41을 넘지 않음을 알 수 있다.  \r\n(배열은 0부터 시작하므로 40개가 아닌 0을 포함한 41개임에 유의하자)\r\n\r\n이후 피보나치 연산에서 각 과정의 값을 배열에 저장하는 로직을 추가한다.  \r\n배열의 값이 null일 경우, 아직 연산이 진행되지 않았으므로 피보나치 연산을 수행하고 배열에 저장한다.  \r\n반대로, 배열이 특정 숫자값을 가질 경우, 이미 연산이 진행된 인덱스이므로 별도의 연산을 거치지 않고 해당 값을 바로 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\npackage all.a1003;\r\n\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1003 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 23:29:03\r\n */\r\npublic class Main\r\n{\r\n\tstatic Integer[] arr = new Integer[41];\r\n\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 0)\r\n\t\tarr[0] = 0;\r\n\r\n\t\t// 피보나치 수열 초기값 (N = 1)\r\n\t\tarr[1] = 1;\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint n = scanner.nextInt();\r\n\r\n\t\t\tfibonacci(n);\r\n\r\n\t\t\t// n이 0일 경우\r\n\t\t\tif (n == 0)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"1 0\");\r\n\t\t\t}\r\n\r\n\t\t\t// n이 1일 경우\r\n\t\t\telse if (n == 1)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(\"0 1\");\r\n\t\t\t}\r\n\r\n\t\t\t// 초기값이 아닐 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(new StringBuffer().append(arr[n - 1]).append(\" \").append(arr[n]).toString());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscanner.close();\r\n\t}\r\n\r\n\t/**\r\n\t * 피보나치 값 반환 함수\r\n\t *\r\n\t * @param n: [int] 인덱스\r\n\t *\r\n\t * @return [int] 피보나치 값\r\n\t */\r\n\tprivate static int fibonacci(int n)\r\n\t{\r\n\t\t// 해당 인덱스의 피보나치가 아직 연산되지 않았을 경우\r\n\t\tif (arr[n] == null)\r\n\t\t{\r\n\t\t\tarr[n] = fibonacci(n - 1) + fibonacci(n - 2);\r\n\t\t}\r\n\r\n\t\treturn arr[n];\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍","url":["2021-05-21-A1003","2021","05","21","A1003"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1002번 터렛","excerpt":"조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:56:10","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","기하학","SILVER","SILVER IV"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-A1002.md","content":"\r\n# 터렛\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1002번 문제](https://www.acmicpc.net/problem/1002)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승현의 사진이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg\" width=\"128px\" />\r\n</p>\r\n\r\n이석원은 조규현과 백승환에게 상대편 마린(류재영)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.  \r\n조규현의 좌표 $(x_1, y_1)$와 백승환의 좌표 $(x_2, y_2)$가 주어지고, 조규현이 계산한 류재명과의 거리 $r_1$과 백승환이 계산한 류재명과의 거리 $r_2$가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.  \r\n한 줄에 $x_1$, $y_1$, $r_1$, $x_2$, $y_2$, $r_2$가 주어진다. $x_1$, $y_1$, $x_2$, $y_2$는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 점수이고, $r_1$, $r_2$는 10,000보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n0 0 13 40 0 37\r\n0 0 30 0 7 4\r\n1 1 1 1 1 5\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n2\r\n1\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n예제의 요소를 사람 이름으로 두었으나, 문제 이해에 방해가 되니 간단하게 서술하면 아래와 같다.  \r\n임의의 위치에 있는 점 $A$, $B$, $C$가 존재하며, $A$와 $C$의 거리, $B$와 $C$의 거리가 주어진다.  \r\n이 때, $C$가 실제로 위치할 수 있는 점의 갯수를 구하는 것. 즉, 간단하게 **두 원의 접점을 구하는 문제**라고 정의할 수 있다.  \r\n원이 완벽하게 겹칠 경우, **그 수가 무수히 많으므로 -1로 표현**하라는 조건이 포함된다.\r\n\r\n이를 그림으로 표현하면 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120757881-14146780-c54c-11eb-94ee-ab79d997000e.png)\r\n\r\n변수는 아래와 같이 정리할 수 있다.\r\n\r\n|  $n$  |   $x_n$   |   $y_n$   |   $r_n$    |\r\n| :---: | :-------: | :-------: | :--------: |\r\n|   1   | A의 x좌표 | A의 y좌표 | A의 반지름 |\r\n|   2   | B의 x좌표 | B의 y좌표 | B의 반지름 |\r\n\r\n케이스를 세분화하면 총 6가지로 나눌 수 있다.\r\n\r\n1. 두 원이 정확히 겹칠 경우 (-1)\r\n2. 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n3. 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n4. 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n5. 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n6. 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\r\n본 풀이에선 $x_1$, $y_1$과 $x_2$, $y_2$의 거리($distance$) 및 $r_1$, $r_2$를 합한 길이($sum$)와 뺀 길이($sub$)의 절대값을 이용하여 진행한다.\r\n\r\n$$\r\ndistance = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\r\n$$\r\n\r\n$$\r\nsum = r_1 + r_2\r\n$$\r\n\r\n$$\r\nsub = \\vert r_1 - r_2 \\vert\r\n$$\r\n\r\n* <b class=\"primary\">case 1 - 두 원이 정확히 겹칠 경우</b>\r\n\r\n\t두 원의 위치 및 반지름이 서로 동일한 상황.  \r\n\t$distance$가 0이며, $r_1$과 $r_2$의 길이가 동일할 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이보다 짧은 상황.  \r\n\t$distance < sub$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합보다 긴 상황.  \r\n\t$distance > sum$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 4 - 두 원이 서로 겹치면서 인접하는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 차이와 일치하는 상황.  \r\n\t$distance == sub$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우</b>\r\n\r\n\t두 원의 원점과의 거리가 반지름의 합과 일치하는 상황.  \r\n\t$distance == sum$일 경우 성립한다.\r\n\r\n* <b class=\"primary\">case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우</b>\r\n\r\n\t두 원이 서로 적당히 겹치는 상황.  \r\n\t$distance < sum$ $\\&\\&$ $distance > sub$일 경우 성립한다.\r\n\r\n굳이 식으로 표현하지 않아도, 위의 5개 케이스에 부합하지 않는 모든 상황에 적용하면 된다.  \r\n위 케이스들을 `if`문을 사용하여 적절히 표현하면 된다. `switch`문의 경우 하나의 변수를 기준으로 분기를 판단하므로 해당 알고리즘에 적용하기엔 다소 부적절하다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1002 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:56:10\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint length = scanner.nextInt();\r\n\r\n\t\tfor (int i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tint x1 = scanner.nextInt();\r\n\t\t\tint y1 = scanner.nextInt();\r\n\t\t\tint r1 = scanner.nextInt();\r\n\r\n\t\t\tint x2 = scanner.nextInt();\r\n\t\t\tint y2 = scanner.nextInt();\r\n\t\t\tint r2 = scanner.nextInt();\r\n\r\n\t\t\tSystem.out.println(calcPoints(x1, y1, r1, x2, y2, r2));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 접점 갯수 반환 함수\r\n\t *\r\n\t * case 1 - 두 원이 정확히 겹칠 경우 (-1)\r\n\t * case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우 (0)\r\n\t * case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우 (0)\r\n\t * case 4 - 두 원이 서로 겹치면서 인접하는 경우 (1)\r\n\t * case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우 (1)\r\n\t * case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우 (2)\r\n\t *\r\n\t * @param x1: [int] A의 x좌표\r\n\t * @param y1: [int] A의 y좌표\r\n\t * @param r1: [int] A와 C 사이의 거리\r\n\t * @param x2: [int] B의 x좌표\r\n\t * @param y2: [int] B의 y좌표\r\n\t * @param r2: [int] B와 C 사이의 거리\r\n\t *\r\n\t * @return [int] 접점 갯수\r\n\t */\r\n\tprivate static int calcPoints(int x1, int y1, int r1, int x2, int y2, int r2)\r\n\t{\r\n\t\t// 두 점 사이의 거리 계산식\r\n\t\tdouble distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n\r\n\t\tint sum = r1 + r2;\r\n\t\tint sub = Math.abs(r1 - r2);\r\n\r\n\t\t// case 1 - 두 원이 정확히 겹칠 경우\r\n\t\tif (distance == 0 && r1 == r2)\r\n\t\t{\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// case 2 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse if (distance < sub)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// case 3 - 두 원이 서로 겹치지 않으면서 인접하지 않는 경우\r\n\t\telse if (distance > sum)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// case 4 - 두 원이 서로 겹치면서 인접하는 경우\r\n\t\telse if (distance == sub)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// case 5 - 두 원이 서로 겹치지 않으면서 인접하는 경우\r\n\t\telse if (distance == sum)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// case 6 - 두 원이 서로 겹치면서 인접하지 않는 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 기하학","url":["2021-05-21-A1002","2021","05","21","A1002"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1001번 A - B","excerpt":"두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:51:19","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-A1001.md","content":"\r\n# A - B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1001번 문제](https://www.acmicpc.net/problem/1001)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A - B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 A - B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n```\r\n\r\n# 풀이\r\n\r\n1000번 문제에서 연산만 달라지는 뺄셈 알고리즘\r\nScanner로 두 숫자를 입력받아 뺄셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1001 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:51:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\r\n\t\tscanner.close();\r\n\r\n\t\tSystem.out.println(a - b);\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-05-21-A1001","2021","05","21","A1001"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1000번 A + B","excerpt":"두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:38:17","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","사칙연산","BRONZE","BRONZE V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-A1000.md","content":"\r\n# A + B\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1000번 문제](https://www.acmicpc.net/problem/1000)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n두 정수 A와 B를 입력받은 다음, A + B를 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 A와 B가 주어진다. $(0 < A, B < 10)$\r\n\r\n## 출력\r\n\r\n첫째 줄에 A + B를 출력한다.\r\n\r\n## 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 2\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n3\r\n```\r\n\r\n# 풀이\r\n\r\n알고리즘이라고 하기 뭐한 기초적인 연산 알고리즘\r\nScanner로 두 숫자를 입력받아 덧셈한 결과를 출력한다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1000 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.04.21 Wed 21:38:17\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\r\n\t\tint a = scanner.nextInt();\r\n\t\tint b = scanner.nextInt();\r\n\r\n\t\tscanner.close();\r\n\r\n\t\tSystem.out.println(a + b);\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 구현\r\n* 사칙연산","url":["2021-05-21-A1000","2021","05","21","A1000"]},{"header":{"title":"백준 알고리즘 시작하기","excerpt":"코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다. 그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다. 풀이의 규칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-05-21T21:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-05-21-start-beakjoon.md","content":"\r\n# 백준 알고리즘\r\n\r\n코딩 테스트 및 개인 실력 향상을 위해 백준 알고리즘을 차례로 풀어보기로 했다.\r\n\r\n그냥 풀기만 하면 분명히 나중에 어떻게 풀었는지 까먹을테니, 이해한 내용을 포스팅하며 풀이를 진행한다.\r\n\r\n풀이의 규칙은 아래와 같다.\r\n\r\n1. 가급적 문제번호 순서대로 진행한다.\r\n2. 기본 언어는 <span class=\"orange-A400\">JAVA</span>로 진행한다.\r\n3. 원리는 과하다 싶을 정도로 최대한 자세하게 적는다.\r\n4. 번은 개인주의야\r\n5. 숏코딩을 지양하고, 이해하기 쉽도록 성능이 허락하는 선에서 풀어 쓴다.\r\n6. 주석을 적극 활용한다.\r\n7. 채점결과가 반드시 <b class=\"green-A400\">맞았습니다!!</b>인 코드를 기준으로 한다.\r\n8. 풀이에 제시되는 코드는 그대로 복사해도 알고리즘 풀이가 가능하도록 코딩한다.\r\n9. 신명호는 놔둔다.","url":["2021-05-21-start-beakjoon","2021","05","21","start-beakjoon"]},{"header":{"title":"Jekyll에서 Next.js로","excerpt":"Jekyll에서 Next.js로의 블로그 이동기","coverImage":"https://user-images.githubusercontent.com/50317129/119211732-cf6de280-baee-11eb-8539-f2f5344fecb1.png","date":"2021-05-21T15:09:33","type":"posts","category":"잡담","tag":["React(리액트)","Next.js","개발 블로그","Jekyll"],"comment":true,"publish":true},"name":"2021-05-21-jekyll-to-nextjs.md","content":"\r\n# Bye, Jekyll!\r\n\r\n<div>\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/119211743-e44a7600-baee-11eb-85d0-f21c1f68debc.png\" />\r\n</div>\r\n\r\n기존에 <a href=\"http://jekyllrb-ko.github.io/\" target=\"_blank\" class=\"pink-500\">Jekyll</a>로 운영하던 블로그를 버리고 React 기반의 <span class=\"blue-500\">Next.js</span>를 통해 블로그를 새로 개발했다.\r\n\r\nGithub Pages를 처음 접했을 때, 호스팅을 반드시 <span class=\"pink-500\">Jekyll</span> 기반으로 해야한다고 착각하고있었다. 사실 조금만 생각해보면 상관 없던건데.\r\n\r\n최근에 React를 접했는데, 생각보다 꽤나 매력적인 프레임워크라 소소하게나마 뭔가 만들어보고 싶었다.  \r\n블로그가 적절한 프로젝트(?)가 될 것 같았다. 명색이 개발자인데 블로그 하나 정도는 직접 개발해야 할 것 같기도 하고....\r\n\r\n# 굳이 멀쩡한 블로그 놔두고?\r\n\r\n한동안 안 하긴 했지만, 지금까진 <span class=\"pink-500\">Jekyll</span> 블로그를 운영하고 있었다. [Moon Theme](http://taylantatli.github.io/Moon/)를 적용해서 사용했었는데, 크고작은 불편함이 있었다.\r\n\r\n<br />\r\n\r\n1. <b class=\"green-500\">Jekyll이라는 생소한 환경</b>\r\n\r\n\tGithub의 개발언어는 <span class=\"red-500\">Ruby</span>다. 그래서일까, Github Pages의 기본 배포는 <span class=\"red-500\">Ruby</span> 기반 프레임워크인 <span class=\"pink-500\">Jekyll</span>을 따라간다.  \r\n\t문제는 한국엔 <span class=\"pink-500\">Jekyll</span>은 물론, <span class=\"red-500\">Ruby</span>라는 언어 자체의 수요가 많지 않다. 단순 블로그 하나 운영하기 위해 생판 모르는 언어를 접해야 한다는 점은 무시할 수 없는 디메리트.\r\n\r\n\t물론 <span class=\"red-500\">Ruby</span>를 직접적으로 개발하진 않지만 <span class=\"pink-500\">Jekyll</span> 생태계 또한 그리 친숙한 형태는 아니였다.\r\n\r\n2. <b class=\"green-500\">타인이 개발한 소스의 이해</b>\r\n\r\n\t1번과 같은 문제로, 밑바닥부터 <span class=\"pink-500\">Jekyll</span>을 개발할 수 없었다.  \r\n\t특정 기능에 대한 소요가 발생할 경우, 현재 테마에 어울리도록 \"**잘 디자인**\"하는 것이 중요하다. 하지만 사용자의 입장에서 테마 개발자의 디자인 철학을 이해하는 것은 단순 디자인과는 또 다른 문제. 구조 파악은 덤  \r\n\t더군다나 내 경우 모자란 실력에 이상한 강박증까지 있어서, 내 스타일로 작성되지 않은 코드의 리딩을 못 한다. 또한, 프로젝트의 블랙박스를 싫어한다. 실력은 없는 주제에 프로젝트 내에 내가 모르는 코드 덩어리가 있는 걸 굉장히 싫어한다. 디자인 감각이 좋지도 못 해서 결과물도 기존 테마와 이질적인 무언가가 나온다.\r\n\r\n3. <b class=\"green-500\">편리한 사용자 확장성, 불편한 개발자 확장성</b>\r\n\r\n\t블로그나, 웹 페이지, PPT 같은 환경에서 <span class=\"grenn-500\">테마</span>를 사용하는 이유는 뭘까? 귀찮지만 중요한 디자인에 대한 투자를 과감히 패스하면서도 준수한 디자인 퍼포먼스를 내기 위함이다. 물론 취지는 좋다. 어디까지나 **단순히 해당 테마가 의도한 방향에 맞을 때만.**\r\n\r\n\t다들 비슷한 경험이 있었을 것이다. 테마 혹은 템플릿을 사용하면서 필요에 따라 커스터마이징이 필요할 경우가 그렇다.  \r\n\t대부분의 테마는 결과물이 테마가 추구하는 디자인 철학과 상통할 때 그 빛을 발한다. 다시 말해, 그 의도가 손상될 경우 결과물의 퀄리티는 급락한다.  \r\n\t이 뿐만 아니라, <span class=\"red-500\">필요에 따라 기존의 요소(소스코드, 플러그인 등)을 제거할 경우 그 의존성을 파악하기 힘들어 리스크</span>가 크다.\r\n\r\n\t일례로, 위에서 언급한 <span class=\"lightBlue-500\">Moon Theme</span>의 경우, JQuery에 의존성을 갖고 있다.  \r\n\t근래 웹 개발의 JQuery에 대한 비관적인 평을 생각한다면, 이는 큰 디메리트로 다가온다. 제거 작업으로 인한 공수 또한 무시할 수 없을 것이고.  \r\n\t물론 당시의 개발 트렌드를 무시할 수 없으며, **개발**은 그 중에서도 트렌드의 주기가 매우 빠른 편이다. 이로 미루어 볼 때, 결과론적인 얘기다. 그럼에도 불구하고, **사용자가 의도하지 않은 결함**이라는 사실은 불변하다.\r\n\r\n4. <b class=\"green-500\">개발 욕구</b>\r\n\r\n\t정적 블로그의 경우 백엔드 영역이 거의 전무한데다, 복잡한 비즈니스 로직도 필요 없기 때문에 개발 난이도가 상대적으로 낮다고 판단했다. 즉, 원한다면 내가 직접 개발한 블로그를 사용하는게 그리 어렵지 않다.  \r\n\t위에서 언급했듯이, 직접 개발한 블로그를 사용하는 것이 좀 더 개발자스럽다. 난이도 또한 공부 중인 React를 적용하기도 적합하고.\r\n\r\n# Hello, Next.js!\r\n\r\nReact로 블로그를 만들 땐 주로 <a href=\"https://nextjs.org/\" target=\"_blank\" class=\"blue-500\">Next.js</a> 혹은 <a href=\"https://www.gatsbyjs.com/\" target=\"_blank\" class=\"deepPurple-400\">Gatsby.js</a>를 사용한다. 이번에 개발한 블로그는 <span class=\"blue-500\">Next.js</span>를 활용했다.\r\n\r\n<span class=\"blue-500\">Next.js</span>는 <span class=\"red-500\">Ruby</span>의 <span class=\"pink-500\">Jekyll</span> 프레임워크와 그 결이 비슷하다. <span class=\"pink-500\">Jekyll</span>는 **프레임워크 자체에 구조 스키마를 정함으로써 React의 Component와 유사하게 동작**한다. 그 당시의 난 React라는 걸 접하지도 않은 상황에서, React의 Component 방식으로 블로그를 구성했던 것이다. 말 그대로 낫 놓고 기역자도 모른 셈.\r\n\r\n<span class=\"blue-500\">Next.js</span> 역시 라이브러리 자체에 정적 웹을 구성하고 빌드할 수 있는 환경이 구축되어 있어, 쉽게 사용이 가능하다. 여러 사용자들이 개발한 다수의 플러그인은 덤.  \r\n덕분에 정적 블로그를 밑바닥에서부터 개발할 수 있었다. 나름대로 디자인 한다고 하긴 했는데, 역시 디자인은 어렵다.  \r\n<span class=\"blue-500\">Next.js</span>와 <span class=\"deepPurple-500\">Gatsby.js</span>에 대한 내용은 나중에 따로 다룰 예정이다.\r\n\r\n아직 해야할 것들이 남아있다. sitemap 생성기도 붙여야 하고, 연관 게시물 기능도 필요하다. 아직 다듬어지지 않은 자잘한 요소들도 있고. 역시 규모에 상관없이 무언가를 퍼블리싱하는건 정말 힘든 것 같다.  \r\n적어도 이번 블로그는 내 노력으로 내가 개발한 거니, 꾸준히 운영할 수 있었음 한다.","url":["2021-05-21-jekyll-to-nextjs","2021","05","21","jekyll-to-nextjs"]}],"categories":["CS","JAVA","Jekyll","WAS","WEB","알고리즘","잡담"],"images":["celeb1.gif","celeb10.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"page":1},"__N_SSG":true}