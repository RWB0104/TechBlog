{"pageProps":{"page":{"type":"posts","prev":{"title":"빅 오 표기법","excerpt":"하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 문제를 해결하는 효율성의 차이 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-14T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","빅 오 표기법"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-14-about-algorithm-chapter03","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 3장 빅 오 표기법\r\n\r\n하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 <span class=\"orange-A400\">문제를 해결하는 효율성의 차이</span> 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.\r\n\r\n이러한 알고리즘의 성능을 하나의 규칙으로 표기한 것이 <span class=\"primary\">빅 오 표기법</span>이다. 이 장에서는 알고리즘의 빅 오 표기법에 대해 설명한다.\r\n\r\n## 3-1. 빅 오: 단계 수 계산\r\n\r\n보통 알고리즘의 성능을 측정한다고 하면 소요시간을 생각하겠지만, 의외로 소요시간은 객관적인 성능 지표가 되지 못 한다. 그 이유는 컴퓨터마다 성능이 제각각이기 때문. 똑같은 게임을 구동해도 어떤 컴퓨터는 울트라옵으로 165 프레임을 뽑는다고 하면, 다른 컴퓨터는 최하옵으로도 버벅일 수 있다. <span class=\"teal-400\">동일한 작업을 수행해도 컴퓨터의 성능에 따라 그 소요시간이 천차만별</span>로 달라진다.\r\n\r\n때문에 <span class=\"green-A400\">알고리즘의 성능을 측정하는 적절한 지표는 처리 단계</span>라 할 수 있다. 이전 장의 <span class=\"primary\">읽기 연산</span>과 <span class=\"primary\">선형 검색</span>을 통해 예를 들어보자.\r\n\r\n읽기 연산의 경우, 배열이 10개가 있던 1억개가 있던 관계없이 인덱스 i의 요소를 읽는데 필요한 단계는 하나다. 반대로 선형 검색의 경우, 요소가 많아지면 많아질 수록 연산에 요구되는 단계가 늘어난다. 배열 $N$개가 있을 때, 찾는 요소가 배열 맨 끝에 있는 최악의 경우 $N$개의 단계가 필요하다.\r\n\r\n즉, 읽기 연산의 경우 언제나 한 단계만 필요하므로 $O(1)$로 표기할 수 있으머, 선형 검색의 경우 $O(N)$으로 표기할 수 있다. 이러한 표기를 <span class=\"amber-400\">시간 복잡도</span>라 한다.\r\n\r\n## 3-2. 상수 시간과 선형 시간\r\n\r\n읽기 연산처럼 요소의 갯수에 상관없이 일정한 단계만을 필요로하는 연산이 있는가 하면, 선형 검색처럼 요소의 크기에 따라 단계가 가변하는 연산도 존재한다. 이전 문단에서 언급했듯이 읽기 연산의 시간 복잡도는 $O(1)$, 선형 검색의 시간 복잡도는 $O(N)$으로 표기할 수 있다. 이를 그래프로 비교하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599099-db099ea5-e3e9-4b79-ad19-700870b07891.png\" width=\"600px\" />\r\n</p>\r\n\r\n$O(N)$의 경우 우리가 흔히 접한 1차원 그래프 $y = x$와 패턴이 동일하다. 요소의 수가 1씩 증가할 수록 단계 또한 1씩 정직하게 증가한다. 이러한 패턴을 <span class=\"primary\">선형 시간</span>이라고 표현한다. 그러나 $O(1)$의 경우 단계에 관계없이 일정한 상수 그래프 $y = 1$와 패턴이 동일하다. 이러한 패턴을 <span class=\"primary\">상수 시간</span>이라고 표현한다.\r\n\r\n$O(1)$의 경우 조금 특이한데, 아래의 모든 그래프는 $O(1)$의 시간 복잡도를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599889-72b5cbb9-ca20-4b19-9f49-6d363b8ebec5.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 수에 관계 없이 두 단계를 요구하면 $O(2)$, 100 단계를 요구하면 $O(100)$일 것 같지만, 빅 오 표기법은 단계가 일정할 경우 이를 크게 신경쓰지 않는다. 즉, 설령 단계가 1억개가 된다 하더라도 시간 복잡도는 $O(1)$이 된다.\r\n\r\n<span class=\"red-400\">상수 시간의 경우 기본적으로 선형 시간보다 효율적</span>이라고 판단한다. 그 이유는 아래 그래프와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599827-0f58c448-9ab5-44dc-9bca-80d3ffd49d64.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n깊게 생각하지 않더라도, 선형적으로 증가하는 그래프는 언젠가 상수 그래프를 넘어서게 된다. 즉, 요소가 무수히 많아지는 거시적 관점으로 보면 <span class=\"red-400\">언젠가 선형 시간의 효율이 상수 시간보다 떨어지는 시점에 도달</span>한다. 예제를 보면 요소가 10개 이상일 경우 선형 시간의 효율성이 점점 떨어진다.\r\n\r\n그런데 선형 시간의 경우를 생각해보자. 분명히 단계가 최대 $N$개가 소요될 수 있다는 뜻이지, 항상 $N$개가 소요된다는 것은 아니다. 예를 들어, 1부터 오름차순으로 정렬된 1억개의 배열에서 5를 검색한다고 가정하면, 필요한 단계는 5밖에 안 된다. 그럼에도 책에서는 선형 시간보다 상수 시간이 비교적 효율적이라고 설명하고 있다. 그 이유는 뭘까? 다음 문단에서 그 해답을 찾을 수 있다.\r\n\r\n## 3-3. 같은 알고리즘, 다른 시나리오\r\n\r\n선형 검색은 검색하려는 요소의 위치에 따라서 생각보다 많은 시간이 소요되지 않을 수도 있다. 최선의 경우 요소가 맨 앞에 있으므로 단계가 하나만 필요하여 $O(1)$과 동일한 시간 복잡도를 가질 수도 있다. 그러나 최악의 경우 요소가 맨 끝에 있으므로 온전히 $N$개의 단계가 필요하여 $O(N)$의 시간 복잡도를 가진다.\r\n\r\n통상 알고리즘이 어떤 데이터를 얼마나 많이 처리할지 미리 알 수 없다. $O(N)$의 시간 복잡도를 가지는 임의의 알고리즘에 최선의 케이스를 적용하여 처리하면 $O(1)$에 가깝게 동작할 것이고, 최악의 케이스를 적용하여 처리하면 $O(N)$에 가깝게 동작할 것이다. <span class=\"orange-A400\">알고리즘은 기본적으로 가장 비관적인 접근</span>으로 바라본다.\r\n\r\n우리가 어떤 물건을 온라인으로 주문한다고 생각해보자. 내가 원하는 물건을 여러 업체에서 동일한 가격에 팔고 있지만, 택배 도착에 걸리는 시간이 다르다. 이는 업체의 페이지에 각각 아래와 같이 써있으며, 택배 도착은 이 시간을 절대로 벗어나지 않는다고 가정하자.\r\n\r\n* A업체: 빠르면 오늘, 늦으면 일주일 뒤\r\n* B업체: 빠르면 내일, 늦으면 3일 뒤\r\n* C업체: 빠르면 3일, 늦으면 5일 뒤\r\n\r\n우리가 3일 안으로 물건을 반드시 받아야 한다면 B업체가 가장 안전할 것이다. 물론 A업체에 주문하면 오늘 당장이라도 올 가능성이 있지만, 최악의 경우 일주일을 꼬박 기다려야 받게 될 수도 있기 때문에 3일을 넘어버릴 가능성 또한 무시할 수 없다. 빠르게 오면 단순히 좋은 정도지만, 3일을 넘어서면 안 되므로 A업체 또한 적절하지 않은 것이다. C업체는 말할 필요도 없고.\r\n\r\n알고리즘도 이러한 관점과 동일하다. $N$이 최대 100인 $O(N)$ 알고리즘이 있을 때, 성능 상의 이유로 단계가 50이 넘어가면 크래쉬를 유발할 경우 이 알고리즘은 적절하지 않다. 이와 같이 최악의 상황을 알아야 장애를 대비할 수 있다. 이러한 이유로 알고리즘의 성능은 항상 최악을 기준으로 표시한다.\r\n\r\n## 3-4 세 번째 유형의 알고리즘\r\n\r\n물론 시간 복잡도가 $O(1)$, $O(N)$만 있는 것은 아니다. 우리가 2장에서 다뤘던 이진 검색의 경우, 요소에 따라 단계가 증가하긴 하지만 $O(N)$과 같이 선형적으로 증가하지는 않는다. 즉, $O(1)$도 아니고, $O(N)$도 아닌 그 사이의 시간 복잡도를 가진다.\r\n\r\n이진 검색의 시간 복잡도는 기본적으로 $O(\\log_2N)$을 가진다. $O(1)$, $O(\\log_2N)$, $O(N)$가 요구하는 단계를 표로 표현하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125602081-0cc6075b-ba14-43c5-8aa6-52d8561559a3.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$, $O(\\log N)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n## 로가리즘\r\n\r\n우리가 흔히 부르는 $\\log$. 즉, 로그는 로가리즘(Logarithm)의 줄임말이다. $x^n = y$가 성립할 경우, 이를 로그로 표현하면 $\\log_xy = n$과 같다.\r\n\r\n예를 들어, $3^2 = 9$가 성립한다. 이를 로그로 표현하면 $\\log_39 =  2$가 된다. 이렇게 로그를 통해 수의 제곱수를 구할 수 있다.\r\n\r\n## $O(\\log N)$의 해석\r\n\r\n위 문단에서 로그에 대해 어느정도 이해를 했으니, $O(\\log N)$에 대해 논의해보자. 통상 수학에선 $\\log_{10}x$을 간략화하여 $\\log$로 표현했지만, 빅 오 표기법에서는 $\\log_2x$의 간략화다. <span class=\"orange-A400\">현실에선 십진법이 통용</span>되지만, <span class=\"orange-A400\">컴퓨터는 이진법을 사용</span>하기 때문.\r\n\r\n$O(N)$과 $O(\\log N)$를 비교하면 아래와 같다.\r\n\r\n|    $N$    |  $O(N)$   | $O(\\log N)$ |\r\n| :-------: | :-------: | :---------: |\r\n|     2     |     2     |      1      |\r\n|     4     |     4     |      2      |\r\n|     8     |     8     |      3      |\r\n|    16     |    16     |      4      |\r\n|    32     |    32     |      5      |\r\n|    64     |    64     |      6      |\r\n|    128    |    128    |      7      |\r\n|    256    |    256    |      8      |\r\n|    512    |    512    |      9      |\r\n|   1024    |   1024    |     10      |\r\n| $2^{100}$ | $2^{100}$ |     100     |\r\n\r\n$O(N)$는 $N$이 증가함에 따라 정직하게 같이 증가하지만, $O(\\log N)$은 $N$이 정확히 두 배가 될 때 1씩 증가한다.\r\n\r\n여담으로, 천문학같은 거시세계에서 로그가 중요한 이유가 위 표만으로도 쉽게 확인할 수 있다. $2^{100}$은 126,7650,6002,2822,9401,4967,0320,5376이다. 약 100양에 육박하는 수치로, 양은 수의 단위인 조를 아득히 뛰어넘는 단위다.\r\n\r\n> 거시적 수의 단위  \r\n> 일반적으로 사람이 접할 수 있는 의미 있는 단위는 조 단위로, 1억씩 천 번을 모아야 만들어지는 수치다.  \r\n> 조 단위 뒤로는 경, 해, 자, 양 순으로 나열되며, 현실에서 경 이후로는 그 수의 크기를 논하는게 의미가 없는 정도\r\n\r\n현실세계와 달리 수학이나 천문학과 같은 경우 우리에게 의미가 없을 정도로 큰 수를 다루기도 하는데, 이를 로그로 표현하면 이를 효과적으로 다룰 수 있다.\r\n\r\n## 3-7. 실제 예제\r\n\r\n지금까지 기술한 내용을 토대로 실제 코드에 적용해보자. 4개의 요소를 가진 배열이 있고, 배열의 값을 하나씩 출력하는 알고리즘이 있다고 가정해보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:40:00\r\n */\r\npublic class BigO\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열\r\n\t\tString[] things = { \"apples\", \"baboons\", \"cribs\", \"delcimers\" };\r\n\t\t\r\n\t\t// 배열마다 하나씩 순회\r\n\t\tfor (String thing : things)\r\n\t\t{\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(\"Here's a thing: \");\r\n\t\t\tbuilder.append(thing);\r\n\t\t\t\r\n\t\t\twriter.write(builder.toString());\r\n\t\t\twriter.newLine();\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHere's a thing: apples\r\nHere's a thing: baboons\r\nHere's a thing: cribs\r\nHere's a thing: delcimers\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n요소마다 하나씩 읽어 요소의 내용을 출력한다. 즉, <span class=\"blue-400\">요소가 많아지면 많아질 수록 같이 선형적으로 증가</span>하므로, 이 알고리즘의 시간 복잡도는 $O(N)$으로 표현할 수 있다.\r\n\r\n반대로 가장 기본적인 문자열 하나를 출력하는 알고리즘을 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:56:49\r\n */\r\npublic class BigO2\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"Hello world!\");\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHello world!\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n알고리즘이라 부르기는 조금 뭐하지만, 어쨌든 이 알고리즘을 수행하는 데 <span class=\"blue-400\">필요한 단계는 무조건 하나</span>다. 즉 시간 복잡도는 $O(1)$이다.\r\n\r\n좀 더 실속있는 예제를 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 소수 판별 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 18:01:20\r\n */\r\npublic class CheckPrime\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"소수를 판별할 값 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 입력값\r\n\t\tint target = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 소수일 경우\r\n\t\tif (isPrime(target))\r\n\t\t{\r\n\t\t\twriter.write(\"소수로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"소수가 아닌 것으로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 함수\r\n\t *\r\n\t * @param num: [int] 대상 값\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate static boolean isPrime(int num)\r\n\t{\r\n\t\tfor (int i = 2; i < num; i++)\r\n\t\t{\r\n\t\t\t// 나누어 떨어지는 수가 있을 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력값\r\n\r\n``` tc\r\n156842101\r\n```\r\n\r\n* 출력값\r\n\r\n``` tc\r\n소수가 아닌 것으로 판별됨\r\n```\r\n\r\n이 소스는 임의의 값을 입력받아 소수인지 아닌지를 판별하는 알고리즘이다. 이 알고리즘을 통해 156842101은 소수가 아님을 쉽게 알 수 있다.\r\n\r\n해당 알고리즘은 가장 작은 소수인 2부터 입력값 `target`까지 하나씩 증가시킨 값을 `target`과 나눠서 정확히 나눠떨어지는지 아닌지를 통해 소수를 판별하는 매우 기초적인 알고리즘이다.\r\n\r\n최악의 케이스는 판별값이 소수일 경우로,  2부터 `target - 1`까지의 작업 전체를 요구하므로 총 `target - 2`의 작업이 발생한다. $N = target$일 때, -2는 그렇게 의미있는 값이 아니므로 위 알고리즘의 시간 복잡도는 $O(N)$으로 봐도 무방하다.\r\n\r\n# 마무리\r\n\r\n알고리즘을 정석적으로 공부하지 않아서, 빅 오 표기법과 같은 시간 복잡도를 제대로 이해하지 않았었다. 시간 복잡도의 개념과 그 계산 방식을 알 수 있었던 매우 의미있는 장이였다.\r\n\r\n다음 장에선 이 빅 오 표기법을 활용하여 알고리즘을 개선하는 방법에 대해 설명한다."},"next":-1},"group":[{"title":"빅 오 표기법","excerpt":"하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 문제를 해결하는 효율성의 차이 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-14T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","빅 오 표기법"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-14-about-algorithm-chapter03","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 3장 빅 오 표기법\r\n\r\n하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 <span class=\"orange-A400\">문제를 해결하는 효율성의 차이</span> 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.\r\n\r\n이러한 알고리즘의 성능을 하나의 규칙으로 표기한 것이 <span class=\"primary\">빅 오 표기법</span>이다. 이 장에서는 알고리즘의 빅 오 표기법에 대해 설명한다.\r\n\r\n## 3-1. 빅 오: 단계 수 계산\r\n\r\n보통 알고리즘의 성능을 측정한다고 하면 소요시간을 생각하겠지만, 의외로 소요시간은 객관적인 성능 지표가 되지 못 한다. 그 이유는 컴퓨터마다 성능이 제각각이기 때문. 똑같은 게임을 구동해도 어떤 컴퓨터는 울트라옵으로 165 프레임을 뽑는다고 하면, 다른 컴퓨터는 최하옵으로도 버벅일 수 있다. <span class=\"teal-400\">동일한 작업을 수행해도 컴퓨터의 성능에 따라 그 소요시간이 천차만별</span>로 달라진다.\r\n\r\n때문에 <span class=\"green-A400\">알고리즘의 성능을 측정하는 적절한 지표는 처리 단계</span>라 할 수 있다. 이전 장의 <span class=\"primary\">읽기 연산</span>과 <span class=\"primary\">선형 검색</span>을 통해 예를 들어보자.\r\n\r\n읽기 연산의 경우, 배열이 10개가 있던 1억개가 있던 관계없이 인덱스 i의 요소를 읽는데 필요한 단계는 하나다. 반대로 선형 검색의 경우, 요소가 많아지면 많아질 수록 연산에 요구되는 단계가 늘어난다. 배열 $N$개가 있을 때, 찾는 요소가 배열 맨 끝에 있는 최악의 경우 $N$개의 단계가 필요하다.\r\n\r\n즉, 읽기 연산의 경우 언제나 한 단계만 필요하므로 $O(1)$로 표기할 수 있으머, 선형 검색의 경우 $O(N)$으로 표기할 수 있다. 이러한 표기를 <span class=\"amber-400\">시간 복잡도</span>라 한다.\r\n\r\n## 3-2. 상수 시간과 선형 시간\r\n\r\n읽기 연산처럼 요소의 갯수에 상관없이 일정한 단계만을 필요로하는 연산이 있는가 하면, 선형 검색처럼 요소의 크기에 따라 단계가 가변하는 연산도 존재한다. 이전 문단에서 언급했듯이 읽기 연산의 시간 복잡도는 $O(1)$, 선형 검색의 시간 복잡도는 $O(N)$으로 표기할 수 있다. 이를 그래프로 비교하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599099-db099ea5-e3e9-4b79-ad19-700870b07891.png\" width=\"600px\" />\r\n</p>\r\n\r\n$O(N)$의 경우 우리가 흔히 접한 1차원 그래프 $y = x$와 패턴이 동일하다. 요소의 수가 1씩 증가할 수록 단계 또한 1씩 정직하게 증가한다. 이러한 패턴을 <span class=\"primary\">선형 시간</span>이라고 표현한다. 그러나 $O(1)$의 경우 단계에 관계없이 일정한 상수 그래프 $y = 1$와 패턴이 동일하다. 이러한 패턴을 <span class=\"primary\">상수 시간</span>이라고 표현한다.\r\n\r\n$O(1)$의 경우 조금 특이한데, 아래의 모든 그래프는 $O(1)$의 시간 복잡도를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599889-72b5cbb9-ca20-4b19-9f49-6d363b8ebec5.png\" width=\"600px\" />\r\n</p>\r\n\r\n요소의 수에 관계 없이 두 단계를 요구하면 $O(2)$, 100 단계를 요구하면 $O(100)$일 것 같지만, 빅 오 표기법은 단계가 일정할 경우 이를 크게 신경쓰지 않는다. 즉, 설령 단계가 1억개가 된다 하더라도 시간 복잡도는 $O(1)$이 된다.\r\n\r\n<span class=\"red-400\">상수 시간의 경우 기본적으로 선형 시간보다 효율적</span>이라고 판단한다. 그 이유는 아래 그래프와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125599827-0f58c448-9ab5-44dc-9bca-80d3ffd49d64.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n깊게 생각하지 않더라도, 선형적으로 증가하는 그래프는 언젠가 상수 그래프를 넘어서게 된다. 즉, 요소가 무수히 많아지는 거시적 관점으로 보면 <span class=\"red-400\">언젠가 선형 시간의 효율이 상수 시간보다 떨어지는 시점에 도달</span>한다. 예제를 보면 요소가 10개 이상일 경우 선형 시간의 효율성이 점점 떨어진다.\r\n\r\n그런데 선형 시간의 경우를 생각해보자. 분명히 단계가 최대 $N$개가 소요될 수 있다는 뜻이지, 항상 $N$개가 소요된다는 것은 아니다. 예를 들어, 1부터 오름차순으로 정렬된 1억개의 배열에서 5를 검색한다고 가정하면, 필요한 단계는 5밖에 안 된다. 그럼에도 책에서는 선형 시간보다 상수 시간이 비교적 효율적이라고 설명하고 있다. 그 이유는 뭘까? 다음 문단에서 그 해답을 찾을 수 있다.\r\n\r\n## 3-3. 같은 알고리즘, 다른 시나리오\r\n\r\n선형 검색은 검색하려는 요소의 위치에 따라서 생각보다 많은 시간이 소요되지 않을 수도 있다. 최선의 경우 요소가 맨 앞에 있으므로 단계가 하나만 필요하여 $O(1)$과 동일한 시간 복잡도를 가질 수도 있다. 그러나 최악의 경우 요소가 맨 끝에 있으므로 온전히 $N$개의 단계가 필요하여 $O(N)$의 시간 복잡도를 가진다.\r\n\r\n통상 알고리즘이 어떤 데이터를 얼마나 많이 처리할지 미리 알 수 없다. $O(N)$의 시간 복잡도를 가지는 임의의 알고리즘에 최선의 케이스를 적용하여 처리하면 $O(1)$에 가깝게 동작할 것이고, 최악의 케이스를 적용하여 처리하면 $O(N)$에 가깝게 동작할 것이다. <span class=\"orange-A400\">알고리즘은 기본적으로 가장 비관적인 접근</span>으로 바라본다.\r\n\r\n우리가 어떤 물건을 온라인으로 주문한다고 생각해보자. 내가 원하는 물건을 여러 업체에서 동일한 가격에 팔고 있지만, 택배 도착에 걸리는 시간이 다르다. 이는 업체의 페이지에 각각 아래와 같이 써있으며, 택배 도착은 이 시간을 절대로 벗어나지 않는다고 가정하자.\r\n\r\n* A업체: 빠르면 오늘, 늦으면 일주일 뒤\r\n* B업체: 빠르면 내일, 늦으면 3일 뒤\r\n* C업체: 빠르면 3일, 늦으면 5일 뒤\r\n\r\n우리가 3일 안으로 물건을 반드시 받아야 한다면 B업체가 가장 안전할 것이다. 물론 A업체에 주문하면 오늘 당장이라도 올 가능성이 있지만, 최악의 경우 일주일을 꼬박 기다려야 받게 될 수도 있기 때문에 3일을 넘어버릴 가능성 또한 무시할 수 없다. 빠르게 오면 단순히 좋은 정도지만, 3일을 넘어서면 안 되므로 A업체 또한 적절하지 않은 것이다. C업체는 말할 필요도 없고.\r\n\r\n알고리즘도 이러한 관점과 동일하다. $N$이 최대 100인 $O(N)$ 알고리즘이 있을 때, 성능 상의 이유로 단계가 50이 넘어가면 크래쉬를 유발할 경우 이 알고리즘은 적절하지 않다. 이와 같이 최악의 상황을 알아야 장애를 대비할 수 있다. 이러한 이유로 알고리즘의 성능은 항상 최악을 기준으로 표시한다.\r\n\r\n## 3-4 세 번째 유형의 알고리즘\r\n\r\n물론 시간 복잡도가 $O(1)$, $O(N)$만 있는 것은 아니다. 우리가 2장에서 다뤘던 이진 검색의 경우, 요소에 따라 단계가 증가하긴 하지만 $O(N)$과 같이 선형적으로 증가하지는 않는다. 즉, $O(1)$도 아니고, $O(N)$도 아닌 그 사이의 시간 복잡도를 가진다.\r\n\r\n이진 검색의 시간 복잡도는 기본적으로 $O(\\log_2N)$을 가진다. $O(1)$, $O(\\log_2N)$, $O(N)$가 요구하는 단계를 표로 표현하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125602081-0cc6075b-ba14-43c5-8aa6-52d8561559a3.png\" width=\"600px\" />\r\n</p>\r\n\r\n<small class=\"red-400\">※ $O(1)$, $O(\\log N)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.</small>\r\n\r\n## 로가리즘\r\n\r\n우리가 흔히 부르는 $\\log$. 즉, 로그는 로가리즘(Logarithm)의 줄임말이다. $x^n = y$가 성립할 경우, 이를 로그로 표현하면 $\\log_xy = n$과 같다.\r\n\r\n예를 들어, $3^2 = 9$가 성립한다. 이를 로그로 표현하면 $\\log_39 =  2$가 된다. 이렇게 로그를 통해 수의 제곱수를 구할 수 있다.\r\n\r\n## $O(\\log N)$의 해석\r\n\r\n위 문단에서 로그에 대해 어느정도 이해를 했으니, $O(\\log N)$에 대해 논의해보자. 통상 수학에선 $\\log_{10}x$을 간략화하여 $\\log$로 표현했지만, 빅 오 표기법에서는 $\\log_2x$의 간략화다. <span class=\"orange-A400\">현실에선 십진법이 통용</span>되지만, <span class=\"orange-A400\">컴퓨터는 이진법을 사용</span>하기 때문.\r\n\r\n$O(N)$과 $O(\\log N)$를 비교하면 아래와 같다.\r\n\r\n|    $N$    |  $O(N)$   | $O(\\log N)$ |\r\n| :-------: | :-------: | :---------: |\r\n|     2     |     2     |      1      |\r\n|     4     |     4     |      2      |\r\n|     8     |     8     |      3      |\r\n|    16     |    16     |      4      |\r\n|    32     |    32     |      5      |\r\n|    64     |    64     |      6      |\r\n|    128    |    128    |      7      |\r\n|    256    |    256    |      8      |\r\n|    512    |    512    |      9      |\r\n|   1024    |   1024    |     10      |\r\n| $2^{100}$ | $2^{100}$ |     100     |\r\n\r\n$O(N)$는 $N$이 증가함에 따라 정직하게 같이 증가하지만, $O(\\log N)$은 $N$이 정확히 두 배가 될 때 1씩 증가한다.\r\n\r\n여담으로, 천문학같은 거시세계에서 로그가 중요한 이유가 위 표만으로도 쉽게 확인할 수 있다. $2^{100}$은 126,7650,6002,2822,9401,4967,0320,5376이다. 약 100양에 육박하는 수치로, 양은 수의 단위인 조를 아득히 뛰어넘는 단위다.\r\n\r\n> 거시적 수의 단위  \r\n> 일반적으로 사람이 접할 수 있는 의미 있는 단위는 조 단위로, 1억씩 천 번을 모아야 만들어지는 수치다.  \r\n> 조 단위 뒤로는 경, 해, 자, 양 순으로 나열되며, 현실에서 경 이후로는 그 수의 크기를 논하는게 의미가 없는 정도\r\n\r\n현실세계와 달리 수학이나 천문학과 같은 경우 우리에게 의미가 없을 정도로 큰 수를 다루기도 하는데, 이를 로그로 표현하면 이를 효과적으로 다룰 수 있다.\r\n\r\n## 3-7. 실제 예제\r\n\r\n지금까지 기술한 내용을 토대로 실제 코드에 적용해보자. 4개의 요소를 가진 배열이 있고, 배열의 값을 하나씩 출력하는 알고리즘이 있다고 가정해보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:40:00\r\n */\r\npublic class BigO\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열\r\n\t\tString[] things = { \"apples\", \"baboons\", \"cribs\", \"delcimers\" };\r\n\t\t\r\n\t\t// 배열마다 하나씩 순회\r\n\t\tfor (String thing : things)\r\n\t\t{\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(\"Here's a thing: \");\r\n\t\t\tbuilder.append(thing);\r\n\t\t\t\r\n\t\t\twriter.write(builder.toString());\r\n\t\t\twriter.newLine();\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHere's a thing: apples\r\nHere's a thing: baboons\r\nHere's a thing: cribs\r\nHere's a thing: delcimers\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n요소마다 하나씩 읽어 요소의 내용을 출력한다. 즉, <span class=\"blue-400\">요소가 많아지면 많아질 수록 같이 선형적으로 증가</span>하므로, 이 알고리즘의 시간 복잡도는 $O(N)$으로 표현할 수 있다.\r\n\r\n반대로 가장 기본적인 문자열 하나를 출력하는 알고리즘을 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 17:56:49\r\n */\r\npublic class BigO2\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"Hello world!\");\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHello world!\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n알고리즘이라 부르기는 조금 뭐하지만, 어쨌든 이 알고리즘을 수행하는 데 <span class=\"blue-400\">필요한 단계는 무조건 하나</span>다. 즉 시간 복잡도는 $O(1)$이다.\r\n\r\n좀 더 실속있는 예제를 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 소수 판별 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\">빅 오 표기법</a>\r\n * @since 2021.07.14 Wed 18:01:20\r\n */\r\npublic class CheckPrime\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"소수를 판별할 값 입력 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 입력값\r\n\t\tint target = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 소수일 경우\r\n\t\tif (isPrime(target))\r\n\t\t{\r\n\t\t\twriter.write(\"소수로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"소수가 아닌 것으로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 함수\r\n\t *\r\n\t * @param num: [int] 대상 값\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate static boolean isPrime(int num)\r\n\t{\r\n\t\tfor (int i = 2; i < num; i++)\r\n\t\t{\r\n\t\t\t// 나누어 떨어지는 수가 있을 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력값\r\n\r\n``` tc\r\n156842101\r\n```\r\n\r\n* 출력값\r\n\r\n``` tc\r\n소수가 아닌 것으로 판별됨\r\n```\r\n\r\n이 소스는 임의의 값을 입력받아 소수인지 아닌지를 판별하는 알고리즘이다. 이 알고리즘을 통해 156842101은 소수가 아님을 쉽게 알 수 있다.\r\n\r\n해당 알고리즘은 가장 작은 소수인 2부터 입력값 `target`까지 하나씩 증가시킨 값을 `target`과 나눠서 정확히 나눠떨어지는지 아닌지를 통해 소수를 판별하는 매우 기초적인 알고리즘이다.\r\n\r\n최악의 케이스는 판별값이 소수일 경우로,  2부터 `target - 1`까지의 작업 전체를 요구하므로 총 `target - 2`의 작업이 발생한다. $N = target$일 때, -2는 그렇게 의미있는 값이 아니므로 위 알고리즘의 시간 복잡도는 $O(N)$으로 봐도 무방하다.\r\n\r\n# 마무리\r\n\r\n알고리즘을 정석적으로 공부하지 않아서, 빅 오 표기법과 같은 시간 복잡도를 제대로 이해하지 않았었다. 시간 복잡도의 개념과 그 계산 방식을 알 수 있었던 매우 의미있는 장이였다.\r\n\r\n다음 장에선 이 빅 오 표기법을 활용하여 알고리즘을 개선하는 방법에 대해 설명한다."},{"title":"알고리즘이 중요한 까닭","excerpt":"IT영역에서의 알고리즘이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. 개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구된다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열","정렬","이진 검색"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-10-about-algorithm-chapter02","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 2장 알고리즘이 중요한 까닭\r\n\r\nIT영역에서의 <span class=\"primary\">알고리즘</span>이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. <span class=\"teal-400\">개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구</span>된다.\r\n\r\n이러한 특징으로 알고리즘은 뛰어난 문제 해결력과 수학적 사고 능력을 요한다. 때문에 많은 사람들이 어려워하는 분야 중 하나지만, 그 강력함과 효율로 인해 개발 역량의 척도를 확인하는데 사용하기도 한다. 흔히 기업에서 보는 <span class=\"teal-400\">코딩 테스트</span>가 좋은 예시다.\r\n\r\n이 장에서는 <span class=\"primary\">알고리즘</span>을 통해 검색 연산을 더욱 효과적으로 개선하는 방법에 대해 설명한다. 이전 장에서 언급했듯이, 검색 연산은 무수히 많은 읽기 연산의 모음이나 다름없다. 알고리즘이 어떻게 읽기 연산을 최적화시키는지 알아보자.\r\n\r\n## 2-1. 정렬된 배열\r\n\r\n<span class=\"primary\">정렬된 배열</span>이란, 기존의 배열에서 요소들이 특정 조건으로 정렬된 배열을 의미한다. 정렬된 배열은 그 요소들이 항상 정해진 조건에 따라 순서대로 배치된다. 이는 삽입을 할 때도 동일하다. 정렬된 배열이 항상 정렬된 상태를 유지하기 위해선 <span class=\"red-A400\">삽입 시에도 요소의 정렬에 따라 정렬을 훼손하지 않는 올바른 자리에 삽입</span>되어야 한다.\r\n\r\n기존의 배열이라면 배열의 크기가 허락하는 한, 원하는 위치 어디에서나 삽입이 가능하다. 배열에 55를 삽입할 때, 일반적인 배열은 아래처럼 삽입에 제한이 없다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144062-a3b6c280-e157-11eb-88d6-20689d8f05b1.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 정렬된 배열이라면 어떨까? 이번엔 배열이 오름차순으로 정렬된 배열이라고 가정해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144070-aa453a00-e157-11eb-9390-1550623a57bd.png\" width=\"600px\" />\r\n</p>\r\n\r\n정렬된 위 배열에서 55를 삽입한다면 어떨까?\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144072-aca79400-e157-11eb-8939-cc0beb583b9b.png\" width=\"600px\" />\r\n</p>\r\n\r\n반드시 44와 94의 사이에 삽입되어야 오름차순 정렬을 유지할 수 있다. 그렇다면 우리는 여기서 정렬된 배열의 삽입은 기존의 삽입 연산에 비해 로직이 추가됨을 유추할 수 있다. 원리는 간단하다. 요소를 순차적으로 읽어서 55보다 큰 수가 나올 때까지 반복한다. 배열이 정렬되어 있으므로, 55보다 큰 수를 만나게 되면 이전의 요소는 모두 55보다 작을 것이다. 이 위치를 기준으로 삽입을 진행하면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125144075-ae715780-e157-11eb-92ed-71ee06140c5f.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 그림과 같이 순차적으로 요소를 검색하여 55보다 큰 요소를 찾는다. 94는 배열에서 55보다 큰 가장 작은 수다.\r\n\r\n94의 인덱스인 4번째 요소에 55를 삽입하고, 94를 한 칸 뒤로 미룬다. 이 과정을 통해 정렬된 배열의 연산을 수행할 수 있다.\r\n\r\n그렇다면 이 고생을 뭐하러 사서하는 것일까? 그 이유는 검색의 최적화에 있다. <span class=\"orange-A400\">정렬된 배열은 그 자체로 순서라는 규칙성을 지니기 때문에 이를 활용한 알고리즘 적용이 가능</span>하기 때문이다. 이를 통해 검색의 작업량을 효과적으로 줄여 더욱 빠른 검색이 가능하다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 정렬된 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 02:41:14\r\n */\r\npublic class SortedArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 9, 14, 43, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tint result = run(item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(result);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 및 삽입된 인덱스 반환 함수\r\n\t *\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [int] 삽입된 인덱스\r\n\t */\r\n\tprivate static int run(int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\tinsert(result, item);\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자보다 배열의 값이 클 경우\r\n\t\t\tif (target < ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 인덱스에 55 삽입: [6, 9, 14, 43, 55, 94, -1, -1, -1, -1]\r\n```\r\n\r\n`insert` 함수는 이전 장에 나왔던 함수와 동일하지만, `find`의 경우 조금 달라졌다. `target == ARRAY[i]`로 동일한 값을 찾는 것이 아니라, `target < ARRAY[i]`로 삽입할 요소보다 큰 값을 찾도록 변경됐다. `run` 함수는 이를 적절히 구동하여 삽입된 인덱스를 반환한다.\r\n\r\n> **JAVA의 정렬 함수**  \r\n> 자바는 `Arrays.sort()`라는 함수가 제공되며, 인수로 정렬할 배열을 전달한다. 기본적으로 오름차순으로 정렬되며, 본인이 직접 정렬 함수를 오버라이딩함으로써 자신만의 조건으로 정렬되도록 설계할 수도 있다.\r\n\r\n## 2-3. 이진 검색\r\n\r\n우리가 앞에서 배열을 정렬한 이유가 바로 이 것이다. <span class=\"primary\">이진 검색</span>이라는 알고리즘을 적용하면 검색의 속도를 상당부분 개선할 수 있다. 심지어 이진 검색은 알고리즘 축에서는 매우 쉬운 편에 속한다. 심지어 우리는 이미 다른 형태로 이진 검색이라는 알고리즘을 접한 적이 있다.\r\n\r\n어렸을 때나, 혹은 술자리에서 Up & Down이라는 게임을 해본적이 있을 것이다. 진행자가 임의의 구간에 해당하는 임의의 수 하나를 머릿속으로 생각하면, 참가자들이 이 수를 맞추는 것이다. 참가자가 수를 말하면 진행자는 그 수가 자신의 수보다 큰 지, 작은 지 알려준다. 이걸 누군가 맞출 때까지 반복한다. 이진 검색의 원리는 이와 정확히 일치한다.\r\n\r\n<span class=\"red-A400\">이진 검색은 그 특성 상 정렬된 배열에서만 가능</span>하다. 1 ~ 100의 구간으로 순차적으로 정렬된 배열이 있다고 가정해보자. 찾아야 할 수가 68일 때, 이진 검색은 아래와 같이 이루어진다.\r\n\r\n1. 1과 100의 중간인 50과 비교한다. (작업 +1)\r\n2. 50은 68보다 작으로 51 ~ 100의 구간을 검색한다.\r\n3. 51과 100의 중간인 75와 비교한다. (작업 +1)\r\n4. 75는 68보다 크므로 51 ~ 74의 구간을 검색한다.\r\n5. 51과 74의 중간인 62와 비교한다. (작업 +1)\r\n6. 62는 68보다 작으므로 63 ~ 74의 구간을 검색한다.\r\n7. 63과 74의 중간인 68과 비교한다. (작업 +1)\r\n8. 검색이 종료된다.\r\n\r\n만약 순차적으로 검색했다면 1 부터 68까지 총 68번의 작업이 발생할 것을 단 4번의 작업으로 검색을 완료했다. 간단한 알고리즘을 적용하는 것으로도 작업량이 17배 줄어든 것이다. 지금은 구간이 작지만, 구간의 끝이 만 단위가 넘어간다면 검색하려는 숫자의 위치에 따라 작업량이 기하급수적으로 감소한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색을 구현한 소스는 위와 같다. 눈여겨 볼 부분은 `binarySearch` 함수다. 시작값 `start`는 1로 초기화되고, 끝값 `max`는 배열의 크기와 동일하다.\r\n\r\n`mid`를 계산하여 `target`과 크기비교를 한다. `target`이 더 클 경우, 중간값을 기준으로 윗 구간이므로 `start`를 `mid + 1`로 보정한다. 반대로 `target`이 더 작을 경우, 중간값을 기준으로 아랫 구간이므로 `end`를 `mid - 1`로 보정한다. 검색 대상값인 `target`과 중간값 `mid`가 동일할 때까지 알고리즘을 반복한다.\r\n\r\n1 ~ 100까지 차례대로 배치되어 있으므로, 1은 `ARRAY[0]`, 43은 `ARRAY[42]`로 값 자체로 인덱스나 다름없기 때문에 인덱스는 따로 구하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색의 단점이 있는데, 1 ~ 100의 구간이 있다고 가정하면, 1이나 100과 같은 <span class=\"orange-A400\">구간의 시작과 끝을 검색하는데 시간이 매우 오래 걸린다.</span> 이는 이진 검색이 중간값을 기준으로 검색한다는 특징으로 인한 단점이다. 위의 소스는 구간의 시작과 끝도 비교함으로써 이진 검색을 강화한 소스다.\r\n\r\n``` java\r\n// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\nif (target == start || target == end)\r\n{\r\n\tbreak;\r\n}\r\n```\r\n\r\n눈여겨 볼 부분은 `binarySearch` 함수의 해당 부분이다. 기존에 없던 `start`와 `end`의 비교 로직이 추가되어, <span class=\"orange-A400\">구간의 시작과 끝이 목표일 경우 더욱 빠르게 검색</span>할 수 있도록 보정한 것이다.\r\n\r\n| 구분  | 보정 전 | 보정 후 |\r\n| :---: | :-----: | :-----: |\r\n|   1   |    6    |    1    |\r\n|  51   |    6    |    2    |\r\n|  100  |    7    |    1    |\r\n\r\n## 2-4. 이진 검색 대 선형 검색\r\n\r\n1부터 순차적으로 하나하나 검색하는 알고리즘을 <span class=\"primary\">선형 검색</span>, 구간의 중간값을 기준으로 검색하는 알고리즘을 <span class=\"primary\">이진 검색</span>이라 한다. 우리가 2장까지 진행하면서, 배열의 일반적인 검색과 이진 검색에 대해 설계하고 차이점을 비교했다.\r\n\r\n선형 검색의 경우 요소의 갯수 $N$이 늘어나면 늘어날수록 예상되는 최대 작업량도 $N$개로 비례하여 늘어난다. 이에 비해 이진 검색의 경우 $N = 10,000$일 때, 책에 의하면 최대 작업량이 13이라고 한다. $N = 1,000,000$이면 작업량은 20으로, 선형 검색의 작업량이 1,000,000임을 감안하면 <span class=\"green-A400\">데이터가 많아질 수록 이진 검색으로 절약할 수 있는 기대 비용이 더욱 큼</span>을 알 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 검색 퍼포먼스 비교 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\">알고리즘이 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 04:21:37\r\n */\r\npublic class SearchCompare\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100000000;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 86421478;\r\n\t\t\r\n\t\tlong tic = System.nanoTime();\r\n\t\t\r\n\t\tint linearResult = find(target);\r\n\t\t\r\n\t\tlong toc1 = System.nanoTime() - tic;\r\n\t\t\r\n\t\ttic = System.nanoTime();\r\n\t\t\r\n\t\tint binaryResult = binarySearch(target);\r\n\t\t\r\n\t\tlong toc2 = System.nanoTime() - tic;\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 선형 검색 프로세스: \");\r\n\t\tbuilder.append(linearResult);\r\n\t\tbuilder.append(\"(\").append(toc1).append(\"ns)\\n\");\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 이진 검색 프로세스: \");\r\n\t\tbuilder.append(binaryResult);\r\n\t\tbuilder.append(\"(\").append(toc2).append(\"ns)\\n\\n\");\r\n\t\tbuilder.append(\"이진 검색이 약 \").append(toc1 / toc2).append(\"배 더 빠릅니다.\");\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i < max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target > mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n86421478을 탐색하는데 소요된 선형 검색 프로세스: 86421477(26936600ns)\r\n86421478을 탐색하는데 소요된 이진 검색 프로세스: 26(5100ns)\r\n\r\n이진 검색이 약 5281배 더 빠릅니다.\r\n```\r\n\r\n위 소스는 선형 검색과 이진 검색을 통합해 퍼포먼스를 비교할 수 있는 소스다. 100,000,000(1억)의 구간에서 임의의 수 `target`을 검색한다. 해당 소스에서는 86,421,478으로 지정했다.\r\n\r\n|    구분     | 선형 검색  | 이진 검색 |    차이    |\r\n| :---------: | :--------: | :-------: | :--------: |\r\n| 프로세스 수 | 86,421,477 |    26     |     -      |\r\n|  테스트 1   | $2.442ms$  |  $5.2us$  | 약 4,699배 |\r\n|  테스트 2   | $2.463ms$  |  $5.3us$  | 약 4,648배 |\r\n|  테스트 3   | $2.434ms$  |  $5.5us$  | 약 4,424배 |\r\n|  테스트 4   | $2.536ms$  |  $5.3us$  | 약 4,785배 |\r\n|  테스트 5   | $2.383ms$  |   $5us$   | 약 4,766배 |\r\n|  테스트 6   | $2.509ms$  |  $5.1us$  | 약 4,919배 |\r\n|  테스트 7   | $2.487ms$  |  $5.4us$  | 약 4,605배 |\r\n|  테스트 8   | $2.394ms$  |  $4.5us$  | 약 5,320배 |\r\n|  테스트 9   | $2.666ms$  |  $5.3us$  | 약 5,030배 |\r\n|  테스트 10  | $2.352ms$  |  $5.3us$  | 약 4,438배 |\r\n\r\n<small class=\"red-400\">※ 위 테스트는 CPU i7-10700K, RAM 32GB에서 테스트한 결과물로, 구동 환경에 따라 연산 결과가 달라질 수 있음</small>\r\n\r\n이진검색이 선형검색에 비해 약 5000배 까지도 차이가 남을 확인할 수 있다. 단위가 $ms$, $us$니까 사람 입장에선 그게 그거지만, 기계 입장에선 이진 검색으로 5000번 수행할 동안 선형 검색은 한 번 수행하는 셈이니 실로 어마어마한 차이다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 알고리즘을 적용한 이진 검색을 구현하고 이를 기존의 선형 검색과 비교함으로써 알고리즘의 강력함을 체감할 수 있었다.\r\n\r\n현업에서 일하면서 알고리즘이 강력하다는 건 알고있었지만, 이렇게 간단하게 구현해서 직접 비교해보니 역시나 알고리즘이 중요한 이유를 알 것 같다.\r\n\r\n원래 오늘같이 내일 쉬는 날이면 새벽 네 다섯시까지 공부하긴 하는데, 포스팅 때문에 풀타임으로 집중하다 보니 유난히 더 피곤하다...."},{"title":"자료구조가 중요한 까닭","excerpt":"혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T01:30:56","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-10-about-algorithm-chapter01","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 개요\r\n\r\n혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다.\r\n\r\n마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.\r\n\r\n비전공자가 자료구조같은 기초지식이 항상 아킬레스건이였다. 특히 백준 풀 때 뼈저리게 느끼지만. 이 스터디가 끝나면 자료구조에 대해 기초정도는 알 수 있었음 한다.\r\n\r\n언어는 가급적 <span class=\"orange-400\">JAVA</span>로 진행한다.\r\n\r\n# 1장 자료 구조가 중요한 까닭\r\n\r\n이 장에서는 배열의 기초와 그에 해당하는 연산들에 대한 내용을 소개하면서 사용자에게 배열에 관한 러프한 개념을 설명해준다.\r\n\r\n배열과 <span class=\"primary\">집합</span>이라는 개념에 대한 내용을 기술한다. 저자에 의하면 챕터가 진행될 수록 연산 성능에 대한 점진적인 비교를 한다고 하니, 알고리즘 적용에 따른 성능 향상의 차이를 확인해 볼 수 있을 것이다.\r\n\r\n## 1-1. 배열: 기초 자료 구조\r\n\r\n<span class=\"primary\">배열</span>은 거의 모든 언어에 존재하는 매우 기초적인 자료구조다.\r\n\r\nJAVA에는 `int`, `boolean`과 같은 <span class=\"green-A400\">기본형 타입(Primitive Type)</span>과 `String`, `HashMap`과 같은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>으로 구분된다.\r\n\r\n이와 같은 데이터들은 각각 단일로 사용할 수도 있지만, 다수의 데이터를 동시에 다뤄야하는 경우가 심심치않게 발생한다. 이러한 데이터들이 모여 하나의 배열이 될 수 있다.\r\n\r\n`String` 데이터가 모여 `String[]`이라는 <span class=\"primary\">문자열 배열</span>이 되며, `int` 데이터가 모여 `int[]`라는 <span class=\"primary\">정수 배열</span>이 된다.\r\n\r\nJAVA에서의 배열은 이처럼 특정한 데이터가 여러개 모인 자료 구조이며, 반드시 <span class=\"red-A400\">지정된 데이터만을 요소로 받아들일 수 있다.</span>\r\n\r\n예를 들어, `boolean`은 `true`, `false`로 이루어진 데이터 형식이다. `boolean[]`은 `boolean` 데이터가 여러개 모인 배열이며, 이렇게 선언된 배열은 `boolean`에 해당하는 `true`, `false`만 받아들일 수 있다. 즉, 1이나 \"A\"와 같은 문자열은 배열에 삽입할 수 없다.\r\n\r\n또한 <span class=\"red-A400\">배열은 고정 길이를 가진다.</span> 한 번 할당된 배열의 길이는 재할당되지 않는 이상 절대로 길이가 변경되지 않는다.\r\n\r\n> **⚠잠깐! 이건 어디까지나 JAVA 얘기에요!**  \r\n> 지금 설명하는 배열의 특징은 JAVA에 국한되는 예시다. 당장 JavaScript만 봐도, 배열에 별다른 제약이 존재하지 않는다. 길이는 필요에 따라 증축할 수 있으며, 요소에 아무 데이터 타입이나 할당 가능하다.\r\n\r\nJAVA에서 배열은 <span class=\"green-A400\">참조형 타입(Reference Type)</span>에 해당한다.\r\n\r\n배열에서 수행 가능한 연산에는 4가지가 존재한다.\r\n\r\n* 읽기\r\n* 검색\r\n* 삽입\r\n* 삭제\r\n\r\n위 4가지 연산은 배열의 가장 기초적인 연산이다. 이 4가지 연산을 JAVA로 직접 구현하며 어떤 단계를 거치는지 확인해보자.\r\n\r\n## 1-2 읽기\r\n\r\n<span class=\"primary\">읽기</span>연산은 배열의 특정 인덱스에 어떠한 값이 있는지 읽는 연산이다.\r\n\r\n대부분 모든 언어의 런타임에서 할당되는 데이터들은 메모리에 기록된다. 많은 양의 데이터가 할당될수록 프로그램이 요구하는 메모리, 즉 RAM의 요구사항이 높아진다. 배틀그라운드나, 스타크래프트2와 같은 게임들은 많은 양의 메모리를 요구한다. 그 만큼 기록되고 처리되는 데이터의 양이 매우 방대하기 때문이다.\r\n\r\n데이터가 메모리에 할당될 때, 가용한 임의의 메모리 주소에 저장된다. 해당 메모리 주소에 원하는 값이 존재할 것이므로, 값을 호출하기 위해선 해당 값이 저장된 메모리 주소에 접근하여 값을 조회한다. JAVA를 포함한 대부분의 언어들은 이러한 과정이 개발자에게까지 노출되지 않는 내부의 영역에 존재한다. 이걸 직접 다루는 것이 C언어의 그 악명높은 포인터다.\r\n\r\nJAVA의 메모리는 JVM(Java Virtual Machine, 자바 가상머신)이 관리한다. JVM의 메모리 구조부터 시작하면 한도끝도 없이 브랜치가 뻗어나가니, 핵심만 찝어보자.\r\n\r\n위에서 언급했듯이, 배열은 참조형 타입이며, 이 참조형 타입은 JVM의 Heap 영역에서 관리한다. 메모리를 간략하게 도식화하면 아래와 같이 표현할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111131-7dc1fb80-e120-11eb-8a75-0cf615c9c020.png\" width=\"600px\" />\r\n</p>\r\n\r\n네모 한 칸에 하나의 데이터를 할당할 수 있다고 해보자. 만약 6, 43, 14, 9, 94 5개의 정수로 이루어진 정수형 배열을 메모리에 할당한다고 가정하자. JVM이 해당 배열의 크기를 메모리에 기록할 수 있는지 확인하고, 가능하다면 기록한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111294-b2ce4e00-e120-11eb-8a6e-d5fc241db0ee.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 처럼 메모리 상의 적절한 위치에 배열이 기록될 것이다. 여기서 배열의 4번째 데이터를 읽어보자.\r\n\r\n프로그램은 해당 배열의 주소를 알고있다. 자기가 직접 할당했으니 당연하다. 배열의 주소를 0x0404라고 가정하면 아래와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n0x0404에서 4번째 데이터를 호출하므로 0x0407의 데이터를 조회하면 된다.\r\n\r\n> **😒아니 4번째 데이터라면서요...**  \r\n> 거의 대부분의 컴퓨터 언어는 시작 인덱스를 0으로 지정한다. 그 이유는 메모리에 있는데, 메모리를 기준으로 배열의 첫 번째 데이터는 주소의 이동이 없다.  \r\n> 만약 주소가 0x0101이라면, 첫 번째 데이터는 0x0101이 되기 때문에 주소의 이동이 없으므로 0번째 데이터라고 정의하는 것이다. 이는 관점의 차이로, 초대 프로그램의 언어가 이와 같은 방식을 차용했다. 이후 이를 기반으로 생겨난 수 많은 언어들이 이 영향을 받았다.\r\n\r\n이처럼 배열의 주소에서 해당 인덱스만큼 주소에 더해 데이터를 읽는 것이므로, 동작은 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111156-887c9080-e120-11eb-94db-46545b8a5e9c.png\" width=\"600px\" />\r\n</p>\r\n\r\n주소 0x0404를 시작으로 4번째 데이터인 0x0407인 주소에 접근한다. 배열의 주소와 배열의 인덱스를 알고 있으므로 별도의 연산 없이 바로 접근 가능하다. 이로써 0x0407의 값 9에 접근할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 읽기 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 22:53:39\r\n */\r\npublic class ArrayRead\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 읽을 인덱스\r\n\t\tint index = 4;\r\n\t\t\r\n\t\tint result = read(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(\"4번 째 아이템: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 읽기 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t *\r\n\t * @return [int] 인덱스에 해당하는 값\r\n\t */\r\n\tprivate static int read(int index)\r\n\t{\r\n\t\treturn ARRAY[index];\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 아이템: 9\r\n```\r\n\r\nJAVA 소스는 위와 같다. 배열 `array`을 선언하고, `array[3]`을 호출하면 배열의 4번째 값인 94가 변수 `four`에 할당된다. 목표에 바로 접근하므로 작업에 필요한 단계는 단 하나다.\r\n\r\n## 1-3. 검색\r\n\r\n이처럼 주소의 값이나 인덱스를 정확히 알고 있다면, 별도의 연산 없이 바로 해당하는 값을 갖고올 수 있다. 하지만 실제로 배열을 다루다보면 꼭 이렇게 간단한 케이스만 있지는 않다.\r\n\r\n우리가 구조를 알지 못하는 배열이 있다고 가정할 때, 해당 배열에서 우리가 원하는 값을 찾아야할 경우가 적지않게 발생한다. 이 경우 원하는 값의 인덱스를 가지고 있지도 않으며, 심지어 배열 내부에 원하는 값이 존재하는지조차 알 수 없다. 이 경우 <span class=\"primary\">검색</span>연산을 통해 배열의 값을 찾아야 한다.\r\n\r\n위에서 선언했던 배열을 다시 가져와보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\" />\r\n</p>\r\n\r\n이번엔 우리가 이 배열에 대한 정확한 정보를 가지고있지 않다고 가정해보자. 현재 우리는 이 배열의 어떤 인덱스에 어떤 값이 있는지 전혀 모르는 상태다.\r\n\r\n이 상황에서 14라는 값을 검색해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111164-8a465400-e120-11eb-9432-8c127bfed9b2.png\" width=\"600px\" />\r\n</p>\r\n\r\n검색은 읽기 작업의 반복이라고 봐도 무방하다. 위 그림은 이러한 검색의 특성을 여실히 보여준다. 목표값인 14를 찾기 위해 `array[0]` 부터 순차적으로 읽음으로써 14를 찾는다.\r\n\r\n만약 어떠한 방법으로든 읽기과정을 줄이면서도 정상적인 검색이 가능하다면 소요시간이 효과적으로 감소할 것이다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 검색 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Fri 23:47:03\r\n */\r\npublic class ArrayFind\r\n{\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 목표 숫자\r\n\t\tint target = 14;\r\n\t\t\r\n\t\tint result = find(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"이 포함된 인덱스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n14이 포함된 인덱스: 2\r\n```\r\n\r\n하지만 위는 가장 기초적인 검색 알고리즘을 적용한 것이다. 3번째 요소를 찾기 위해선 3개 과정이 필요하고, 5484번째 요소를 찾기 위해선 5484개 과정이 필요하다.\r\n\r\n그러나, 요소가 맨 끝에 있거나, 불행히도 배열 내에 존재하지 않을 경우 배열 전체를 검색해야할 수도 있다. 즉 배열에 $N$개의 요소가 있다면, 검색의 최대 작업 갯수는 $N$개가 된다.\r\n\r\n## 1-4. 삽입\r\n\r\n배열에 새로운 요소를 넣는 작업을 <span class=\"primary\">삽입</span> 연산이라 한다. 배열에서 55를 삽입하는 과정을 통해 삽입 연산에 대해 알아보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111179-8d414480-e120-11eb-9c36-965d4506fd8c.png\" width=\"600px\" />\r\n</p>\r\n\r\n런타임 시 배열을 할당했다면 우리는 배열의 주소를 알고 있을 것이다. 배열의 맨 끝에 요소를 추가한다면 그냥 이어붙이면 된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111188-8fa39e80-e120-11eb-8576-aee6d30ae3a7.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간에 삽입한다면 이야기가 조금 달라진다. 삽입하려는 위치 이후의 요소를 한 칸씩 뒤로 미루고, 해당 위치에 값을 삽입하게 된다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치에 요소를 삽입한다면 모든 배열의 요소를 한 칸씩 뒤로 미룬뒤 55를 삽입해야한다. 즉, 배열에 $N$개의 요소가 있을 경우 삽입에 필요한 작업량은 $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $N + 1$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:27:47\r\n */\r\npublic class ArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tinsert(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 요소에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 요소에 55 삽입: [6, 43, 55, 14, 9, 94, -1, -1, -1, -1]\r\n```\r\n\r\n삽입 소스는 위와 같다.\r\n\r\n> **@SuppressWarnings는 뭔가요?**  \r\n> Eclipse, IntelliJ와 같은 IDE는 코드를 분석하는 과정에서 오류 또는 경고를 개발자에게 알려줌으로써 잠재적 위험을 제거할 수 있도록 유도한다. 간혹 의도된 동작임에도, IDE의 최적화 설정과 맞지 않아 경고를 띄우기도 한다. 이 경우 @SuppressWarnings 애노테이션을 쓰면 해당 경고를 무시할 수 있다. @@SuppressWarnings를 지워도 소스 동작엔 아무런 문제가 없다.\r\n\r\n위에서도 언급했지만, JAVA의 배열은 고정길이를 가진다. 삽입 연산을 하기 위해선 필연적으로 현재 배열의 크기보다 하나 이상 커야하므로, 이전과 달이 총 길이가 10인 배열을 선언했다. 배열의 요소가 -1일 경우, 해당 요소는 아직 할당되지 않은 빈 요소로 간주한다.\r\n\r\n> **가변 길이를 가지는 List**  \r\n> JAVA에서도 얼마든지 가변길이 배열이 필요한 경우가 생긴다. 이 경우 `ArrayList`와 같은 `List` 데이터를 활용하면 된다. `List`는 가변길이를 가짐으로써 비정형화된 배열 데이터를 다루는데 유리하다.\r\n\r\n배열의 가장 끝 요소부터 삽입하려는 인덱스 이전까지 순차적으로 내려오며 현재 요소의 값을 이전 요소의 값으로 할당하여 요소를 이동시킨다. 이후 삽입하려는 인덱스에 요소를 할당함으로써 삽입이 완료된다.\r\n\r\n## 1-5. 삭제\r\n\r\n삽입을 했으니, 반대로 <span class=\"primary\">삭제</span>도 필요할 수 있다. 삭제 연산은 원하는 인덱스의 요소를 삭제하는 것이다. 간단히 말하자면, 삽입과 정 반대의 프로세스를 가진다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111198-93372580-e120-11eb-9949-aa21aef11dfa.png\" width=\"600px\" />\r\n</p>\r\n\r\n마찬가지로, 배열의 맨 끝에 요소를 삭제한다면 그냥 끝의 요소를 삭제하면 그만이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111204-9500e900-e120-11eb-8c44-c45faeb459fd.png\" width=\"600px\" />\r\n</p>\r\n\r\n하지만 배열의 중간을 삭제한다면 동일한 작업이 필요하다. 삭제하려는 위치의 요소를 삭제하고, 요소를 한 칸씩 당겨야 한다.\r\n\r\n최악의 경우, 배열의 가장 첫 인덱스인 0의 위치의 요소를 삭제한다면 해당 요소를 삭제한 뒤 모든 배열의 요소를 한 칸씩 앞으로 당길 것이다. 즉, 배열에 $N$개의 요소가 있을 경우 삭제에 필요한 작업량은 해당 인덱스의 요소를 삭제하는 작업 1개, $N - 1$개의 요소를 하나씩 이동하는 작업 $N - 1$개로 최대 $N$의 작업량이 발생할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 삭제 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.09 Sat 00:59:02\r\n */\r\npublic class ArrayDelete\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삭제할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\tremove(index);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번째 요소 삭제 \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삭제 함수\r\n\t *\r\n\t * @param index: [int] 삭제 위치\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void remove(int index)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = index; i < ARRAY.length - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i + 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tARRAY[ARRAY.length - 1] = -1;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번째 요소 삭제 [6, 43, 9, 94, -1, -1, -1, -1, -1, -1]\r\n```\r\n\r\n삭제 소스는 위와 같다.\r\n\r\n삭제는 삽입과 달리 배열의 크기가 증가할 필요가 없다. 마찬가지로 배열의 요소가 -1일 경우, 해당 요소는 삭제된 빈 요소로 간주한다.\r\n\r\n삽입과는 반대로, 삭제하려는 인덱스부터 배열의 끝까지 순차적으로 올라가며 현재 요소의 값을 이후 요소의 값으로 할당하여 요소를 이동시킨다. 이후 배열의 끝 요소를 제거함으로써 삭제가 완료된다.\r\n\r\n## 1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다\r\n\r\n배열의 경우 요소의 타입만 맞다면 별다른 신경을 쓰지 않는다. 이말인즉슨, 중복되는 요소에 대한 처리도 이루어지지 않는다. 하지만 종종 중복되는 값을 허용하지 않는 배열의 필요성이 생기기도 한다. 책에서는 이를 <span class=\"primary\">집합</span>이라는 개념으로 설명한다.\r\n\r\n배열에 요소를 삽입할 때, 중복여부를 확인하기 위해선 검색 작업이 선행되어야 한다. 검색을 통해 집합에 해당 요소가 없는 것이 확인될 경우에만 삽입이 이루어지는 방식이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111212-97634300-e120-11eb-8d2e-c024761e23ff.png\" width=\"600px\" />\r\n</p>\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125111220-992d0680-e120-11eb-97a2-3e1e8eda7518.png\" width=\"600px\" />\r\n</p>\r\n\r\n위의 두 그림은 집합 개념이 적용된 배열에서 존재하지 않는 값 55와, 존재하는 값 14를 삽입했을 때 나타나는 결과를 도식화한 것이다.\r\n\r\n55의 경우 기존에 존재하지 않았으므로 삽입이 가능하지만, 14의 경우 이미 2번 째 인덱스에 동일한 값이 있으므로 삽입이 불가능하다.\r\n\r\n검증이 완료된 이후의 삽입 과정은 기존의 삽입 과정과 동일하다. 단, 작업량은 달라진다. 기존의 삽입 작업량에서 검색의 작업량이 추가되기 때문이다.\r\n\r\n가장 최악의 케이스는 중복되지 않는 임의의 값을 배열의 0번 째 인덱스에 삽입하는 것이다. $N$개의 요소를 가진 배열에서 $N$개 요소를 검색하는 작업량 $N$개, $N$개의 요소를 하나씩 이동하는 작업 $N$개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 $2N + 1$개의 작업량이 발생한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 집합 배열 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\">자료구조가 중요한 까닭</a>\r\n * @since 2021.07.10 Sat 01:30:56\r\n */\r\npublic class UniqueArray\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 43, 14, 9, 94 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 인덱스\r\n\t\tint index = 2;\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tboolean result = hasInserted(index, item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(index);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입 결과: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [boolean] 삽입 결과\r\n\t */\r\n\tprivate static boolean hasInserted(int index, int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\t// 중복되지 않을 경우\r\n\t\tif (result == -1)\r\n\t\t{\r\n\t\t\tinsert(index, item);\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 중복될 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i < ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i > index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n2번 째 인덱스에 55 삽입 결과: true\r\n```\r\n\r\n집합 배열의 삽입 소스는 위와 같다.\r\n\r\n`find`와 `insert` 함수는 검색과 삽입 파트에서 사용한 로직과 동일한 로직이다. 집합 배열은 반드시 고유한 요소만을 삽입해야 하므로, `hasInserted` 함수를 구성하여 중복 여부를 검증한 뒤 삽입을 진행한다.\r\n\r\n`find` 함수는 검색되는 요소가 없을 경우 -1을 반환한다. 즉, -1을 반환하는 숫자는 고유한 숫자다. `find`가 -1을 반환할 경우 `insert` 함수로 삽입을 진행한다.\r\n\r\n> **Set 객체는 중복을 허용하지 않아요**  \r\n> JAVA의 배열은 기본적으로 요소의 중복같은건 신경쓰지 않는다. 때문에, 요소의 중복을 감지하기 위해선 별도의 검증 로직을 구성해야한다.  \r\n> 하지만 `HashSet`과 같은 `Set` 객체를 활용하면 항상 고유한 값만 삽입할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 최대한 개념 위주로 설명하며, 설명에 어떠한 알고리즘 지식이 들어가지 않은 것으로 보인다. 이러한 저자의 의도를 최대한 반영하여, 내 로직 역시 가능한 기본 데이터 타입을 사용했으며, 복잡한 로직을 최대한 지양했다. 철저히 연산이 동작하는 기본 원리에 입각하도록 소스를 구성했다.\r\n\r\n다음 장에서는 알고리즘에 대한 본격적인 내용이 기술될 것이다."}],"post":{"title":"빅 오로 코드 속도 올리기","excerpt":"이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-16T21:39:54","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","버블 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-16-about-algorithm-chapter04","content":"<nav class=\"toc-wrap\"><ol class=\"toc-level toc-level-1\"><li class=\"toc-item toc-item-h1\"><a class=\"toc-link toc-link-h1\" href=\"#4장-빅-오로-코드-속도-올리기\">4장 빅 오로 코드 속도 올리기</a><ol class=\"toc-level toc-level-2\"><li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#41-버블-정렬\">4.1 버블 정렬</a></li><li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#4-2-버블-정렬-실제로-해보기\">4-2. 버블 정렬 실제로 해보기</a></li><li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#4-3-버블-정렬-구현\">4-3. 버블 정렬 구현</a></li><li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#4-4-버블-정렬의-효율성\">4-4. 버블 정렬의 효율성</a></li><li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#4-5-이차-문제\">4-5. 이차 문제</a></li><li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#4-6-선형-해결법\">4-6. 선형 해결법</a></li></ol></li><li class=\"toc-item toc-item-h1\"><a class=\"toc-link toc-link-h1\" href=\"#마무리\">마무리</a></li></ol></nav><p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\n<h1 id=\"4장-빅-오로-코드-속도-올리기\"><a class=\"head-link\" href=\"#4장-빅-오로-코드-속도-올리기\"><span>🔗</span></a>4장 빅 오로 코드 속도 올리기</h1>\n<p>이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.</p>\n<h2 id=\"41-버블-정렬\"><a class=\"head-link\" href=\"#41-버블-정렬\"><span>🔗</span></a>4.1 버블 정렬</h2>\n<p>배열을 효과적으로 다루기 위해 <span class=\"primary\">정렬</span> 기법이 폭넓게 이용된다. <span class=\"orange-A400\">이진 검색</span>에서도 겪었듯이, 정렬된 배열은 배열의 요소를 어느정도 <strong>예측</strong>할 수 있도록 규칙성을 부여한다. 이러한 이유로 배열을 정렬하는 다양한 기법이 고안되었으며, 이 문단에서는 정렬 중 가장 기본적이면서 상대적으로 비효율적인 <span class=\"orange-A400\">버블 정렬</span>에 대해 알아본다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947608-e434441d-f735-44d6-8634-32431c152333.png\" width=\"600px\">\n</p>\n<p>위와 같은 배열이 존재할 때, 버블 정렬은 이를 어떻게 오름차순으로 정렬하는 지 알아보자.</p>\n<ol>\n<li>우선 맨 첫 요소와 그 다음 요소를 비교한다.</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\">\n</p>\n<ol start=\"2\">\n<li>앞의 요소가 뒤의 요소보다 클 경우 서로 교환(swap)한다.</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\">\n</p>\n<ol start=\"3\">\n<li>각각 한 칸씩 이동하여 다음 요소를 비교한다.</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\">\n</p>\n<ol start=\"4\">\n<li>1 ~ 3의 과정을 반복한다.</li>\n</ol>\n<p>더 이상 교환이 이루어지지 않을 때까지 1 ~ 3의 과정을 반복한다. 이러한 반복을 <span class=\"primary\">패스스루(passthrough)</span>라 명칭한다.</p>\n<h2 id=\"4-2-버블-정렬-실제로-해보기\"><a class=\"head-link\" href=\"#4-2-버블-정렬-실제로-해보기\"><span>🔗</span></a>4-2. 버블 정렬 실제로 해보기</h2>\n<p>이전 문단에서 <span class=\"orange-A400\">버블 정렬</span>의 원리를 알았으니 실제로 적용하여 배열을 완전히 정렬해보자.</p>\n<p>대상 배열은 이전 문단에서 사용된 배열과 동일하다.</p>\n<ol>\n<li>패스스루 1: 8과 4 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\">\n</p>\n<p>8과 4를 비교한다. 앞의 요소가 더 크므로, 스왑한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\">\n</p>\n<ol start=\"2\">\n<li>패스스루 1: 8과 6 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\">\n</p>\n<p>8과 6을 비교한다. 앞의 요소가 더 크므로, 스왑한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947635-b30df0e3-2b2b-4bee-b727-8bf070c82c73.png\" width=\"600px\">\n</p>\n<ol start=\"3\">\n<li>패스스루 1: 8과 7 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947646-ce35e2d1-0428-4e84-b8da-c2b17a13485c.png\" width=\"600px\">\n</p>\n<p>8과 7을 비교한다. 앞의 요소가 더 크므로, 스왑한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947652-f53b26ef-f291-4c64-9719-e4886aff91b6.png\" width=\"600px\">\n</p>\n<ol start=\"4\">\n<li>패스스루 1: 8과 3 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947657-a374227c-855e-4b88-aba0-a8eb9ee881ca.png\" width=\"600px\">\n</p>\n<p>8과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947666-5574d74d-9d9a-4ff3-b145-9e9b341df0c3.png\" width=\"600px\">\n</p>\n<p>가장 마지막 배열의 요소까지 도달했으므로, 가장 마지막 요소인 8은 올바른 위치에 정렬되어 있다. 오름차순에서 배열의 가장 마지막 요소에는 가장 큰 값이 와야하므로, 배열의 요소 중 가장 큰 값인 8이 오는 것이 적절하다.</p>\n<p>이미 정렬되어있으므로, 다음 패스스루에선 마지막 요소는 비교하지 않아도 된다. 즉, <span class=\"teal-400\">패스스루가 진행될 수록 비교할 요소의 범위가 작아진다.</span></p>\n<p>정렬이 완료된 요소는 <span class=\"yellow-400\">노란색</span>으로 표시한다.</p>\n<ol start=\"5\">\n<li>패스스루 2: 4와 6 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947681-5b8ec91b-9da1-41da-9906-6d9e99c4fdd8.png\" width=\"600px\">\n</p>\n<p>4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.</p>\n<ol start=\"6\">\n<li>패스스루 2: 6과 7 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947698-af6eae59-b9e5-4075-a7e5-e433c8888a6b.png\" width=\"600px\">\n</p>\n<p>6과 7을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.</p>\n<ol start=\"7\">\n<li>패스스루 2: 7과 3 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947709-19eefa54-e834-41cc-9ba2-f57d23424e9c.png\" width=\"600px\">\n</p>\n<p>7과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947720-2fca7b88-3f84-422b-af78-77e57779270f.png\" width=\"600px\">\n</p>\n<p>요소 7이 완전히 정렬됐다. 다음 패스스루를 시작한다.</p>\n<ol start=\"8\">\n<li>패스스루 3: 4와 6 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947722-d73f88f3-3c12-4c19-9c85-0feb6bd4b3a9.png\" width=\"600px\">\n</p>\n<p>4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.</p>\n<ol start=\"9\">\n<li>패스스루 3: 6과 3 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947729-b420b29e-3c9b-42c2-8fe2-88d509da6b91.png\" width=\"600px\">\n</p>\n<p>6과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947744-2d71db3b-e35b-457f-ba35-84d05e2a6088.png\" width=\"600px\">\n</p>\n<p>요소 6이 완전히 정렬됐다. 다음 패스스루를 시작한다.</p>\n<ol start=\"10\">\n<li>패스스루 4: 4와 3 비교</li>\n</ol>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947755-4833cd65-a86e-48c7-8413-d5e8df9c624c.png\" width=\"600px\">\n</p>\n<p>4와 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947767-d8163c94-8fbc-43ec-9b17-5567b9714eb5.png\" width=\"600px\">\n</p>\n<p>가장 마지막 패스스루이므로, 모든 요소가 정렬됐다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947774-a376dc47-0102-4ff1-8b08-d65cb8175cf0.png\" width=\"600px\">\n</p>\n<p>정렬된 배열은 위와 같으며, 총 10번의 작업이 이루어졌다.</p>\n<h2 id=\"4-3-버블-정렬-구현\"><a class=\"head-link\" href=\"#4-3-버블-정렬-구현\"><span>🔗</span></a>4-3. 버블 정렬 구현</h2>\n<p><span class=\"orange-A400\">버블 정렬</span>을 직접 코드로 구현해보자.</p>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">OutputStreamWriter</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 누구나 자료 구조와 알고리즘 버블 정렬 클래스\n *\n * <span class=\"token keyword\">@author</span> RWB\n * <span class=\"token keyword\">@see</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&#x3C;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>빅 오로 코드 속도 올리기<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&#x3C;/</span>a</span><span class=\"token punctuation\">></span></span>\n * <span class=\"token keyword\">@since</span> 2021.07.16 Fri 19:11:19\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BubbleSort</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// 배열</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token doc-comment comment\">/**\n\t * 메인 함수\n\t *\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">args</span>: [String[]] 매개변수\n\t *\n\t * <span class=\"token keyword\">@throws</span> <span class=\"token reference\"><span class=\"token class-name\">IOException</span></span> 데이터 입출력 예외\n\t */</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">BufferedReader</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">BufferedWriter</span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OutputStreamWriter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"버블 정렬할 정수 배열을 띄어쓰기로 구분하여 입력 >> \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\tarray <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">mapToInt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token operator\">::</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> count <span class=\"token operator\">=</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" - 비교 작업량: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" - 스왑 작업량: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" - 총 작업량: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\treader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token doc-comment comment\">/**\n\t * 버블 정렬 및 작업량 반환 함수\n\t *\n\t * <span class=\"token keyword\">@return</span> [int[]] 비교 작업량과 스왑 작업량\n\t */</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 비교 작업량</span>\n\t\t<span class=\"token keyword\">int</span> compareCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 스왑 작업량</span>\n\t\t<span class=\"token keyword\">int</span> swapCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 스왑 여부</span>\n\t\t<span class=\"token keyword\">boolean</span> isSwaped <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 비교 인덱스</span>\n\t\t<span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 스왑이 일어나지 않을 때까지</span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>isSwaped<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\tisSwaped <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\tcompareCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\t<span class=\"token comment\">// 현재 요소가 다음 요소보다 클 경우</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> array<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t\t<span class=\"token comment\">// 스왑 발생</span>\n\t\t\t\t\tisSwaped <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\tswapCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t\n\t\t\t\t\t<span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t\n\t\t\t\t\tarray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\tarray<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\n\t\t\tindex<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span> compareCount<span class=\"token punctuation\">,</span> swapCount <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>위 소스는 사용자로부터 공백으로 구분된 숫자를 입력받아 버블 정렬을 수행하는 알고리즘이다.</p>\n<ul>\n<li>입력</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-tc\"><code class=\"language-tc\">5 4 12 6 77 32 1 9 11 59</code></pre></div>\n<ul>\n<li>출력</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-tc\"><code class=\"language-tc\">[1, 4, 5, 6, 9, 11, 12, 32, 59, 77]\r\n\r\n - 읽기 작업량: 42\r\n - 스왑 작업량: 16\r\n - 총 작업량: 58</code></pre></div>\n<p>실제 버블 정렬이 수행되는 알고리즘은 아래와 같다.</p>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token doc-comment comment\">/**\n * 버블 정렬 및 작업량 반환 함수\n *\n * <span class=\"token keyword\">@return</span> [int[]] 비교 작업량과 스왑 작업량\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// 비교 작업량</span>\n\t<span class=\"token keyword\">int</span> compareCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\">// 스왑 작업량</span>\n\t<span class=\"token keyword\">int</span> swapCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\">// 스왑 여부</span>\n\t<span class=\"token keyword\">boolean</span> isSwaped <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\">// 비교 인덱스</span>\n\t<span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\">// 스왑이 일어나지 않을 때까지</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>isSwaped<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\tisSwaped <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\tcompareCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 현재 요소가 다음 요소보다 클 경우</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> array<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token comment\">// 스왑 발생</span>\n\t\t\t\tisSwaped <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t\t\tswapCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\t<span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\tarray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\tarray<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\tindex<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span> compareCount<span class=\"token punctuation\">,</span> swapCount <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<ul>\n<li><code>compareCount</code>: 비겨 작업량 카운트</li>\n<li><code>swapCount</code>: 스왑 작업량 카운트</li>\n<li><code>isSwaped</code>: 스왑 여부</li>\n<li><code>index</code>: 정렬 인덱스</li>\n</ul>\n<p><code>index</code>는 정렬을 하기위한 배열의 최대 인덱스다. 1을 빼주는 이유는 버블 정렬의 특성 때문이다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1, 2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span></span>와 같은 배열의 최대 인덱스는 3이다. 배열의 최대 인덱스가 3일 때 첫 패스스루의 작업 갯수는 0과 1, 1과 2로 2번 일어난다. 최대 인덱스를 하나 빼주지 않으면 0과 1, 1과 2, 2와 무엇인가를 비교하려 하기 때문에 배열 초과 예외인 <code>ArrayIndexOutOfBoundsException</code>가 발생한다.</p>\n<p><code>while</code>문을 통해 스왑이 일어나지 않을 때까지 반복한다. <span class=\"pink-A400\">패스스루 내에서 스왑이 한 번도 일어나지 않으면 정렬이 완료</span>된 것으로 간주하여 종료한다.</p>\n<p><code>for</code>문을 통해 인덱스 크기까지 비교하여 현재 배열보다 다음 배열이 더 클 경우 스왑한다. 이 과정에서 <code>isSwaped</code>이 <code>true</code>로 할당된다. <code>isSwaped</code>가 <code>true</code>이므로 다음 프로세스가 패스스루가 진행될 것이다.</p>\n<p>해당하는 각 과정은 카운팅된다.</p>\n<h2 id=\"4-4-버블-정렬의-효율성\"><a class=\"head-link\" href=\"#4-4-버블-정렬의-효율성\"><span>🔗</span></a>4-4. 버블 정렬의 효율성</h2>\n<p>버블 정렬은 두 가지 작업으로 이루어진다.</p>\n<ul>\n<li><strong>비교</strong>: 더 큰 수를 찾기위해 비교한다.</li>\n<li><strong>교환</strong>: 정렬하기 위해 스왑한다.</li>\n</ul>\n<p>요소 5개가 있을 때, 아래와 같은 <span class=\"blue-400\">비교</span>작업이 이루어진다.</p>\n<ul>\n<li>패스스루 1: 총 4번의 비교</li>\n<li>패스스루 2: 총 3번의 비교</li>\n<li>패스스루 3: 총 2번의 비교</li>\n<li>패스스루 4: 총 1번의 비교</li>\n<li>패스스루 5: 비교 없음 (정렬 완료)</li>\n</ul>\n<p>즉, 4 + 3 + 2 + 1로 총 10번의 비교가 일어난다.</p>\n<p>그렇다면 <span class=\"blue-400\">스왑</span>작업은 어떨까? 스왑은 상황에 따라 일어날 수도, 일어나지 않을 수도 있다.</p>\n<p>이전 장에서 <span class=\"red-400\">알고리즘은 언제나 비관적인 관점</span>으로 접근한다고 했으니, 스왑이 언제나 일어날 경우를 가정하자.</p>\n<blockquote>\n<p>가장 최악의 버블 정렬 케이스<br>\n버블 정렬은 하나의 요소와 다음 요소를 비교하여 정렬하는 알고리즘이다. 만약 오름차순으로 정렬할 경우, 내림차순으로 정렬된 배열을 입력할 때 가장 최악의 케이스가 된다. 이 경우 모든 요소에 비교와 스왑이 일어난다.</p>\n</blockquote>\n<p>최악의 케이스인 내림차순으로 정렬된 요소 5개가 있을 때, 아래와 같은 <span class=\"blue-400\">스왑</span>작업이 이루어진다.</p>\n<ul>\n<li>패스스루 1: 총 4번의 스왑</li>\n<li>패스스루 2: 총 3번의 스왑</li>\n<li>패스스루 3: 총 2번의 스왑</li>\n<li>패스스루 4: 총 1번의 스왑</li>\n<li>패스스루 5: 스왑 없음 (정렬 완료)</li>\n</ul>\n<p>비교와 동일한 작업량이 발생한다. 이를 표로 정리하면 아래와 같다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th align=\"center\"><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></th><th align=\"center\">작업 수</th><th align=\"center\"><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">N^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></th></tr></thead><tbody><tr><td align=\"center\">5</td><td align=\"center\">20</td><td align=\"center\">25</td></tr><tr><td align=\"center\">10</td><td align=\"center\">90</td><td align=\"center\">100</td></tr><tr><td align=\"center\">20</td><td align=\"center\">380</td><td align=\"center\">400</td></tr><tr><td align=\"center\">40</td><td align=\"center\">1560</td><td align=\"center\">1600</td></tr><tr><td align=\"center\">80</td><td align=\"center\">6320</td><td align=\"center\">6400</td></tr><tr><td align=\"center\">100</td><td align=\"center\">9900</td><td align=\"center\">10000</td></tr></tbody></table>\n<p>요소 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>개 배열에서 버블 정렬의 최대 작업량은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">N(N - 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>이다. 이전 장에서도 언급했 듯이, 알고리즘은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>−</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2 - N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>과 크게 차이를 두지 않는다. 즉, 버블 정렬의 시간 복잡도는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>가 된다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> 보다도 작업량이 급격히 증가한다.</p>\n<p align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/50317129/125947786-fb410c06-799f-4041-8827-9a946a8d076e.png\" width=\"600px\">\n</p>\n<p>이를 비교하면 더욱 한눈에 알 수 있다. 이 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>을 <span class=\"orange-A400\">이차 시간</span>이라고 명칭한다.</p>\n<h2 id=\"4-5-이차-문제\"><a class=\"head-link\" href=\"#4-5-이차-문제\"><span>🔗</span></a>4-5. 이차 문제</h2>\n<p>위에서 버블 정렬에 대한 알고리즘을 설계했다. 시간 복잡도는 무려 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>을 가진다. 이전 장에서 선형 검색과 이진 검색을 비교하며 최대한 시간 복잡도를 줄이는게 좋다고 손아프게 적은게 무색할 정도로, 이 알고리즘의 효율은 지면을 뜷고 추락하고있다.</p>\n<p>여기 비슷한 이차 시간 알고리즘이 있다. 입력한 요소의 중복 여부를 판별하는 알고리즘이다.</p>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">OutputStreamWriter</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 누구나 자료 구조와 알고리즘 중복 확인 클래스\n *\n * <span class=\"token keyword\">@author</span> RWB\n * <span class=\"token keyword\">@see</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&#x3C;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>빅 오로 코드 속도 올리기<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&#x3C;/</span>a</span><span class=\"token punctuation\">></span></span>\n * <span class=\"token keyword\">@since</span> 2021.07.16 Fri 20:46:15\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DuplicateCheck</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token doc-comment comment\">/**\n\t * 메인 함수\n\t *\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">args</span>: [String[]] 매개변수\n\t *\n\t * <span class=\"token keyword\">@throws</span> <span class=\"token reference\"><span class=\"token class-name\">IOException</span></span> 데이터 입출력 예외\n\t */</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">BufferedReader</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">BufferedWriter</span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OutputStreamWriter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 배열</span>\n\t\t<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">mapToInt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token operator\">::</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">boolean</span> result <span class=\"token operator\">=</span> <span class=\"token function\">isDuplicated</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 중복된 요소가 있을 경우</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"중복된 요소가 존재합니다.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token comment\">// 없을 경우</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"중복된 요소가 존재하지 않습니다.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"작업량: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\treader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token doc-comment comment\">/**\n\t * 요소의 중복 여부 반환 함수\n\t *\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">array</span>: [int[]] 배열\n\t *\n\t * <span class=\"token keyword\">@return</span> [boolean] 중복 여부\n\t */</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isDuplicated</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&#x3C;</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\tcount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\t<span class=\"token comment\">// 서로 다른 요소가 동일한 값을 가질 경우</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> j <span class=\"token operator\">&#x26;&#x26;</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>소스는 위와 같다.</p>\n<ul>\n<li>입력</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">6</span> <span class=\"token number\">7</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span>\n</code></pre></div>\n<ul>\n<li>출력</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\">중복된 요소가 존재하지 않습니다<span class=\"token punctuation\">.</span>\n작업량<span class=\"token operator\">:</span> <span class=\"token number\">100</span>\n</code></pre></div>\n<p>위 알고리즘도 마찬가지로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">N = 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">10</span></span></span></span></span>일 때 최악의 경우 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>의 시간 복잡도를 가진다.</p>\n<p>중복을 판별하는 핵심 동작을 보자.</p>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token doc-comment comment\">/**\n * 요소의 중복 여부 반환 함수\n *\n * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">array</span>: [int[]] 배열\n *\n * <span class=\"token keyword\">@return</span> [boolean] 중복 여부\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isDuplicated</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&#x3C;</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\tcount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 서로 다른 요소가 동일한 값을 가질 경우</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> j <span class=\"token operator\">&#x26;&#x26;</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>버블 정렬과 마찬가지로 중첩 반복문이 존재한다. 중첩 반복문이 있을 경우, 반복문의 갯수만큼 시간 복잡도가 급격히 올라간다.</p>\n<p>중첩 반복문은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>개의 요소를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>번 만큼 작업한다. 반복문의 중첩이 심해지면 심해질 수록 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>번의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>번의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>번의... 와 같은 작업을 반복할 것이다. 물론 시간 복잡도의 크기가 하늘 높은줄 모르고 치솟는 것도 포함된다.</p>\n<p>즉, 어디가서 중첩 반복문을 사용하는 알고리즘을 봤다면 그 알고리즘의 시간 복잡도는 최소 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>임을 바로 유추할 수 있다.</p>\n<h2 id=\"4-6-선형-해결법\"><a class=\"head-link\" href=\"#4-6-선형-해결법\"><span>🔗</span></a>4-6. 선형 해결법</h2>\n<p>이전 장에서, 선형 검색과 이진 검색의 시간복잡도를 비교하며 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>이 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>보다 얼마나 비효율적인지 손가락이 아플 정도로 설명했던 걸로 기억한다. 그런데 방금의 두 알고리즘은 아픈 손가락이 무색해질 정도로 미칠듯한 비효율을 선사하고 있다.</p>\n<p><i align=\"center\">아니, 니가 알고리즘을 많이 안 짜봐서 그런가본데, 그렇게 설계할 수 밖에 없는 알고리즘도 있거든??</i></p>\n<p>물론 맞는 말이다. 백준만 해도 로직이 복잡해서 중첩 반복문을 사용하기도 한다. 실무에서도 마찬가지다. 로직이 복잡하거나, 소스 최적화의 비용이 너무 높거나 혹은 효율이 극악이거나. 아니면 컴퓨터 성능이 충분히 좋아서 굳이 그렇게 머리 아픈일에 투자할 필요를 못 느낄 수도 있다.</p>\n<p>여담으로, 실제로 큰 기업은 이런 최적화 보다도 컴퓨팅 성능을 극대화시키는 방법을 많이 선택한다고 한다. 로직이야 어차피 한정적으로 적용되고, 차라리 컴퓨터 성능을 올리는게 오히려 싸게 먹히기도 한다. 로직과 달리 컴퓨팅 자원은 다른 곳에 써먹을 수도 있으니 이쪽이 더 범용적이다.</p>\n<p>필자의 컴퓨터도 작성일 기준으로 그리 못난 편은 아니지만, 안타깝게도 위에 작성한 중복 판별 알고리즘은 최적화의 비용이 매우 저렴한 편이다. 우리는 공부를 목적으로 하니 한 번 최적화해보자.</p>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">OutputStreamWriter</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ArrayList</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token doc-comment comment\">/**\n * 누구나 자료 구조와 알고리즘 향상된 중복 확인 클래스\n *\n * <span class=\"token keyword\">@author</span> RWB\n * <span class=\"token keyword\">@see</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&#x3C;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>빅 오로 코드 속도 올리기<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&#x3C;/</span>a</span><span class=\"token punctuation\">></span></span>\n * <span class=\"token keyword\">@since</span> 2021.07.16 Fri 21:18:05\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ImproveDuplicateCheck</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token doc-comment comment\">/**\n\t * 메인 함수\n\t *\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">args</span>: [String[]] 매개변수\n\t *\n\t * <span class=\"token keyword\">@throws</span> <span class=\"token reference\"><span class=\"token class-name\">IOException</span></span> 데이터 입출력 예외\n\t */</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">BufferedReader</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">BufferedWriter</span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OutputStreamWriter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 >> \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 배열</span>\n\t\t<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">mapToInt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token operator\">::</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">boolean</span> result <span class=\"token operator\">=</span> <span class=\"token function\">isDuplicated</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token comment\">// 중복된 요소가 있을 경우</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"중복된 요소가 존재합니다.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token comment\">// 없을 경우</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"중복된 요소가 존재하지 않습니다.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"작업량: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\twriter<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\treader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token doc-comment comment\">/**\n\t * 요소의 중복 여부 반환 함수\n\t *\n\t * <span class=\"token keyword\">@param</span> <span class=\"token parameter\">array</span>: [int[]] 배열\n\t *\n\t * <span class=\"token keyword\">@return</span> [boolean] 중복 여부\n\t */</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isDuplicated</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> item <span class=\"token operator\">:</span> array<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\tcount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 중복되지 않았을 경우</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\tlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\n\t\t\t<span class=\"token comment\">// 중복된 경우</span>\n\t\t\t<span class=\"token keyword\">else</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>소스는 위와 같다.</p>\n<ul>\n<li>입력</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">6</span> <span class=\"token number\">7</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span>\n</code></pre></div>\n<ul>\n<li>출력</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-java\"><code class=\"language-java\">중복된 요소가 존재하지 않습니다<span class=\"token punctuation\">.</span>\n작업량<span class=\"token operator\">:</span> <span class=\"token number\">10</span>\n</code></pre></div>\n<p>JAVA의 가변 배열 <code>ArrayList</code> 클래스를 활용하여 구현했다. 요소가 한 번도 나오지 않았을 경우, <code>list</code>에 존재하지 않을 것이므로 넣어준다. 이후 동작 중에 이미 <code>list</code>에 존재하는 숫자가 발견될 경우, 중복된 요소이므로 종료하고 결과를 반환한다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">N = 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">10</span></span></span></span></span>일 때 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>의 시간 복잡도로 대폭 개선됨을 확인할 수 있다. 이전의 결과와 비교하면 무려 <span class=\"lightBlue-A400\">10배의 차이</span>로, 산술적으로 이전 알고리즘이 1번 동작할 동안 개선된 알고리즘은 10번 동작할 수 있다.</p>\n<p>지금은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">N = 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">10</span></span></span></span></span>으로 요소 자체가 작아서 체감이 되지 않을 수도 있지만, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>000</mn></mrow><annotation encoding=\"application/x-tex\">N = 10,000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">10</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">000</span></span></span></span></span>일 경우 무려 <span class=\"lightBlue-A400\">10,000배의 차이</span>가 발생한다.</p>\n<p>알고리즘의 최적화가 중요한 이유가 여기에 있다. 처리하는 데이터가 빅데이터에 가까워질수록 그 효율이 미친듯이 상승하기 때문.</p>\n<h1 id=\"마무리\"><a class=\"head-link\" href=\"#마무리\"><span>🔗</span></a>마무리</h1>\n<p>이 장에서 배운 점을 정리하면 아래와 같다.</p>\n<ul>\n<li>반복문의 중첩 여부, 갯수를 통해 시간 복잡도를 유추할 수 있다.</li>\n<li>시간 복잡도를 통해 알고리즘의 성능 향상을 수치상으로 비교, 표시할 수 있다.</li>\n</ul>\n<p>사실 정리해놓고 보니 뭐 별 거 아닌, 당연한 얘기를 가지고 광활하게 설명했나 싶기도 하다. 난 이 당연한 걸 제대로 몰랐던 거고.</p>\n<p>이런 알고리즘도 있다. 속도가 비슷해서 빅 오 표기로는 그 차이가 보이지 않을 경우. 하지만 그럼에도 확실히 어떠한 요인으로든 차이가 발생할 것이다. 다음 장에서는 이러한 알고리즘에 대한 최적화에 대해 알아본다.</p>"}},"__N_SSG":true}