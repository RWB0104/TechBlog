{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 의존성 역전 원칙 (Dependency Inversion Principle)","excerpt":"의존성 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다. 말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가? 고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, 객체는 객체보다 인터페이스에 의존해야한다로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-17T03:06:35","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-17-dependency-inversion-principle.md","content":"\r\n# 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n<span class=\"orange-400\">의존성 역전 원칙</span>이란 <span class=\"red-600\">객체는 저수준 모듈보다 고수준 모듈에 의존해야한다</span>는 원칙이다.\r\n\r\n말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가?\r\n\r\n* <span class=\"primary\">고수준 모듈</span>: 인터페이스와 같은 객체의 형태나 추상적 개념\r\n* <span class=\"primary\">저수준 모듈</span>: 구현된 객체\r\n\r\n고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, <span class=\"red-600\">객체는 객체보다 인터페이스에 의존해야한다</span>로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.\r\n\r\n# 코드로 보는 의존성 역전 원칙\r\n\r\n예시를 통해 의존성 역전 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 의존성 역전 원칙을 준수하지 않은 코드\r\n\r\n어렸을 적 누구나 한 번씩 단풍에 대한 이야기를 다룬 게임을 해본적이 있을 것이다. 비록 이젠 죽어버렸지만 필자도 매우 좋아했었고, 성인이 된 후에도 방학시즌 이벤트만 되면 으레 복귀해서 게임을 즐기곤 했었다.\r\n\r\n그 게임은 RPG 장르로, RPG가 그렇듯 다양한 직업군과 그에 맞는 스킬/무기 시스템이 갖춰져있다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n수 많은 무기 가운데 하나인 한손검을 구현한 `OneHandSword` 객체가 있다. 캐릭터는 위와 같은 무기를 장비할 수 있을 것이다. 인스턴스 생성 시 무기의 이름과 데미지를 입력하여 생성한다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate OneHandSword weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic Character(String name, int health, OneHandSword weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic void chageWeapon(OneHandSword weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터를 구현한 `Character` 객체다. 게임 캐릭터가 취할 수 있는 기본적인 행동 일부가 구현되어있으며, 인스턴스 생성 시 캐릭터 이름, 체력, 무기를 입력하여 생성한다.\r\n\r\n하지만 다들 알다시피, 무기엔 한손검만 있는 게 아니다. 근접계열 무기만 하더라도 두손검, 단검, 창, 도끼, 둔기 등 다양한 종류가 존재할 수 있다. 그러나 이 `Character` 객체. 애초에 한손검 외엔 쓸 수가 없는 구조다. `Character`의 인스턴스 생성 시 `OneHandSword`에 의존성을 가지기 때문. \t공격 동작을 담당하는 `attack()` 메소드 역시 `OneHandSword`에 의존성을 가진다.\r\n\r\n이 상황에서 한손검을 제외한 다른 무기를 사용하려면 `Character`의 코드를 바꿔야한다. 즉, 이전에 다뤘던 [개방-폐쇄 원칙](/posts/2021/08/14/open-closed-principle)을 위배한다. 더 큰 문제는 무기가 바뀔 때마다 이 짓을 해줘야한다. \r\n\r\n## 의존성 역전 원칙을 준수한 코드\r\n\r\n만약 위 코드가 의존성 역전 원칙을 잘 지켰다면 고민할 필요가 없는 문제다. 위 코드의 <span class=\"red-400\">가장 큰 문제는 이미 완전하게 구현된 저수준 모듈을 의존하고 있다는 점</span>이다. 즉, 추상적인 고수준 모듈을 의존하도록 리팩토링해야한다.\r\n\r\n``` java\r\n/**\r\n * 공격 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 02:07:19\r\n */\r\npublic interface Attackable\r\n{\r\n\t/**\r\n\t * 공격 추상 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tint attack();\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 추상 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tString toString();\r\n}\r\n```\r\n\r\n우선 고수준 모듈인 `Weapon` 인터페이스를 생성한다. 공격 데미지를 반환하는 추상 함수 `attack()`과 무기 이름을 반환하는 추상 함수 `toString()`가 선언되어있다. 앞으로 모든 공격 가능한 무기 객체는 이 인터페이스를 상속받게 될 것이다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword implements Attackable\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\t@Override\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n`Attackable`를 상속받은 한손검 객체 `OneHandSword` 객체다. 상속받은 점 외에 크게 달라진 점은 없다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate Attackable weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic Character(String name, int health, Attackable weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic void chageWeapon(Attackable weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터 `Character` 객체다. 기존의 `OneHandSword`를 파라미터에서 좀 더 고수준 모듈인 `Attackable`을 파라미터로 받는 걸 확인할 수 있다. 그 밖의 무기와 관련된 메소드 전부가 그렇다.\r\n\r\n하나의 객체였던 저수준 모듈에서 고수준 모듈로 의존성이 바뀌게 되니, `Attackable`을 상속하는 모든 객체를 다룰 수 있다. 게임 시스템 내부적으로 모든 공격 가능한 무기는 `Attackable`을 상속받기로 가정했으므로, 공격 가능한 모든 무기를 사용할 수 있는 셈이다.\r\n\r\n이러한 변경으로 무기의 변경에 따라 `Character`의 <span class=\"green-600\">코드를 변경할 필요가 없으므로, 개방-폐쇄 원칙 또한 준수</span>할 수 있다.\r\n\r\n# 정리\r\n\r\n의존성 역전 원칙은 코드의 확장성 및 재사용성을 추구하기 위한 원칙이다. 경직된 객체보다 구현되지 않아 유연한 인터페이스가 더욱 확장 가능성이 높을 것이다.\r\n\r\n다른 원칙에 비해 <span class=\"orange-400\">의존성 역전 원칙은 중요도가 좀 떨어지는데, 그 이유는 타 원칙의 하위호환 격이기 때문</span>이다. 당장 위에서도 언급했듯이, 의존성 역전 원칙은 개방-폐쇄 원칙을 준수할 경우 자연스레 준수하기이다. 뿐만 아니라 1객체 = 1책임인 단일 책임 원칙, 기능별 인터페이스화를 추구하는 인터페이스 분리 원칙을 준수할 경우 역시 마찬가지다.\r\n\r\n객체 생성 시 객체로 구현해야할 것과 인터페이스로 구현해야할 것을 적절히 구분하여 올바른 의존 관계를 가지도록 구현하자. 이왕이면 방금 언급한 원칙들을 준수하여 두 마리 토끼를 잡는 것도 매우 좋은 방법일 것이다.\r\n\r\n# 마치며\r\n\r\n이 장을 끝으로 객체지향에 대한 글을 마무리한다. 지금껏 JAVA라는 객체지향 언어를 사용하고 있었음에도, 정작 객체지향에 대해 너무 몰랐다는 것을 새삼 느낀다. 내가 얼마나 비객체지향적으로 코딩했는지도....\r\n\r\n객체지향에서의 가장 큰 특징이라면 바로 <span class=\"primary\">상속</span>일 것이다. 객체지향의 5원칙 중 대부분이 상속과 직/간접적으로 연관된 것만 봐도, 객체지향의 아이덴티티는 상속이라고 할 수 있을 것이다. 그 만큼 객체지향에서 상속은 중요하면서 동시에 이해하기 어려운 개념이다. 잘 쓰기는 더더욱 어렵다.\r\n\r\n물론 객체지향의 의의를 온전히 구현하고, 수립된 원칙들을 전부 지키는 것은 시니어급 개발자라도 매우 어려운 일일 것이다. 당장 나 같아도 \"이 많은 걸 다 지켜가며 설계하라고?\"라는 생각이 들고, 대부분의 개발은 구현 과정보단 동작 결과에 치중하기 때문이다.\r\n\r\n탄탄한 기획과 이에 동반되는 고민은 견고한 설계가 가능하지만, 언제까지나 시간을 낭비할 수 없는 노릇이다. 아무리 탄탄하게 설계 중인 프로젝트라도 개발 기간을 준수하지 못 하면 결과물은 물론, 이 결과물을 내기까지 했던 모든 고민들이 시간낭비로 치부되는 것을 뻔하다.\r\n\r\n이러한 원칙을 정해진 시간 내에 구현해야 하므로, 객체지향을 잘 다루기 위해선 많은 노력이 필요할 것이다.","url":["2021-08-17-dependency-inversion-principle","2021","08","17","dependency-inversion-principle"]},"next":{"header":{"title":"[SSL] SSL 인증서","excerpt":"이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다. SSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다. 그렇다면, 해당 도메인에 SSL이 적용되어 https를 사용할 수 있는 이유는 무엇일까?","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T10:55:24","type":"posts","category":"WEB","tag":["CS","객체지향","SSL"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl-license.md","content":"\r\n# 개요\r\n\r\n이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다.\r\n\r\nSSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다.\r\n\r\n그렇다면, 해당 도메인에 SSL이 적용되어 `https`를 사용할 수 있는 이유는 무엇일까?\r\n\r\n# SSL 인증서\r\n\r\n이는 바로 인증서의 존재 덕분이다. 해당 사이트에 SSL이 적용되었는지 여부는 HandShake의 과정 중 ServerHello에서 받은 인증서 정보를 통해 확인할 수 있다.\r\n\r\nSSL 인증서엔 도메인명, 회사 정보, 서버 공개키가 포함되어있으며, 이 정보를 통해 도메인의 사이트의 유효성 확인, 암호화 통신이 가능하다.\r\n\r\n# SSL 인증서 종류\r\n\r\nSSL 인증서는 인증서 심사의 수준에 따라 DV, OV, EV 세 가지로 구분할 수 있다.\r\n\r\n## DV(Domain Validation)\r\n\r\n<span class=\"pink-600\">DV</span>는 오로지 <span class=\"pink-400\">도메인의 소유만을 검증하여 발급하는 인증서</span>다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820828-2bcf1d36-c954-471d-a7ce-e5facfa27859.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명 (*일 경우 와일드 카드)\r\n\r\n인증서 정보의 주체를 보면 도메인 정보인 CN외에 다른 정보는 확인할 수 없다.\r\n\r\nDV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n도메인 외의 소유자 등에 대한 다른 요인은 전혀 심사에 반영되지 않으므로, <span class=\"green-400\">발급 절차가 간단하고 금방 발급</span>된다. 또한 <span class=\"green-400\">금액 역시 대체적으로 저렴</span>한 편. 하지만 <span class=\"red-400\">신뢰성은 다른 인증서에 비해 떨어진다.</span>\r\n\r\n이 도메인이 실제함은 보증하지만, 그 이상의 요인은 보증하지 않기 때문이다. 혹여 누군가가 불법적인 일을 위해 페이퍼 컴퍼니를 만들고, 사이트를 그럴듯하게 꾸며놓아도 DV 인증서는 SSL을 발급해준다. 심사 기준이 오로지 도메인이기 때문에 발생하는 문제.\r\n\r\n물론 이는 어디까지나 단순한 \"믿음\"의 영역으로, <span class=\"green-400\">DV 인증서의 암호화 알고리즘이 다른 인증서에 비해 취약한 것도 아니기 때문에 보안 자체엔 전혀 문제가 없다.</span>\r\n\r\n신뢰에 기반하는 쇼핑몰, 금융업 등의 서비스에선 가급적 지양해야할 인증서.\r\n\r\n반대로 신뢰성을 그렇게 크게 요구하지 않는 <span class=\"lightBlue-400\">개인 프로젝트</span>, <span class=\"lightBlue-400\">소규모 사이트</span> 등엔 시간적으로나 경제적으로나 DV가 적합하다. DV 인증서를 직접 보고 싶다면, 소규모 개인 사이트나 블로그에 들어가면 된다. 블로그의 경우 GitHub나 NAVER 같은 플랫폼 연계가 아닌, 실제 본인이 서버를 임대해서 플랫폼 없이 직접 배포하는 그런 블로그에 들어가야 한다.\r\n\r\n### E-Mail\r\n\r\n<span class=\"orange-400\">도메인 소유주의 이메일에 인증 메일을 발송하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\n이 이메일은 아무거나 지정할 수 없고, 도메인을 발급받은 DNS 사이트에 등록된 이메일만 가능하다.\r\n\r\n타 인증방식과 다르게 <span class=\"green-400\">HTTP 80포트를 사용하지 못 해도 인증이 가능한 방식</span>이다. 만약 어떠한 이유로든 외부에서 자신의 사이트에 80포트로 접속할 수 없는 경우, 이 방법 외에 다른 인증은 불가능하다.\r\n\r\n### DNS 레코드\r\n\r\n<span class=\"orange-400\">DNS 설정을 추가하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\nDNS 설정의 A 레코드에 CA에서 임의로 생성한 URL을 추가한다. 해당 URL로 접근했을 때, HTTP 응답 코드가 200일 경우 인증된다.\r\n\r\nDNS 설정은 도메인 소유주만 관리할 수 있으므로, CNAME이 추가되면 도메인 소유주라 간주할 수 있다.\r\n\r\n반드시 <span class=\"red-400\">80포트로 웹 페이지에 접속할 수 있어야한다.</span> 만약 본인의 네트워크 환경 특수성으로 인해 80포트가 외부로 개방되지 않을 수도 있다. 이 경우 포트포워딩을 사용해서 외부의 80포트를 내부의 다른 포트로 라우팅해주면 된다. 최악의 경우 80포트 자체의 연결이 막혔거나, 본인이 포트포워딩을 마음대로 설정할 수 없는 경우는 이 방법으로 인증할 수 없다.\r\n\r\n### HTTP 요청\r\n\r\n웹 ROOT 경로에 `.well-known` 폴더를 생성하여 내부에 임시 파일을 생성한다. 임시 파일은 랜덤한 해쉬값이다. 이를 웹 서버에 배포하면 브라우저 상에서 해당 경로를 통해 파일에 접근할 수 있을 것이다.\r\n\r\n<span class=\"orange-400\">HTTP 요청은 이러한 방식으로 소유주에게 특정 파일을 서버에 업로드할 것을 요구하여, 해당 파일 접근 가능 여부를 통해 소유주임을 인증</span>한다.\r\n\r\n마찬가지로, <span class=\"red-400\">80포트 접근이 가능해야만 할 수 있는 인증</span>방법.\r\n\r\n## OV(Organization Validation)\r\n\r\n<span class=\"pink-600\">OV</span>는 <span class=\"pink-400\">도메인 뿐만 아니라, 해당 도메인을 소유한 회사, 기업에 대해 검증하여 발급</span>하는 인증서다.\r\n\r\n내가 제출한 도메인이 유효한지와는 별개로 <span class=\"orange-400\">도메인을 소유한 단체, 회사에 대한 검증까지 진행</span>한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820836-ac84d888-46cc-4877-a060-bea4df121e7c.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명\r\n* <span class=\"orange-400\">O(Organization)</span>: 기관명\r\n* <span class=\"orange-400\">L(Locality)</span>: 지역(시군구)\r\n* <span class=\"orange-400\">S(StateOrProvinceName)</span>: 주(시도)\r\n* <span class=\"orange-400\">C(CountryName)</span>: 국가\r\n\r\n인증서의 주체를 보면 도메인 정보 외에도 이를 소유한 회사/기관의 이름, 지역, 국가 등의 정보를 확인할 수 있다.\r\n\r\nOV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.2</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n자신의 단체/회사가 실존하는지를 입증하기 위해 사업자 등록증 같은 서류를 추가로 제출해야한다.\r\n\r\n소유주에 대한 검증 및 서류가 오가게 되므로, <span class=\"red-400\">발급이 즉시 이루어지진 못한다. 비용도 더 비싸며 족히 1 ~ 3일 정도는 소요</span>되는 편. 하지만 소유주에 대한 인증 덕분에 <span class=\"green-400\">보편적인 신뢰성을 제공</span>한다.\r\n\r\n대부분의 사기업 페이지에 적합한 인증서. OV 인증서는 <span class=\"lightBlue-400\">대부분의 사이트에 적용</span>되어 있으므로, 대충 번듯한 사이트 하나 들어가서 보면 된다. 지금 이 블로그도 GitHub가 주체라 OV 인증서를 확인할 수 있으니 참고할 것.\r\n\r\n## EV(Extended Validation)\r\n\r\n<span class=\"pink-400\">DV, OV인증과 더불어 법인 운영 담당자의 재직 증명, 법인 운영 기간 등 디테일한 요인을 검증</span>하여 발급하는 인증서다.\r\n\r\nOV의 경우 회사가 실재하는지를 검증한다면, <span class=\"pink-400\">EV</span>는 회사가 정상적으로 운영되는지를 검증한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820838-a87a8221-7785-49be-a3c2-26d0041b3295.png)\r\n\r\n인증서의 주체를 보면 도메인 정보, 회사 정보 외에도 다양한 정보가 추가되었음을 알 수 있다.\r\n\r\nEV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820842-41c97a59-f306-48d7-abfc-e6a06fd8ccf4.png)\r\n\r\n또한 EV 인증서는 다른 인증서와 달리 인증서 자체에 회사 서명을 표시해준다. 위 사진을 기준으로 좌측이 EV, 우측이 OV 혹은 DV. Microsoft Chromium Edge 기준으로 위와 같이 표시해준다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820843-1c77482f-bf84-47c4-a46b-ecfdf8149398.png)\r\n\r\n그 뿐만 아니라, IE로 접속했을 경우 주소창에 <span class=\"green-600\">Green Bar</span>를 적용하여 해당 도메인에 EV가 적용되었음을 시각적으로 알려준다. Chromium 기반 브라우저의 경우 시각적으로 표현해주진 않으니 참고할 것.\r\n\r\n인증서의 까다로운 심사절차로 인해 <span class=\"green-400\">발급하는데 걸리는 시간은 2주가 넘어가기도 하며, 비용 또한 매우 비싸다.</span> 하지만 <span class=\"red-400\">매우 강도 높은 신뢰성을 제공</span>한다.\r\n\r\n위와 같은 신뢰성 때문에, 이러한 신뢰성 보증이 필요한 공공기관, 금융권, 쇼핑몰과 같은 페이지에 사용된다. EV 인증서를 직접 보고싶다면, 아무 은행 홈페이지나 들어가보자.\r\n\r\n# 정리\r\n\r\nSSL이 적용되었는지 여부는 해당 사이트에 SSL 인증서가 있는지 여부를 통해 확인할 수 있다. 겉보기엔 SSL 인증서가 거기거 거기같지만 사실 그 종류만 해도 여러가지가 있으며, 인증서의 주체, 정책을 통해 현재 접속 중인 사이트의 SSL 종류를 확인할 수 있다.\r\n\r\nSSL을 적용하는 사이트의 성향에 따라 적합한 SSL 인증서를 발급받도록 하자.\r\n\r\n다음 장에서는 SSL 인증을 받기 위한 사전작업인 도메인 발급을 받아본다.","url":["2021-08-18-about-ssl-license","2021","08","18","about-ssl-license"]}},"group":[{"header":{"title":"[SSL] Tomcat에 SSL 적용하기","excerpt":"SSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다. 이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-20T00:35:21","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","Tomcat(톰캣)"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-20-apply-ssl.md","content":"\r\n# 개요\r\n\r\nSSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다.\r\n\r\n이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.\r\n\r\n# Tomcat에 인증서 적용하기\r\n\r\nTomcat에 인증서를 적용한다. Tomcat Native가 설치되어있는지, 없는지에 따라 방법이 다르다.\r\n\r\n> <b class=\"orange-400\">Tomcat Native</b>  \r\n> Tomcat의 성능 향상을 위해 C, JAVA 같은 네이티브 모듈이 추가된다. Windows의 경우 dll 파일 하나만 옮기면 된다.\r\n\r\nTomcat Native가 적용되어 있다면 `pem` 파일을 바로 적용할 수 있으며, 아니라면 `pem`을 `jks`와 같은 호환 가능한 확장자로 적절히 변경해야한다.\r\n\r\n# Tomcat Native 설치방법\r\n\r\nOS에 따라 Tomcat Native를 설치하는 방법이 다르다. Tomcat Native를 설치하지 않고도 SSL을 적용할 수 있으니, 관심이 없다면 이 단계를 패스해도 무방하다.\r\n\r\n## Windows 10\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 Tomcat Native 라이브러리를 다운로드 받는다. 중간에 [Native 1.2.30 Windows Binaries.zip]을 다운로드 받으면 된다.\r\n\r\n압축 풀면 [bin] 폴더에 `tcnative-1.dll` 파일이 있을텐데, 해당 DLL을 `TOMCAT_HOME_HOME/bin`에 옮기는 것으로 설치가 끝난다.\r\n\r\n## Linux(CentOS 7 이상)\r\n\r\n``` bash\r\nyum -y install tomcat-native\r\n```\r\n\r\nCentOS 7을 기준으로 위 명령어를 입력하면 된다. 만약 위와 같은 명령어를 사용할 수 없다면 직접 [이 링크](https://tomcat.apache.org/download-native.cgi)에서 컴파일해서 적용해야한다.\r\n\r\n## Linux(컴파일)\r\n\r\n직접 소스를 컴파일해서 사용한다. <span class=\"pink-400\">CentOS</span>를 기준으로 설명한다.\r\n\r\n``` bash\r\nyum install apr-devel openssl-devel\r\n```\r\n\r\n혹은 <span class=\"pink-400\">Devian</span> 계열일 경우\r\n\r\n``` bash\r\napt-get install libapr1.0-dev libssl-dev\r\n```\r\n\r\n컴파일 이전에 위 도구들이 설치되어있어야 한다.\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 [Native 1.2.30 Source Release tar.gz]를 다운로드 받아 압축을 푼다.\r\n\r\n``` bash\r\ntar -zxvf Native 1.2.30 Source Release tar.gz\r\n```\r\n\r\n압축은 위 명령어로 해제하면 되며, OS에 따라 명령어가 다를 수 있다.\r\n\r\n``` bash\r\ncd ${압축 해제 경로}\r\n./configure --with-apr=/usr --prefix=${현재경로} --with-java-home=${JAVA_HOME}\r\nmake\r\nmake install\r\n```\r\n\r\n위 명령어를 순차적으로 입력해주면 된다.\r\n\r\n# SSL 인증서 적용하기\r\n\r\nSSL 인증서를 적용하자. <span class=\"orange-400\">Tomcat Native</span> 적용 여부에 따라 방법이 다르다.\r\n\r\n## Tomcat Native로 PEM 파일 적용하기\r\n\r\n`TOMCAT_HOME/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tSSLCertificateFile=\"example.com-crt.pem\"\r\n\tSSLCertificateKeyFile=\"example.com-key.pem\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n위와 같이 수정해주면 된다. `SSLCertificateFile`에 `crt.pem` 파일을, `SSLCertificateKeyFile`에 `key.pem` 파일 경로를 지정한다.\r\n\r\n## 일반 Tomcat에 PEM to JKS로 변환하여 적용하기\r\n\r\n어떠한 이유로든 Tomcat Native를 설치하지 못 할 경우, <span class=\"red-400\">일반 Tomcat은 PEM 파일을 인식할 수가 없다.</span> 따라서 Tomcat이 지원하는 포맷으로 변환하여 사용해야한다. 이 문서에선 `.jks` 파일으로 변환하여 적용한다.\r\n\r\n준비물은 아래와 같다.\r\n\r\n* OpenSSL\r\n* keytool (JAVA 깔면 있음)\r\n\r\n[OpenSSL](https://www.openssl.org/source/)은 직접 설치해야하고, <span class=\"orange-400\">keytool</span>은 `JAVA_HOME/bin`에 있으므로 JAVA가 있다면 따로 설치하지 않아도 된다.\r\n\r\n``` batch\r\n# pem to p12\r\nopenssl pkcs12 -export -out {name}.p12 -in {crt}.pem -inkey {key}.pem\r\n\r\n# p12 to jks\r\nkeytool -importkeystore -srckeystore {name}.p12 -srcstoretype pkcs12 -destkeystore {name}.jks -deststoretype jks\r\n```\r\n\r\n위 명령어를 순서대로 입력하면 된다. <span class=\"red-400\">변환 과정에서 인증서에 저장할 비밀번호를 요구한다. 추후 웹서버에 해당 비밀번호를 제공</span>해야하니, 잘 기억해두자.\r\n\r\n4개였던 `.pem`파일과 달리 `.jks`는 심플하게 하나만 생성된다. 생성이 완료되면 `TOMCAT_HOME/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tkeystoreFile=\"example.com.jks\"\r\n\tkeystorePass=\"비밀번호\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n`keystoreFile`에 생성한 `.jks` 파일을, `keystorePass`에 변환 과정에서 입력한 비밀번호를 입력한다.\r\n\r\n# 확인\r\n\r\n본 문서에선 SSL 포트를 `443`으로 설정했다. SSL의 기본 포트는 443이므로, 별도의 포트 표시를 하지 않아도 자동으로 연결될 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130097706-8a3cc174-e35d-46db-9f60-caa585a59d98.png)\r\n\r\n이제 톰캣을 기동하여, 도메인에 접속해보자. 인증서 정보가 확인되면 성공이다.\r\n\r\n참고로, 인증서는 도메인을 기준으로 동작한다. 만약 `localhost` 내지는 `127.0.0.1`, IP를 입력하여 들어오면 인증서 오류가 뜨니 참고할 것.\r\n\r\n# 정리\r\n\r\n이로써 SSL 적용이 완료됐다. 처음엔 뭔가 복잡해보여도, 한 번 해두면 크게 어려운 부분은 없다.\r\n\r\nLet's Encrypt는 DV 인증서를 무료로 받을 수 있는 가장 쉽고 빠른 방법이므로, SSL이 필요하다면 적극적으로 활용해보자.","url":["2021-08-20-apply-ssl","2021","08","20","apply-ssl"]},{"header":{"title":"[SSL] Windows 10에서 Let's Encrypt로 SSL 인증서 무료 발급받기","excerpt":"도메인도 있겠다. 이제 이 도메인을 가지고 SSL 인증서를 발급받아보자. 물론 SSL 인증서 또한 발급받는데 비용이 든다. 대부분의 운영 중인 도메인 업체는 SSL 발급도 병행한다. 테스트 목적이라면 도메인과 마찬가지로 SSL 발급도 부담스러울 것이다. SSL 역시 무료로 발급받을 수 있는 방법이 있으며, 도메인보다 그 방법이 훨씬 많다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-19T23:37:21","type":"posts","category":"WEB","tag":["CS","객체지향","SSL"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-19-lets-encrypt.md","content":"\r\n# 개요\r\n\r\n도메인도 있겠다. 이제 이 도메인을 가지고 SSL 인증서를 발급받아보자. 물론 SSL 인증서 또한 발급받는데 비용이 든다. 대부분의 운영 중인 도메인 업체는 SSL 발급도 병행한다.\r\n\r\n테스트 목적이라면 도메인과 마찬가지로 SSL 발급도 부담스러울 것이다. SSL 역시 무료로 발급받을 수 있는 방법이 있으며, 도메인보다 그 방법이 훨씬 많다.\r\n\r\n하지만 무료 답게 제약사항이 존재하기도 한다. 유효기간이 매우 짧다던가, 등록할 수 있는 도메인에 한계가 있다던가, 하지만 <span class=\"green-600\">Let's Encrypt</span>를 활용하면 별다른 제약 없이 SSL을 발급받을 수 있다. 이전에 설명했던 <span class=\"lightBlue-600\">Freenom</span>과 달리, 이쪽은 실서버에 적용해도 아무런 문제없이 사용할 수 있다. 덕분에 소규모 사이트의 인증서를 잘 살펴보면 심심치않게 발급기관이 <span class=\"green-600\">Let's Encrypt</span>임을 확인할 수 있다.\r\n\r\n# Let's Encrypt!\r\n\r\n<span class=\"green-600\">Let's Encrypt</span>를 통해 SSL을 발급받아보자. 환경은 아래와 같다. <span class=\"blue-600\">Windows 10</span>을 기준으로 진행한다.\r\n\r\n사실 Let's Encrypt는 SSL을 발급해주는 기관으로, Let's Encrypt에서 회원가입하고 뭐 제출하고 이런 방식이 아니다. Let's Encrypt와 통신하여 SSL을 발급해주는 프로그램들이 많이 있으니 이걸 다운로드 받으면 된다.\r\n\r\n[지원하는 프로그램 목록](https://letsencrypt.org/ko/docs/client-options/)을 확인해보자. 그 중 우리는 Windows 10용으로 빌드된 <span class=\"primary\">win-acme</span>를 사용한다.\r\n\r\n필요한 준비물은 아래와 같다.\r\n\r\n* Windows 10\r\n* 자신의 아이피와 연결된 도메인\r\n* 80포트가 접속 가능한 네트워크 환경\r\n  * 불가능하다면 DNS 설정이 가능함\r\n* WAS (여기선 Tomcat을 사용)\r\n\r\n위 준비물이 없으면 SSL 발급을 진행하기 어렵다.\r\n\r\n## 1. win-acme 다운로드\r\n\r\n아래의 사이트에서 win-acme를 다운로드 받는다.\r\n\r\n<br />\r\n\r\n<p align=\"center\"><a href=\"https://www.win-acme.com/\" target=\"_blank\">다운로드</a></p>\r\n\r\n<br />\r\n\r\n압축을 해제한다. `wacs.exe`를 실행하면 아래와 같은 창이 뜰 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130079131-3eb9c5de-c1bc-4919-a921-e4c7c7f28a3d.png)\r\n\r\n## 2. 발급 방법 선택\r\n\r\n명령어를 입력하여 발급을 진행할 것이다.\r\n\r\n* <span class=\"green-300\">Create certificate (default settings)</span>: 기본 옵션으로 SSL 발급 (N)\r\n* <span class=\"green-A400\">Create certificate (full settings)</span>: 직접 옵션을 선택하여 SSL 발급 (M)\r\n* <span class=\"green-300\">Run renewals</span>: 갱신 (R)\r\n* <span class=\"green-300\">Manage renewals</span>: 갱신 관리 (A)\r\n* <span class=\"green-300\">More options...</span>: 더 많은 옵션 (O)\r\n* <span class=\"green-300\">Quit</span>: 종료 (Q)\r\n\r\n[M]을 입력하여 직접 옵션을 선택하여 SSL을 발급한다. 대소문자는 따로 구분하지 않으니 그냥 입력해도 된다.\r\n\r\n## 3. 도메인 입력 방법 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130080688-2bbbc350-399a-4bc3-b619-732d4b25ae58.png)\r\n\r\n* <span class=\"grey-600\">Read site bindings from IIS</span>: IIS에서 바인딩 (1)\r\n* <span class=\"green-A400\">Manual input</span>: 직접 입력 (2)\r\n* <span class=\"green-300\">CSR created by another program</span>: 다른 프로그램에서 만든 CSR (3)\r\n* <span class=\"green-300\">Abort</span>: 중단 (C)\r\n\r\n우리는 [2]를 입력하여 직접 도메인을 입력한다.\r\n\r\n## 4. 도메인 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130080746-f57c8f5f-6243-4c9d-b5ca-a6859fcb30ec.png)\r\n\r\n인증받을 도메인을 입력한다. 다수의 도메인을 하나의 인증서로 만들 수도 있으며, 이 경우 쉼표(,)로 구분하면 된다.\r\n\r\n``` batch\r\nexample.com\r\n```\r\n\r\n하나의 도메인을 인증받는다면 위와 같이 입력한다.\r\n\r\n``` batch\r\nexample.com,www.example.com,admin.example.com\r\n```\r\n\r\n여러 도메인을 인증받는다면 위와 같이 쉼표로 구분하여 입력한다.\r\n\r\n입력한 모든 도메인이 인증되어야하니 참고할 것. 도메인을 입력하면 도메인에 대한 별칭을 입력하라고 하는데, 그냥 아무것도 입력하지 말고 [Enter] 눌러서 다음으로 넘어가자.\r\n\r\n## 5. 인증 방법 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130081483-11eef349-d3e7-4e81-9498-67355eb2632f.png)\r\n\r\n* <span class=\"green-A400\">Save verification files on (network) path</span>: 네트워크 경로에 인증 파일 저장 (1)\r\n* <span class=\"grey-600\">Serve verification files from memory</span>: 메모리에 인증 파일 저장 (2)\r\n* <span class=\"green-300\">Upload verification files via FTP(S)</span>: FTP를 통한 인증 파일 업로드 (3)\r\n* <span class=\"green-300\">Upload verification files via SSH-FTP</span>: SSH-FTP를 통한 인증 파일 업로드 (4)\r\n* <span class=\"green-300\">Upload verification files via WebDav</span>: WebDav를 통한 인증 파일 업로드 (5)\r\n* <span class=\"green-300\">Create verification records manually (auto-renew not possible)</span>: 수동으로 인증 레코드 생성 (자동 갱신 불가능) (6)\r\n* <span class=\"green-300\">Create verification records acme-dns</span>: acme-dns를 통한 인증 레코드 생성 (7)\r\n* <span class=\"green-300\">Create verification records with your own script</span>: 본인 소유의 스크립트를 통해 인증 레코드 생성 (8)\r\n* <span class=\"grey-600\">Answer TLS verification request from win-acme</span>: win-acme의 TLS 인증요청 응답 (9)\r\n\r\n1번은 이후 입력할 웹루트 경로에 인증파일을 생성해주고, 3 ~ 5번은 제공해주는 파일을 직접 업로드한다. 6 ~ 8번은 DNS 레코드 설정이 필요하다.\r\n\r\n통상 1번이 가장 쉬우니, 본 문서에는 1번으로 진행한다.\r\n\r\n## 6. 웹루트 경로 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130083363-c4e34aeb-6041-4895-9e4c-71085514f51f.png)\r\n\r\n웹루트 경로를 입력한다. 예를 들어, `https://example.com` 도메인이 있다면, 이 도메인의 파일들이 위치한 경로를 입력해야한다.\r\n\r\n만약 순정 <span class=\"amber-400\">Tomcat</span>이라면 `%TOMCAT_HOME%/webapps/ROOT`가 될 것이다.\r\n\r\n환경마다 다르니, 적절히 입력해주면 된다. 이 때 반드시 <span class=\"red-600\">80포트로 접속이 가능해야함에 주의</span>한다.\r\n\r\n만약 80포트 사용이 불가능하다면 DNS 설정으로 인증하는 6 ~ 8번을 시도하자. 이메일 인증은 지원하지 않는다.\r\n\r\n웹 설정을 복사할거냐고 물어보는데, 하지말자.\r\n\r\n## 7. CSR 유형 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130084201-636a0f36-ac1a-4aaa-b17d-948248b2600c.png)\r\n\r\n* <span class=\"green-300\">Elliptic Curve key</span>: 타원곡선 암호화 (1)\r\n* <span class=\"green-A400\">RSA Key</span>: 비대칭 암호화 (2)\r\n\r\n[2]를 선택한다.\r\n\r\n## 8. 인증서 저장 방식 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130084595-c96c3c33-ddde-4b95-b395-5e073d6b4eba.png)\r\n\r\n* <span class=\"green-300\">IIS Central Certificate Store</span>: IIS용 인증서 (.pfx) (1)\r\n* <span class=\"green-A400\">PEM encoded files</span>: 아파치 계열용 인증서 (.pem) (2)\r\n* <span class=\"green-300\">PFX archive</span>: .pfx 파일 (3)\r\n* <span class=\"grey-600\">Windows Certificate Store</span>: 윈도우 인증서 저장소 (4)\r\n* <span class=\"green-300\">No (additional) store steps</span>: (추가적인) 인증서 미저장 (5)\r\n\r\n본 문서에선 Tomcat을 기준으로 설명하므로 [2]를 선택한다.\r\n\r\n## 9. 저장경로 입력\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130085226-7f89895e-ad04-4851-9b6f-5922eb749f36.png)\r\n\r\n원하는 저장경로를 입력한다. 편한 경로로 입력하자.\r\n\r\n## 10. 키파일 암호 입력 방식\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130085398-cc5e9c1e-6b1c-4b20-ba3d-d62caf3b02e3.png)\r\n\r\n* <span class=\"green-300\">None</span>: 안 함 (1)\r\n* <span class=\"green-A400\">Type/paste in console</span>: 콘솔에서 입력/붙여넣기 (2)\r\n* <span class=\"green-300\">Search in vault</span>: vault에서 검색 (3)\r\n\r\n[2]를 선택한다.\r\n\r\n원하는 비밀번호를 입력한다. 입력하면 해당 비밀번호를 추후 사용하도록 valut에 저장할 것이냐고 묻는다. 원하는대로 하자.\r\n\r\n저장하게 되면 아마 [3]을 통해 이전의 암호를 사용할 수 있을 것 같다.\r\n\r\n## 11. 추가 인증서 저장 방식 선택\r\n\r\n8번과 같은 과정. 추가로 다른 확장자의 인증서가 필요하면 더 하면 된다.\r\n\r\n이 문서에선 필요 없으므로, [5]를 눌러 더 생성하지 않고 넘어간다.\r\n\r\n## 12. 추가 옵션\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130086251-6744a758-1f4a-44b3-9bc1-ed260fac4d67.png)\r\n\r\n* <span class=\"grey-300\">Create or update https bindings in IIS</span>: IIS에 HTTPS 바인딩 생성 혹은 갱신 (1)\r\n* <span class=\"grey-300\">Create or update ftps bindings in IIS</span>: IIS에 FTPS(보안 FTP) 바인딩 생성 혹은 갱신 (2)\r\n* <span class=\"green-300\">Start external scripts or program</span>: 외부 스크립트 실행 (3)\r\n* <span class=\"green-A400\">No (additional) installation steps</span>: 추가적인 설치 과정 없음 (4)\r\n\r\n[4] 별도로 할게 없으므로 넘어가자.\r\n\r\n## 13. 도메인 인증\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130086813-01c8e143-e2dd-4b3b-ad41-d89292d07607.png)\r\n\r\n아까 입력했던 도메인에 대한 인증을 수행한다. 도메인의 유효성만 검증하므로 DV 인증서라고 할 수 있다.\r\n\r\n아까 입력했던 웹루트에 `.well-known` 폴더가 생성됐을 것이다.\r\n\r\n`http://www.kapoo.ga/.well-known/{hash}/{file}`로 접근해서 실제 자신이 랜덤으로 생성한 파일의 정보와 일치한지 확인한다. 맞다면 해당 도메인이 유효하다고 판단한다.\r\n\r\n나중에 특정 작업 수행할 거냐고 물어보는 대답엔 아니라고 하자.\r\n\r\n## 14. 인증서 확인\r\n\r\n9번 과정에서 입력한 저장 경로로 가보면 `pem` 파일이 생성되었을 것이다.\r\n\r\n* example.com-chain.pem: 서명과 CA 중간 인증서를 통합한 인증서\r\n* example.com-chain-only.pem: CA의 중간 인증서\r\n* example.com-crt.pem: 서명된 인증서\r\n* example.com-key.pem: 인증서 개인키\r\n\r\n위 네 파일이 생성되면 정상적으로 SSL을 발급받은 것이다. 이를 웹서버, WAS 등에 적용하면 된다.\r\n\r\n# 정리\r\n\r\nLet's Encrypt를 통해 SSL을 무료로 발급받았다. 무료지만 무려 1년의 유효기간을 가지며, 발급 시 자동갱신 스크립트도 자동으로 추가된다.\r\n\r\n무료임에도 불구하고 환경만 잘 구축해두면, SSL은 거의 신경쓰지 않아도 된다. 이러한 편의성 때문에 무료임에도 많은 곳에서 Let's Encrypt를 사용한다.\r\n\r\n다음 장에서는 이 인증서를 직접 Tomcat에 적용해본다.","url":["2021-08-19-lets-encrypt","2021","08","19","lets-encrypt"]},{"header":{"title":"[SSL] Freenom을 활용한 무료 도메인 발급하기","excerpt":"이전 글들에서 SSL이 뭔지, 어떤식으로 동작하는지를 다뤘다. 사이트에 SSL을 적용하기 위해선 SSL 인증서를 발급받아야한다. SSL 인증서를 발급받기 위해선 인증받기 위한 도메인이 필요하다. 국내에서 서비스 중인 도메인 업체에서 쉽게 발급받을 수 있다. 위 업체는 도메인 외에도 호스팅 등 다양한 서비스를 제공한다. 이 외에도 여러 업체들이 있으며, 국내 뿐만 아니라 해외에서 서비스 중인 업체들도 있다. 업체마다 가격 및 정책이 다르니 발품팔다보면 좋은 금액으로 구매할 수도 있다. TLD(Top Level Domain)에 따라 가격이 달라지며, 저렴한 건 연간 몇 천원에서부터 비싸면 수십만원대에 이르기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T23:44:43","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","도메인"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-freenom-domain.md","content":"\r\n# 개요\r\n\r\n이전 글들에서 SSL이 뭔지, 어떤식으로 동작하는지를 다뤘다. 사이트에 SSL을 적용하기 위해선 SSL 인증서를 발급받아야한다.\r\n\r\nSSL 인증서를 발급받기 위해선 인증받기 위한 도메인이 필요하다. 국내에서 서비스 중인 도메인 업체에서 쉽게 발급받을 수 있다.\r\n\r\n* [가비아](https://www.gabia.com/)\r\n* [후이즈](https://whois.co.kr/)\r\n* [카페24](https://www.cafe24.com/)\r\n\r\n위 업체는 도메인 외에도 호스팅 등 다양한 서비스를 제공한다.\r\n\r\n이 외에도 여러 업체들이 있으며, 국내 뿐만 아니라 해외에서 서비스 중인 업체들도 있다. 업체마다 가격 및 정책이 다르니 발품팔다보면 좋은 금액으로 구매할 수도 있다.\r\n\r\nTLD(Top Level Domain)에 따라 가격이 달라지며, 저렴한 건 연간 몇 천원에서부터 비싸면 수십만원대에 이르기도 한다.\r\n\r\n> **TLD?**  \r\n> com, net과 같이 URL 마지막에 오는 최상위도메인을 뜻한다. TLD에 대한 내용은 이전에 작성한 게시글 <a href=\"/2021/05/29/uri-url-urn#TLD(Top-Level Domain, 최상위 도메인)\">URI? URL? URN? 리소스 식별자 구분하기</a>에서 확인 가능하다.\r\n\r\n# Freenom으로 무료 도메인 받기\r\n\r\n물론 위 방법으로 도메인을 발급받아도 좋지만, 여기엔 돈이 든다. 만약 본인이 실제 웹을 배포할 생각이라면 당연히 도메인을 구입하는 게 맞다.\r\n\r\n하지만 도메인 연결, SSL 적용 등 단순 테스트 목적이라면 적은 비용이라도 좀 아깝다는 생각이 들게 된다.\r\n\r\n다행히 [Freenom](https://www.freenom.com/)에서 무료 도메인을 발급해주니, 단순 테스트 목적으로 부담없이 사용할 수 있다.\r\n\r\n## 주의사항\r\n\r\nFrenom을 사용하는 데 몇 가지 주의사항이 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">1. 사용 가능한 TLD가 제한적임</p>\r\n\r\n주로 사용하는 TLD는 `com`, `net` 등이 있지만, Freenom은 `ga`, `ml` 등 특정한 ccTLD만 지원한다.\r\n\r\n* `tk (Tokelau)`: 뉴질랜드령 토켈라우제도\r\n* `ml (Mali)`: 말리\r\n* `ga (Gabon)`: 가봉\r\n* `gq (Equatorial Guinea)`: 적도 기니\r\n* `cf (Central African Republic)`: 중앙아프리카 공화국\r\n\r\n대중적인 TLD를 선택할 순 없지만, 무료이니 감안하자. 어차피 후술할 이유로 실제 서비스에 적용하기엔 무리가 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large amber-600\">2. 연장 시기를 놓치면 유료화</p>\r\n\r\n발급받은 도메인은 최대 1년 단위로 연장해야한다. 연장은 만료일로부터 2주 안에 신청이 가능하다.\r\n\r\n연장하는데 비용은 들지 않으나, 문제는 연장 시기를 놓쳐 만료될 경우다. 이렇게 만료된 도메인은 새로 발급받아야하는데, <span class=\"purple-600\">Special Domain</span>으로 분류되어 약 9$ 정도의 비용을 요구한다.\r\n\r\n9$이면 괜찮은 TLD의 도메인을 발급받을 수 있을 정도의 금액이므로 여기서 구매할 이유도 딱히 없다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large red-600\">3. 인기 도메인 강제 하이재킹</p>\r\n\r\nFreenom 도메인을 <span class=\"red-400\">실제 서비스에 사용하면 안되는 결정적인 이유.</span>\r\n\r\n만약, 당신의 서비스에 Freenom 도메인을 적용했는데, 운 좋게 서비스의 인기가 많아졌다고 가정하자. 인가가 많아지면 덩달아 접속량도 많아지는 건 당연지사.\r\n\r\n문제는 Freenom에서 이를 모니터링한다는 점이다. 단순 모니터링해서 접속자 통계를 제공해주면 좋겠지만, 무료인데 그런 서비스를 제공할리가 없다.\r\n\r\n실상은 도메인이 일정 트래픽 이상을 발생시키면 <span class=\"purple-600\">Special Domain</span> 어쩌고 하면서 <span class=\"red-400\">유료로 전환</span>시켜버린다.\r\n\r\n2번이야 연장하지 않은 귀책사유라도 있지, 이건 그냥 도메인 강탈이라서 답도 없다. 트래픽이 많으면 다음 갱신이 불가능하다 이런 것도 아니고, 그냥 <span class=\"red-400\">트래픽이 많은 도메인은 언제든 뺏길 수 있다.</span>\r\n\r\n도메인이야 다시 발급받으면 된다지만, 이미 사용하던 사람들에게 도메인의 변경으로 혼란을 주고, 서비스의 신뢰성을 훼손하게 되므로 서비스 운영에 지대한 악영향을 미친다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"large red-600\">4. 제한적인 DNS 서버</p>\r\n\r\nDNS 서버가 범용적이지 않다. IP 설정 시 DNS 서버 설정도 같이 할 수 있는데, 반드시 정해진 DNS 서버를 사용해야한다.\r\n\r\n국내 DNS 서버의 경우 Freenom 도메인 정보가 공유되지 않아 국내 환경에선 접속할 수 없는 현상이 발생하기도 한다.\r\n\r\nFreenom에서 제공하는 DNS 혹은 Google DNS와 같은 국제적인 DNS 서버를 사용하면 가능하지만, 국내 DNS를 사용하는 환경에서 접속할 수 없다는 점은 매우 큰 디메리트.\r\n\r\n# 도메인 발급 방법\r\n\r\n아래의 절차에 따라 도메인을 발급받자. 외국 소재 사이트다보니, 사이트 속도가 좀 느릴 수도 있으니 참고할 것.\r\n\r\n## 1. 회원가입\r\n\r\n[Freenom](https://www.freenom.com/)에 접속하여 회원가입을 진행한다. Google 소셜 로그인을 지원하니, 이쪽을 시도해도 좋다.\r\n\r\n## 2. 사용 가능한 도메인 검색\r\n\r\n검색창에서 원하는 도메인명을 검색한다. [Services] -> [Register a New Domain]을 메뉴를 선택하면 검색 페이지가 뜬다. \r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129911927-51d23984-87d3-47e9-88bf-e13abf2dff8a.png)\r\n\r\n<span class=\"blue-400\">rwb0104</span>의 경우 5개의 무료 도메인 중 5개 전부 적용이 가능하다.\r\n\r\n## 3. 무료 TLD 선택\r\n\r\n앞서 언급했듯이, 무료 도메인은 총 5개가 있다.\r\n\r\n이 중 원하는 TLD를 선택하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129912910-869d2ce9-d312-4cf6-85bf-4aa534ea87d8.png)\r\n\r\n여기에선 `tk` TLD를 선택한다. 위의 [<span class=\"green-A400\">Checkout</span>] 버튼을 클릭하여 다음으로 넘어간다.\r\n\r\n## 4. 옵션 선택\r\n\r\n도메인 옵션을 선택한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129913319-c648e9cd-f097-4761-bede-685b5732039f.png)\r\n\r\n보다시피 별건 없고, 반드시 우측 콤보박스에서 [Period]를 12개월로 맞추자. 최대 12개월까지 무료로 사용 가능하며, 만료일자 기준으로 2주 안에 갱신이 가능하다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129913740-d8f36236-2136-477f-8375-e20e435156a1.png)\r\n\r\n[<span class=\"green-A400\">Use DNS</span>]를 선택하여 자신의 IP를 입력하자.\r\n\r\n자신의 실제 IP는 [여기](https://www.findip.kr/)에서 확인할 수 있다. 192.168.0.x과 같은 사설 IP는 입력하면 안 된다.\r\n\r\n위 사진은 `rwb0104.tk`와 `www.rwb0104.tk`에 매칭되는 아이피를 연결하는 설정이다. 앞의 `www`와 같은 서브도메인은 필요에 따라 DNS 설정을 통해 추가할 수도, 삭제할 수도 있으니 크게 신경쓰지 않아도 된다.\r\n\r\n모든 설정을 완료했다면 [<span class=\"lightBlue-A400\">Continue</span>]를 클릭하여 진행한다.\r\n\r\n## 5. 구매\r\n\r\n100원이든 0원이든 일단 \"구매\"는 하는 셈이니, 절차상 구매 약관에 따라 구매한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129914504-abad20fc-e84d-4040-a003-1b82e6ba8080.png)\r\n\r\n$0.00 달러임을 확인하자. 문제가 없다면 약관에 동의하고 [<span class=\"lightBlue-A400\">Complete Order</span>]를 클릭한다.\r\n\r\n구매 확인서가 나오는데, 어차피 무료로 구매했으므로 신경쓰지 말고 넘어가자.\r\n\r\n## 6. 발급받은 도메인 확인\r\n\r\n[Services] -> [My Domains]에서 발급받은 도메인 목록을 확인할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129914950-4ecd1040-82eb-4a35-b402-4914ea1013c1.png)\r\n\r\n[Manage Domain] 버튼을 클릭하면 도메인 설정을 변경하거나 삭제할 수 있다.\r\n\r\n# 도메인을 활용해 접속하기\r\n\r\n이제 도메인을 사용해 내 서버에 접속하자.\r\n\r\n아무런 설정을 건드리지 않은 Tomcat을 기동한다. 통상 `xxx.xxx.xxx.xxx:8080` 혹은 `localhost:8080`으로 접속했겠지만, 이제 IP `xxx.xxx.xxx.xxx`가 도메인과 연결되어 있으므로, 해당 도메인으로 접속해보자.\r\n\r\n`rwb0104.tk:8080` 이렇게 접속해서 문제없이 접속되면 도메인이 정상적으로 IP와 연동된 것이다.\r\n\r\n## 연결이 되지 않아요!\r\n\r\n* `xxx.xxx.xxx.xxx:8080`으로 접속되는지 확인\r\n* 접속이 될 경우 외부에서 문제없이 접속되므로, 도메인에 연결한 IP가 올바른지 확인\r\n* 접속되지 않을 경우 애초에 외부에서 접속되지 않는 것이므로 방화벽이나 포트 통신에 문제가 없는지 확인\r\n* 공유기 환경일 경우 IP주소의 포트포워딩이 설정되어있는지 확인\r\n\r\n# 정리\r\n\r\nFreenom은 실제로 쓰긴 굉장히 난감한 단점을 가진다. 그럼에도 불구하고 도메인 관련 테스트나 공부할 땐 또 이만한 사이트가 없는 것 같다.\r\n\r\n이제 도메인까지 발급받았으니, SSL 인증서를 발급받는 방법에 대해 다뤄보자.","url":["2021-08-18-freenom-domain","2021","08","18","freenom-domain"]},{"header":{"title":"[SSL] SSL 인증서","excerpt":"이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다. SSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다. 그렇다면, 해당 도메인에 SSL이 적용되어 https를 사용할 수 있는 이유는 무엇일까?","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T10:55:24","type":"posts","category":"WEB","tag":["CS","객체지향","SSL"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl-license.md","content":"\r\n# 개요\r\n\r\n이전 장을 읽었다면 인증서에 대한 언급이 있음을 확인할 수 있다.\r\n\r\nSSL이 적용되면 서버와 클라이언트가 어떤 식으로 통신하고 암/복호화하여 데이터를 다루는지 설명했지만, 이는 SSL의 원리일 뿐이다.\r\n\r\n그렇다면, 해당 도메인에 SSL이 적용되어 `https`를 사용할 수 있는 이유는 무엇일까?\r\n\r\n# SSL 인증서\r\n\r\n이는 바로 인증서의 존재 덕분이다. 해당 사이트에 SSL이 적용되었는지 여부는 HandShake의 과정 중 ServerHello에서 받은 인증서 정보를 통해 확인할 수 있다.\r\n\r\nSSL 인증서엔 도메인명, 회사 정보, 서버 공개키가 포함되어있으며, 이 정보를 통해 도메인의 사이트의 유효성 확인, 암호화 통신이 가능하다.\r\n\r\n# SSL 인증서 종류\r\n\r\nSSL 인증서는 인증서 심사의 수준에 따라 DV, OV, EV 세 가지로 구분할 수 있다.\r\n\r\n## DV(Domain Validation)\r\n\r\n<span class=\"pink-600\">DV</span>는 오로지 <span class=\"pink-400\">도메인의 소유만을 검증하여 발급하는 인증서</span>다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820828-2bcf1d36-c954-471d-a7ce-e5facfa27859.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명 (*일 경우 와일드 카드)\r\n\r\n인증서 정보의 주체를 보면 도메인 정보인 CN외에 다른 정보는 확인할 수 없다.\r\n\r\nDV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n도메인 외의 소유자 등에 대한 다른 요인은 전혀 심사에 반영되지 않으므로, <span class=\"green-400\">발급 절차가 간단하고 금방 발급</span>된다. 또한 <span class=\"green-400\">금액 역시 대체적으로 저렴</span>한 편. 하지만 <span class=\"red-400\">신뢰성은 다른 인증서에 비해 떨어진다.</span>\r\n\r\n이 도메인이 실제함은 보증하지만, 그 이상의 요인은 보증하지 않기 때문이다. 혹여 누군가가 불법적인 일을 위해 페이퍼 컴퍼니를 만들고, 사이트를 그럴듯하게 꾸며놓아도 DV 인증서는 SSL을 발급해준다. 심사 기준이 오로지 도메인이기 때문에 발생하는 문제.\r\n\r\n물론 이는 어디까지나 단순한 \"믿음\"의 영역으로, <span class=\"green-400\">DV 인증서의 암호화 알고리즘이 다른 인증서에 비해 취약한 것도 아니기 때문에 보안 자체엔 전혀 문제가 없다.</span>\r\n\r\n신뢰에 기반하는 쇼핑몰, 금융업 등의 서비스에선 가급적 지양해야할 인증서.\r\n\r\n반대로 신뢰성을 그렇게 크게 요구하지 않는 <span class=\"lightBlue-400\">개인 프로젝트</span>, <span class=\"lightBlue-400\">소규모 사이트</span> 등엔 시간적으로나 경제적으로나 DV가 적합하다. DV 인증서를 직접 보고 싶다면, 소규모 개인 사이트나 블로그에 들어가면 된다. 블로그의 경우 GitHub나 NAVER 같은 플랫폼 연계가 아닌, 실제 본인이 서버를 임대해서 플랫폼 없이 직접 배포하는 그런 블로그에 들어가야 한다.\r\n\r\n### E-Mail\r\n\r\n<span class=\"orange-400\">도메인 소유주의 이메일에 인증 메일을 발송하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\n이 이메일은 아무거나 지정할 수 없고, 도메인을 발급받은 DNS 사이트에 등록된 이메일만 가능하다.\r\n\r\n타 인증방식과 다르게 <span class=\"green-400\">HTTP 80포트를 사용하지 못 해도 인증이 가능한 방식</span>이다. 만약 어떠한 이유로든 외부에서 자신의 사이트에 80포트로 접속할 수 없는 경우, 이 방법 외에 다른 인증은 불가능하다.\r\n\r\n### DNS 레코드\r\n\r\n<span class=\"orange-400\">DNS 설정을 추가하여 자신이 해당 도메인의 소유주임을 인증</span>하는 방식이다.\r\n\r\nDNS 설정의 A 레코드에 CA에서 임의로 생성한 URL을 추가한다. 해당 URL로 접근했을 때, HTTP 응답 코드가 200일 경우 인증된다.\r\n\r\nDNS 설정은 도메인 소유주만 관리할 수 있으므로, CNAME이 추가되면 도메인 소유주라 간주할 수 있다.\r\n\r\n반드시 <span class=\"red-400\">80포트로 웹 페이지에 접속할 수 있어야한다.</span> 만약 본인의 네트워크 환경 특수성으로 인해 80포트가 외부로 개방되지 않을 수도 있다. 이 경우 포트포워딩을 사용해서 외부의 80포트를 내부의 다른 포트로 라우팅해주면 된다. 최악의 경우 80포트 자체의 연결이 막혔거나, 본인이 포트포워딩을 마음대로 설정할 수 없는 경우는 이 방법으로 인증할 수 없다.\r\n\r\n### HTTP 요청\r\n\r\n웹 ROOT 경로에 `.well-known` 폴더를 생성하여 내부에 임시 파일을 생성한다. 임시 파일은 랜덤한 해쉬값이다. 이를 웹 서버에 배포하면 브라우저 상에서 해당 경로를 통해 파일에 접근할 수 있을 것이다.\r\n\r\n<span class=\"orange-400\">HTTP 요청은 이러한 방식으로 소유주에게 특정 파일을 서버에 업로드할 것을 요구하여, 해당 파일 접근 가능 여부를 통해 소유주임을 인증</span>한다.\r\n\r\n마찬가지로, <span class=\"red-400\">80포트 접근이 가능해야만 할 수 있는 인증</span>방법.\r\n\r\n## OV(Organization Validation)\r\n\r\n<span class=\"pink-600\">OV</span>는 <span class=\"pink-400\">도메인 뿐만 아니라, 해당 도메인을 소유한 회사, 기업에 대해 검증하여 발급</span>하는 인증서다.\r\n\r\n내가 제출한 도메인이 유효한지와는 별개로 <span class=\"orange-400\">도메인을 소유한 단체, 회사에 대한 검증까지 진행</span>한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820836-ac84d888-46cc-4877-a060-bea4df121e7c.png)\r\n\r\n* <span class=\"orange-400\">CN(Common Name)</span>: 도메인명\r\n* <span class=\"orange-400\">O(Organization)</span>: 기관명\r\n* <span class=\"orange-400\">L(Locality)</span>: 지역(시군구)\r\n* <span class=\"orange-400\">S(StateOrProvinceName)</span>: 주(시도)\r\n* <span class=\"orange-400\">C(CountryName)</span>: 국가\r\n\r\n인증서의 주체를 보면 도메인 정보 외에도 이를 소유한 회사/기관의 이름, 지역, 국가 등의 정보를 확인할 수 있다.\r\n\r\nOV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.2.2</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n자신의 단체/회사가 실존하는지를 입증하기 위해 사업자 등록증 같은 서류를 추가로 제출해야한다.\r\n\r\n소유주에 대한 검증 및 서류가 오가게 되므로, <span class=\"red-400\">발급이 즉시 이루어지진 못한다. 비용도 더 비싸며 족히 1 ~ 3일 정도는 소요</span>되는 편. 하지만 소유주에 대한 인증 덕분에 <span class=\"green-400\">보편적인 신뢰성을 제공</span>한다.\r\n\r\n대부분의 사기업 페이지에 적합한 인증서. OV 인증서는 <span class=\"lightBlue-400\">대부분의 사이트에 적용</span>되어 있으므로, 대충 번듯한 사이트 하나 들어가서 보면 된다. 지금 이 블로그도 GitHub가 주체라 OV 인증서를 확인할 수 있으니 참고할 것.\r\n\r\n## EV(Extended Validation)\r\n\r\n<span class=\"pink-400\">DV, OV인증과 더불어 법인 운영 담당자의 재직 증명, 법인 운영 기간 등 디테일한 요인을 검증</span>하여 발급하는 인증서다.\r\n\r\nOV의 경우 회사가 실재하는지를 검증한다면, <span class=\"pink-400\">EV</span>는 회사가 정상적으로 운영되는지를 검증한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820838-a87a8221-7785-49be-a3c2-26d0041b3295.png)\r\n\r\n인증서의 주체를 보면 도메인 정보, 회사 정보 외에도 다양한 정보가 추가되었음을 알 수 있다.\r\n\r\nEV의 인증서 정책은 <span class=\"orange-400\">2.23.140.1.1</span>이다. 이를 통해 해당 인증서가 DV임을 유추할 수도 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820842-41c97a59-f306-48d7-abfc-e6a06fd8ccf4.png)\r\n\r\n또한 EV 인증서는 다른 인증서와 달리 인증서 자체에 회사 서명을 표시해준다. 위 사진을 기준으로 좌측이 EV, 우측이 OV 혹은 DV. Microsoft Chromium Edge 기준으로 위와 같이 표시해준다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/129820843-1c77482f-bf84-47c4-a46b-ecfdf8149398.png)\r\n\r\n그 뿐만 아니라, IE로 접속했을 경우 주소창에 <span class=\"green-600\">Green Bar</span>를 적용하여 해당 도메인에 EV가 적용되었음을 시각적으로 알려준다. Chromium 기반 브라우저의 경우 시각적으로 표현해주진 않으니 참고할 것.\r\n\r\n인증서의 까다로운 심사절차로 인해 <span class=\"green-400\">발급하는데 걸리는 시간은 2주가 넘어가기도 하며, 비용 또한 매우 비싸다.</span> 하지만 <span class=\"red-400\">매우 강도 높은 신뢰성을 제공</span>한다.\r\n\r\n위와 같은 신뢰성 때문에, 이러한 신뢰성 보증이 필요한 공공기관, 금융권, 쇼핑몰과 같은 페이지에 사용된다. EV 인증서를 직접 보고싶다면, 아무 은행 홈페이지나 들어가보자.\r\n\r\n# 정리\r\n\r\nSSL이 적용되었는지 여부는 해당 사이트에 SSL 인증서가 있는지 여부를 통해 확인할 수 있다. 겉보기엔 SSL 인증서가 거기거 거기같지만 사실 그 종류만 해도 여러가지가 있으며, 인증서의 주체, 정책을 통해 현재 접속 중인 사이트의 SSL 종류를 확인할 수 있다.\r\n\r\nSSL을 적용하는 사이트의 성향에 따라 적합한 SSL 인증서를 발급받도록 하자.\r\n\r\n다음 장에서는 SSL 인증을 받기 위한 사전작업인 도메인 발급을 받아본다.","url":["2021-08-18-about-ssl-license","2021","08","18","about-ssl-license"]}],"data":{"header":{"title":"[SSL] SSL이란?","excerpt":"웹을 배포해본 적이 있다면 SSL에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 https://로 시작하며, http://와 달리 보안(Secure)을 의미하는 s가 붙는다. 지금 이 사이트의 주소도 https://blog.itcode.dev로 SSL이 적용된 걸 확인할 수 있다. NAVER나 Google도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-18T00:26:08","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","TLS"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-18-about-ssl.md","content":"<h1 id=\"개요\">개요 <a href=\"#개요\">🔗</a></h1><p>웹을 배포해본 적이 있다면 <span class=\"pink-600\">SSL</span>에 대해 들어본 적이 있을 것이다. SSL이 적용된 URL의 프로토콜은 <code class=\"inline-code\">https://</code>로 시작하며, <code class=\"inline-code\">http://</code>와 달리 <span class=\"blue-400\">보안(Secure)</span>을 의미하는 <code class=\"inline-code\">s</code>가 붙는다. 지금 이 사이트의 주소도 <a href=\"https://blog.itcode.dev\" target=\"_blank\">https://blog.itcode.dev</a>로 SSL이 적용된 걸 확인할 수 있다. <a href=\"https://naver.com\" target=\"_blank\">NAVER</a>나 <a href=\"https://google.com\" target=\"_blank\">Google</a>도 마찬가지. 이 처럼 SSL은 굳이 웹 개발자에게만 친숙한 개념이 아니다. 누구나 인터넷을 사용했다면, 좋든 싫든 모두가 SSL을 접했다고 봐도 무방하다.</p>\n<h1 id=\"SSL(Secure-Socket Layer)\">SSL(Secure Socket Layer) <a href=\"#SSL(Secure-Socket Layer)\">🔗</a></h1><p>그렇다면 이 <span class=\"pink-600\">SSL</span>이란 놈은 뭘까? SSL은 Secure Socket Layer의 약자로, 직역하면 암호화 소켓층이다. 1994년 Netscape사에서 처음 개발되어 3.0 버전까지 존재한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129691442-090810ed-30c5-4245-aa9d-9dd785f621a6.png\" alt=\"image\"></p>\n<p>SSL이란, <span class=\"amber-400\">웹 서버와 클라이언트의 통신 암호화 프로토콜</span>이다.</p>\n<p>SSL이 적용되지 않은 통신의 경우, 위 그림과 같이 평문(Plain Text)가 그대로 전송된다. 만약 제 3자가 어떠한 방식으로든 통신 패킷을 탈취할 경우, 그 내용을 쉽게 확인할 수 있다.</p>\n<p>통신 내용에 시덥잖은 것만 있다면 다행이겠지만, 사용자의 개인 정보나, 결제 정보와 같은 민감한 정보의 통신이라면 얘기가 달라진다.</p>\n<p>SSL을 적용한다면 이러한 문제를 기술적으로 해결할 수 있다. 요청을 암호화해서 보내므로 통신 패킷이 탈취되도 복호화 키가 없으면 원래 내용을 알 수 없기 때문이다.</p>\n<h2 id=\"TLS(Transport-Layer Security)\">TLS(Transport Layer Security) <a href=\"#TLS(Transport-Layer Security)\">🔗</a></h2><p>SSL을 접하다보면 <span class=\"pink-600\">TLS</span>라는 개념도 접하게 된다. 찾다보면 SSL이랑 TLS랑 혼재되어있기도 하고.</p>\n<p>SSL은 1996년에 3.0 버전이 출시되었으며, 보안취약점으로 인해 현재는 퇴출된 상태다.</p>\n<p>TLS는 국제 인터넷 표준화 기구(IETF)에서 개발한 것으로, SSL 3.0의 보안취약점을 보완한 통신 보안 프로토콜이다. 현재 TLS는 2018년 1.3 버전이 출시됏다.</p>\n<p>SSL을 보완한 것이 TLS지만, 인터넷에 적용되는 <span class=\"indigo-500\">통신 보안 프로토콜을 전부 통틀어서 SSL이라 부른다.</span></p>\n<p>하지만 정작 SSL은 2015년에 SSL의 마지막 버전인 3.0 마저 금지됐으므로, 현재 사용 중인 통신 보안 프로토콜은 모두 TLS다. 마치 호빵과 찐빵같은 상황인 셈.</p>\n<blockquote>\n<p><strong>호빵과 찐빵이 왜 나와</strong><br>우리가 흔히 호빵, 찐빵이라고 구분없이 부르는 음식의 정식 명칭은 <strong>찐빵</strong>이다. 호빵은 삼립식품에서 내놓은 찐빵 제품의 이름으로, 오랜 시간동안 유명해져 원래의 명칭을 대체하기도 한다.<br>비슷한 예로 초코파이, 대일밴드 등이 있다.</p>\n</blockquote>\n<h1 id=\"SSL의-특징\">SSL의 특징 <a href=\"#SSL의-특징\">🔗</a></h1><ol>\n<li>URL 프로토콜은 <code class=\"inline-code\">https</code>이며, 기본 포트는 <code class=\"inline-code\">443</code>이다.</li>\n<li>통신 데이터가 암호화되어, 패킷이 탈취되는 사고가 발생해도 데이터를 지킬 수 있다.</li>\n<li>SSL 인증서를 통해 도메인의 신뢰성을 검증할 수 있다.</li>\n<li>데이터 송/수신 과정에서 암/복호화가 발생하므로 속도가 느리다.</li>\n</ol>\n<h1 id=\"SSL의-원리\">SSL의 원리 <a href=\"#SSL의-원리\">🔗</a></h1><p>SSL의 통신하는 원리는 아래와 같으며, 이러한 일련의 과정을 HandShake라 한다. 클라이언트와 서버 간의 요청/응답을 반복하며 통신에 필요한 사전 작업을 하는게 마치 악수 같아 붙여졌다고 한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129752108-1423e7cf-3c4c-4e4c-a77a-7a76d208d7f8.png\" alt=\"image\"></p>\n<br />\n<br />\n\n<p class=\"large amber-600\">1. ClientHello 요청</p>\n\n<p>클라이언트가 특정 주소에 접근하면, 해당하는 서버에 요청을 보낸다. <a href=\"https://naver.com\" target=\"_blank\">NAVER</a>에 접근하면 네이버 서버에 요청을 보내게 된다.</p>\n<ul>\n<li>난수 데이터</li>\n<li>암호화 프로토콜 정보 (프로토콜, 버전 등)</li>\n<li>클라이언트가 사용 가능한 암호화 기법</li>\n<li>세션 아이디</li>\n<li>기타 확장 정보</li>\n</ul>\n<p>이 요청에는 위와 같은 정보들이 포함되어있다. 클라이언트의 주요 정보를 서버에 전송하여, 해당 클라이언트를 식별하고, 어떤 암호화를 사용할 수 있는 지 등의 정보를 서버가 인지하도록 한다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">2. ServerHello 응답</p>\n\n<p>서버가 ClientHello 요청을 받으면, 위의 정보를 담아 클라이언트에게 일종의 화답을 보낸다.</p>\n<ul>\n<li>난수 데이터 (ClientHello의 데이터와 다름)</li>\n<li>서버가 사용할 암호화 기법</li>\n<li>인증서<ul>\n<li>CA</li>\n<li>도메인</li>\n<li>공개키</li>\n</ul>\n</li>\n</ul>\n<p>난수 데이터는 ClientHello에서 보낸 데이터과 아무런 상관관계가 없는 별개의 데이터다.</p>\n<p>클라이언트가 사용 가능하다고 통보한 암호화 기법 중 서버에서 활용할 암호화 기법을 전달하여 동일한 암호화 기법으로 송수신할 수 있도록 선언한다.</p>\n<p>인증서 정보와 함께, 서버와의 암호화 통신을 위한 서버 공개키가 전달된다. 서버의 공개키로 데이터를 암호화하면 서버는 이를 받아 개인키로 복호화하여 요청을 분석할 수 있다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">3. 인증서 검토</p>\n\n<p>서버가 전달한 인증서가, 실제 해당 서버의 인증서인지, 신뢰할 수 있는 CA에서 발급된 것인지, 실제 해당 CA에서 발급받았는지 등 인증서를 검토한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129752361-4831de06-e99b-4f0c-9862-fe1f8ab5642a.png\" alt=\"image\"></p>\n<p>인증서에 이상이 없다면 주소창에 위와 같이 표시된다. (Microsoft Chromium Edge 기준)</p>\n<p>만약 문제가 있다면 아래와 같은 창을 보게 될 것이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/50317129/129752602-f9967221-3b82-487f-91c4-7fefc1cf3e94.png\" alt=\"image\"></p>\n<p>이는 브라우저가 사용자에게 보내는 경고문으로, 해당 사이트의 인증서가 올바르지 않으므로 신뢰할 수 없다고 경고하는 것이다.</p>\n<p>물론 사이트 관리자의 실수로 인증서가 만료됐거나, 잘못된 인증서를 교체해서 발생한 사소한 이유일 수도 있다. 하지만 낮선 사이트를 접속하는데 이와 같은 경고가 뜬다면, 정상적인 방법으로 인증서를 발급받을 수 없는 사이트일 가능성이 있으므로 접근을 자제하자.</p>\n<p>악의가 없는 사이트일지라도, 사용자의 데이터는 보호해주지 못 하니 주의할 것.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">4. Premaster Secret 송수신</p>\n\n<p>ClientHello, ServerHello에서 송수신한 난수 데이터를 조합하여 Premaster Secret을 생성한다.</p>\n<p>이를 ServerHello에서 전달받았던 공개키로 암호화한다. 이 데이터는 서버가 가진 개인키로만 복호화가 가능하다. 즉, 이 데이터는 탈취된다 하더라도 그 내용이 보호된다.</p>\n<p>서버는 수신된 데이터를 복호화하여 클라이언트와 동일한 Premaster Secret을 저장할 수 있다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">5. 통신 키 생성</p>\n\n<p>보유한 Premaster Secret을 토대로 Master Secret, Session Key를 생성한다. 이를 통해 클라이언트와 서버가 동일한 키를 보유하게 되므로 자신들끼리의 암호화 통신이 가능하다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">6. 데이터 송수신</p>\n\n<p>필요한 데이터는 저장된 Session Key를 통한 대칭키 암호화 방식으로 암/복호화하여 통신한다.</p>\n<br />\n<br />\n\n<p class=\"large amber-600\">7. 세션 종료</p>\n\n<p>클라이언트와의 연결이 끊겼을 경우 사용했던 Session Key는 폐기한다.</p>\n<h1 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h1><p>SSL은 통신 패킷을 암호화하여 패킷 탈취, 정보 누출 등을 방지하기 위한 보안 프로토콜이다.</p>\n<p>현재는 모두 TLS로 교체되었지만, SSL 자체가 고유명사되어 넓은 의미의 통신 보안 프로토콜을 명칭하는 의미로 쓰인다.</p>\n<p>현대에 이르러서는 웹 배포에 있어서 필수적인 사항이므로, 내용을 잘 이해하자.</p>\n<p>다음 장에서는 SSL 인증서에 대해 다룬다.</p>\n","url":["2021-08-18-about-ssl","2021","08","18","about-ssl"],"toc":[{"text":"개요","tag":"개요","depth":1},{"text":"SSL(Secure Socket Layer)","tag":"SSL(Secure-Socket Layer)","depth":1},{"text":"TLS(Transport Layer Security)","tag":"TLS(Transport-Layer Security)","depth":2},{"text":"SSL의 특징","tag":"SSL의-특징","depth":1},{"text":"SSL의 원리","tag":"SSL의-원리","depth":1},{"text":"정리","tag":"정리","depth":1}]},"hash":"29815e25018"},"__N_SSG":true}