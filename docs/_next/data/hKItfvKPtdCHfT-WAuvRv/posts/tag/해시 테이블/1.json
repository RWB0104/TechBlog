{"pageProps":{"posts":[{"header":{"title":"스택과 큐로 간결한 코드 생성","excerpt":"이 장에서는 스택과 큐에 대해 알아본다. 사실 이 두 자료구조는 배열에 특정한 제약을 건 자료구조다. 제약이라는 개념 때문에 특수한 상황에서만 쓰이지 않을까 싶지만, 오히려 이러한 제약이 주는 규칙으로 인해 굉장히 많은 곳에서 쓰인다. 스택과 큐의 가장 큰 특징은 데이터 처리에 순서가 있다는 점이다. 스택과 큐는 그 제약에 따라 반드시 정해진 순서로 데이터를 처리한다. 이러한 특징 덕에 순서가 필요한 작업들에 유용하게 사용된다. 대표적으로 스케쥴러, 대기 등이 있으며 OS의 인터럽트(Interrupt) 작업에서 스택이 쓰인다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-31T11:58:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","해시 테이블"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-31-about-algorithm-chapter08.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 8장 스택과 큐로 간결한 코드 생성\r\n\r\n이 장에서는 <span class=\"amber-400\">스택</span>과 <span class=\"amber-400\">큐</span>에 대해 알아본다. 사실 이 두 자료구조는 배열에 특정한 제약을 건 자료구조다. <span class=\"red-400\">제약</span>이라는 개념 때문에 특수한 상황에서만 쓰이지 않을까 싶지만, 오히려 이러한 제약이 주는 규칙으로 인해 굉장히 많은 곳에서 쓰인다.\r\n\r\n스택과 큐의 가장 큰 특징은 <span class=\"green-400\">데이터 처리에 순서</span>가 있다는 점이다. 스택과 큐는 그 제약에 따라 반드시 정해진 순서로 데이터를 처리한다. 이러한 특징 덕에 순서가 필요한 작업들에 유용하게 사용된다. 대표적으로 스케쥴러, 대기 등이 있으며 OS의 인터럽트(Interrupt) 작업에서 스택이 쓰인다.\r\n\r\n## 8-1. 스택\r\n\r\n<span class=\"amber-400\">스택</span>이 데이터를 관리하는 방식은 배열의 그것과 매우 유사하다. 아까도 말했듯이, 스택과 큐엔 특정한 제약이 걸려있으며 그 중 스택의 제약은 아래와 같다.\r\n\r\n* 데이터는 반드시 스택의 입구에서만 삽입할 수 있다.\r\n* 스택의 가장 끝에 위치한 데이터만 읽을 수 있다.\r\n* 스택의 가장 끝에 위치한 데이터만 삭제할 수 있다.\r\n\r\n스택의 입구는 하나 뿐이며, 이 <span class=\"red-400\">입구에서 모든 연산</span>이 일어난다. 길쭉한 프링글스 통을 연상하면 이해하기 쉽다. 프링글스 칩을 꺼내먹기 위해선 반드시 정해진 입구에서만 꺼내서 먹을 수 있으며, 맨 위의 칩만 꺼낼 수 있다. 스택의 데이터와 연산을 이에 대입하면 매우 유사하다.\r\n\r\n스택의 입구. 즉, 끝을 위(top)이라 하며, 스택의 가장 밑을 아래(bottom)라 한다. 스택의 연산은 두 가지로 나뉜다.\r\n\r\n| 구분  |     내용      |\r\n| :---: | :-----------: |\r\n| PUSH  | 데이터를 삽입 |\r\n|  POP  | 데이터를 삭제 |\r\n\r\n스택의 푸시 연산을 도식화하면 아래와 같다.\r\n\r\n1. 스택에 2를 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523633-6a838ba9-339f-4443-bfd7-bea18c4d6558.png\" width=\"200px\" />\r\n\r\n2. 스택에 6을 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523640-caec6583-e44a-43f8-95d0-678f1aac1523.png\" width=\"200px\" />\r\n\r\n3. 스택에 9를 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523649-7046261f-d896-4c24-bd68-648a795c8b58.png\" width=\"200px\" />\r\n\r\n푸시는 항상 스택의 위에서 이루어진다는 점을 기억하자.\r\n\r\n스택의 팝 연산은 아래와 같다.\r\n\r\n1. 스택에 9를 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523655-40e026a8-5631-41c8-a300-03d0ce237242.png\" width=\"200px\" />\r\n\r\n2. 스택에 6을 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127523665-e28389b1-27d0-4fb9-b29a-aa4c5278c253.png\" width=\"200px\" />\r\n\r\n이 과정 후엔 스택에 5만 남게된다. 스택은 항상 위에만 데이터를 삽입할 수 있으므로, 스택의 중간에 데이터를 삽입하려면 해당 위치까지 모든 데이터를 팝한 뒤 푸시해야한다.\r\n\r\n이렇게 먼저 들어온 게 가장 늦게 나가고. 반대로 가장 늦게 들어온 게 가장 빨리 나가는 걸 <span class=\"primary\">LIFO</span>(Last In, First Out)이라 한다.\r\n\r\n월요일의 출근길을 생각해보자. 최대한 늦게 들어가고 최대한 빨리 나오고 싶지 않은가?\r\n\r\n## 8-2. 스택 다뤄보기\r\n\r\n필자는 코드 규칙에 굉장히 민감한 편이다. 쓸데없이 예민해서, 내 방식대로 포맷팅이 되어있지 않은 소스는 리딩만으로도 스트레스를 받는다. 굳이 내 방식이 아니더라도 일관성있는 규칙이라면 그나마 나은데, 일관성도 없이 막 짠 코드를 보는 건 정말이지.... 가뜩이나 코드 리딩도 제대로 못 하는데 코드가 난잡하기까지 하면 당연히 답이 없을 것 같다.\r\n\r\n그래서 나는 ESLint를 굉장히 선호한다. TypeScript, HTML 등의 코드를 내가 정의한 규칙에 부합한지 알려주고, 틀리다면 수정까지 해준다. 나같이 코드 규칙에 예민한 사람에겐 필수품이나 다름없다.\r\n\r\n이렇게 코드를 정렬해주는 Lint는 언어별로 다른 규칙을 일일히 이해하고 틀린 부분을 잘 찾아야 하므로 딱 봐도 구현하기 매우 어려워 보인다. 이 문단에서는 스택을 활용하여 간단한 코드 Lint를 만들어본다.\r\n\r\n예를 들어, 아래와 같은 코드가 있다고 가정하자.\r\n\r\n``` javascript\r\n// 정상\r\nconst list1 = [ 1, 2, 3 ]\r\n\r\n// 오류1. 닫는 대괄호 없음\r\nconst list2 = [ 1, 2, 3\r\n\r\n// 오류2. 여는 대괄호 없음\r\nconst list3 = 1, 2, 3]\r\n\r\n// 오류3. 괄호 쌍이 맞지 않음\r\nconst list4 = (1, 2, 3]\r\n```\r\n\r\n모든 언어에서, 괄호는 항상 한 쌍으로 이루어진다. 따라서 `list1`을 제외한 나머지 코드에는 오류가 표시된다. 스택을 사용한다 해서 린트 구현이 쉬워지는 건 아니다. 온전한 동작을 하는 하나의 린트를 설계하는 것은 매우 어려우므로, 여기서는 <span class=\"green-400\">괄호</span>에 대해서만 생각한다.\r\n\r\n책에서 정의한 괄호 린트의 규칙은 아래와 같다.\r\n\r\n1. 괄호가 아닌 문자는 모두 무시한다.\r\n2. 여는 괄호가 나오면 스택에 푸시한다. 스택에 넣는다는 것은 해당 괄호가 닫히기를 기다린다는 의미이다.\r\n3. 닫는 괄호가 나오면 스택 위의 원소를 확인하고, 아래와 같이 분석한다.\r\n   * 스택에 원소가 없으면 이전에 여는 괄호가 나오지 않은 것으로, <span class=\"red-400\">오류 2</span>와 같다.\r\n   * 스택에 데이터가 있지만, 닫는 괄호가 스택 위에 있는 원소와 종류가 일치하지 않을 경우, <span class=\"red-400\">오류 3</span>과 같다.\r\n   * 닫는 괄호가 스택 위에 있는 원소와 괄호 종류가 같을 경우, 괄호가 성공적으로 닫혔으므로 정상적인 케이스다. 해당 괄호는 더 이상 기록할 필요가 없으므로 스택 위 원소를 POP한다.\r\n4. 줄 끝에 도달했는데, 스택에 여전히 원소가 남아있을 경우, 닫는 괄호가 없는 <span class=\"red-400\">오류 1</span>과 같다.\r\n\r\n정의한 규칙을 토대로 예제를 기술하면 아래와 같다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666476-c4e4a04d-bfc7-4a64-9861-554fab1c41d7.png\" width=\"400px\" />\r\n\r\n예제는 위 구문을 토대로 서술하며, 스택 역시 그림과 같다.\r\n\r\n1. 여는 소괄호를 스택에 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666490-27aa0e68-7d97-4285-9ab5-564b4ae3fa34.png\" width=\"400px\" />\r\n\r\n만약 닫는 괄호였다면 오류였을 것이다.\r\n\r\n2. 다음 괄호가 나올 때까지 포인터를 이동한다.\r\n\r\n`var`, `x` 등 괄호가 아닌 구문은 모두 무시한다. 이후부터는 2번 과정의 기술은 생략한다.\r\n\r\n3. 여는 중괄호를 스택에 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666497-84783779-d69a-49a2-941e-1c45fa3daafe.png\" width=\"400px\" />\r\n\r\n비록 스택 밑의 괄호와 종류는 다르지만, 둘 다 여는 괄호이므로 제대로 닫히기만 하면 오류는 아니다.\r\n\r\n4. 여는 대괄호를 스택에 푸시한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666504-41da2695-b18f-494c-bbc9-e63bd9199866.png\" width=\"400px\" />\r\n\r\n마찬가지로 스택에 푸시한다.\r\n\r\n5. 닫는 대괄호가 감지되었으므로, 스택의 맨 위 원소와 비교하여 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666509-840346c4-7b4a-4b33-ab01-cd0fc558b536.png\" width=\"400px\" />\r\n\r\n아래와 같을 경우 팝 연산이 가능하다.\r\n\r\n* 스택의 맨 위 괄호와 현재 포인터의 괄호 종류가 같다.\r\n* 스택의 맨 위 괄호는 반드시 여는 괄호다.\r\n\r\n이 경우 위 두 조건을 충족하므로, 여는 대괄호를 스택에서 팝하여 제거한다.\r\n\r\n6. 닫는 중괄호가 감지되었으므로, 스택의 맨 위 원소와 비교하여 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666517-95b68f96-48c9-4883-a1c5-765658a85bd2.png\" width=\"400px\" />\r\n\r\n여는 대괄호가 팝 연산으로 인해 스택에서 삭제되었으므로, 현재 스택의 가장 맨 위 요소는 여는 중괄호다. 조건을 충족하므로 마찬가지로 스택에서 팝하여 제거한다.\r\n\r\n7. 닫는 소괄호가 감지되었으므로, 스택의 맨 위 원소와 비교하여 팝한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127666523-8a33d330-933a-47fe-b3bc-e4bcbfde07d5.png\" width=\"400px\" />\r\n\r\n마찬가지로 조건을 충족하므로 요소를 팝한다.\r\n\r\n8. 코드 끝에 도달했으므로, 스택의 상태를 확인하여 오류 여부를 판단한다.\r\n\r\n코드의 모든 요소들을 확인했다. 만약 스택에 원소가 하나라도 남아있다면 해당 구문은 오류가 발생한 것이다.\r\n\r\n이 경우 스택에 원소가 하나도 없으므로 정상적인 구문으로 판단할 수 있다. 즉 위 구문에서 우리가 설계한 린트는 오류를 표시하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Stack;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 괄호 린트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/31/about-algorithm-chapter08/\">스택과 큐로 간결한 코드 생성</a>\r\n * @since 2021.07.30 Fri 23:30:56\r\n */\r\npublic class Linter\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString code = reader.readLine();\r\n\t\t\r\n\t\tchar c = lint(code);\r\n\t\t\r\n\t\t// 린트 결과가 정상일 경우\r\n\t\tif (c == '0')\r\n\t\t{\r\n\t\t\twriter.write(\"오류 없음\");\r\n\t\t}\r\n\t\t\r\n\t\t// 여는 괄호가 없을 경우\r\n\t\telse if (c == 'x')\r\n\t\t{\r\n\t\t\twriter.write(\"여는 괄호 존재하지 않음\");\r\n\t\t}\r\n\t\t\r\n\t\t// 닫는 괄호가 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(c);\r\n\t\t\twriter.write(\" 닫는 괄호 존재하지 않음\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 린트 결과 반환 함수\r\n\t *\r\n\t * @param text: [String] 구문\r\n\t *\r\n\t * @return [char] 린트 결과\r\n\t */\r\n\tprivate static char lint(String text)\r\n\t{\r\n\t\tStack<Character> stack = new Stack<>();\r\n\t\t\r\n\t\tfor (int i = 0; i < text.length(); i++)\r\n\t\t{\r\n\t\t\tchar c = text.charAt(i);\r\n\t\t\t\r\n\t\t\t// 여는 괄호일 경우\r\n\t\t\tif (isOpenBrace(c))\r\n\t\t\t{\r\n\t\t\t\tstack.push(c);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 닫는 괄호일 경우\r\n\t\t\telse if (isCloseBrace(c))\r\n\t\t\t{\r\n\t\t\t\t// 스택이 비어있을 경우\r\n\t\t\t\tif (stack.isEmpty())\r\n\t\t\t\t{\r\n\t\t\t\t\treturn 'x';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 스택이 비어있지 않을 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tchar co = stack.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 괄호가 서로 매칭되지 않을 경우\r\n\t\t\t\t\tif (!isMatched(co, c))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn co;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 스택이 비어이쓸 경우\r\n\t\tif (stack.isEmpty())\r\n\t\t{\r\n\t\t\treturn '0';\r\n\t\t}\r\n\t\t\r\n\t\t// 스택이 비어있지 않을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn stack.pop();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 여는 괄호 여부 반환 함수\r\n\t *\r\n\t * @param c: [char] 문자\r\n\t *\r\n\t * @return [boolean] 여는 괄호 여부\r\n\t */\r\n\tprivate static boolean isOpenBrace(char c)\r\n\t{\r\n\t\treturn c == '(' || c == '{' || c == '[';\r\n\t}\r\n\t\r\n\t/**\r\n\t * 닫는 괄호 여부 반환 함수\r\n\t *\r\n\t * @param c: [char] 문자\r\n\t *\r\n\t * @return [boolean] 여는 괄호 여부\r\n\t */\r\n\tprivate static boolean isCloseBrace(char c)\r\n\t{\r\n\t\treturn c == ')' || c == '}' || c == ']';\r\n\t}\r\n\t\r\n\t/**\r\n\t * 괄호 매칭 여부 반환 함수\r\n\t *\r\n\t * @param open: [char] 여는 괄호\r\n\t * @param close: [char] 닫는 괄호\r\n\t *\r\n\t * @return [boolean] 괄호 매칭 여부\r\n\t */\r\n\tprivate static boolean isMatched(char open, char close)\r\n\t{\r\n\t\t// 소괄호가 서로 매칭될 경우\r\n\t\tif (open == '(' && close == ')')\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 중괄호가 서로 매칭될 경우\r\n\t\telse if (open == '{' && close == '}')\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn open == '[' && close == ']';\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nconst a = (1 + 2 * 3;\r\n```\r\n\r\n``` output\r\n( 닫는 괄호 존재하지 않음\r\n```\r\n\r\n소스와 입출력은 위와 같다. 문자열을 하나하나 분석하여 여는 괄호가 있을 때까지 분석하여, 여는 괄호가 감지되면 스택에 푸시한다.\r\n\r\n분석 중에 닫는 괄호가 나오면, 스택을 팝하여 닫는 괄호와 종류가 일치하는지 비교한다. 만약 일치할 경우 계속 진행하며, 일치하지 않다면 관련 오류를 표시한다.\r\n\r\n``` java\r\nfor (int i = 0; i < text.length(); i++)\r\n{\r\n\tchar c = text.charAt(i);\r\n\t\r\n\t// 여는 괄호일 경우\r\n\tif (isOpenBrace(c))\r\n\t{\r\n\t\tstack.push(c);\r\n\t}\r\n\t\r\n\t// 닫는 괄호일 경우\r\n\telse if (isCloseBrace(c))\r\n\t{\r\n\t\t// 스택이 비어있을 경우\r\n\t\tif (stack.isEmpty())\r\n\t\t{\r\n\t\t\treturn 'x';\r\n\t\t}\r\n\t\t\r\n\t\t// 스택이 비어있지 않을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tchar co = stack.pop();\r\n\t\t\t\r\n\t\t\t// 괄호가 서로 매칭되지 않을 경우\r\n\t\t\tif (!isMatched(co, c))\r\n\t\t\t{\r\n\t\t\t\treturn co;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n해당 동작은 위 소스에서 제어한다. 또한 모든 동작 이후에도 스택에 원소가 남아있을 경우, 정상적으로 닫히지 않은 괄호가 있는 것이므로 역시 오류를 표시한다.\r\n\r\n``` java\r\n// 스택이 비어있을 경우\r\nif (stack.isEmpty())\r\n{\r\n\treturn '0';\r\n}\r\n\r\n// 스택이 비어있지 않을 경우\r\nelse\r\n{\r\n\treturn stack.pop();\r\n}\r\n```\r\n\r\n해당 동작은 모든 감지가 끝난 뒤, 위 소스에서 제어한다.\r\n\r\n이와 같이 스택은 가장 나중에 들어온 데이터를 먼저 처리해야할 경우에 굉장히 유용하다. 방금과 같은 린트나, 우리의 실수를 막아주는 `Ctrl + z` 등에 사용된다.\r\n\r\n## 8-3. 큐\r\n\r\n큐 역시 스택과 비슷하게 배열에 특정 규칙이 적용된 자료구조다. 큐의 제약사항은 아래와 같다.\r\n\r\n* 데이터는 큐의 끝에만 삽입할 수 있다. (스택과 동일)\r\n* 데이터는 큐의 앞에서만 읽을 수 있다. (스택과 반대)\r\n* 데이터는 큐의 앞에서만 삭제할 수 있다. (스택과 반대)\r\n\r\n스택과 골자는 비슷하나, 연산을 보면 살짝 다르다. 스택이 출입구가 하나로 통일된 형태라면, 큐는 출입구가 서로 나뉜 형태다. 스택은 프링글스 통을, 큐는 일반적인 파이프를 연상하면 쉽다. 단, 이 파이프는 한 쪽 방향으로만 흘러간다.\r\n\r\n스택과 달리 큐는 PUSH 같은 연산명이 따로 있진 않다. 큐의 연산을 도식화하면 아래와 같다.\r\n\r\n1. 큐에 8을 삽입한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694394-a849f2e6-591e-46f3-aef5-e94332f61df6.png\" width=\"400px\" />\r\n\r\n2. 큐에 93을 삽입한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694400-dfc6ccda-f609-4dcc-b9b0-4365fb21abf3.png\" width=\"400px\" />\r\n\r\n3. 큐에 51을 삽입한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694406-70a9119d-e29f-4ad9-9fa1-f3259c3b537f.png\" width=\"400px\" />\r\n\r\n여기까지는 스택의 PUSH 연산과 크게 다른 점이 없다.\r\n\r\n4. 큐의 8을 삭제한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694414-d59f5897-2f8c-481c-bd5f-e66c77875907.png\" width=\"400px\" />\r\n\r\n스택과 달리 큐는 데이터 입구의 반대편에서 데이터를 삭제할 수 있다.\r\n\r\n5. 큐의 93을 삭제한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694425-97870074-8a27-412f-945f-50c458f991d7.png\" width=\"400px\" />\r\n\r\n6. 큐의 51을 삭제한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/127694428-f3bb5a80-ec75-446a-b8f0-6d12b0d74abd.png\" width=\"400px\" />\r\n\r\n컨테이너 벨트처럼 순차적으로 처리하는 특징을 확인할 수 있다.\r\n\r\n## 8-4. 큐 다뤄보기\r\n\r\n스택과는 다른 방식으로 데이터를 순차적으로 처리하는 큐의 특성 덕분에 여러 곳에서 유용하게 쓰인다. 대기열이나 작업 예약 등 먼저 들어온 요소가 먼저 나가는 <span class=\"primary\">FIFO</span>(First In, First Out)으로 동작한다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.LinkedList;\r\nimport java.util.Objects;\r\nimport java.util.Queue;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 큐 프린터 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/31/about-algorithm-chapter08/\">스택과 큐로 간결한 코드 생성</a>\r\n * @since 2021.07.31 Sat 03:21:35\r\n */\r\npublic class Printer\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tQueue<String> queue = new LinkedList<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"출력할 문자열 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString work = reader.readLine();\r\n\t\t\t\r\n\t\t\t// 입력을 종료할 경우\r\n\t\t\tif (work.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 작업할 입력이 들어올 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tqueue.offer(work);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\twriter.write(\"[INFO] \");\r\n\t\t\twriter.write(Objects.requireNonNull(queue.poll()));\r\n\t\t\twriter.newLine();\r\n\t\t\twriter.flush();\r\n\t\t}\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nFirst Document\r\nSecond Document\r\nThird Document\r\nFourth Document\r\nFifth Document\r\nx\r\n```\r\n\r\n``` output\r\n[INFO] First Document\r\n[INFO] Second Document\r\n[INFO] Third Document\r\n[INFO] Fourth Document\r\n[INFO] Fifth Document\r\n```\r\n\r\n얼핏 보면 그냥 입력받은 순서대로 바로 콘솔에 뿌려주는 것 처럼 보이지만, 이는 소스가 간단하기 때문에 일어나는 착각이다.\r\n\r\n실제로 복잡한 작업을 하다보면, 조건에 따라 작업을 저장했다가 후에 순차적으로 후처리를 해야하는 등의 작업이 필요하다. 이런 경우에 큐의 특징은 매우 유용하다. \r\n\r\n우리가 흔히 아는 배열에 담아도 되지 않냐 반문할 수 있지만, 수시로 작업이 추가/삭제될 경우 배열은 그 인덱스를 신경써주어야한다. 반면 큐의 경우 작업의 IO에 있어서 정해진 규약이 있기 때문에 인덱스에 구애받지 않고 추가하고 삭제하면 된다.\r\n\r\n# 마무리\r\n\r\n이 장의 핵심은 아래와 같이 정리할 수 있다.\r\n\r\n* 스택은 후입선출(LIFO) 방식이다.\r\n* 스택은 원소의 추가/삭제 모두 스택의 위(TOP)에서 발생한다.\r\n* 스택 중간에 원소를 삽입하려면, 해당 위치에 도달할 때까지 모든 원소를 삭제해야한다.\r\n* 큐는 선입선출(FIFO) 방식이다.\r\n* 큐는 원소의 추가가 한 쪽, 삭제가 다른 쪽에서 각각 따로 발생한다.\r\n\r\n스택과 큐의 개념 자체는 어렵지 않았지만, JAVA에서 이를 다루는 것은 익숙치 않았었다. 이 장을 정리하면서 스택과 큐의 특성은 물론, JAVA에서 이를 어떻게 다루는 지도 알 수 있었다.\r\n\r\n다음 장에서는 반복적인 연산을 단축하는데 매우 효과적인 재귀에 대해 다룰 예정이다.","url":["2021-07-31-about-algorithm-chapter08","2021","07","31","about-algorithm-chapter08"]},{"header":{"title":"해시 테이블로 매우 빠른 룩업","excerpt":"현재까지 다룬 데이터 형식 중 다수의 데이터를 다루는 데 가장 효과적인 형식은 배열일 것이다. 하지만 배열의 경우, 요소별로 단 하나의 값이 들어가는 데 특화되어 있다. 만약 하나의 요소에 두 값을 넣고자 한다면 어떻게 될까? [[A, 1], [B, 2], [C, 3]]과 같은 형태로 나타낼 것이다. 배열의 단점 중 하나는, 값을 빠르게 찾기 위해선 반드시 정렬을 수행해야 한다는 것이다. 하지만 저렇게 배열 안에 또다른 배열이 포함되는 것처럼 배열의 depth가 심해질 경우 구조가 복잡해서 배열을 다루기 점점 난해해진다. 더군다나 배열의 경우 원하는 요소를 탐색하기 위해선 적어도 O(logN) 이상의 시간복잡도를 필요로 한다. 만약, 배열과 같이 특정 데이터의 모음에서 내가 원하는 데이터를 O(1)과 같이 상수 시간으로 탐색할 수 있는 데이터가 있다면 어떨까? 왠지 이 장에서 그 해답을 찾을 수 있을 것 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-29T23:02:27","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","해시 테이블"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-07-29-about-algorithm-chapter07.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 7장 해시 테이블로 매우 빠른 룩업\r\n\r\n현재까지 다룬 데이터 형식 중 다수의 데이터를 다루는 데 가장 효과적인 형식은 <span class=\"primary\">배열</span>일 것이다. 하지만 배열의 경우, 요소별로 단 하나의 값이 들어가는 데 특화되어 있다. 만약 하나의 요소에 두 값을 넣고자 한다면 어떻게 될까? $[ [ \"A\", 1 ], [ \"B\", 2 ], [ \"C\", 3 ] ]$과 같은 형태로 나타낼 것이다.\r\n\r\n배열의 단점 중 하나는, 값을 빠르게 찾기 위해선 반드시 정렬을 수행해야 한다는 것이다. 하지만 저렇게 배열 안에 또다른 배열이 포함되는 것처럼 배열의 depth가 심해질 경우 구조가 복잡해서 배열을 다루기 점점 난해해진다.\r\n\r\n더군다나 배열의 경우 원하는 요소를 탐색하기 위해선 적어도 $O(\\log N)$ 이상의 시간복잡도를 필요로 한다. 만약, 배열과 같이 특정 데이터의 모음에서 내가 원하는 데이터를 $O(1)$과 같이 상수 시간으로 탐색할 수 있는 데이터가 있다면 어떨까? 왠지 이 장에서 그 해답을 찾을 수 있을 것 같다.\r\n\r\n## 7-1. 해시 테이블 소개\r\n\r\n<span class=\"orange-A400\">JAVA</span>를 포함한 대부분의 프로그래밍 언어에선 <span class=\"teal-400\">Hash Table</span>(해시 테이블)이란 개념이 존재한다. 언어에 따라 부르는 용어는 해시나 맵, 해시 맵 등으로 불리지만 궁극적인 개념은 해시 테이블이다.\r\n\r\n``` java\r\nHashMap<String, String> map = new HashMap<>();\r\nmap.put(\"A\", \"1\");\r\nmap.put(\"B\", \"2\");\r\nmap.put(\"C\", \"3\");\r\nmap.put(\"D\", \"4\");\r\n```\r\n\r\n자바는 이를 `HashMap` 클래스로 관리한다. <span class=\"yellow-700\">JavaScript</span>와 다르게 미리 선언된 데이터 형식만 입력 가능하다는 특징이 있다. `A: 1`, `B: 2`와 같이 하나의 쌍으로 이루어진 데이터를 흔히 <span class=\"blue-400\">key-value</span> 데이터라고 한다. 해시 테이블은 이러한 key-value 데이터를 관리하는데 매우 효과적이다.\r\n\r\n``` java\r\nHashMap<String, String> map = new HashMap<>();\r\nmap.put(\"A\", \"1\");\r\nmap.put(\"B\", \"2\");\r\nmap.put(\"C\", \"3\");\r\nmap.put(\"D\", \"4\");\r\n\r\nSystem.out.println(map.get(\"A\"));\r\n```\r\n\r\nHashMap의 데이터에 접근하기 위해선 위처럼 원하는 value의 key를 입력하여 접근할 수 있다. 그런데 재밌는 점은, 해시 테이블의 경우 이렇게 탐색하는 데 필요한 작업량이 1이다. 즉, $O(1)$의 시간 복잡도를 가진다. 우리가 배열에서 갖가지 정렬을 배워가면서 탐색 속도를 향상시키기 위해 노력했는데, 이 친구는 뭐길래 이런 작업량이 가능한걸까?\r\n\r\n## 7-2. 해시 함수로 해싱\r\n\r\n<span class=\"primary\">해싱</span>이라는 개념에 대해 들어본 적이 있는가? 데이터를 고유한 값으로 반환하는 것을 해싱이라고 한다. 간단한 예를 들자면, 아래와 같이 매칭되는 표가 있다고 가정하자.\r\n\r\n|    키    |    값    |\r\n| :------: | :------: |\r\n|    A     |    1     |\r\n|    B     |    2     |\r\n|    C     |    3     |\r\n| $\\dotsb$ | $\\dotsb$ |\r\n|    Y     |    25    |\r\n|    Z     |    26    |\r\n\r\n위 표에 의거하면, `ABC = 123`, `EAD = 514`와 같이 변환될 것이다. 매우 허술하지만, 이러한 변환도 일종의 해싱이라고 할 수 있다. 위 표와 같이 변환해주는 알고리즘을 <span class=\"primary\">해시 함수</span>라 부른다.\r\n\r\n만약, 우리가 사용하려는 해시 함수가 A-Z의 키를 위 표에 매칭되는 숫자로 변경하고, 이를 다 더하는 알고리즘이라고 가정해보자. `FAD`를 변환하면 아래의 순서로 변환이 진행된다.\r\n\r\n1. 해시 함수에 의해 FAD가 614로 변환된다.\r\n2. 각 숫자를 더하여 6 + 1 + 4를 연산한다.\r\n3. 11이라는 해시값을 얻는다.\r\n\r\n이렇게 `FAD = 11`이라는 해싱을 얻을 수 있다. 해싱에는 아래와 같은 조건이 중요하다.\r\n\r\n* 정해진 값을 해싱하면 항상 동일한 결과를 반환한다. (FAD는 언제나 11을 반환해야 함)\r\n* 서로 다른 값이 동일한 해시값을 가질 수 없다.\r\n\r\n> 🔒 **해시 함수**  \r\n> 위의 예제와 달리, 해싱 함수는 대부분 복호화가 불가능한 비대칭 암호화 방식을 취한다. 또한 보안을 위해 Salt라는 임의의 난수를 포함하여 해싱함으로써, Brute Force를 방지하기도 한다.  \r\n> 이러한 특성으로 해싱은 사용자 이외에 그 누구도 알아서는 안 되는 비밀번호, 개인정보 등을 암호화하는데 쓰이며, 그 종류는 MD5, SHA-1, SHA-256, SHA-512 등이 있다.\r\n\r\n하지만 예제의 해싱 함수는 단순 이해를 돕기 위한 예시로, 실제 해싱과는 맞지 않다. 위 해시 함수에 의하면 `FAD`와 `ADF`, `DAF` 모두 동일한 값 11을 가진다. 이는 해시의 요건 중 하나인 <span class=\"red-500\">서로 다른 값이 동일한 해시값을 가질 수 없다</span>는 조건을 정면으로 위반한다.\r\n\r\n이러한 문제점에 대한 얘기는 후에 다룬다.\r\n\r\n## 7-3. 재미와 이익, 특히 이익을 남길 유의어 사전 만들기\r\n\r\n책에서 표현한 대로, 특정 단어를 입력하면 가장 핫한 유의어를 반환해주는 키치한 사전을 만든다고 가정해보자.\r\n\r\n해시는 이전 문단에서 사용한 표를 기준으로 하며, 변환된 숫자를 각각 곱한 값이 해싱 결과가 된다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   |       |\r\n|   7   |       |\r\n|   8   |       |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   |       |\r\n|  16   |       |\r\n\r\n이 때 내부적으로 동작하는 해시 테이블을 도식화하면 위와 같을 것이다. `bad: evil`이라는 key-value가 있을 경우, 해시 함수에 의해 아래와 같이 변환된다.\r\n\r\n1. `bad: evil`의 키 `bad`를 변환한다.\r\n2. 변환값 214를 얻는다.\r\n3. 각 숫자를 곱하여 해시값 $2 \\times 1 \\times 4 = 8$을 얻는다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   |       |\r\n|   7   |       |\r\n|   8   | evil  |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   |       |\r\n|  16   |       |\r\n\r\n위와 같이 8에 evil 데이터가 삽입된다. 추가로 `cab: taxi`를 해싱해보자. 해시값이 6이다, 또한 `ace: star`의 경우 해시값이 15다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   | taxi  |\r\n|   7   |       |\r\n|   8   | evil  |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   | star  |\r\n|  16   |       |\r\n\r\n해시 테이블의 현황은 위와 같을 것이다. 여기서 만약 이전에 저장된 값을 호출하려면 어떻게 될까?\r\n\r\n사용했던 키 중 하나dls `cab`의 데이터를 호출해보자. 해싱 알고리즘에 의해 6으로 변환된다.\r\n\r\n해시값을 구했으므로, 인덱스 6의 요소 `taxi`에 접근하면 된다. 별다른 탐색 없이도 간단하게 원하는 값에 접근한 것이다.\r\n\r\n이러한 방식으로 해시 테이블은 $O(1)$의 시간복잡도를 가진다.\r\n\r\n## 7-4. 충돌 해결\r\n\r\n이전에 잠깐 언급했던 해시의 요건이 있다.\r\n\r\n* 서로 다른 값이 동일한 해시값을 가질 수 없다.\r\n\r\n이전 문단의 해시 테이블에 `dab: pat`을 추가한다고 생각해보자. `dab`의 해시값은 8이다. 이제 테이블에 넣어주기만 하면 되는데, 문제가 있다.\r\n\r\n|  키   |                  값                   |\r\n| :---: | :-----------------------------------: |\r\n|   8   | evil <span class=\"red-400\">pat</span> |\r\n\r\n이미 8번 인덱스에 evil이 들어가있다. 이렇게 서로 다른 값의 해시값이 동일한 현상을 <span class=\"primary\">충돌</span>이라고 한다.\r\n\r\n가장 전통적이고 간단하 방법은, 동일한 위치에 값이 할당될 경우, 배열과 같이 이중 구조를 추가하는 것이다.\r\n\r\n|  키   |        값         |\r\n| :---: | :---------------: |\r\n|   8   | [ \"evil\", \"pat\" ] |\r\n\r\n즉, 위와 같이 배치하면 된다. 그렇다면 이 경우 검색은 어떻게 진행될까? 키가 `dab`인 테이터를 탐색해보자.\r\n\r\n1. `dab`의 해시값 8을 구한다.\r\n2. 8번 인덱스에 충돌로 인해 배열이 있음을 확인한다.\r\n3. 각 배열의 key를 확인하여 일치 여부를 반한다.\r\n\r\n이 경우 검색은 잘 될지 모르나, $O(N)$이라는 시간 복잡도를 가진다. $O(1)$의 시간 복잡도를 가질 정도로 빠른 데이터 형식이 순식간에 일반적인 배열와 동급이 되어버렸다. 아무리 봐도 좋은 현상은 아니다.\r\n\r\n결론적으론 해싱은 최대한 충돌이 일어나지 않도록 설계해야한다.\r\n\r\n## 7-5. 훌륭한 충돌 조정\r\n\r\n책에서는 해시 테이블의 효율성은 아래의 세 가지 요인에 좌우된다고 설명한다.\r\n\r\n* 해시 테이블에 얼마나 많은 데이터를 저장하는가\r\n* 해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가\r\n* 어떤 해시 함수를 사용하는가\r\n\r\n이전에 사용한 표의 매칭을 기준으로, 이번엔 변환된 각각의 숫자를 1의 자리가 될 때까지 더하는 함수를 사용한다고 가정하자.\r\n\r\n`put`의 경우 16 + 21 + 20 = 57의 변환값을 가지며, 다시 이 57을 각각 더하 5 + 7 = 12, 1 + 2 = 3으로 최종적으로 `put = 3`이 된다.\r\n\r\n|  키   |  값   |\r\n| :---: | :---: |\r\n|   1   |       |\r\n|   2   |       |\r\n|   3   |       |\r\n|   4   |       |\r\n|   5   |       |\r\n|   6   |       |\r\n|   7   |       |\r\n|   8   |       |\r\n|   9   |       |\r\n|  10   |       |\r\n|  11   |       |\r\n|  12   |       |\r\n|  13   |       |\r\n|  14   |       |\r\n|  15   |       |\r\n|  16   |       |\r\n\r\n위와 같은 해시 테이블이 있다고 가정하자. 16개의 할당 가능한 공간이 있지만, 해시 함수의 특성 상 언제나 1 ~ 9 사이의 해시값을 가지므로 10 ~ 16은 언제나 비어있다.\r\n\r\n즉, 해싱 테이블의 크기는 최소한 예상되는 해시값의 범위만큼 가지고 있어야한다. 만약 해시 범위가 1 ~ 10인데, 해시 테이블의 크기는 100이라고 한다면 충돌이 일어날 가능성은 매우 적겠지만 메모리 낭비가 너무 심하다.\r\n\r\n즉, <span class=\"red-400\">너무 많은 메모리를 낭비하지 않으면서 해시값을 전부 수용</span>할 수 있도록 적절히 충돌 조정을 수행해야한다.\r\n\r\n연구에 의하면 데이터가 7개일 때, 10개의 테이블 행이 있는 것이 이상적이다. 이를 <span class=\"primary\">부하율</span>이라고 하며, 부하율이 70%일 때가 최적이다. 다행히도 해시 테이블의 세부적인 사항은 컴파일러 단계에서 관리하니, 디테일한 튜닝을 하지 않는 이상 개발자가 신경쓸 부분은 없다.\r\n\r\n## 7-6. 실제 예제\r\n\r\n해시의 특성 덕분에 해시 테이블은 많은 곳에서 많은 용도로 사용되지만, 이 책에서는 해시 테이블을 통해 알고리즘의 속도를 높이는 데 초점을 맞추었다.\r\n\r\n1장에서 모든 요소가 중복되지 않는 <span class=\"primary\">집합</span>에 대해 다뤘다. 집합 알고리즘을 배열로 구성하면 탐색과 삽입 작업이 필요하며, 이 작업은 $O(N)$의 시간 복잡도를 가진다.\r\n\r\n모든 요소가 중복되지 않는 고유한 값을 가지는 집합의 특성은 여러 곳에서 굉장히 유용하게 쓸 수 있지만, $O(N)$이라는 선형적 시간 복잡도가 걸린다. 만약 여기서 탐색의 시간 복잡도가 $O(1)$을 가지는 해시 테이블을 적용한다면 어떨까?\r\n\r\n| 작업  |  집합  | 해시 테이블 |\r\n| :---: | :----: | :---------: |\r\n| 탐색  | $O(N)$ |   $O(1)$    |\r\n| 삽입  | $O(1)$ |   $O(1)$    |\r\n| 총합  | $O(N)$ |   $O(1)$    |\r\n\r\n위와 같이 작업량을 획기적으로 줄일 수 있을 것이다. 우리는 이미 4장에서 배열의 중복 요소를 체크하는 로직을 작성한 바 있다. 처음 설계한 알고리즘의 시간 복잡도는 $O(N^2)$였지만, 이후 개선을 통해 $O(N)$으로 단축할 수 있었다.\r\n\r\n``` java\r\n/**\r\n * 요소의 중복 여부 반환 함수\r\n *\r\n * @param array: [int[]] 배열\r\n *\r\n * @return [boolean] 중복 여부\r\n */\r\nprivate static boolean isDuplicated(int[] array)\r\n{\r\n\tfor (int i = 0; i < array.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < array.length; j++)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\tif (i != j && array[i] == array[j])\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n위 소스는 4장에서 다룬 중복 요소 체크 알고리즘 중 $O(N^2)$를 가지는 알고리즘이다. \r\n\r\n``` java\r\n/**\r\n * 요소의 중복 여부 반환 함수\r\n *\r\n * @param array: [int[]] 배열\r\n *\r\n * @return [boolean] 중복 여부\r\n */\r\nprivate static boolean isDuplicated(int[] array)\r\n{\r\n\tArrayList<Integer> list = new ArrayList<>();\r\n\t\r\n\tfor (int item : array)\r\n\t{\r\n\t\tcount++;\r\n\t\t\r\n\t\t// 중복되지 않았을 경우\r\n\t\tif (!list.contains(item))\r\n\t\t{\r\n\t\t\tlist.add(item);\r\n\t\t}\r\n\t\t\r\n\t\t// 중복된 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n위 소스는 4장에서 다룬 중복 요소 체크 알고리즘 중 $O(N)$을 가지는 알고리즘이다. 이러한 종류의 알고리즘을 해시 테이블을 활용하여 $O(1)$의 시간 복잡도를 가지게끔 줄여보자.\r\n\r\n책에서 제시한 주제대로, 투표자가 후보자 목록 중 하나를 고르거나, 임의의 후보를 추가할 수 있는 전자 투표 기계를 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 전자 투표 기계 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/29/about-algorithm-chapter07/\">해시 테이블로 매우 빠른 룩업</a>\r\n * @since 2021.07.29 Thu 22:15:32\r\n */\r\npublic class Vote\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString name = reader.readLine().trim();\r\n\t\t\t\r\n\t\t\t// x가 입력되었을 경우\r\n\t\t\tif (name.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 빈 문자가 입력되었을 경우\r\n\t\t\telse if (name.equals(\"\") || name.isEmpty())\r\n\t\t\t{\r\n\t\t\t\twriter.newLine();\r\n\t\t\t\twriter.write(\"올바른 이름을 입력하세요.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 일반적인 이름이 입력되었을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlist.add(name);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(list.toString());\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nJay\r\nPark\r\nKim\r\nPark\r\nKim\r\nJay\r\nJay\r\nJay\r\nPark\r\nKim\r\nx\r\n```\r\n\r\n``` output\r\n[Jay, Park, Kim, Park, Kim, Jay, Jay, Jay, Park, Kim]\r\n```\r\n\r\n소스와 입력, 출력은 위와 같다. 단순히 입력을 받아서 중복 여부 상관없이 배열에 이어 붙이므로, 시간 복잡도는 삽입 과정 하나만 있으며 $O(1)$이다.\r\n\r\n빠르기야 하다만, 후보자가 많거나, 투표자가 많아지면 정리하기 매우 힘들다. 전자는 분류할 케이스가 많아지고, 후자는 분류할 데이터가 많아지기 때문\r\n\r\n해시 테이블을 활용하여 후보의 이름과 후보의 투표수를 서로 매칭해서 심플하게 보여주면 어떨까?\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 해시 테이블을 적용한 전자 투표 기계 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/29/about-algorithm-chapter07/\">해시 테이블로 매우 빠른 룩업</a>\r\n * @since 2021.07.29 Thu 22:27:23\r\n */\r\npublic class HashVote\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString name = reader.readLine().trim();\r\n\t\t\t\r\n\t\t\t// x가 입력되었을 경우\r\n\t\t\tif (name.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 빈 문자가 입력되었을 경우\r\n\t\t\telse if (name.equals(\"\") || name.isEmpty())\r\n\t\t\t{\r\n\t\t\t\twriter.newLine();\r\n\t\t\t\twriter.write(\"올바른 이름을 입력하세요.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 일반적인 이름이 입력되었을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlist.add(name);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor (String name : list)\r\n\t\t{\r\n\t\t\t// 이미 등록된 이름일 경우\r\n\t\t\tif (map.containsKey(name))\r\n\t\t\t{\r\n\t\t\t\tmap.put(name, map.get(name) + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 등록되지 않은 이름일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmap.put(name, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(map.toString());\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nJay\r\nPark\r\nKim\r\nPark\r\nKim\r\nJay\r\nJay\r\nJay\r\nPark\r\nKim\r\nx\r\n```\r\n\r\n``` output\r\n{Jay=4, Kim=3, Park=3}\r\n```\r\n\r\n소스와 입출력은 위와 같다. Jay가 4표, 나머지가 3표를 받았다. 깔끔하게 잘 동작하지만, 투표가 끝난 뒤 일괄적으로 표를 계산하므로, 탐색 $O(N)$ 작업이 추가되어 시간 복잡도가 상수에서 선형으로 늘어나게 됐다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 해시 테이블을 적용한 향상된 전자 투표 기계 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/29/about-algorithm-chapter07/\">해시 테이블로 매우 빠른 룩업</a>\r\n * @since 2021.07.29 Thu 22:31:45\r\n */\r\npublic class ImproveHashVote\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tHashMap<String, Integer> map = new HashMap<>();\r\n\t\t\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\twriter.write(\"후보 이름 입력 (x: 종료) >> \");\r\n\t\t\twriter.flush();\r\n\t\t\t\r\n\t\t\tString name = reader.readLine().trim();\r\n\t\t\t\r\n\t\t\t// x가 입력되었을 경우\r\n\t\t\tif (name.equalsIgnoreCase(\"x\"))\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 빈 문자가 입력되었을 경우\r\n\t\t\telse if (name.equals(\"\") || name.isEmpty())\r\n\t\t\t{\r\n\t\t\t\twriter.newLine();\r\n\t\t\t\twriter.write(\"올바른 이름을 입력하세요.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 일반적인 이름이 입력되었을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 이미 등록된 이름일 경우\r\n\t\t\t\tif (map.containsKey(name))\r\n\t\t\t\t{\r\n\t\t\t\t\tmap.put(name, map.get(name) + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 등록되지 않은 이름일 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmap.put(name, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(map.toString());\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nJay\r\nPark\r\nKim\r\nPark\r\nKim\r\nJay\r\nJay\r\nJay\r\nPark\r\nKim\r\nx\r\n```\r\n\r\n``` output\r\n{Jay=4, Kim=3, Park=3}\r\n```\r\n\r\n표 수를 계산하는 과정을 마지막이 아닌, 투표를 할 때마다 실시간으로 카운팅한다. 기본적인 원리나 결과가 같지만, 그 속도가 다르다.\r\n\r\n이미 등록되었는지 아닌지에 따라 탐색 + 삽입 혹은 단순히 삽입으로 나누어지지만, 탐색 또한 $O(1)$의 시간 복잡도를 가지므로 최종적으로는 $O(1)$로 표현할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서 핵심 내용은 아래와 같다.\r\n\r\n* 해시 테이블은 key-value 형태의 값을 저장한다.\r\n* 해시 테이블은 key를 임의의 함수로 해싱하여 관리한다.\r\n* 해시 테이블의 탐색 시간 복잡도는 $O(1)$이다.\r\n* 해시 함수는 충돌이 적어야 한다.\r\n\r\nkey-value로 데이터를 저장하는 특성, 빠른 탐색 속도는 여러 알고리즘에서 유용하게 쓰일 것이다. 다음 장에서는 이와 더불어 매우 클래식한 자료구조인 <span class=\"amber-500\">스택</span>(Stack)과 <span class=\"amber-500\">큐</span>(Queue)에 대해 다뤄본다.","url":["2021-07-29-about-algorithm-chapter07","2021","07","29","about-algorithm-chapter07"]}],"categories":["CS","JAVA","Jekyll","React","WAS","WEB","알고리즘","잡담"],"images":["celeb1.gif","celeb10.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"해시 테이블","page":1},"__N_SSG":true}