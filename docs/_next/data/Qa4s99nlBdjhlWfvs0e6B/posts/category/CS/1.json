{"pageProps":{"posts":[{"header":{"title":"객체지향 프로그래밍(Object Oriented Programming)이란?","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-07T12:06:45","type":"posts","category":"CS","tag":["CS","객체지향"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-07-what-is-oop.md","content":"\r\n# OOP\r\n\r\nIT 업계에 종사하게 된다면 십중팔구 <span class=\"amber-400\">JAVA</span>, <span class=\"amber-400\">C++</span>, <span class=\"amber-400\">C#</span> 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 <span class=\"primary\">객체지향</span>언어라는 점이다.\r\n\r\n물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, <span class=\"amber-400\">C</span>의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.\r\n\r\n# 객체지향에 대해 설명해보세요.\r\n\r\n제목 그대로 위와 같은 질문을 받았다고 가정해보자. 난 이 질문의 명확한 답을 주지 못 한다. 자바 경험이 없지 않음에도 불구하고, 이론에는 크게 관심이 없기도 했고, 비전공자인 난 구태여 찾아보지 않는 이상 이와 같은 내용을 실무에서 습득하긴 어려웠다.\r\n\r\n내가 쓰는 언어가 어떤 방식으로 동작하는지 모른다면 그건 제대로 쓴다고 보긴 어렵다. 이 주제를 통해 객체지향의 개념에 대해 정리해보고자 한다.\r\n\r\n## 객체\r\n\r\n**객체**지향. 말 그대로 <span class=\"teal-400\">객체</span>를 지향하는 언어다. 객체지향에 대해 이해하기 위해선, 일단 이 방법론이 궁극적으로 지향하는 **객체**란 개념에 대해 이해할 필요가 있다.\r\n\r\n객체지향이 말하는 <span class=\"teal-400\">객체</span>란 프로그램 동작의 주체가 되는 요소를 의미한다. 이 객체는 유/무형을 가리지 않는다. 실체가 명확한 것일 수도 있고, 무형의 개념일 수도 있다.\r\n\r\n모든 객체는 상태와 동작을 가진다. 예를 들어, **TV**를 구매한다고 생각해보자. 대부분의 사람들은 TV의 디자인, 성능, 가격 등을 적절히 고려하여 TV를 구매할 것이다.\r\n\r\nTV의 색, 인치, 가격 등은 TV가 가진 상태라고 볼 수 있다. TV 채널 이동, 다시 보기, 넷플릭스 연결 등은 TV의 기능이라고 볼 수 있다.\r\n\r\n이렇게 모든 객체에는 <span class=\"green-400\">상태</span>와 <span class=\"green-400\">동작</span>이 존재한다.\r\n\r\n국내 객체지향 언어의 대표격인 <span class=\"amber-400\">JAVA</span>는 이러한 개념을 아래와 같이 접근한다.\r\n\r\n| 객체지향 |     JAVA      |\r\n| :------: | :-----------: |\r\n|   객체   |    클래스     |\r\n|   상태   |   멤버 변수   |\r\n|   동작   | 메소드 (함수) |\r\n\r\n여기 **자동차**라는 현실의 객체를 JAVA가 어떻게 클래스로 다루는지 예제를 통해 알아보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.05 22:06:24\r\n */\r\npublic class Car\r\n{\r\n\t// 시동 여부\r\n\tprivate final boolean IS_STARTED = false;\r\n\t\r\n\t// 최대 속력\r\n\tprivate final int MAX_SPEED;\r\n\t\r\n\t// 현재 속력\r\n\tprivate int speed;\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param maxSpeed: [int] 최대 속도\r\n\t */\r\n\tpublic Car(int maxSpeed)\r\n\t{\r\n\t\tMAX_SPEED = maxSpeed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 결과\r\n\t */\r\n\tpublic boolean startUp()\r\n\t{\r\n\t\treturn !IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 종료 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 종료 결과\r\n\t */\r\n\tpublic boolean shutdown()\r\n\t{\r\n\t\treturn IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 현재 속도 반환 함수\r\n\t *\r\n\t * @return [int] 현재 속도\r\n\t */\r\n\tpublic int getSpeed()\r\n\t{\r\n\t\treturn speed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void upSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 가속된 값이 최대 속도를 넘지 않을 경우\r\n\t\t\tif (MAX_SPEED >= speed + amount)\r\n\t\t\t{\r\n\t\t\t\tspeed += amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가속된 값이 최대 속도를 넘을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = MAX_SPEED;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 감속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void downSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 감속된 값이 0보다 클 경우\r\n\t\t\tif (0 <= speed - amount)\r\n\t\t\t{\r\n\t\t\t\tspeed -= amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 감속된 값이 0보다 작을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위의 코드 Car 클래스는 자동차라는 현실의 객체를 매우 간단한 형태로 구현한 클래스다.\r\n\r\n<br />\r\n\r\n* **멤버 변수** (상태)\r\n  * `IS_STARTED` 자동차 시동 여부\r\n  * `MAX_SPEED`: 최대 속도\r\n  * `speed`: 현재 속도\r\n\r\n<br />\r\n\r\n* **메소드** (동작)\r\n  * `startUp`: 엔진 시동\r\n  * `shutdown`: 엔진 정지\r\n  * `getSpeed`: 현재 속도 표시\r\n  * `upSpeed`: 가속\r\n  * `downSpeed`: 감속\r\n\r\n<br />\r\n\r\nCar 클래스의 요소는 위와 같이 구분된다. JAVA에서 이 객체를 사용하려면 메모리에 할당해야하고, 이렇게 할당된 객체를 <span class=\"teal-400\">인스턴스</span>(Instance)라 칭한다.\r\n\r\nCar 클래스를 메모리에 할당하여 새로운 인스턴스를 만드는 것은 현실에서 자동차 하나를 뽑는 것과 동일한 개념이다.\r\n\r\n## 객체지향\r\n\r\n객체**지향**이므로, 앞서 언급했듯이 이를 이해하기 위해선 객체를 이해해야한다. 이미 이전 문단에서 객체에 대해 장황하게 설명했으므로, <span class=\"teal-400\">객체지향</span>은 이러한 객체를 통해 코드를 구성하는 방법론이라 정의할 수 있다.\r\n\r\n모든 객체는 각 객체의 특성에 부합하는 상태와 동작을 가지며, 이를 통해 객체 간의 상호작용을 코드로 나타낼 수 있다. 객체지향은 이러한 객체의 상호작용을 코드로 나타낸다.\r\n\r\n일례로 JAVA는 `String`, `HashMap` 등, 모든 요소를 객체(Object)로 다룬다. 우리는 JAVA로 필요한 객체를 메모리에 할당하고, 객체가 가진 변수나 메소드를 사용하여 코딩한다. 이러한 JAVA의 프로그래밍 방식은 지금껏 설명한 객체지향의 그 것과 동일함을 알 수 있다.\r\n\r\n# 그래서 이걸 왜 쓰는데?\r\n\r\n객체지향을 차용한 언어는 매우 많다. 대표격인 JAVA 이외에도 C++, C#, Visual Basic, Swift, Python 등이 있다. 또한 이 언어들은 우리에게 매우 익숙한 이름일 뿐만 아니라, 프로그래밍 언어에서 다들 한 자리씩은 차지하는 매우 비중있는 언어들이다.\r\n\r\n그렇다면 객체지향 언어가 개발자들에게 그토록 널리 쓰이며, 사랑받을 수 있었던 이유는 무엇일까?\r\n\r\n객체지향은 절차지향의 후발주자다. 보통 이런 경우의 후발주자는 선발의 단점 혹은 니즈들을 개선하여 출시하므로 기능 혹은 편의성에서 많은 이점을 가진다. 객체지향은 특히 생산성과 유지보수 용이성을 높이는 데 포커스를 두었으며, 덕분에 객체지향 언어를 구사하는 개발자는 개발을 비교적 쉽고 빠르게 수행할 수 있다.\r\n\r\n## 장점\r\n\r\n* <span class=\"green-400\">코드 재사용성</span>  \r\n모듈화된 객체를 기반으로 코드가 작성되기 때문에, 해당 객체의 특징을 비슷한 다른 로직에도 적용해서 사용하거나, 다른 개발자가 구현한 객체를 가져와 쓰기에도 용이하다.\r\n\r\n* <span class=\"green-400\">간편한 유지보수</span>  \r\n객체를 수정할 경우, 해당 객체를 사용하는 모든 로직에 일괄적으로 적용되니, 중복 코드에 대한 관리가 간단해진다. 혹은 객체나 동작이 변경될 경우, 해당 객체나 동작과 연관된 객체만을 찾아 수정하면 된다.\r\n\r\n* <span class=\"green-400\">큰 규모의 프로그래밍에 유리</span>  \r\n객체, 모듈 단위로 구분되는 특징으로 인해 업무 분장이 쉽고, 각 모듈의 연관성을 도식하기 용이하다.\r\n\r\n## 단점\r\n\r\n* <span class=\"red-400\">비교적 느린 속도</span>  \r\n절차지향과 달리 객체지향은 각 객체의 의존 관계로 인해 대체적으로 속도가 느리다.\r\n\r\n* <span class=\"red-400\">높은 설계역량 요구</span>  \r\n모듈 단위의 상호작용으로 이루어진 방식은, 모듈의 정확한 명세와 상호 간의 연관성이 얼마나 짜임새있게 설계되었는지 중요하다. 잘 못 설계된 객체나 연관성은 라쟈나 코드로 변하기 쉽다.\r\n\r\n* <span class=\"red-400\">코드의 잠재적인 복잡성</span>  \r\n높은 수준의 설계역량 요구와 더불어 추상 객체, 상속, 인터페이스 등의 복잡한 개념과 그 활용은 코드의 구조를 파악하기 어렵게 만든다.\r\n\r\n# 객체지향을 사용하는 언어들\r\n\r\n* JAVA\r\n* C++\r\n* C#\r\n* Python\r\n* Simula 67\r\n* Delphi\r\n* Swift\r\n* Ruby\r\n* Perl\r\n\r\n<del class=\"grey-600\">대부분 아는 얼굴들이구만</del>\r\n\r\n# 정리\r\n\r\n기존의 C언어의 기반인 절차지향도 나름의 장점이 있었다. 컴퓨터의 처리 흐름과 코드의 흐름이 매우 유사하기 때문에 전처리가 적어 실행 속도가 비교적 빨랐다. 또한 코드의 흐름이 일정했으므로, 이를 분석하기도 수월했을 것이다.\r\n\r\n하지만 시대가 지남에 따라 시대가 발전했고, 개발자의 평균 역량 또한 높아졌다. 컴퓨터의 처리 속도는 언급할 필요조차 없었고. 이러한 환경의 발전으로 인해 절차지향의 장점이 주는 메리트가 적어지면서, 반대로 단점이 주는 디메리트가 더더욱 크게 다가왔을 것이다.\r\n\r\n객체지향은 유지보수의 용이성과 개발 편의성을 중요시 여기는 개발 방법론이다. 객체지향이 가지는 장점 덕분에 <span class=\"pink-400\">개발자 간의 코드 공유</span>가 쉬워졌으며, <span class=\"pink-400\">서비스의 규모는 더욱 증가</span>하고, <span class=\"pink-400\">견고한 프로그램</span>을 만들기 쉬워졌다.\r\n\r\n절차지향이 컴퓨터에게 친화적이라면, 객체지향은 개발자에게 친화적이라 할 수 있겠다. 컴퓨터의 성능이 미친듯이 높아짐에 따라, 프로그램의 성능은 자연스레 개발자의 역량에 갈리게 됐다. 이러한 흐름으로 인해 객체지향은 많은 언어, 개발자에게 사랑받을 수 있었을 것이다.\r\n\r\n요즘 AI 기술이 발달함에 따라 [Copilot](https://copilot.github.com/) 등 AI가 코딩을 보조해주는 기술이 연구되고, 등장하고 있는 것 같다.\r\n\r\n나중에 시간이 지나 개발자의 역량이 더 이상 중요하지 않게 되면 새로운 방법론이 대세가 되지 않을까?","url":["2021-08-07-what-is-oop","2021","08","07","what-is-oop"]},{"header":{"title":"Compiler(컴파일러) & Interpreter(인터프리터)","excerpt":"천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다. 하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 컴퓨터가 알아먹을 수 있어야 실행된다는 얘기다. 글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 컴퓨터는 개발 이래로 초지일관 기계어만을 고집한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.","coverImage":"https://user-images.githubusercontent.com/50317129/120613280-0a79f980-c491-11eb-81a9-15e63062db75.png","date":"2021-06-03T17:25:23","type":"posts","category":"CS","tag":["Compiler(컴파일러)","Interpreter(인터프리터)"],"comment":true,"publish":true},"name":"2021-06-03-compiler-interpreter.md","content":"\r\n# 컴파일러와 인터프리터\r\n\r\n천공카드 이래로 지금까지 컴퓨터 언어는 무수히 많은 발전을 거듭했다. 현재에 이르러서는 개발된 언어끼리의 시너지가 일어나 하루가 멀다하고 새로운 언어, 개념이 생성되고 있다.\r\n\r\n하지만 그 아무리 새로운 언어로 구현한 소프트웨어라 하더라도, 결과적으로 프로그램의 실행 주체는 컴퓨터에게 있다. 우리가 아무리 새로운 언어니, 프레임워크니, 기술이니 지지고 볶고 하더라도 결국은 <span class=\"blue-500\">컴퓨터가 알아먹을 수 있어야 실행된다</span>는 얘기다.\r\n\r\n글로벌 시대답게 초등학생도 1개 이상의 외국어를 하는 마당에, 안타깝게도 우리 <span class=\"blue-500\">컴퓨터는 개발 이래로 초지일관 기계어만을 고집</span>한다. 한글, 영어는 고사하고 우리가 개발할 때 사용하는 프로그래밍 언어라고 하는 대부분의 언어들. 심지어 C언어 보다도 저수준인 어셈블리어 조차 컴퓨터 입장에서는 외계어와 다를 바 없다.\r\n\r\n우리가 일상생활에서 외국어를 접할 때, 번역기라는 걸 사용해서 한글로 번역하면 우리가 비교적 쉽게 이해할 수 있다. 그렇다면 이 프로그래밍 언어들을 컴퓨터가 이해할 수 있는 기계어로 번역해준다면, 컴퓨터는 우리가 짠 코드를 이해하고 코드를 실행시킬 수 있을 것이다. 이를 위해 <span class=\"blue-500\">모든 언어는 해당 언어를 기계어로 번역할 수 있는 도구를 사용하여 기계어로 번역</span>한다. 이 번역기들은 방식에 따라 크게 두 가지로 구분할 수 있는데, <span class=\"green-500\">컴파일러</span>와 <span class=\"pink-500\">인터프리터</span>다.\r\n\r\n# Compiler(컴파일러)\r\n\r\n<span class=\"green-500\">컴파일러</span>는 소스코드 전체를 기계어로 번역해주는 도구다. 기계어로 번역된 결과물이 생성되고, 프로그램 실행 시 번역한 결과물을 실행한다. 굳이 기계어가 아니더라도, 원래의 원시코드(소스코드) 전체를 목적코드(기계어 등)로 번역한다면 <span class=\"green-500\">컴파일러</span>라 할 수 있다. 핵심은 전체 원시코드를 다른 코드로 변환함에 있다. <span class=\"green-500\">컴파일러</span> 아래와 같은 특징을 가지고 있다.\r\n\r\n1. <b class=\"primary\">소스코드 전체 번역</b>  \r\n   이러한 특징으로 별도의 컴파일 시간이 요구되며, 코드 한 글짜만 변경하더라도 재컴파일을 수행해야 한다. 코드의 규모가 클 수록 컴파일에 요구되는 시간 또한 늘어난다.\r\n\r\n2. <b class=\"primary\">빠른 속도</b>  \r\n   이미 컴파일을 수행하여 기계어로 번역했기 때문에, 프로그램 실행 시점엔 컴퓨터가 별다른 작업 없이 해당 프로그램을 이해할 수 있다. 즉, 실행 속도가 <span class=\"pink-500\">인터프리터</span>에 비해 대체적으로 빠르다.\r\n\r\n3. <b class=\"primary\">플랫폼 의존성</b>  \r\n   <span class=\"green-500\">컴파일러</span>는 컴파일한 컴퓨터의 CPU, OS에 해당하는 기계어로 번역한다. 즉, CPU나 OS의 구조가 다른 컴퓨터에선 정상적인 동작을 보증할 수 없다. 이와 더불어, 특정 PC에 맞게 컴파일하려면 특정 PC의 CPU와 OS를 가진 컴퓨터가 필요하다.\r\n\r\n4. <b class=\"primary\">강한 보안</b>  \r\n   소스코드의 결과물이 기계어로 번역된 실행 파일이므로 보안이 상대적으로 우수하다. 단, 이는 어디까지나 상대적인 것으로, 실행 파일의 암호화나 소스코드의 난독화가 되어있지 않을 경우, 디컴파일, 해킹같은 분석기법을 통해 코드를 역설계할 수도 있다. 물론 이 자체로도 큰 분야이므로 많은 기술력을 요한다.\r\n\r\n<span class=\"green-500\">컴파일러</span>를 차용하는 언어는 아래와 같다.\r\n\r\n* C계열 (C, C++, C#)\r\n* FORTRAN\r\n* Go\r\n* JAVA (기본적으론 컴파일러 방식)\r\n* Pascal\r\n* Rust\r\n* Visual Basic\r\n\r\n대체적으로 초창기에 출시된, 역사가 깊은 언어가 대부분이다.\r\n\r\n지금의 컴퓨터와 달리, 초창기 컴퓨터들은 사양이 그리 좋지 못 했다. VGA대란을 무시하고 보편적인 하이엔드급 컴퓨터 본체가 대략 200만원 선임을 감안할 때, 동일한 가격으로 90년대 컴퓨터는 CPU가 Intel Pentium 100, RAM은 8MB, HDD는 1GB였다. RAM의 경우 단위를 GB로 바꿔도 다소 부족함을 감안한다면 실로 엄청난 차이.\r\n\r\n이러한 점으로 미루어보아 컴퓨터 자원을 낭비할 수 없었음이 당연할 것이다. 때문에 선처리 과정이 얼마나 걸리든 관계없이, 컴퓨터에서 가능한한 빠르고 가볍게 실행하는 것이 최우선 과제였을 것이다. 이러한 상황에서 초창기 언어들이 <span class=\"green-500\">컴파일러</span>를 차용한 것은 당연한 것이다.\r\n\r\n# Interpreter(인터프리터)\r\n\r\n<span class=\"pink-500\">인터프리터</span>는 실행 시 코드를 한 줄씩 읽어서 기계어로 번역하는 도구다. 한 줄씩 읽어서 실행하므로 별도의 결과물이 생성되지 않아 소스코드 자체가 실행 파일이 된다. 마찬가지로 굳이 기계어가 아니더라도 원래의 코드를 한 줄씩 읽어서 중간코드(기계어 등)으로 변환하여 실행한다면 <span class=\"pink-500\">인터프리터</span>라 할 수 있다. 핵심은 <span class=\"blue-500\">원시코드를 한 줄씩 읽어서 변환함</span>에 있다. <span class=\"pink-500\">인터프리터</span>는 아래와 같은 특징을 가지고 있다.\r\n\r\n1. <b class=\"primary\">소스코드 한줄 씩 변경</b>  \r\n   실행할 때마다 코드를 읽어서 번역하므로 컴파일이라는 작업 자체가 존재하지 않는다. 때문에 생산성이 매우 높다.\r\n\r\n2. <b class=\"primary\">느린 속도</b>  \r\n   컴파일 작업이 없는 대신, 프로그램 실행 시 코드 한 줄마다 작은 컴파일 작업이 이루어진다고 생각하면 된다. 때문에 <span class=\"green-500\">컴파일러</span>에 비해 상대적으로 실행 속도가 느리다.\r\n\r\n3. <b class=\"primary\">플랫폼 독립성</b>  \r\n   소스코드를 통해 프로그램을 실행하므로 컴퓨터의 CPU, OS의 영향을 받지 않는다. 해당 소스코드를 실행할 환경만 구축한다면, 어디서나 동일한 동작을 보증한다.\r\n\r\n4. <b class=\"primary\">약한 보안</b>  \r\n   소스코드 자체가 실행 파일이므로 코드가 유출되기 매우 쉽다. 중요한 동작이나 정보를 다룰 경우 난독화나 암호화를 반드시 해야한다. 이러한 보안작업은 오히려 프로그램의 실행 속도를 더욱 낮추기도 한다.(복호화 등의 작업 추가됨)\r\n\r\n<span class=\"pink-500\">인터프리터</span>를 차용하는 언어는 아래와 같다.\r\n\r\n* HTML\r\n* JavaScript\r\n* PHP\r\n* Python\r\n* Ruby\r\n\r\n<span class=\"green-500\">컴파일러</span>와 달리 비교적 젊은 언어들이 차지하고 있다. 현대에 들어서면서 컴퓨터의 성능이 급격히 좋아짐에 따라 연산 속도도 증가했다. 이와 더불어 시간이 지나면서 인터프리터의 속도 이슈를 해결할 여러 기술들이 개발되기도 했다. 이와 같은 노력들이 <span class=\"pink-500\">인터프리터</span>의 단점을 상쇄시켜줌에 따라 <span class=\"pink-500\">인터프리터</span>의 장점인 높은 생산성이 부각됐다. 이러한 이유로 <span class=\"pink-500\">인터프리터</span>의 언어는 비교적 최신 언어에 많이 적용되어있다.","url":["2021-06-03-compiler-interpreter","2021","06","03","compiler-interpreter"]}],"categories":["CS","JAVA","Jekyll","React","WAS","WEB","알고리즘","잡담"],"images":["celeb1.gif","celeb10.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"category":"CS","page":1},"__N_SSG":true}