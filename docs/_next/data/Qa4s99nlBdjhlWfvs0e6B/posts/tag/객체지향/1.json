{"pageProps":{"posts":[{"header":{"title":"객체지향 프로그래밍(Object Oriented Programming)이란?","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-07T12:06:45","type":"posts","category":"CS","tag":["CS","객체지향"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-07-what-is-oop.md","content":"\r\n# OOP\r\n\r\nIT 업계에 종사하게 된다면 십중팔구 <span class=\"amber-400\">JAVA</span>, <span class=\"amber-400\">C++</span>, <span class=\"amber-400\">C#</span> 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 <span class=\"primary\">객체지향</span>언어라는 점이다.\r\n\r\n물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, <span class=\"amber-400\">C</span>의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.\r\n\r\n# 객체지향에 대해 설명해보세요.\r\n\r\n제목 그대로 위와 같은 질문을 받았다고 가정해보자. 난 이 질문의 명확한 답을 주지 못 한다. 자바 경험이 없지 않음에도 불구하고, 이론에는 크게 관심이 없기도 했고, 비전공자인 난 구태여 찾아보지 않는 이상 이와 같은 내용을 실무에서 습득하긴 어려웠다.\r\n\r\n내가 쓰는 언어가 어떤 방식으로 동작하는지 모른다면 그건 제대로 쓴다고 보긴 어렵다. 이 주제를 통해 객체지향의 개념에 대해 정리해보고자 한다.\r\n\r\n## 객체\r\n\r\n**객체**지향. 말 그대로 <span class=\"teal-400\">객체</span>를 지향하는 언어다. 객체지향에 대해 이해하기 위해선, 일단 이 방법론이 궁극적으로 지향하는 **객체**란 개념에 대해 이해할 필요가 있다.\r\n\r\n객체지향이 말하는 <span class=\"teal-400\">객체</span>란 프로그램 동작의 주체가 되는 요소를 의미한다. 이 객체는 유/무형을 가리지 않는다. 실체가 명확한 것일 수도 있고, 무형의 개념일 수도 있다.\r\n\r\n모든 객체는 상태와 동작을 가진다. 예를 들어, **TV**를 구매한다고 생각해보자. 대부분의 사람들은 TV의 디자인, 성능, 가격 등을 적절히 고려하여 TV를 구매할 것이다.\r\n\r\nTV의 색, 인치, 가격 등은 TV가 가진 상태라고 볼 수 있다. TV 채널 이동, 다시 보기, 넷플릭스 연결 등은 TV의 기능이라고 볼 수 있다.\r\n\r\n이렇게 모든 객체에는 <span class=\"green-400\">상태</span>와 <span class=\"green-400\">동작</span>이 존재한다.\r\n\r\n국내 객체지향 언어의 대표격인 <span class=\"amber-400\">JAVA</span>는 이러한 개념을 아래와 같이 접근한다.\r\n\r\n| 객체지향 |     JAVA      |\r\n| :------: | :-----------: |\r\n|   객체   |    클래스     |\r\n|   상태   |   멤버 변수   |\r\n|   동작   | 메소드 (함수) |\r\n\r\n여기 **자동차**라는 현실의 객체를 JAVA가 어떻게 클래스로 다루는지 예제를 통해 알아보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.05 22:06:24\r\n */\r\npublic class Car\r\n{\r\n\t// 시동 여부\r\n\tprivate final boolean IS_STARTED = false;\r\n\t\r\n\t// 최대 속력\r\n\tprivate final int MAX_SPEED;\r\n\t\r\n\t// 현재 속력\r\n\tprivate int speed;\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param maxSpeed: [int] 최대 속도\r\n\t */\r\n\tpublic Car(int maxSpeed)\r\n\t{\r\n\t\tMAX_SPEED = maxSpeed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 결과\r\n\t */\r\n\tpublic boolean startUp()\r\n\t{\r\n\t\treturn !IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시동 종료 결과 반환 함수\r\n\t *\r\n\t * @return [boolean] 시동 종료 결과\r\n\t */\r\n\tpublic boolean shutdown()\r\n\t{\r\n\t\treturn IS_STARTED;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 현재 속도 반환 함수\r\n\t *\r\n\t * @return [int] 현재 속도\r\n\t */\r\n\tpublic int getSpeed()\r\n\t{\r\n\t\treturn speed;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 가속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void upSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 가속된 값이 최대 속도를 넘지 않을 경우\r\n\t\t\tif (MAX_SPEED >= speed + amount)\r\n\t\t\t{\r\n\t\t\t\tspeed += amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 가속된 값이 최대 속도를 넘을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = MAX_SPEED;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 감속 함수\r\n\t *\r\n\t * @param amount: [int] 속도\r\n\t */\r\n\tpublic void downSpeed(int amount)\r\n\t{\r\n\t\t// 시동이 걸렸을 경우\r\n\t\tif (IS_STARTED)\r\n\t\t{\r\n\t\t\t// 감속된 값이 0보다 클 경우\r\n\t\t\tif (0 <= speed - amount)\r\n\t\t\t{\r\n\t\t\t\tspeed -= amount;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 감속된 값이 0보다 작을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tspeed = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n위의 코드 Car 클래스는 자동차라는 현실의 객체를 매우 간단한 형태로 구현한 클래스다.\r\n\r\n<br />\r\n\r\n* **멤버 변수** (상태)\r\n  * `IS_STARTED` 자동차 시동 여부\r\n  * `MAX_SPEED`: 최대 속도\r\n  * `speed`: 현재 속도\r\n\r\n<br />\r\n\r\n* **메소드** (동작)\r\n  * `startUp`: 엔진 시동\r\n  * `shutdown`: 엔진 정지\r\n  * `getSpeed`: 현재 속도 표시\r\n  * `upSpeed`: 가속\r\n  * `downSpeed`: 감속\r\n\r\n<br />\r\n\r\nCar 클래스의 요소는 위와 같이 구분된다. JAVA에서 이 객체를 사용하려면 메모리에 할당해야하고, 이렇게 할당된 객체를 <span class=\"teal-400\">인스턴스</span>(Instance)라 칭한다.\r\n\r\nCar 클래스를 메모리에 할당하여 새로운 인스턴스를 만드는 것은 현실에서 자동차 하나를 뽑는 것과 동일한 개념이다.\r\n\r\n## 객체지향\r\n\r\n객체**지향**이므로, 앞서 언급했듯이 이를 이해하기 위해선 객체를 이해해야한다. 이미 이전 문단에서 객체에 대해 장황하게 설명했으므로, <span class=\"teal-400\">객체지향</span>은 이러한 객체를 통해 코드를 구성하는 방법론이라 정의할 수 있다.\r\n\r\n모든 객체는 각 객체의 특성에 부합하는 상태와 동작을 가지며, 이를 통해 객체 간의 상호작용을 코드로 나타낼 수 있다. 객체지향은 이러한 객체의 상호작용을 코드로 나타낸다.\r\n\r\n일례로 JAVA는 `String`, `HashMap` 등, 모든 요소를 객체(Object)로 다룬다. 우리는 JAVA로 필요한 객체를 메모리에 할당하고, 객체가 가진 변수나 메소드를 사용하여 코딩한다. 이러한 JAVA의 프로그래밍 방식은 지금껏 설명한 객체지향의 그 것과 동일함을 알 수 있다.\r\n\r\n# 그래서 이걸 왜 쓰는데?\r\n\r\n객체지향을 차용한 언어는 매우 많다. 대표격인 JAVA 이외에도 C++, C#, Visual Basic, Swift, Python 등이 있다. 또한 이 언어들은 우리에게 매우 익숙한 이름일 뿐만 아니라, 프로그래밍 언어에서 다들 한 자리씩은 차지하는 매우 비중있는 언어들이다.\r\n\r\n그렇다면 객체지향 언어가 개발자들에게 그토록 널리 쓰이며, 사랑받을 수 있었던 이유는 무엇일까?\r\n\r\n객체지향은 절차지향의 후발주자다. 보통 이런 경우의 후발주자는 선발의 단점 혹은 니즈들을 개선하여 출시하므로 기능 혹은 편의성에서 많은 이점을 가진다. 객체지향은 특히 생산성과 유지보수 용이성을 높이는 데 포커스를 두었으며, 덕분에 객체지향 언어를 구사하는 개발자는 개발을 비교적 쉽고 빠르게 수행할 수 있다.\r\n\r\n## 장점\r\n\r\n* <span class=\"green-400\">코드 재사용성</span>  \r\n모듈화된 객체를 기반으로 코드가 작성되기 때문에, 해당 객체의 특징을 비슷한 다른 로직에도 적용해서 사용하거나, 다른 개발자가 구현한 객체를 가져와 쓰기에도 용이하다.\r\n\r\n* <span class=\"green-400\">간편한 유지보수</span>  \r\n객체를 수정할 경우, 해당 객체를 사용하는 모든 로직에 일괄적으로 적용되니, 중복 코드에 대한 관리가 간단해진다. 혹은 객체나 동작이 변경될 경우, 해당 객체나 동작과 연관된 객체만을 찾아 수정하면 된다.\r\n\r\n* <span class=\"green-400\">큰 규모의 프로그래밍에 유리</span>  \r\n객체, 모듈 단위로 구분되는 특징으로 인해 업무 분장이 쉽고, 각 모듈의 연관성을 도식하기 용이하다.\r\n\r\n## 단점\r\n\r\n* <span class=\"red-400\">비교적 느린 속도</span>  \r\n절차지향과 달리 객체지향은 각 객체의 의존 관계로 인해 대체적으로 속도가 느리다.\r\n\r\n* <span class=\"red-400\">높은 설계역량 요구</span>  \r\n모듈 단위의 상호작용으로 이루어진 방식은, 모듈의 정확한 명세와 상호 간의 연관성이 얼마나 짜임새있게 설계되었는지 중요하다. 잘 못 설계된 객체나 연관성은 라쟈나 코드로 변하기 쉽다.\r\n\r\n* <span class=\"red-400\">코드의 잠재적인 복잡성</span>  \r\n높은 수준의 설계역량 요구와 더불어 추상 객체, 상속, 인터페이스 등의 복잡한 개념과 그 활용은 코드의 구조를 파악하기 어렵게 만든다.\r\n\r\n# 객체지향을 사용하는 언어들\r\n\r\n* JAVA\r\n* C++\r\n* C#\r\n* Python\r\n* Simula 67\r\n* Delphi\r\n* Swift\r\n* Ruby\r\n* Perl\r\n\r\n<del class=\"grey-600\">대부분 아는 얼굴들이구만</del>\r\n\r\n# 정리\r\n\r\n기존의 C언어의 기반인 절차지향도 나름의 장점이 있었다. 컴퓨터의 처리 흐름과 코드의 흐름이 매우 유사하기 때문에 전처리가 적어 실행 속도가 비교적 빨랐다. 또한 코드의 흐름이 일정했으므로, 이를 분석하기도 수월했을 것이다.\r\n\r\n하지만 시대가 지남에 따라 시대가 발전했고, 개발자의 평균 역량 또한 높아졌다. 컴퓨터의 처리 속도는 언급할 필요조차 없었고. 이러한 환경의 발전으로 인해 절차지향의 장점이 주는 메리트가 적어지면서, 반대로 단점이 주는 디메리트가 더더욱 크게 다가왔을 것이다.\r\n\r\n객체지향은 유지보수의 용이성과 개발 편의성을 중요시 여기는 개발 방법론이다. 객체지향이 가지는 장점 덕분에 <span class=\"pink-400\">개발자 간의 코드 공유</span>가 쉬워졌으며, <span class=\"pink-400\">서비스의 규모는 더욱 증가</span>하고, <span class=\"pink-400\">견고한 프로그램</span>을 만들기 쉬워졌다.\r\n\r\n절차지향이 컴퓨터에게 친화적이라면, 객체지향은 개발자에게 친화적이라 할 수 있겠다. 컴퓨터의 성능이 미친듯이 높아짐에 따라, 프로그램의 성능은 자연스레 개발자의 역량에 갈리게 됐다. 이러한 흐름으로 인해 객체지향은 많은 언어, 개발자에게 사랑받을 수 있었을 것이다.\r\n\r\n요즘 AI 기술이 발달함에 따라 [Copilot](https://copilot.github.com/) 등 AI가 코딩을 보조해주는 기술이 연구되고, 등장하고 있는 것 같다.\r\n\r\n나중에 시간이 지나 개발자의 역량이 더 이상 중요하지 않게 되면 새로운 방법론이 대세가 되지 않을까?","url":["2021-08-07-what-is-oop","2021","08","07","what-is-oop"]}],"categories":["CS","JAVA","Jekyll","React","WAS","WEB","알고리즘","잡담"],"images":["celeb1.gif","celeb10.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"객체지향","page":1},"__N_SSG":true}