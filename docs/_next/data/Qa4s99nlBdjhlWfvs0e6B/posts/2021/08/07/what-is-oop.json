{"pageProps":{"page":{"type":"posts","prev":{"header":{"title":"재귀를 사용한 재귀적 반복","excerpt":"컴퓨터 언어에서의 재귀란 자기 자신을 호출함을 의미한다. 알고리즘에서의 재귀는 매우 중요한 개념 중 하나로써, 그 특성 상 복잡한 연산 및 연산에 걸리는 소요 시간을 효과적으로 개선할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-08-04T00:26:26","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","재귀"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true},"name":"2021-08-04-about-algorithm-chapter09.md","content":"\r\n<p class=\"orange-A400\" align=\"center\">본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>\r\n\r\n# 9장 재귀를 사용한 재귀적 반복\r\n\r\n컴퓨터 언어에서의 <span class=\"primary\">재귀</span>란 자기 자신을 호출함을 의미한다. 알고리즘에서의 재귀는 매우 중요한 개념 중 하나로써, 그 특성 상 복잡한 연산 및 연산에 걸리는 소요 시간을 효과적으로 개선할 수 있다.\r\n\r\n``` javascript\r\n/**\r\n * 재귀 함수\r\n */\r\nfunction recursive()\r\n{\r\n\tconsole.log('recursive');\r\n\r\n\trecursive();\r\n}\r\n```\r\n\r\n``` output\r\nrecursive\r\nrecursive\r\nrecursive\r\nrecursive\r\nrecursive\r\nrecursive\r\n...\r\n```\r\n\r\n위 소스는 재귀의 특성을 간단하게 구현한 예제다. 위 함수를 호출하면 <span class=\"teal-400\">\"recursive\"</span>라는 단어가 끝없이 출력된다.\r\n\r\n`recursive` 함수 내에서 자기 자신을 끝없이 호출하기 때문에 이러한 현상이 일어난다. 겉보기엔 쓸데없는 장난처럼 보이기도 하지만, 재귀의 특징을 잘 활용하면 매우 강력한 도구가 된다.\r\n\r\n## 9-1. 루프 대신 재귀\r\n\r\n지금껏 코드에서 어떤 동작을 반복하기 위해 우리는 루프를 사용한다. `for`, `while` 등과 같은 반복문을 통해 원하는 만큼 동작을 반복한다.\r\n\r\n10부터 0까지 카운트다운을 하는 소스를 설계해보면 아래와 같다.\r\n\r\n``` javascript\r\n/**\r\n * 루프를 활용한 카운트다운 함수\r\n * \r\n * @param {number} start: 시작 숫자\r\n */\r\nfunction countdown(start)\r\n{\r\n\tfor (let i = start; i >= 0; i--)\r\n\t{\r\n\t\tconsole.log(i);\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n10\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n0\r\n```\r\n\r\n위 소스는 javascript로 루프를 사용해 작성한 카운트다운 소스다. 하지만, 루프 대신 재귀를 사용하면 아래처럼 구성할 수도 있다.\r\n\r\n``` javascript\r\n/**\r\n * 재귀를 활용한 카운트다운 함수\r\n * \r\n * @param {number} start: 시작 숫자\r\n */\r\nfunction countdown(start)\r\n{\r\n\tconsole.log(start);\r\n\r\n\tcountdown(start - 1);\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n10\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n0\r\n-1\r\n-2\r\n...\r\n```\r\n\r\n반대로 위 소스는 루프 대신 재귀를 활용하여 카운트다운을 수행한다. `start`를 출력하고 1을 뺀 값을 다시 자기 자신인 `countdown`에 전달한다.\r\n\r\n대부분의 루프는 재귀로 대체할 수 있다. 단순히 대체되는 것 이상으로 재귀는 루프와 달리 유의미한 성능 향상도 기대할 수 있다.\r\n\r\n그 이전에, 위 소스의 출력을 살펴보자. 통상 카운트다운은 정해진 숫자부터 1 혹은 0까지를 센다. 그런데 위 소스, 0을 넘어서 -1, -2... 한 없이 내려간다. 왜 이러는 걸까?\r\n\r\n## 9-2. 기저 조건\r\n\r\n이전 문단에서 기술한 재귀 함수는 카운트다운이라고 볼 수 없다. 그냥 입력한 숫자부터 끊임없이 숫자를 나열하는 것이나 다름없다. 이런 현상이 발생하는 이유는, 이 재귀 함수에 일종의 브레이크라고 할만한 것이 없기 때문이다.\r\n\r\n우리가 원하는 것은 0까지의 카운트다운이므로, `start`의 값이 0일 경우 더 이상 자기 자신을 호출하지 않도록 바꿔줄 필요가 있다.\r\n\r\n``` javascript\r\n/**\r\n * 재귀를 활용한 완전한 카운트다운 함수\r\n * \r\n * @param {number} start: 시작 숫자\r\n */\r\nfunction countdown(start)\r\n{\r\n\tconsole.log(start);\r\n\r\n\t// 값이 0보다 클 경우\r\n\tif (start > 0)\r\n\t{\r\n\t\tcountdown(start - 1);\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n10\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n0\r\n...\r\n```\r\n\r\n위 소스는 이러한 문제를 개선한 소스다. `start`가 0보다 클 경우에만 자기 자신을 다시 호출한다. 0보다 작거나 같을 경우, 재귀가 더 이상 일어나지 않아 동작이 종료된다. 동작에 브레이크가 걸리는 것이다.\r\n\r\n우리가 `for`나 `while`에 특정 조건을 삽입해서 원하는 만큼만 반복문을 수행하는 것처럼 재귀도 이러한 조건을 달아서 원하는 만큼만 반복하게끔 구성해야한다.\r\n\r\n물론 위의 두 반복문은 조건을 어디에 어떤 식으로 입력해야하는지 명확하게 기술되어있다면, 재귀는 코드 내에서 조건을 구성하므로 그 방식이 명확하지 않다. 때문에 재귀를 처음 접하거나, 경험이 없을 경우 이런 방식의 조건 설정이 익숙하지 않아 무한히 동작하는 재귀 함수를 만들기도 한다.\r\n\r\n이렇게 재귀를 멈추는 조건을 <span class=\"primary\">기저 조건</span>이라 한다. 앞서 설명한 예제 `countdown`의 기저 조건은 `start > 0`이라 할 수 있다.\r\n\r\n## 9-3. 재귀 코드 읽기\r\n\r\n앞서 말했듯이, 재귀는 그 조건이 명확하게 보이지 않다. 때문에 경우에 따라선 재귀 코드를 읽는 것초자 어렵기도 하다. 간단한 예제를 통해서 재귀 코드를 읽어보자.\r\n\r\n고등학교 수학에서 배운 내용 중 팩토리얼(Factorial) 연산이 있다. 팩토리얼은 $5!$과 같이 표기하며, 연산 결과는 $5 \\times 4 \\times 3 \\times 2 \\times 1 = 120$이 된다. 즉, 일반식으로 표기하면 아래와 같다.\r\n\r\n$$\r\nn! = n \\times (n - 1) \\times (n - 2) \\times \\dotsb \\times 2 \\times 1\r\n$$\r\n\r\n팩토리얼 연산을 단축하면 $n! = n \\times (n - 1)!$와 같이 표기할 수 있다. 이러한 패턴은 재귀를 적용시키기 매우 용이한 패턴이다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 팩토리얼 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/07/31/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.02 Mon 22:57:53\r\n */\r\npublic class Factorial\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tint index = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\twriter.write(String.valueOf(factorial(index)));\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 팩토리열 연산 결과 반환 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t *\r\n\t * @return [int] 팩토리얼 연산 결과\r\n\t */\r\n\tprivate static int factorial(int index)\r\n\t{\r\n\t\t// 인덱스가 1일 경우\r\n\t\tif (index == 1)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t\r\n\t\t// 인덱스가 1이 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn index * factorial(index - 1);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\n10\r\n```\r\n\r\n``` output\r\n3628800\r\n```\r\n\r\n책에서 설명하는 재귀 코드를 읽는 방법은 아래와 같다.\r\n\r\n1. 기저 조건이 무엇인지 찾는다.\r\n2. 기저 조건을 다룬다는 가정하에 함수를 살펴본다.\r\n3. 기저 조건 바로 **전** 조건을 다룬다는 가정하에 함수를 살펴본다.\r\n4. 한 번에 한 조건씩 올라가면서 계속 분석한다.\r\n\r\n``` java\r\n// 인덱스가 1일 경우\r\nif (index == 1)\r\n{\r\n\treturn 1;\r\n}\r\n\r\n// 인덱스가 1이 아닐 경우\r\nelse\r\n{\r\n\treturn index * factorial(index - 1);\r\n}\r\n```\r\n\r\n위 소스의 구조는 매우 간단하므로, 어렵지 않게 분기를 찾을 수 있다. `index == 1`인 경우와 아닌 경우가 분기다.\r\n\r\n``` java\r\n// 인덱스가 1이 아닐 경우\r\nelse\r\n{\r\n\treturn index * factorial(index - 1);\r\n}\r\n```\r\n\r\n재귀는 자기 자신을 호출하는 것이므로, 분기의 `else` 부분이 재귀가 일어나는 영역이라 추측할 수 있다. 따라서 재귀가 일어나지 않는 영역이 <span class=\"teal-400\">기저 조건</span>이라 할 수 있다.\r\n\r\n``` java\r\n// 인덱스가 1일 경우\r\nif (index == 1)\r\n{\r\n\treturn 1;\r\n}\r\n```\r\n\r\n즉, 위 재귀 함수의 기저 조건은 `index == 1`이다. `factorial(1)`은 1을 반환한다. 이 기저 조건을 토대로 `factorial(4)`의 동작을 전개하면 아래와 같다.\r\n\r\n1. $\\text{factorial(4)} = 4 \\times \\text{factorial(3)}$\r\n2. $\\text{factorial(4)} = 4 \\times 3 \\times \\text{factorial(2)}$\r\n3. $\\text{factorial(4)} = 4 \\times 3 \\times 2 \\times \\text{factorial(1)}$\r\n4. $\\text{factorial(4)} = 4 \\times 3 \\times 2 \\times 1 = 12$\r\n\r\n이와 같이 순차적으로 자기 자신을 호출하여 연산을 수행한다. 재귀 함수의 <span class=\"green-400\">기저 조건은 재귀를 멈추는 요인</span>이므로, 기저 조건을 바탕으로 전개하면 비교적 쉽게 연산을 이해할 수 있다.\r\n\r\n## 9-4. 컴퓨터의 눈으로 바라본 재귀\r\n\r\n우리가 재귀함수를 이해하는 것도 중요하지만, 결국 코드의 실행 주체는 어찌됐든 컴퓨터가 담당하게 된다. 즉, 우리가 이를 이해하는 것 만큼 컴퓨터가 이를 어떻게 이해하는지 아는 것 또한 매우 중요하다.\r\n\r\n이전 장에서, 우리는 <span class=\"amber-400\">스택</span>에 대해 다뤘었다. 컴퓨터가 재귀를 다룰 때 스택을 활용하여 관리한다. `factorial(4)`를 컴퓨터가 스택으로 어떻게 관리하는 지 알아보자.\r\n\r\n1. `factorial(4)`를 호출한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024009-1ee1fc5d-ecce-4711-b729-36a70b8592d1.png\" width=\"200px\" />\r\n\r\n`factorial(4)` 내부에서 `factorial(3)`을 호출하므로, `factorial(4)`를 스택에 삽입하고 `factorial(3)`을 수행한다. 이 때 `factorial(4)`는 종료된 것이 아니라, 재귀 호출로 인해 연산이 중단된 상태다.\r\n\r\n<br />\r\n<br />\r\n\r\n2. `factorial(3)`을 호출한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024019-b76d21a2-24f6-47f6-bf2f-f46350da31e1.png\" width=\"200px\" />\r\n\r\n마찬가지로 재귀로 인해 연산 과정에서 `factorial(2)`를 호출하므로, 마찬가지로 연산을 중단하고 스택에 삽입한다.\r\n\r\n<br />\r\n<br />\r\n\r\n3. `factorial(2)`를 호출한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024025-f96e2b60-943b-4abc-8200-043ffbb63821.png\" width=\"200px\" />\r\n\r\n위와 동일하다.\r\n\r\n<br />\r\n<br />\r\n\r\n4. `factorial(1)`를 호출한다.\r\n\r\n`factorial(1)`는 기저 조건이므로 재귀가 호출되지 않는다. 1을 반환하고 연산을 종료한다. 하지만 스택에 데이터가 남아있으므로, 전체 연산이 종료되지 않았음을 알 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n5. `factorial(2)`를 종료한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024038-575615fd-5018-4c32-b205-a0fe3b0a34f2.png\" width=\"200px\" />\r\n\r\n`factorial(2)`의 연산 결과는 `factorial(1)`의 결과와 연관된다. `factorial(1)` 결과가 계산되었으므로, `factorial(2)`를 종료할 수 있다. 연산을 종료하고 스택에서 제거한다.\r\n\r\n<br />\r\n<br />\r\n\r\n6. `factorial(3)`을 종료한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024048-93fcb67e-c73e-4423-ab3f-415f2fa817d4.png\" width=\"200px\" />\r\n\r\n`factorial(3)`의 연산을 종료하고 스택에서 제거한다.\r\n\r\n<br />\r\n<br />\r\n\r\n7. `factorial(4)`을 종료한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/50317129/128024224-c83b0f90-388c-4264-8543-194c56cea310.png\" width=\"200px\" />\r\n\r\n`factorial(4)`의 연산을 종료하고 스택에서 제거한다. 스택에 데이터가 남아있지 않으므로 모든 연산이 종료된다.\r\n\r\n<br />\r\n<br />\r\n\r\n위와 같이 재귀는 스택을 활용하여 연산한다. 만약 기저 조건의 설정을 잘 못 해서 재귀 연산이 끝없이 일어날 수도 있다. 이 경우 스택 역시 끝없이 쌓이게 되서 메모리가 더 이상 감당할 수 없을 때 스택 오버플로우가 발생한다.\r\n\r\n## 9-5. 재귀 다뤄보기\r\n\r\n지금까지 다룬 팩토리얼 연산의 경우 사실 루프를 사용해도 그리 어렵지 않게 풀 수 있으며, 제시된 코드 역시 재귀를 사용했을 때 크게 이점이 있는 것도 아니였다.\r\n\r\n이번엔 좀 더 재귀를 사용했을 때 이점이 있을 법한 주제로 코드를 설계해보자. 재귀는 구조 상 알고리즘 내에서 자기 자신을 호출하는 알고리즘에 가장 적합하다. 즉, 재귀의 사용 여부는 루프의 보다 <span class=\"red-400\">나 자신을 다시 호출해야 하는지 여부</span>에 따라 갈린다.\r\n\r\n코드로 파일 리스트를 불러온 적이 있다면 익숙할 것이다. 우리가 생각하는 것처럼 특정 폴더 내의 파일 리스트 전체를 불러오는 것은 생각보다 까다롭다. 단순히 폴더 바로 밑의 파일 리스트만을 가져온다면 쉽겠지만, 그 하위, 하위의 하위 파일까지 가져오려면 그리 간단하지 않기 때문이다.\r\n\r\n현재 폴더 및 하위 폴더의 모든 폴더 리스트를 출력하는 코드를 작성해보자. 우선은 가장 간단하게, 하위 폴더는 신경쓰지 말고 현재 폴더에 존재하는 폴더 리스트만을 가져와보자.\r\n\r\n폴더 루트 경로는 `D:\\root`와 같으며, 구조는 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128032026-9ad5c07e-c274-45b2-8865-0164ddd8f618.png)\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.Objects;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 폴더 리스트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/08/04/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.03 Tue 22:55:59\r\n */\r\npublic class DirectoryList\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"폴더 리스트를 출력할 경로를 입력하세요 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString path = reader.readLine();\r\n\t\t\r\n\t\tString[] list = getList(path);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(list));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 폴더 리스트 반환 함수\r\n\t *\r\n\t * @param path: [String] 경로\r\n\t *\r\n\t * @return [String[]] 폴더 리스트\r\n\t */\r\n\tprivate static String[] getList(String path)\r\n\t{\r\n\t\treturn Arrays.stream(Objects.requireNonNull(new File(path).listFiles(File::isDirectory))).map(File::getName).toArray(String[]::new);\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nD:\\root\r\n```\r\n\r\n``` output\r\n[a, b, c]\r\n```\r\n\r\n현재 폴더의 직전 하위 폴더 리스트만을 출력한다. 한단계 하위 폴더 리스트를 출력하기 위해 코드를 개선해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 폴더 리스트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/08/04/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.03 Tue 23:32:46\r\n */\r\npublic class MoreDirectoryList\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"폴더 리스트를 출력할 경로를 입력하세요 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString path = reader.readLine();\r\n\t\t\r\n\t\tArrayList<String> list = getList(path);\r\n\t\t\r\n\t\twriter.write(String.valueOf(list));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 폴더 리스트 반환 함수\r\n\t *\r\n\t * @param path: [String] 경로\r\n\t *\r\n\t * @return [ArrayList<String>] 폴더 리스트\r\n\t */\r\n\tprivate static ArrayList<String> getList(String path)\r\n\t{\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\t\r\n\t\tFile[] files = new File(path).listFiles(File::isDirectory);\r\n\t\t\r\n\t\t// 파일 배열이 유효할 경우\r\n\t\tif (files != null)\r\n\t\t{\r\n\t\t\tfor (File file : files)\r\n\t\t\t{\r\n\t\t\t\tlist.add(file.getName());\r\n\t\t\t\t\r\n\t\t\t\tFile[] files1 = file.listFiles(File::isDirectory);\r\n\t\t\t\t\r\n\t\t\t\t// 파일 배열이 유효할 경우\r\n\t\t\t\tif (files1 != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (File file1 : files1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlist.add(file1.getName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list;\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nD:\\root\r\n```\r\n\r\n``` output\r\n[a, a1, a2, b, b1, b2, c, c1, c2]\r\n```\r\n\r\n각 폴더의 하위 폴더의 리스트까지 출력해준다. 소스를 봐도 폴더일 경우 동일한 소스가 한 번 더 동작된다. 하지만 이는 매우 제한적이다. 폴더의 깊이가 정해져있다면 이런 식으로 계속 동일한 소스를 반복하면 되겠지만, 이러한 케이스는 거의 존재하지 않아 무의미하다.\r\n\r\n이 경우 재귀를 사용하면 매우 손쉽게 모든 폴더의 하위 리스트를 출력할 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 재귀 폴더 리스트 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/08/04/about-algorithm-chapter09/\">재귀를 사용한 재귀적 반복</a>\r\n * @since 2021.08.03 Tue 23:36:43\r\n */\r\npublic class RecursiveDirectoryList\r\n{\r\n\tprivate static final ArrayList<String> LIST = new ArrayList<>();\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"폴더 리스트를 출력할 경로를 입력하세요 >> \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tString path = reader.readLine();\r\n\t\t\r\n\t\tgetList(path);\r\n\t\t\r\n\t\twriter.write(String.valueOf(LIST));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 폴더 리스트 산출 함수\r\n\t *\r\n\t * @param path: [String] 경로\r\n\t */\r\n\tprivate static void getList(String path)\r\n\t{\r\n\t\tFile[] files = new File(path).listFiles(File::isDirectory);\r\n\t\t\r\n\t\t// 파일 배열이 유효할 경우\r\n\t\tif (files != null)\r\n\t\t{\r\n\t\t\tfor (File file : files)\r\n\t\t\t{\r\n\t\t\t\tLIST.add(file.getName());\r\n\t\t\t\t\r\n\t\t\t\tgetList(file.getPath());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n``` input\r\nD:\\root\r\n```\r\n\r\n``` output\r\n[a, a1, a2, b, b1, b11, b2, c, c1, c11, c12, c2]\r\n```\r\n\r\n재귀를 이용하여 하위 폴더의 전체 폴더명을 출력할 수 있다. 동일한 소스를 구태여 반복할 필요도 없고, 하위 깊이가 얼마나 되는지 알 필요 없이 폴더명 전체 리스트를 출력할 수 있다.\r\n\r\n탐색 순서는 아래와 같다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128036750-4094185e-3e77-4f24-94c7-dd8ccc9428ef.png)\r\n\r\n# 마무리\r\n\r\n이 장의 핵심 내용은 아래와 같다.\r\n\r\n* 재귀는 자기 자신을 호출하는 구조다.\r\n* 대부분의 루프는 재귀로 대체할 수 있다.\r\n* 알고리즘 구조 상 자기 자신을 호출해야할 때 가장 적합하다.\r\n\r\n백준 알고리즘을 풀었을 때도, 재귀를 사용해야하는 문제가 적지 않았을 정도로 재귀는 알고리즘에서 그 쓰임새가 매우 높다. 이번 장을 통해 재귀의 특성을 정리함으로써, 앞으로 알고리즘을 푸는데 많은 도움이 될 것 같다.","url":["2021-08-04-about-algorithm-chapter09","2021","08","04","about-algorithm-chapter09"]},"next":null},"group":[],"data":{"header":{"title":"객체지향 프로그래밍(Object Oriented Programming)이란?","excerpt":"","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-07T12:06:45","type":"posts","category":"CS","tag":["CS","객체지향"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-07-what-is-oop.md","content":"<h1 id=\"OOP\">OOP <a href=\"#OOP\">🔗</a></h1><p>IT 업계에 종사하게 된다면 십중팔구 <span class=\"amber-400\">JAVA</span>, <span class=\"amber-400\">C++</span>, <span class=\"amber-400\">C#</span> 중 하나는 다루게 된다. 국내 IT의 최다 공급이자 수요인 JAVA를 위시한 위 세 가지 언어의 공통점은 전부 <span class=\"primary\">객체지향</span>언어라는 점이다.</p>\n<p>물론 지금에 이르러서는 함수형이라는 개념도 나왔지만, <span class=\"amber-400\">C</span>의 단순한 절차지향 이래로 나온 객체지향은 프로그래밍의 새로운 관점을 제시했고, 크고 작은 언어들이 알게 모르게 영향을 받았다. 이렇게 영향력이 큰 개념임에도 불구하고 막상 이와 관련된 질문을 받으면 명확하게 답을 내지 못 하기도 한다.</p>\n<h1 id=\"객체지향에-대해 설명해보세요.\">객체지향에 대해 설명해보세요. <a href=\"#객체지향에-대해 설명해보세요.\">🔗</a></h1><p>제목 그대로 위와 같은 질문을 받았다고 가정해보자. 난 이 질문의 명확한 답을 주지 못 한다. 자바 경험이 없지 않음에도 불구하고, 이론에는 크게 관심이 없기도 했고, 비전공자인 난 구태여 찾아보지 않는 이상 이와 같은 내용을 실무에서 습득하긴 어려웠다.</p>\n<p>내가 쓰는 언어가 어떤 방식으로 동작하는지 모른다면 그건 제대로 쓴다고 보긴 어렵다. 이 주제를 통해 객체지향의 개념에 대해 정리해보고자 한다.</p>\n<h2 id=\"객체\">객체 <a href=\"#객체\">🔗</a></h2><p><strong>객체</strong>지향. 말 그대로 <span class=\"teal-400\">객체</span>를 지향하는 언어다. 객체지향에 대해 이해하기 위해선, 일단 이 방법론이 궁극적으로 지향하는 <strong>객체</strong>란 개념에 대해 이해할 필요가 있다.</p>\n<p>객체지향이 말하는 <span class=\"teal-400\">객체</span>란 프로그램 동작의 주체가 되는 요소를 의미한다. 이 객체는 유/무형을 가리지 않는다. 실체가 명확한 것일 수도 있고, 무형의 개념일 수도 있다.</p>\n<p>모든 객체는 상태와 동작을 가진다. 예를 들어, <strong>TV</strong>를 구매한다고 생각해보자. 대부분의 사람들은 TV의 디자인, 성능, 가격 등을 적절히 고려하여 TV를 구매할 것이다.</p>\n<p>TV의 색, 인치, 가격 등은 TV가 가진 상태라고 볼 수 있다. TV 채널 이동, 다시 보기, 넷플릭스 연결 등은 TV의 기능이라고 볼 수 있다.</p>\n<p>이렇게 모든 객체에는 <span class=\"green-400\">상태</span>와 <span class=\"green-400\">동작</span>이 존재한다.</p>\n<p>국내 객체지향 언어의 대표격인 <span class=\"amber-400\">JAVA</span>는 이러한 개념을 아래와 같이 접근한다.</p>\n\n\t\t\t<div class=\"table-wrapper\">\n\t\t\t\t<table>\n\t\t\t\t\t<thead>\n\t\t\t\t\t\t<tr>\n<th align=\"center\">객체지향</th>\n<th align=\"center\">JAVA</th>\n</tr>\n\n\t\t\t\t\t</thead>\n\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr>\n<td align=\"center\">객체</td>\n<td align=\"center\">클래스</td>\n</tr>\n<tr>\n<td align=\"center\">상태</td>\n<td align=\"center\">멤버 변수</td>\n</tr>\n<tr>\n<td align=\"center\">동작</td>\n<td align=\"center\">메소드 (함수)</td>\n</tr>\n\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t<p>여기 <strong>자동차</strong>라는 현실의 객체를 JAVA가 어떻게 클래스로 다루는지 예제를 통해 알아보자.</p>\n\n\t\t\t\t\t<div class=\"codeblock\">\n\t\t\t\t\t\t<div class=\"top\">\n\t\t\t\t\t\t\t<p>JAVA</p>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button onclick=\"window.getSelection().selectAllChildren(this.parentElement.querySelector('code'));document.execCommand('copy');\">COPY</button>\n\n\t\t\t\t\t\t<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * 자동차 클래스\n *\n * @author RWB\n * @since 2021.08.05 22:06:24\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Car</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 시동 여부</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> IS_STARTED <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 최대 속력</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MAX_SPEED<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 현재 속력</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> speed<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">/**\n     * Car 생성자 함수\n     *\n     * @param maxSpeed: [int] 최대 속도\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Car</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> maxSpeed<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        MAX_SPEED <span class=\"token operator\">=</span> maxSpeed<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">/**\n     * 시동 결과 반환 함수\n     *\n     * @return [boolean] 시동 결과\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">startUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>IS_STARTED<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">/**\n     * 시동 종료 결과 반환 함수\n     *\n     * @return [boolean] 시동 종료 결과\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> IS_STARTED<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">/**\n     * 현재 속도 반환 함수\n     *\n     * @return [int] 현재 속도\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSpeed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> speed<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">/**\n     * 가속 함수\n     *\n     * @param amount: [int] 속도\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">upSpeed</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> amount<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 시동이 걸렸을 경우</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>IS_STARTED<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 가속된 값이 최대 속도를 넘지 않을 경우</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>MAX_SPEED <span class=\"token operator\">>=</span> speed <span class=\"token operator\">+</span> amount<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                speed <span class=\"token operator\">+=</span> amount<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            \n            <span class=\"token comment\">// 가속된 값이 최대 속도를 넘을 경우</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                speed <span class=\"token operator\">=</span> MAX_SPEED<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">/**\n     * 감속 함수\n     *\n     * @param amount: [int] 속도\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">downSpeed</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> amount<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 시동이 걸렸을 경우</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>IS_STARTED<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 감속된 값이 0보다 클 경우</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> <span class=\"token operator\">&lt;=</span> speed <span class=\"token operator\">-</span> amount<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                speed <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            \n            <span class=\"token comment\">// 감속된 값이 0보다 작을 경우</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                speed <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n\t\t\t\t\t</div>\n\t\t\t\t<p>위의 코드 Car 클래스는 자동차라는 현실의 객체를 매우 간단한 형태로 구현한 클래스다.</p>\n<br />\n\n<ul>\n<li><strong>멤버 변수</strong> (상태)<ul>\n<li><code class=\"inline-code\">IS_STARTED</code> 자동차 시동 여부</li>\n<li><code class=\"inline-code\">MAX_SPEED</code>: 최대 속도</li>\n<li><code class=\"inline-code\">speed</code>: 현재 속도</li>\n</ul>\n</li>\n</ul>\n<br />\n\n<ul>\n<li><strong>메소드</strong> (동작)<ul>\n<li><code class=\"inline-code\">startUp</code>: 엔진 시동</li>\n<li><code class=\"inline-code\">shutdown</code>: 엔진 정지</li>\n<li><code class=\"inline-code\">getSpeed</code>: 현재 속도 표시</li>\n<li><code class=\"inline-code\">upSpeed</code>: 가속</li>\n<li><code class=\"inline-code\">downSpeed</code>: 감속</li>\n</ul>\n</li>\n</ul>\n<br />\n\n<p>Car 클래스의 요소는 위와 같이 구분된다. JAVA에서 이 객체를 사용하려면 메모리에 할당해야하고, 이렇게 할당된 객체를 <span class=\"teal-400\">인스턴스</span>(Instance)라 칭한다.</p>\n<p>Car 클래스를 메모리에 할당하여 새로운 인스턴스를 만드는 것은 현실에서 자동차 하나를 뽑는 것과 동일한 개념이다.</p>\n<h2 id=\"객체지향\">객체지향 <a href=\"#객체지향\">🔗</a></h2><p>객체<strong>지향</strong>이므로, 앞서 언급했듯이 이를 이해하기 위해선 객체를 이해해야한다. 이미 이전 문단에서 객체에 대해 장황하게 설명했으므로, <span class=\"teal-400\">객체지향</span>은 이러한 객체를 통해 코드를 구성하는 방법론이라 정의할 수 있다.</p>\n<p>모든 객체는 각 객체의 특성에 부합하는 상태와 동작을 가지며, 이를 통해 객체 간의 상호작용을 코드로 나타낼 수 있다. 객체지향은 이러한 객체의 상호작용을 코드로 나타낸다.</p>\n<p>일례로 JAVA는 <code class=\"inline-code\">String</code>, <code class=\"inline-code\">HashMap</code> 등, 모든 요소를 객체(Object)로 다룬다. 우리는 JAVA로 필요한 객체를 메모리에 할당하고, 객체가 가진 변수나 메소드를 사용하여 코딩한다. 이러한 JAVA의 프로그래밍 방식은 지금껏 설명한 객체지향의 그 것과 동일함을 알 수 있다.</p>\n<h1 id=\"그래서-이걸 왜 쓰는데?\">그래서 이걸 왜 쓰는데? <a href=\"#그래서-이걸 왜 쓰는데?\">🔗</a></h1><p>객체지향을 차용한 언어는 매우 많다. 대표격인 JAVA 이외에도 C++, C#, Visual Basic, Swift, Python 등이 있다. 또한 이 언어들은 우리에게 매우 익숙한 이름일 뿐만 아니라, 프로그래밍 언어에서 다들 한 자리씩은 차지하는 매우 비중있는 언어들이다.</p>\n<p>그렇다면 객체지향 언어가 개발자들에게 그토록 널리 쓰이며, 사랑받을 수 있었던 이유는 무엇일까?</p>\n<p>객체지향은 절차지향의 후발주자다. 보통 이런 경우의 후발주자는 선발의 단점 혹은 니즈들을 개선하여 출시하므로 기능 혹은 편의성에서 많은 이점을 가진다. 객체지향은 특히 생산성과 유지보수 용이성을 높이는 데 포커스를 두었으며, 덕분에 객체지향 언어를 구사하는 개발자는 개발을 비교적 쉽고 빠르게 수행할 수 있다.</p>\n<h2 id=\"장점\">장점 <a href=\"#장점\">🔗</a></h2><ul>\n<li><p><span class=\"green-400\">코드 재사용성</span><br>모듈화된 객체를 기반으로 코드가 작성되기 때문에, 해당 객체의 특징을 비슷한 다른 로직에도 적용해서 사용하거나, 다른 개발자가 구현한 객체를 가져와 쓰기에도 용이하다.</p>\n</li>\n<li><p><span class=\"green-400\">간편한 유지보수</span><br>객체를 수정할 경우, 해당 객체를 사용하는 모든 로직에 일괄적으로 적용되니, 중복 코드에 대한 관리가 간단해진다. 혹은 객체나 동작이 변경될 경우, 해당 객체나 동작과 연관된 객체만을 찾아 수정하면 된다.</p>\n</li>\n<li><p><span class=\"green-400\">큰 규모의 프로그래밍에 유리</span><br>객체, 모듈 단위로 구분되는 특징으로 인해 업무 분장이 쉽고, 각 모듈의 연관성을 도식하기 용이하다.</p>\n</li>\n</ul>\n<h2 id=\"단점\">단점 <a href=\"#단점\">🔗</a></h2><ul>\n<li><p><span class=\"red-400\">비교적 느린 속도</span><br>절차지향과 달리 객체지향은 각 객체의 의존 관계로 인해 대체적으로 속도가 느리다.</p>\n</li>\n<li><p><span class=\"red-400\">높은 설계역량 요구</span><br>모듈 단위의 상호작용으로 이루어진 방식은, 모듈의 정확한 명세와 상호 간의 연관성이 얼마나 짜임새있게 설계되었는지 중요하다. 잘 못 설계된 객체나 연관성은 라쟈나 코드로 변하기 쉽다.</p>\n</li>\n<li><p><span class=\"red-400\">코드의 잠재적인 복잡성</span><br>높은 수준의 설계역량 요구와 더불어 추상 객체, 상속, 인터페이스 등의 복잡한 개념과 그 활용은 코드의 구조를 파악하기 어렵게 만든다.</p>\n</li>\n</ul>\n<h1 id=\"객체지향을-사용하는 언어들\">객체지향을 사용하는 언어들 <a href=\"#객체지향을-사용하는 언어들\">🔗</a></h1><ul>\n<li>JAVA</li>\n<li>C++</li>\n<li>C#</li>\n<li>Python</li>\n<li>Simula 67</li>\n<li>Delphi</li>\n<li>Swift</li>\n<li>Ruby</li>\n<li>Perl</li>\n</ul>\n<p><del class=\"grey-600\">대부분 아는 얼굴들이구만</del></p>\n<h1 id=\"정리\">정리 <a href=\"#정리\">🔗</a></h1><p>기존의 C언어의 기반인 절차지향도 나름의 장점이 있었다. 컴퓨터의 처리 흐름과 코드의 흐름이 매우 유사하기 때문에 전처리가 적어 실행 속도가 비교적 빨랐다. 또한 코드의 흐름이 일정했으므로, 이를 분석하기도 수월했을 것이다.</p>\n<p>하지만 시대가 지남에 따라 시대가 발전했고, 개발자의 평균 역량 또한 높아졌다. 컴퓨터의 처리 속도는 언급할 필요조차 없었고. 이러한 환경의 발전으로 인해 절차지향의 장점이 주는 메리트가 적어지면서, 반대로 단점이 주는 디메리트가 더더욱 크게 다가왔을 것이다.</p>\n<p>객체지향은 유지보수의 용이성과 개발 편의성을 중요시 여기는 개발 방법론이다. 객체지향이 가지는 장점 덕분에 <span class=\"pink-400\">개발자 간의 코드 공유</span>가 쉬워졌으며, <span class=\"pink-400\">서비스의 규모는 더욱 증가</span>하고, <span class=\"pink-400\">견고한 프로그램</span>을 만들기 쉬워졌다.</p>\n<p>절차지향이 컴퓨터에게 친화적이라면, 객체지향은 개발자에게 친화적이라 할 수 있겠다. 컴퓨터의 성능이 미친듯이 높아짐에 따라, 프로그램의 성능은 자연스레 개발자의 역량에 갈리게 됐다. 이러한 흐름으로 인해 객체지향은 많은 언어, 개발자에게 사랑받을 수 있었을 것이다.</p>\n<p>요즘 AI 기술이 발달함에 따라 <a href=\"https://copilot.github.com/\">Copilot</a> 등 AI가 코딩을 보조해주는 기술이 연구되고, 등장하고 있는 것 같다.</p>\n<p>나중에 시간이 지나 개발자의 역량이 더 이상 중요하지 않게 되면 새로운 방법론이 대세가 되지 않을까?</p>\n","url":["2021-08-07-what-is-oop","2021","08","07","what-is-oop"],"toc":[{"text":"OOP","tag":"OOP","depth":1},{"text":"객체지향에 대해 설명해보세요.","tag":"객체지향에-대해 설명해보세요.","depth":1},{"text":"객체","tag":"객체","depth":2},{"text":"객체지향","tag":"객체지향","depth":2},{"text":"그래서 이걸 왜 쓰는데?","tag":"그래서-이걸 왜 쓰는데?","depth":1},{"text":"장점","tag":"장점","depth":2},{"text":"단점","tag":"단점","depth":2},{"text":"객체지향을 사용하는 언어들","tag":"객체지향을-사용하는 언어들","depth":1},{"text":"정리","tag":"정리","depth":1}]}},"__N_SSG":true}