{"pageProps":{"posts":[{"header":{"title":"[라즈베리파이 4] 라즈베리파이에 도메인 입히기","excerpt":"지금까지 과정을 거치면서 라즈베리파이에 OS를 설치하고, Tomcat을 구동하여 웹 서버로 동작할 수 있도록 환경을 구축했다. 이제 우리는 라즈베리파이의 IP로 접속하여 웹 사이트를 호스팅할 수 있다. 하지만 정상적인 페이지라면 IP를 입력하여 접속하지 않는다. Domain을 발급받아 IP에 연동하고, 이를 URL 주소로 사용할 것이다. 이 장에서는 Domain을 직접 구입하고 라즈베리파이 서버에 이를 연동한다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-09-04T12:09:04","type":"posts","category":"Ubuntu","tag":["라즈베리파이","Ubuntu","도메인"],"comment":true,"publish":true},"name":"2021-09-04-raspberry-domain.md","content":"\r\n# 개요\r\n\r\n지금까지 과정을 거치면서 라즈베리파이에 OS를 설치하고, Tomcat을 구동하여 웹 서버로 동작할 수 있도록 환경을 구축했다.\r\n\r\n이제 우리는 라즈베리파이의 IP로 접속하여 웹 사이트를 호스팅할 수 있다.\r\n\r\n하지만 정상적인 페이지라면 IP를 입력하여 접속하지 않는다. Domain을 발급받아 IP에 연동하고, 이를 URL 주소로 사용할 것이다.\r\n\r\n이 장에서는 Domain을 직접 구입하고 라즈베리파이 서버에 이를 연동한다.\r\n\r\n# 무슨 도메인을 쓰지?\r\n\r\n일전 [게시글](/posts/2021/08/18/freenom-domain)에서 Freenom을 통해 무료로 도메인을 받는 과정에 대해 다룬적이 있다.\r\n\r\n무료도 상관없지만, Freenom은 실 서비스에 사용하기에 매우 부적합하다.\r\n\r\nTLD 중 어떤 걸 사용할까 고민했다. 개인적으론 `io` 도메인의 트렌디함에 끌렸지만, 가비아 기준 도메인 비용이 무려 연 20만원... 반드시 `io`가 필요하지도 않은 마당에 연에 20을 태우는 건 너무 비효율적이라 생각했다.\r\n\r\n원랜 대중적인 `com`으로 하려했으나, 조사 중 `dev`라는 개발자스러운 도메인이 있음을 확인하여 이를 선택하기로 했다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132054483-01b3e988-376d-444f-9d5e-8415368e0822.png)\r\n\r\n[Google Domains](https://domains.google/)에서 구매하기로 했으며, Google Domains 기준 일반가는 12$다.\r\n\r\n<br />\r\n\r\n뭐든지 네이밍이 제일 어렵다. 게임 캐릭터 닉네임을 정하는 것도 그렇고, 변수명을 짓는 것도 그렇다.\r\n\r\n유명한 도메인인 `socket.io`처럼 뭔가 `dev`를 적절히 이용하여 하나의 문장처럼 보이는 도메인을 생성하고 싶었다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132054569-31a96ab2-652f-4631-849f-759d3c82f823.png)\r\n\r\n<br />\r\n\r\n<p class=\"orange-600\" align=\"center\">단어에 따라 프리미엄가가 붙기도 하며, 단어의 고유화 정도에 따라 같은 프리미엄이라도 가격이 다르게 적용된다.</p>\r\n\r\n<br />\r\n\r\n그렇다고 너무 <span class=\"amber-600\">범용적인 단어를 사용하면 프리미엄</span>이랍시고 가격을 매우 비싸게 받는다.... 일례로 `unix.dev`는 unix라는 보통명사가 들어갔음에도 아직 발급되지 않았는데, 프리미엄 가격이 무려 1,000$가 넘어간다. `webapps.dev`도 매우 비싸긴 마찬가지.\r\n\r\n하지만 여러 단어를 조합해서 만드는 문장은 인식을 잘 못하는지, 찾다보면 꽤 괜찮은 도메인임에도 프리미엄이 붙지 않기도 하다.\r\n\r\n고민끝에 선정한 후보는 아래와 같다.\r\n\r\n* itcode.dev\r\n* mustdo.dev\r\n* imnow.dev\r\n\r\n셋 다 프리미엄이 붙지 않으며, 최대한 도메인에 개발자스러움을 담았다. 원랜 `mustdo.dev`로 하려 했으나, `itcode.dev`의 깔끔함 때문에 막판에 이 쪽으로 선회했다.\r\n\r\n# Google Domains에서 도메인 발급받기\r\n\r\n도메인을 발급받을 수 있는 사이트는 여러군데가 있으나, 이 장에서는 Google Domains를 기준으로 설명한다.\r\n\r\n이유는 그냥 구글이라서.\r\n\r\n## 준비물\r\n\r\n* 서버\r\n* 해외결제를 지원하는 결제수단\r\n\r\n필자가 도메인을 발급받을 때 필요했던 준비물은 위와 같다.\r\n\r\n만약 Google Domains가 아닌 국내 사이트에서 결제한다면 해외결제는 신경쓰지 않아도 된다. Google의 경우 해외 서비스이므로 해외결제가 지원되야 한다.\r\n\r\n## 1. 도메인 결정하기\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132057934-b103e4ef-157d-46e1-b9aa-52a9b8f273c1.png)\r\n\r\n원하는 도메인을 검색하자.\r\n\r\n도메인을 골랐다면 우측 가운데 [카트] 버튼을 클릭하여 장바구니에 담는다.\r\n\r\n`dev` 도메인과 같이 몇몇 일부 도메인은 <span class=\"red-400\">More secure</span> 정책이 적용되어 SSL을 강제한다.\r\n\r\n이러한 정책이 적용된 도메인은 <span class=\"red-600\">HTTP 서비스가 불가능하며, 반드시 HTTPS 서비스만을 제공</span>함에 유의하자.\r\n\r\n## 2. 화폐 단위 선택하기\r\n\r\n첫 결제라면 결제할 화폐 단위를 선택해야한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132058739-2766fbd9-791c-4e19-971f-7520e46de5b2.png)\r\n\r\n아쉽게도 원화는 지원되지 않으므로, 지원되는 화폐 중 하나를 선택한다.\r\n\r\n이 장에서는 달러($)를 기준으로 수행한다.\r\n\r\n> <span class=\"yellow-600\">해외결제의 경우 달러가 수수료 측면에서 이득이다</span>  \r\n> 필자는 군대 전역 후 카드사 콜센터에서 잠깐 일을 한 적이 있었다. 거기서 얻은 지식 중 하나로, <span class=\"orange-600\">해외결제는 달러를 기준으로 환전</span>한다. 만약 원화 -> 유로로 결제한다면, 실제론 <span class=\"blue-600\">원화 -> 달러 -> 유로</span>로 두 차례 환전이 일어나 수수료 역시 이중으로 나간다.  \r\n> 이는 해외에서 원화를 결제할때도 마찬가지. 해외에서 국내 카드로 원화결제를 수행할 경우 <span class=\"blue-600\">원화 -> 달러 -> 원화</span>라는 해괴한 매커니즘으로 결제되니, 해외결제는 그냥 속편하게 달러로 하자.\r\n\r\n## 3. 사용자 정보 입력\r\n\r\n첫 결재라면 도메인 소유주 정보를 입력받는다. 적절히 입력하자.\r\n\r\n우편번호의 경우 <span class=\"red-600\">미국 우편번호만을 입력</span>받으니, 구글에 그냥 미국 주소 아무거나 쳐서 우편번호 하나 확인하여 입력하자.\r\n\r\n## 4. 도메인 구매\r\n\r\n도메인 구매를 수행한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132058813-3eb136bc-d801-40ac-a1c3-83a68478f6e4.png)\r\n\r\n<span class=\"red-600\">[Read trademark notice]</span>는 starcraft라는 브랜드명을 도메인으로 사용함에 따라 관련 약관의 동의를 받는 것이다.\r\n\r\n일반적인 도메인엔 해당 과정이 존재하지 않다.\r\n\r\n* <span class=\"amber-600\">Registration</span> - 소유 기간 선택 (최소 1년)\r\n* <span class=\"amber-600\">Privacy protection is on</span> - 도메인 소유주 정보를 숨긴다. 후이즈(WHOIS) 등에서 도메인 정보를 조회할 경우, 소유주에 대한 정보를 숨긴 채 제공한다.\r\n* <span class=\"amber-600\">Auto-renew is on</span> - 도메인 자동 갱신 활성화\r\n* <span class=\"grey-600\">Custom email</span> - 도메인 이메일계정 활성화\r\n\r\nCustom email은 자신의 도메인으로 된 구글 이메일을 만드는 것이다. 즉, `example@starcraft.dev`와 같이 <span class=\"orange-500\">자신이 구입한 도메인으로 이메일 아이디를 생성</span>해주는 서비스다.\r\n\r\n물론 무료는 아니고, 유저당 월 12$ 비용이 청구된다. 도메인 유지 비용이 연 12$임을 감안하면 10배에 달하는 비용이다. 비즈니스 등 반드시 필요한 서비스가 아니라면 해당 서비스는 체크를 해제하자.\r\n\r\n# IP와 도메인 연결하기\r\n\r\n도메인 구입이 완료되면 소유주 정보에 입력한 이메일로 구매 영수증과 함께 안내 메일이 수신된다.\r\n\r\n구입 이후 도메인은 즉시 사용이 가능하다. 이 도메인을 라즈베리파이에 연동하기 위해선 DNS 설정을 통해 <span class=\"green-600\">라즈베이파이의 IP와 도메인을 연결</span>해주면 된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132080600-d1083686-ceb4-4046-a6ab-c4a0c7a83f90.png)\r\n\r\nGoogle Domains의 DNS 메뉴에서 DNS 설정을 관리할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132080643-7a92c2ec-8b8a-4428-b4c3-4ba149bb6875.png)\r\n\r\n[맞춤 레코드 관리]를 클릭하여 DNS Record를 추가한다.\r\n\r\n<span class=\"green-600\">A Record를 하나 추가하여 데이터에 라즈베리파이의 IP를 입력</span>하고 저장한다. 수 분 이내로 반영이 완료된다.\r\n\r\n> <b class=\"teal-A400\">사설 IP 입력? 멈춰!</b>  \r\n> 공유기 환경을 사용한다면 IP 확인 시 <span class=\"pink-600\">192.168.0.xxx</span>와 같은 사설 IP가 출력될 것이다. A Record엔 사설 IP가 아닌 실제 IP를 입력해야한다. 공유기 설정이나 [findIP](https://www.findip.kr/)에서 확인할 수 있다.\r\n\r\n# 도메인 연동 확인\r\n\r\n``` bash\r\nnslookup [도메인]\r\n```\r\n\r\n윈도우든 Ubuntu든 위 명령어를 입력하여 도메인과 연동된 IP를 확인할 수 있다.\r\n\r\n내가 입력한 IP가 정상적으로 나온다면 성공이다.\r\n\r\n라즈베리파이에서 Tomcat을 기동하고 `example.com:8080`에 접속하여 페이지가 잘 출력되는지 확인하자.\r\n\r\n## 연결이 되지 않아요!\r\n\r\n* `xxx.xxx.xxx.xxx:8080`으로 접속되는지 확인\r\n* 접속이 될 경우 외부에서 문제없이 접속되므로, 도메인에 연결한 IP가 올바른지 확인\r\n* 접속되지 않을 경우 애초에 외부에서 접속되지 않는 것이므로 방화벽이나 포트 통신에 문제가 없는지 확인\r\n* 공유기 환경일 경우 IP주소의 포트포워딩이 설정되어있는지 확인\r\n\r\n# 목표\r\n\r\n* <del class=\"grey-400\">라즈베리파이에 Ubuntu 서버를 구축한다.</del>\r\n* <del class=\"grey-400\">Tomcat을 구동하여 페이지를 호스팅한다.</del>\r\n* <del class=\"grey-400\">도메인을 입힌다.</del>\r\n* SSL 인증서를 발급하여 HTTPS 통신을 제공한다.\r\n* SSH, RDP 등의 원격 통신환경을 구축한다.\r\n* MariaDB를 설치하여 DB 통신을 수행한다.\r\n\r\n`dev` 도메인은 반드시 SSL이 필요하다. 더군다나 현재에 배포되는 모든 웹 페이지엔 HTTPS 적용을 거의 강제하다시피 함으로 HTTPS 적용을 목표에 추가한다.","url":["2021-09-04-raspberry-domain","2021","09","04","raspberry-domain"]},{"header":{"title":"[Ubuntu] ufw로 방화벽 포트 설정하기","excerpt":"모든 건물에는 입구가 존재한다. 일반적인 상황에서, 누구든지 해당 건물에 드나들기 위해선 좋든 싫든 입구를 통과해야한다. 이 입구라는 것이 또 마냥 열려있는 건 아니라서, 필요 시엔 개방되어있다가도 특정 시간에는 폐쇄되기도 한다. 심지어 어떤 곳은 까다롭기 그지없어서, 사람을 가려받기도 한다. 이를테면 보안구역이라던가, 금요일 밤의 클럽이라던가. PC통신도 이와 원리가 별반 다를 바 없다. 보기엔 그냥 막 통신하는 것 같아도, 저마다 할당받은 입구를 통해 PC에 드나든다. PC가 건물이라고 한다면, PC의 입구는 포트(PORT)라 할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/132039520-3efc64ec-28c2-499c-af29-dfe153f53852.png","date":"2021-09-04T01:26:20","type":"posts","category":"Ubuntu","tag":["Ubuntu","방화벽"],"comment":true,"publish":true},"name":"2021-09-04-firewall-with-ufw.md","content":"\r\n# 개요\r\n\r\n모든 건물에는 입구가 존재한다. 일반적인 상황에서, 누구든지 해당 건물에 드나들기 위해선 좋든 싫든 입구를 통과해야한다.\r\n\r\n이 입구라는 것이 또 마냥 열려있는 건 아니라서, 필요 시엔 개방되어있다가도 특정 시간에는 폐쇄되기도 한다.\r\n\r\n심지어 어떤 곳은 까다롭기 그지없어서, 사람을 가려받기도 한다. 이를테면 보안구역이라던가, 금요일 밤의 클럽이라던가.\r\n\r\n<br />\r\n\r\nPC통신도 이와 원리가 별반 다를 바 없다. 보기엔 그냥 막 통신하는 것 같아도, 저마다 할당받은 입구를 통해 PC에 드나든다.\r\n\r\nPC가 건물이라고 한다면, PC의 입구는 포트(PORT)라 할 수 있다.\r\n\r\n<br />\r\n\r\n모든 프로그램은 PC와의 통신 시 임의의 입구, 포트를 할당받는다. 프로그램은 해당 포트를 통해 들어오고, 나가며 정해진 동작을 수행한다.\r\n\r\n만약 해당 포트가 막혀있다면, 해당 컴퓨터를 대상으론 정상적으로 동작할 수 없을 것이다.\r\n\r\n이 프로그램이 내 PC에 필요하다면 포트를 열어주면 될 것이고, 아니라면 포트를 닫음으로써 접근하지 못하게 함이 바람직하다. 혹은 인증된 소수의 프로그램에게만 포트를 허용할 수도 있을 것이다.\r\n\r\n<br />\r\n\r\n말 그대로 보안과 매우 밀접한 개념으로써, <span class=\"red-600\">방화벽 설정을 통해 원하는 포트를 원하는 대상에게 개방/폐쇄</span>할 수 있다.\r\n\r\nUbuntu에서 ufw를 통해 방화벽 설정을 원하는대로 설정해보자.\r\n\r\n# 그냥 다 열면 안 돼?\r\n\r\n조선시대 제주도는 문을 잠근다는 개념이 매우 미약했다고 한다.\r\n\r\n옛 교통방식과 섬이라는 폐쇄적인 환경 덕분에 유동인구가 매우 적었고, 각 마을 주민에 대한 신원이 확실했을 것이다. 내륙에 비해 외지인이 방문/거주할 일도 매우 적었을 것이다.\r\n\r\n이처럼 주변 환경과 사람들 간의 신뢰성이 있다면 굳이 그렇게 폐쇄적일 필요는 없을지도 모른다.\r\n\r\n<br />\r\n\r\n하지만 인터넷이라는 환경은 이와 결이 매우 다르다. 인터넷에 연결만 되어있다면 누구나 내 PC에 접근할 수 있는 잠재적 가능성을 가진다. 누가, 왜, 무엇을 위해 오는지도 알 수 없다.\r\n\r\n이 경우 문을 아무렇게나 열어재껴놓는건 바람직한 상황이 아닐 것이다.\r\n\r\n<br />\r\n\r\n방화벽은 이러한 문제로부터 PC를 최대한 보호하기위해, <span class=\"green-600\">기본적으로 폐쇄적인 설정</span>을 가진다. 일단 안 된다고 질러놓고 보는 셈이다.\r\n\r\n보안을 위해서 방화벽은 가급적 폐쇄하되, 필요한 프로그램만 개방하는 화이트리스트 방식을 쓰는 습관을 들이도록 하자.\r\n\r\n# ufw\r\n\r\n기본적인 방화벽 명령어 `iptables`가 있지만, 명령어가 그리 직관적이지 않다는 단점이 있다. 이에 비해 `ufw`는 `iptables`에 비해 훨씬 쉽고 직관적인 명령어로 다룰 수 있다.\r\n\r\n`iptables`과 성능상의 차이가 거의 없다는 점을 감안하면 확실한 장점.\r\n\r\n## ufw 설치\r\n\r\nufw는 기본 명령어가 아니다. <span class=\"blue-400\">ufw를 설치</span>하자.\r\n\r\n``` bash\r\nsudo apt-get install ufw\r\n```\r\n\r\n위 명령어를 통해 설치할 수 있다.\r\n\r\n## ufw 상태 관리 명령어\r\n\r\nufw의 상태를 관리하는 명령어다.\r\n\r\n``` bash\r\n# ufw 활성화\r\nsudo ufw enable\r\n\r\n# ufw 비활성화\r\nsudo ufw disable\r\n\r\n# ufw 상태 확인\r\nsudo ufw status verbose\r\n```\r\n\r\nufw가 설치된 후 방화벽에 영향을 주는 걸 방지하기 위해 <span class=\"blue-400\">기본적으로 비활성화 상태</span>로 설치된다.\r\n\r\n`sudo ufw enable` 명령어를 입력하여 활성화하자.\r\n\r\n## ufw 정책 관리 명령어\r\n\r\nufw에 적용된 <span class=\"blue-400\">정책을 관리</span>한다.\r\n\r\n``` bash\r\n# 정책 조회\r\nsudo ufw show raw\r\n\r\n# 기본 정책 허용\r\nsudo ufw default allow\r\n\r\n# 기본 정책 차단\r\nsudo ufw default deny\r\n```\r\n\r\n모든 포트 통신에 대한 일괄 허용/차단이 가능하다.\r\n\r\n``` bash\r\n# 들어오는 통신 차단\r\nsudo ufw default deny incoming\r\n\r\n# 나가는 통신 허용\r\nsudo ufw default allow outgoing\r\n```\r\n\r\n오는사람 막고 가는사람 안 막는다라는 말을 들어본 적이 있을 것이다. 보안도 똑같다. 내게 들어오는 통신은 최대한 폐쇄적으로, 내게서 나가는 통신은 개방적으로 대한다.\r\n\r\n## ufw 정책 설정 명령어\r\n\r\n``` bash\r\n# 80포트(HTTP) 허용\r\nsudo ufw allow 80\r\n\r\n# 80포트(HTTP) TCP 허용\r\nsudo ufw allow 80/tcp\r\n\r\n# 80포트(HTTP) UDP 허용\r\nsudo ufw allow 80/udp\r\n\r\n# 80포트(HTTP) 허용\r\nsudo ufw allow http\r\n```\r\n\r\n위 명령어는 <span class=\"blue-400\">HTTP 포트 80을 허용하는 명령어</span>들의 모음이다.\r\n\r\nufw는 고유 서비스 이름을 사용해서 포트를 관리할 수 있다. HTTP(80), HTTPS(443), FTP(21), SSH(22) 등이 이에 해당한다.\r\n\r\n`allow` 이외에도 `deny`를 통해 통신을 거부하거나, `delete`를 통해 해당 정책을 아예 지워버릴 수도 있다.\r\n\r\n정책을 지우게 되면 ufw에 설정된 기본 정책을 따르게 된다.\r\n\r\n## ufw 정책 세부설정 명령어\r\n\r\n### IP 통신 정책\r\n\r\n``` bash\r\n# 192.168.0.100 IP의 통신 허용\r\nsudo ufw allow from 192.168.0.100\r\n\r\n# 192.168.0.100 ~ 200 대역의 IP의 통신 허용\r\nsudo ufw allow from 192.168.0.100/200\r\n```\r\n\r\n위 명령어를 통해서 <span class=\"blue-400\">특정 IP 혹은 IP 대역의 통신을 관리</span>할 수 있다.\r\n\r\n### IP 및 포트 통신 정책\r\n\r\n``` bash\r\n# 192.168.0.100 IP의 80포트 허용\r\nsudo ufw allow from 192.168.0.100 to any port 80\r\n\r\n# 192.168.0.100 IP의 80포트 TCP 허용\r\nsudo ufw allow from 192.168.0.100 to any port 80 proto tcp\r\n```\r\n\r\n<span class=\"blue-400\">특정 IP의 특정 포트만 허용/차단</span>할 수도 있다.\r\n\r\n## ufw 정책 수정 명령어\r\n\r\n``` bash\r\nsudo ufw status numbered\r\n```\r\n\r\n현재 적용된 정책을 인덱스 번호와 함께 보여준다.\r\n\r\n해당 번호를 통해 <span class=\"blue-400\">정책을 수정, 삭제</span>할 수 있다.\r\n\r\n``` bash\r\n# 1번 정책을 80포트 차단 정책으로 변경\r\nsudo ufw insert 1 deny 80\r\n\r\n# 2번 정책을 192.168.0.100 IP의 통신 허용 정책으로 변경\r\nsudo ufw insert 2 allow from 192.168.0.100\r\n```\r\n\r\n## ufw 정책 삭제 명령어\r\n\r\n``` bash\r\n# 1번 정책 삭제\r\nsudo ufw delete 1\r\n```\r\n\r\n# 정리\r\n\r\n서비스에서 서버가 갖는 역할과 비중을 생각해본다면, 서버의 보안은 서비스의 안정성과 직결되는 중요한 문제다.\r\n\r\n때문에 서버의 보안은 귀찮을정도로 견고하게 구성되는 것이 바람직하다.\r\n\r\n<br />\r\n\r\n프로그램, 웹 등 모든 서비스의 기초는 데이터의 통신이므로, 통신을 잘 제어하는 것이 중요하다.\r\n\r\n반드시 필요한 통신만을 허가하고 관리하여 서버가 항상 최상의 보안을 유지할 수 있도록 보안정책을 구성하자.","url":["2021-09-04-firewall-with-ufw","2021","09","04","firewall-with-ufw"]},{"header":{"title":"[라즈베리파이 4] Ubuntu에 톰캣 설치하기","excerpt":"OS가 준비되었으므로 본격적으로 웹 서버 환경을 구축해보자. 대표적인 WAS인 Tomcat을 활용하여 페이지를 호스팅한다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-09-02T23:07:19","type":"posts","category":"RaspberryPi","tag":["라즈베리파이","Ubuntu","도메인"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-09-02-ubuntu-in-tomcat.md","content":"\r\n# 개요\r\n\r\nOS가 준비되었으므로 본격적으로 웹 서버 환경을 구축해보자. 대표적인 WAS인 Tomcat을 활용하여 페이지를 호스팅한다.\r\n\r\n* Tomcat 9.0.50\r\n\r\n# 웹 서버 구축하기\r\n\r\n아래의 과정을 통해 Ubuntu 서버에 웹 서버를 구축하자.\r\n\r\n## 1. JAVA 설치\r\n\r\n우리가 사용할 WAS는 Tomcat으로, 구동 시 WAS를 필요로한다.\r\n\r\n``` bash\r\nsudo apt-get install openjdk-15-jdk\r\n```\r\n\r\n원하는 JAVA 버전을 설치한다. 본 문서에서는 최신 버전인 JAVA 15를 설치한다.\r\n\r\n``` bash\r\njava -version\r\n```\r\n\r\n``` output\r\nopenjdk version \"15.0.3\" 2021-04-20\r\nOpenJDK Runtime Environment (build 15.0.3+3-Ubuntu-1)\r\nOpenJDK 64-Bit Server VM (build 15.0.3+3-Ubuntu-1, mixed mode, sharing)\r\n```\r\n\r\n`java -version` 명령어를 수행하여 위와 같은 형식의 결과물이 출력되면 JAVA 설치가 완료된 것이다.\r\n\r\n## 2. 환경변수 설정\r\n\r\nJAVA 환경변수를 설정한다. 자바 컴파일러인 `javac` 명령어 입력 시 실제로 호출되는 파일의 경로를 확인하여 설치 경로를 찾는다.\r\n\r\n``` bash\r\nwhich javac\r\n```\r\n\r\n``` output\r\n/usr/lib/jvm/java-15-openjdk-arm64/bin/javac\r\n```\r\n\r\n`which` 명령어는 명령어의 위치를 찾아주는 명령어다. 이를 입력하여 위치를 확인하면 위와 같은 경로가 나온다. `java-{VERSION}-openjdk-arm64`과 같은 폴더에 설치되어있으며, 버전마다 폴더명이 조금씩 다르다.\r\n\r\n위 경로는 폴더가 아닌, 명령어 파일의 경로다. `JAVA_HOME`은 자바가 설치된 최상위 경로인 `/usr/lib/jvm/java-15-openjdk-arm64`가 된다.\r\n\r\n사용자 설정파일인 `.profile`에 환경변수를 지정한다.\r\n\r\n``` bash\r\nvi ~/.profile\r\n```\r\n\r\n``` input\r\nexport JAVA_HOME=/usr/lib/jvm/java-15-openjdk-arm64\r\nexport PATH=$JAVA_HOME/bin:$PATH\r\n```\r\n\r\n사용자 설정파일을 열어 위 내용을 입력한다. `a` 혹은 `i`를 눌러 작성할 수 있다. 작성 이후 `:wq`를 입력하여 저장하면 된다.\r\n\r\n``` bash\r\nsource ~/.profile\r\n```\r\n\r\n위 명령어를 입력하여 변경된 사용자 설정파일을 갱신한다. 이를 입력하지 않으면 해당 쉘에서는 변경된 환경변수가 반영되지 않는다.\r\n\r\n## 3. Tomcat 설치\r\n\r\n``` bash\r\nsudo apt-get install tomcat9\r\nsudo apt-get install libtcnative-1\r\n```\r\n\r\n`tomcat9`는 Tomcat 9버전이고, `libtcnative-1` 패키지를 설치하여 컴파일없이 Tomcat Native를 활성화할 수 있다.\r\n\r\nTomcat Native 찾다보면 `./configure`, `make` 같은 명령어가 나오기도 하는데, Tomcat Native 모듈을 직접 컴파일하는 방식이니 참고할 것.\r\n\r\n톰캣의 설치 경로는 `/var/lib/tomcat9`다.\r\n\r\n``` bash\r\n# 톰캣 기동\r\nsystemctl start tomcat9\r\n\r\n# 톰캣 정지\r\nsystemctl stop tomcat9\r\n\r\n# 톰캣 재기동\r\nsystemctl restart tomcat9\r\n```\r\n\r\n위 명령어를 통해 톰캣 서비스를 on/off할 수 있다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131715233-e70c15ac-0e38-48f3-8618-96b63a87ee0e.png)\r\n\r\nTomcat Native 활성화 여부는 로그에서 확인할 수 있으며, 로그에 위와 같은 문구가 출력되면 Tomcat Native가 활성화된 것이다.\r\n\r\n``` bash\r\ncd /var/log/tomcat9\r\n```\r\n\r\nTomcat9 기준 로그는 위와 같으며, `catalina.yyyy-MM-dd.log` 형태의 파일을 열면 확인할 수 있다.\r\n\r\n## 4. 포트 개방\r\n\r\n통신에 사용할 포트를 개방한다.\r\n\r\nUbuntu는 <span class=\"primary\">ufw</span>로 방화벽 설정을 쉽게 관리할 수 있다.\r\n\r\n``` bash\r\nsudo apt-get install ufw\r\n```\r\n\r\n위 명령어를 입력하여 ufw를 설치할 수 있다.\r\n\r\n``` bash\r\n# ufw 활성화\r\nsudo ufw enable\r\n\r\n# ufw 비활성화\r\nsudo ufw disable\r\n\r\n# ufw 상태 확인\r\nsudo ufw status verbose\r\n```\r\n\r\nufw를 설치하면 기본적으로 비활성화되어있으므로, `sudo ufw enable` 명령어를 통해 활성화시킨다.\r\n\r\nTomcat의 경우 `8080`을 기본 포트로 사용하므로 해당 포트를 개방한다.\r\n\r\n``` bash\r\nsudo ufw allow 8080\r\n```\r\n\r\n> **ufw를 활용한 방화벽 구성하기**  \r\n> Ubuntu에선 ufw를 통해 방화벽을 쉽게 구성할 수 있으며, [이 게시글](/posts/2021/09/04/firewall-with-ufw)에서 사용법을 확인할 수 있다.\r\n\r\n## 4. 페이지 호스팅 확인\r\n\r\n``` bash\r\nifconfig -a\r\n```\r\n\r\n위 명령어를 입력하면 연결된 IP를 알 수 있으나, 공유기를 사용할 경우 `192.168.0.x`와 같은 사설 IP가 표시된다. 이 경우 공유기 설정에서 들어오는 실제 IP를 확인하자.\r\n\r\n* `eth0` - 이더넷 정보\r\n* `wlan0` - 무선랜 정보\r\n\r\n인터넷 연결 방식에 따라 위와 같이 구분된다. 동일한 방식으로 여러개가 연결되어있다면 숫자가 1씩 늘어난다.\r\n\r\n라즈베리파이의 IP `xxx.xxx.xxx.xxx:8080`에 접속하여 톰캣 페이지가 정상적으로 출력되는지 확인하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131716513-505d0ed5-32ef-423e-b86d-d020253cede0.png)\r\n\r\n별다른 설정을 변경하지 않았을 경우 위와 같은 관리자 페이지가 표시될 것이다.\r\n\r\n만약 정상적으로 출력되지 않는다면 아래 항복을 확인해보자.\r\n\r\n* 인터넷 연결이 정상적인지\r\n* 라즈베리파이에 연결된 IP가 맞는지\r\n* Tomcat 서비스 포트가 개방되어있는지\r\n* Tomcat이 정상적으로 구동되었는지\r\n\r\n# 목표\r\n\r\n* <del class=\"grey-400\">라즈베리파이에 Ubuntu 서버를 구축한다.</del>\r\n* <del class=\"grey-400\">Tomcat을 구동하여 페이지를 호스팅한다.</del>\r\n* 도메인을 입힌다.\r\n* SSH, RDP 등의 원격 통신환경을 구축한다.\r\n* MariaDB를 설치하여 DB 통신을 수행한다.","url":["2021-09-02-ubuntu-in-tomcat","2021","09","02","ubuntu-in-tomcat"]},{"header":{"title":"[라즈베리파이 4] 라즈베리파이에 Unbuntu 설치하기","excerpt":"목요일을 기점으로 모든 준비물의 배송이 완료됐다. 클린 상태의 라즈베리파이는 OS가 별도로 깔려있지 않은 FreeDOS 상태이므로, 직접 OS를 설치해야한다. 컴퓨터도 주기적으로 포맷하고, 가상머신도 몇 개 돌려본 나로썬 크게 문제될 건 없지만, 이건 내가 지금까지 다루던 컴퓨터와는 좀 다르다는점이 흠. 한 번도 다뤄보지 않은 장비인데다, 일반적인 데스크탑에 비해 여러 차이점과 제약사항이 있어 그리 순탄하진 않았다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-08-31T01:51:39","type":"posts","category":"RaspberryPi","tag":["라즈베리파이","Ubuntu"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-08-31-ubuntu-in-raspberry.md","content":"\r\n# 개요\r\n\r\n목요일을 기점으로 모든 준비물의 배송이 완료됐다. 클린 상태의 라즈베리파이는 OS가 별도로 깔려있지 않은 FreeDOS 상태이므로, 직접 OS를 설치해야한다. 컴퓨터도 주기적으로 포맷하고, 가상머신도 몇 개 돌려본 나로썬 크게 문제될 건 없지만, 이건 내가 지금까지 다루던 컴퓨터와는 좀 다르다는점이 흠.\r\n\r\n한 번도 다뤄보지 않은 장비인데다, 일반적인 데스크탑에 비해 여러 차이점과 제약사항이 있어 그리 순탄하진 않았다.\r\n\r\n# Rasbian? Ubuntu?\r\n\r\n라즈베리파이는 전용 OS인 <span class=\"pink-600\">Raspbian</span>이 존재한다. Raspbian은 라즈베리파이에 가장 최적화된 OS이므로 라즈베리파이의 네이티브한 영역을 쉽게 다룰 수 있을 것이다.\r\n\r\n하지만 난 라즈베리파이를 다룬다기보단 라즈베리파이를 통해 서버를 구축할 예정이므로, Raspbian보단 훨씬 범용적인 OS가 알맞다. 이를테면 CentOS 같은 거 말이다.\r\n\r\n그 중에서 내가 선택한 OS는 Ubuntu. CentOS는 RHEL에서 인수한 뒤 CentOS의 가장 큰 장점인 RHEL과의 동일성을 아작내놨다. 굳이 쓸 필요가 없어진 셈.\r\n\r\n때문에 이전부터 써보고 싶기도 했고, 한국인에게 가장 친숙한 Linux인 Ubuntu를 설치하고자 한다.\r\n\r\n익숙하지 않은 라즈베리파이로의 설치는 물론 관련 정보들을 쉽게 얻을 수 있을 것이다.\r\n\r\n# 라즈베이파이에 Ubuntu 설치하기\r\n\r\n본격적으로 라즈베리파이에 Ubuntu를 설치해보자.\r\n\r\n## 준비물\r\n\r\n* Raspberry Pi 4 Model B\r\n* 전원 케이블 (5V 3A 이상)\r\n* MicroSD, 리더기 (구형 펌웨어일 경우)\r\n* Micro HDMI, 혹은 HDMI 케이블 (모니터 쓸 경우)\r\n\r\n준비물은 위와 같다.\r\n\r\n원래 기본적으로 라즈베리파이는 MicroSD 이외에는 인식하지 않는다. USB같은 외장 디스크를 인식하려면 펌웨어의 업데이트가 필요하다.\r\n\r\n<span class=\"red-600\">2020년 8월 이후 출시된 보드의 경우 펌웨어가 기본적으로 업데이트</span>된다고 한다. 난 중고로 샀는데, 8월 이전 출시된 보드인지 USB를 바로 인식하지 않았었다.\r\n\r\n펌웨어 업데이트는 OS설치 후 가능하므로, 만약 <span class=\"red-600\">구형 보드라면 얄쨜없이 MicroSD가 필요</span>하니 참고할 것.\r\n\r\n<br />\r\n\r\n라즈베리파이는 기본적으로 Micro HDMI라고 하는 작은 단자를 제공한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131310544-4fc47a26-b541-45e1-ac8c-4586bcbdc978.png)\r\n\r\n위 사진의 좌측 단자가 일반적으로 알고있는 HDMI, 우측의 작은 단자가 Micro HDMI다. Argon M2 케이스의 경우 Micro HDMI와 연결된 HDMI 단자를 제공해주므로 상관없었으나, 별도의 케이스나 커넥터 없이 모니터를 연결할 경우 위 사진과 같은 <span class=\"amber-500\">Micro HDMI to HDMI</span> 케이블이 필요하니 주의할 것.\r\n\r\n## Ubuntu 설치파일 다운로드\r\n\r\n디스크에 Ubuntu를 설치하기위해 아래 두 파일을 다운로드하자.\r\n\r\n* [이미지 레코더 BalenaEtcher 다운로드](https://www.balena.io/etcher/)\r\n* [Ubuntu ISO 다운로드](https://ubuntu.com/download/raspberry-pi)\r\n\r\n이미지 레코더는 부팅 디스크를 만들어준다. Windows 포맷 USB를 만드는 과정이라고 생각하면 된다.\r\n\r\nUbuntu는 Linux이므로, 위 경로에서 쉽게 다운로드 받을 수 있다.\r\n\r\n* <span class=\"orange-600\">Ubuntu Server</span> - CLI 기반 (GUI 없음)\r\n* <span class=\"orange-600\">Ubuntu Desktop</span> - GUI 기반 (설치 시 모니터 필요)\r\n\r\n페이지에 접속하면 두 버전을 다운로드 받을 수 있다. Desktop은 우리가 일반적으로 알고있는 GUI 기반의 OS다. Server는 DOS같은 명령어 기반의 CLI OS다. 어떤 걸 설치해도 상관없으나 Linux에 익숙하지 않다면 Desktop을 추천한다. 하지만 <span class=\"red-500\">GUI 기반이므로 설치 후 OS 셋팅 시 모니터가 필요함</span>에 유의하자.\r\n\r\n이 문서에서는 Ubuntu Desktop을 설치한다. Electron 같은 UI 프로그램이나 Ubuntu에서의 웹 페이지 테스트를 위해선 GUI 환경이 필요하다. CLI에선 브라우저를 띄우는 등의 행위가 불가능하기 때문. Ubuntu Server도 추후 관련 프로그램을 설치하여 GUI 환경으로 구동할 수 있다.\r\n\r\n## Ubuntu 부팅 디스크 만들기\r\n\r\n아래의 과정을 통해 부팅 디스크를 만든다. 본문에서는 MicroSD로 진행한다. 디스크 종류가 달라진다고 해서 과정이 달라지지 않으니 걱정하지 않아도 된다.\r\n\r\n### 1. BalenaEtcher 실행\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131342380-c9c0d006-e4cf-457a-9cbf-66ffcfbf8e4f.png)\r\n\r\nUSB를 꽂고 다운로드받은 <span class=\"green-400\">BalenaEtcher를 실행</span>한다.\r\n\r\n### 2. Ubuntu ISO 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131342500-b406e9e9-c72f-41f6-aedb-1e1d88f678f7.png)\r\n\r\n다운로드받은 <span class=\"green-400\">Ubuntu ISO를 선택</span>한다. 선택한 ISO가 디스크에 기록될 것이다.\r\n\r\nUbuntu Desktop ISO는 용량이 많음에 유의하자.\r\n\r\n### 3. 디스크 드라이브 선택\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131343798-ae4caaa3-5b39-42cc-8d87-362bde5ad5eb.png)\r\n\r\nISO가 기록될 디스크 드라이브를 선택한다.\r\n\r\n<span class=\"blue-400\">[Show hidden]</span>을 클릭하면 USB 형태의 외장 드라이브 뿐만 아니라, M2 혹은 SATA와 연결된 D드라이브 등도 선택 가능하다. 물론 그럴일은 없겠지만, 시스템 드라이브는 선택 불가능하다.\r\n\r\n### 4. 디스크 기록\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131343897-2ab71120-ba0e-4a10-9e20-85b7f562f25c.png)\r\n\r\n모든 선택이 완료되면 <span class=\"blue-400\">[Flash!]</span> 버튼을 클릭하여 부팅 디스크를 만든다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131344037-dd53f8e7-4a66-4e3e-90d5-dd06bdf79904.png)\r\n\r\nSSD같이 Disk I/O가 빠르면 금방 끝나지만, 느리면 수 분의 시간이 걸린다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/131344661-ef5737a7-e2b8-483b-88af-9f79318c6661.png)\r\n\r\n완료되면 위와 같은 화면이 뜬다.\r\n\r\n디스크를 뺐다 껴서 다시 인식시키면 아래 두 디스크가 인식된다.\r\n\r\n* `system-boot` 혹은 `boot` - 부팅 디스크\r\n* 메인 디스크\r\n\r\n이 부팅 디스크를 라즈베리파이에 연결하면 Ubuntu를 사용할 수 있다.\r\n\r\n## 라즈베리파이 연결\r\n\r\n부팅 디스크를 라즈베리파이에 연결하자. MicroSD라면 칩 아래쪽에, USB라면 USB 단자 등 맞는 방식으로 연결하면 된다.\r\n\r\n정상적으로 부팅되면 빨간불과 함께 녹색불이 점멸한다. <span class=\"red-500\">빨간불만 뜨면 부팅 중 문제가 있다는 뜻</span>이다. 이 경우 모니터를 연결해야 자세한 문제를 확인할 수 있다.\r\n\r\n이후 셋팅은 일반적인 Ubuntu 사용과 동일하다. 사용자 생성하고 설정값 지정하고 그런 것들.\r\n\r\n본인이 MicroSD가 아닌 USB로 부팅디스크를 만들었는데, 화면에서 <span class=\"red-500\">USB Stop</span>이라는 문구가 뜨며 반복적으로 Fail이 뜨면 USB를 인식할 수 없는 구형보드라는 뜻이다. \r\n\r\nMicroSD 정도로 만족하거나, 신형 보드라서 애초에 USB나 SSD를 부팅 디스크로 사용했다면 그냥 쓰면 된다. 하지만 본인의 라즈베리파이의 펌웨어가 구형이고, MicroSD로는 만족할 수 없다면 아래의 과정을 통해 펌웨어 업데이트를 진행해야한다.\r\n\r\n# 펌웨어 업데이트\r\n\r\n<p class=\"red-600\" align=\"center\">USB가 인식되는 신형 펌웨어는 수행할 필요 없음</p>\r\n\r\n라즈베리파이가 USB나 SSD를 부팅 디스크로 인식할 수 있도록 펌웨어를 업데이트한다.\r\n\r\n펌웨어 업데이트는 반드시 라즈베리파이에 OS가 설치된 후에 진행할 수 있다. 즉, 구형 보드에서 SSD로 부팅하려면 MicroSD로 부팅 한 번, 펌웨어 업데이트 후 SSD로 부팅 한 번으로 총 두 개의 부팅 디스크를 만들어야 한다.\r\n\r\n## 1. 패키지 최신화\r\n\r\n먼저, 터미널을 열어 아래 두 명령어를 입력한다.\r\n\r\n``` bash\r\nsudo apt-get update\r\nsudo apt-get upgrade\r\n```\r\n\r\n패키지 저장소 및 설치된 패키지를 최신화한다.\r\n\r\n## 2. 설정값 변경\r\n\r\n업데이트가 완료되면 아래의 명령어를 입력하여 해당 파일의 내용을 변경한다.\r\n\r\n``` bash\r\nsudo vim /etc/default/rpi-eeprom-update\r\n```\r\n\r\n`FIRMWARE_RELEASE_STATUS=\"critical\"` 설정값에서 `critical`을 `stable`로 변경한다.\r\n\r\n즉, `FIRMWARE_RELEASE_STATUS=\"stable\"`로 변경해주면 된다.\r\n\r\n## 3. 부트로더 업데이트\r\n\r\n이제 부트로더를 업데이트한다.\r\n\r\n``` bash\r\nsudo rpi-eeprom-update -d -f /lib/firmware/raspberrypi/bootloader/stable/pieeprom-2020-06-15.bin\r\n```\r\n\r\n해당 경로에 가보면 `2020-06-15` 버전 말고도 `2020-07-16`, `2020-12-11` 등 다양한 버전이 있는데, 대부분 위 버전을 추천하는 것 같다.\r\n\r\n필자는 최신버전을 좋아해서, 버전 중 가장 최신이였던 `2020-12-11`로 업데이트했으나 설정값이 이상하여 결국 상기한 `2020-06-15` 버전으로 다시 업데이트했다. 업데이트는 금방되니 부담가질 필요는 없다.\r\n\r\n## 4. 확인\r\n\r\n``` bash\r\nsudo reboot\r\n```\r\n\r\n부트로더 업데이트가 완료되면 기기를 재부팅한다.\r\n\r\n재부팅이 완료되면 아래의 명령어를 입력하여 USB를 인식할 수 있는지 확인하자.\r\n\r\n``` bash\r\nsudo vcgencmd bootloader_config\r\n```\r\n\r\n``` output\r\n[all]\r\nBOOT_UART=0\r\nWAKE_ON_GPIO=1\r\nPOWER_OFF_ON_HALT=0\r\nDHCP_TIMEOUT=45000\r\nDHCP_REQ_TIMEOUT=4000\r\nTFTP_FILE_TIMEOUT=30000\r\nENABLE_SELF_UPDATE=1\r\nDISABLE_HDMI=0\r\nBOOT_ORDER=0xf41\r\n```\r\n\r\n위 명령어를 입력하면 이와 같은 형식의 설정값이 출력된다. 다른건 상관없고, `BOOT_ORDER`의 값이 `0xf41`라면 정상적으로 업데이트가 완료된 것이다.\r\n\r\n이제 라즈베리파이가 USB를 부팅 디스크로 인식할 수 있다.\r\n\r\n디스크의 값이 아닌 라즈베리파이 기기 자체의 펌웨어가 업데이트된 것이므로, MicroSD에서 USB로 디스크가 바뀌어도 업데이트는 유지된다. 필자는 이걸 몰라서 쓸데없는 고민을 했었다.\r\n\r\n## 5. 부팅 디스크 재생성\r\n\r\n이제 MicroSD의 역할은 모두 끝났다. 나중을 대비해 MicroSD는 고이 모셔두자. 아주 간간히 쓸 일이 생기기도 하고 그런다.\r\n\r\nUSB, SSD 등 원하는 디스크에다 본문의 [부팅 디스크 만들기](#Ubuntu-부팅%20디스크%20만들기) 과정을 다시 수행한다.\r\n\r\n# 설정\r\n\r\nUbuntu 설치가 완료되면, 이후는 우리가 아는 일반적인 OS 셋팅이 진행된다.\r\n\r\nUbuntu Desktop의 경우, 언어, 계정 등의 설정이 추가로 진행된다.\r\n\r\nUbuntu Server의 경우, CLI 환경이므로 별도의 설정이 필요하지 않다. 기본 계정이 생성되며, 아이디와 비밀번호 모두 동일하게 ubuntu다. 로그인 후 바꿔주자. \r\n\r\n# 목표\r\n\r\n* <del class=\"grey-400\">라즈베리파이에 Ubuntu 서버를 구축한다.</del>\r\n* 도메인을 입힌다.\r\n* SSH, RDP 등의 원격 통신환경을 구축한다.\r\n* Tomcat을 구동하여 페이지를 호스팅한다\r\n* MariaDB를 설치하여 DB 통신을 수행한다.","url":["2021-08-31-ubuntu-in-raspberry","2021","08","31","ubuntu-in-raspberry"]}],"categories":{"All":{"count":66,"flag":true},"Ubuntu":{"count":2,"flag":true},"RaspberryPi":{"count":3,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"Ubuntu","page":1,"hash":"b081f613afd"},"__N_SSG":true}