{"pageProps":{"posts":[{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1020번 디지털 카운터","excerpt":"지민이는 매 초마다 수가 증가하는 N자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. 10^N-1에 이르면 다시 0부터 시작한다. 각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다. 모든 인접한 두 개의 선분은 +로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다. 현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오. 1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 N자리를 채워야 하므로, N자리보다 작을 때는 앞에 0이 있을 수도 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-08-24T01:17:46","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","PLATINUM","PLATINUM II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-08-24-a1020.md","content":"\r\n# 디지털 카운터\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1020번 문제](https://www.acmicpc.net/problem/1020)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 매 초마다 수가 증가하는 $N$자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. $10^{N - 1}$에 이르면 다시 0부터 시작한다.\r\n\r\n각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다.\r\n\r\n``` input\r\n    +   +---+   +---+   +   +   +---+\r\n    |       |       |   |   |   |\r\n    +   +---+   +---+   +---+   +---+\r\n    |   |           |       |       |\r\n    +   +---+   +---+       +   +---+\r\n\r\n+---+   +---+   +---+   +---+   +---+\r\n|           |   |   |   |   |   |   |\r\n+---+       +   +---+   +---+   +   +\r\n|   |       |   |   |       |   |   |\r\n+---+       +   +---+       +   +---+\r\n```\r\n\r\n모든 인접한 두 개의 선분은 $+$로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다.\r\n\r\n현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오.\r\n\r\n1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 $N$자리를 채워야 하므로, $N$자리보다 작을 때는 앞에 0이 있을 수도 있다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 현재 카운터에 나와있는 수가 주어진다. $N$은 그 수의 길이와 같다. (수가 0으로 시작할 수도 있음) 그리고, $N$은 15보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 최소 몇 초가 지나야 현재 카운터에 나와 있는 수와 선분의 개수가 같아지는지 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n``` input\r\n007\r\n```\r\n\r\n``` output\r\n11\r\n```\r\n\r\n# 풀이\r\n\r\n## 문제 이해하기\r\n\r\n문제 이해도는 그리 높지 않다. <span class=\"green-A400\">디지털 계산기</span>를 생각해보자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/124596989-df266800-de9d-11eb-963c-2dea1d25f9b3.png)\r\n\r\n숫자를 표현하는데 여러 개의 선분이 필요하며, 문제의 기호보다 위 그림을 보면 쉽게 이해할 수 있을 것이다. 각 숫자를 표현하는데 필요한 숫자를 표로 정리하면 아래와 같다.\r\n\r\n|   숫자    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 선분 갯수 |   6   |   2   |   5   |   5   |   4   |   5   |   6   |   3   |   7   |   5   |\r\n\r\n### 특징 1\r\n\r\n임의의 숫자 02를 표현하는데 필요한 선분의 갯수는 각각 6개와 5개로, 11개의 선분이 필요하다.\r\n\r\n숫자는 1초마다 바뀌며, 선분의 합이 11개가 되는 숫자가 몇 초 뒤에 나오는지를 계산하면 된다. 선분의 합이 11개인 가장 가까운 수는 03으로, 1초가 걸린다.\r\n\r\n만약 정해진 자릿수의 최대를 넘어가면 0부터 다시 돌아와 카운팅한다. 즉, 02의 경우 두 자리이므로, 99를 넘어서면 다시 00으로 되돌아간다.\r\n\r\n### 특징 2\r\n\r\n이번엔 임의의 숫자 98의 케이스를 생각해보자. 주어진 숫자가 두 자리이므로, $N = 2$임을 알 수 있다. 98을 표현하는데 필요한 선분의 갯수는 각각 7과 5로, 12개의 선분이 필요하다.\r\n\r\n99 역시 총 10개의 선분으로 이루어지므로 답이 되지 못하며, 두 자리 수의 최대값은 99이므로 00으로 넘어가서 값을 찾는다. <span class=\"primary\">오버플로우(Overflow)</span>의 개념과 동일하다.\r\n\r\n0은 6개의 선분으로 이루어져 있으므로, 00을 표현하는데 필요한 선분의 갯수는 12개다. 즉, 답은 2초가 된다.\r\n\r\n이렇게 정해진 자릿수를 초과할 경우 또한 계산해야한다.\r\n\r\n## 다이나믹 프로그래밍 적용하기\r\n\r\n문제의 요구사항도 직관적이고, 특징 또한 그리 복잡하지 않다. 순수히 문제에서 요구하는 로직 자체가 어렵다.\r\n\r\n숫자의 자릿수가 최대 15자리(100조)에 육박하므로, 이렇게 많은 양의 데이터를 빠르게 처리하는데는 <span class=\"primary\">다이나믹 프로그래밍</span>이 적절할 것이다.\r\n\r\n또한 `int`는 약 21억까지만 다룰 수 있으므로, `long` 데이터를 써야함을 짐작할 수 있다.\r\n\r\n<br />\r\n<br />\r\n\r\n그 어떤 고려사항 없이 무식하게 접근한다면 그리 어렵지 않을 것이다. 숫자를 하나하나 분리해서 선분의 갯수를 구하여 합한 다음, 현재 숫자부터 1씩 증가시키며 위 계산을 반복하면 될 것이다. 물론 그렇게 쉬웠다면 내가 일주일 넘게 고민하지도 않았겠지만.\r\n\r\n<span class=\"primary\">다이나믹 프로그래밍</span>은 이분 매칭과 같은 특정한 패턴이 있는게 아닌 개념에 가까워서, 이를 적절히 적용할 수 있는 접근 방식<span class=\"grey-400\">(점화식 등)</span>을 도출해야한다.\r\n\r\n### 원리 이해하기\r\n\r\n이 알고리즘의 핵심은 <span class=\"red-A400\">선분의 합</span>이다. <span class=\"orange-400\">하나의 숫자를 표시하는데 필요한 선분의 수는 2 ~ 7 사이의 값</span>을 가진다. 동일한 선분의 갯수를 가지는 숫자가 있으므로 일부 겹친다.\r\n\r\n만약 하나의 숫자를 통해 만들 수 있는 선분의 합을 나열하고, 이 합을 가질 수 있는 숫자들 중 가장 작은 수를 표시하면 아래와 같다.\r\n\r\n| 선분 갯수 |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n예를 들어, 선분의 갯수가 5인 숫자는 [ 2, 3, 5, 9 ]로 4개가 존재한다. 그 중 가장 작은 수는 4이므로 위 표의 5에는 2가 매칭된다.\r\n\r\n위 표는 한 자릿수에서 나올 수 있는 경우의 수다. 만약 두 자릿수를 기준으로 표를 도식하면 아래와 같다. 한 자릿수에서의 최소값이 2, 최대값이 7이므로, 두 자릿수에서는 4 ~ 14의 범위를 가짐을 유추할 수 있다.\r\n\r\n| 선분 갯수 |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |\r\n\r\n위처럼 나타낼 수 있다. 두 자릿수에서 선분의 합이 11인 수는 02가 가장 작음을 바로 찾을 수 있다.\r\n\r\n이러한 원리를 통해 자릿수를 하나하나 넓혀가며 동일한 선분을 가지는 값을 빠르게 찾을 수 있다.\r\n\r\n예를 들어, **0598**와 동일한 선분의 수를 갖는 가장 가까운 수를 찾아보자. **0598**의 선분합은 6 + 5 + 5 + 7 = <p class=\"amber-600\">23</p>이다. 즉, 0598과 가장 가까우면서 선분의 합이 23인 숫자를 찾으면 된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"amber-600 large\">1. 1의 자리 비교하기</p>\r\n\r\n1의 자리를 비우면 **059_**와 같이 표기할 수 있다. 8의 선분값은 7이므로 **_**에 0부터 9까지 순차적으로 대입하여 선분값이 <span class=\"lightBlue-600\">7</span>이 되는 수를 찾는다. 단, 원래의 값인 8은 탐색 대상에서 제외한다.\r\n\r\n선분의 합이 7이 되는 한 자릿수는 8 이외엔 없으므로, 1의 자리에선 동일한 선분합을 갖는 숫자가 자신 이외에 없다.\r\n\r\n따라서 1의 자리 조합으로는 만족하는 수를 찾을 수 없다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"amber-600 large\">2. 10의 자리 비교하기</p>\r\n\r\n10의 자리를 비우면 **05_X**와 같이 표기할 수 있다. **_**는 0부터 9까지 대입할 자리이며, **X**은 해당 자리에서 나올 수 있는 선분의 합을 가지는 가장 작은 수가 대입된다.\r\n\r\n| 선분 갯수 |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n즉, **X**는 위 표에 해당하는 0, 1, 2, 4, 7, 8만 올 수 있다.\r\n\r\n* `_` 0 ~ 9\r\n* `X` 0, 1, 2, 4, 7, 8\r\n\r\n**_**와 **X**의 합이 8, 9의 선분합과 동일하면 된다. 따라서 선분의 합이 <span class=\"lightBlue-600\">12</span>가 되는 조합을 찾는다.\r\n\r\n| 구분  |                    0                    |   1    |                    2                    |                    3                    |    4    |                    5                    |                    6                    |    7    |                    8                    |                    9                    |\r\n| :---: | :-------------------------------------: | :----: | :-------------------------------------: | :-------------------------------------: | :-----: | :-------------------------------------: | :-------------------------------------: | :-----: | :-------------------------------------: | :-------------------------------------: |\r\n|   1   |                 01 (8)                  | 11 (4) |                 21 (7)                  |                 31 (7)                  | 41 (6)  |                 51 (7)                  |                 61 (8)                  | 71 (5)  |                 81 (9)                  |                 91 (7)                  |\r\n|   7   |                 07 (9)                  | 17 (5) |                 27 (8)                  |                 37 (8)                  | 47 (7)  |                 57 (8)                  |                 67 (9)                  | 77 (6)  |                 87 (10)                 |                 97 (8)                  |\r\n|   4   |                 04 (10)                 | 14 (6) |                 24 (9)                  |                 34 (9)                  | 44 (8)  |                 54 (9)                  |                 64 (10)                 | 74 (7)  |                 84 (11)                 |                 94 (9)                  |\r\n|   2   |                 02 (11)                 | 12 (7) |                 22 (10)                 |                 32 (10)                 | 42 (9)  |                 52 (10)                 |                 62 (11)                 | 72 (8)  | <span class=\"yellow-600\">82 (12)</span> |                 92 (10)                 |\r\n|   0   | <span class=\"yellow-600\">00 (12)</span> | 10 (8) |                 20 (11)                 |                 30 (11)                 | 40 (10) |                 50 (11)                 | <span class=\"yellow-600\">60 (12)</span> | 70 (9)  |                 80 (13)                 |                 90 (11)                 |\r\n|   8   |                 08 (13)                 | 18 (9) | <span class=\"yellow-600\">28 (12)</span> | <span class=\"yellow-600\">38 (12)</span> | 48 (11) | <span class=\"yellow-600\">58 (12)</span> |                 68 (13)                 | 78 (10) |                 88 (14)                 | <span class=\"yellow-600\">98 (12)</span> |\r\n\r\n0500, 0528, 0538, 0558, 0560, 0582, 0598이 후보군이다.\r\n\r\n하지만 0598은 자기 자신으로 제외되며, 나머지 숫자 모두 조건은 맞지만, 0598보다 작다. 한 사이클을 돌아야 나오는 수이므로, 아직 속단하긴 이르다.\r\n\r\n<br />\r\n<br />\r\n\r\n<p class=\"amber-600 large\">3. 100의 자리 비교하기</p>\r\n\r\n100의 자리를 비우면 **0_XX**와 같이 표기할 수 있다.\r\n\r\n| 선분 갯수 |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |\r\n\r\n즉, **XX**는 위 표에 해당하는 00, 01, 02, 04, 07, 08, 11, 12, 14, 17, 88만 올 수 있다.\r\n\r\n* `_` 0 ~ 9\r\n* `X` 00, 01, 02, 04, 07, 08, 11, 12, 14, 17, 88\r\n\r\n**_**와 **XX**에 값을 각각 대입해봄으로써 5, 8, 9의 선분합인 17을 가지는 수를 찾는다.\r\n\r\n| 구분  |                    0                     |    1     |                    2                     |                    3                     |                    4                     |                    5                     |                    6                     |                    7                     |                    8                     |                    9                     |\r\n| :---: | :--------------------------------------: | :------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: |\r\n|  11   |                 011 (10)                 | 111 (6)  |                 211 (9)                  |                 311 (9)                  |                 411 (8)                  |                 511 (9)                  |                 611 (10)                 |                 711 (7)                  |                 811 (11)                 |                 911 (9)                  |\r\n|  17   |                 017 (11)                 | 117 (7)  |                 217 (10)                 |                 317 (10)                 |                 417 (9)                  |                 517 (10)                 |                 617 (11)                 |                 717 (8)                  |                 817 (12)                 |                 917 (10)                 |\r\n|  14   |                 014 (12)                 | 114 (8)  |                 214 (11)                 |                 314 (11)                 |                 414 (10)                 |                 514 (11)                 |                 614 (12)                 |                 714 (9)                  |                 814 (13)                 |                 914 (11)                 |\r\n|  12   |                 012 (13)                 | 112 (9)  |                 212 (12)                 |                 312 (12)                 |                 412 (11)                 |                 512 (12)                 |                 612 (13)                 |                 712 (10)                 |                 812 (14)                 |                 912 (12)                 |\r\n|  01   |                 001 (14)                 | 101 (10) |                 201 (13)                 |                 301 (13)                 |                 401 (12)                 |                 501 (13)                 |                 601 (14)                 |                 701 (11)                 |                 801 (15)                 |                 901 (13)                 |\r\n|  07   |                 007 (15)                 | 107 (11) |                 207 (14)                 |                 307 (14)                 |                 407 (13)                 |                 507 (14)                 |                 607 (15)                 |                 707 (12)                 |                 807 (16)                 |                 907 (14)                 |\r\n|  04   |                 004 (16)                 | 104 (12) |                 204 (15)                 |                 304 (15)                 |                 404 (14)                 |                 504 (15)                 |                 604 (16)                 |                 704 (13)                 | <span class=\"yellow-600\">804 (17)</span> |                 904 (15)                 |\r\n|  02   | <span class=\"yellow-600\">002 (17)</span> | 102 (13) |                 202 (16)                 |                 302 (16)                 |                 402 (15)                 |                 502 (16)                 | <span class=\"yellow-600\">602 (17)</span> |                 702 (14)                 |                 802 (18)                 |                 902 (16)                 |\r\n|  00   |                 000 (18)                 | 100 (14) | <span class=\"yellow-600\">200 (17)</span> | <span class=\"yellow-600\">300 (17)</span> |                 400 (16)                 | <span class=\"yellow-600\">500 (17)</span> |                 600 (18)                 |                 700 (15)                 |                 800 (19)                 | <span class=\"yellow-600\">900 (17)</span> |\r\n|  08   |                 008 (19)                 | 108 (15) |                 208 (18)                 |                 308 (18)                 | <span class=\"yellow-600\">408 (17)</span> |                 508 (18)                 |                 608 (19)                 |                 708 (16)                 |                 808 (20)                 |                 908 (18)                 |\r\n|  88   |                 088 (20)                 | 188 (16) |                 288 (19)                 |                 388 (19)                 |                 488 (18)                 |                 588 (19)                 |                 688 (20)                 | <span class=\"yellow-600\">788 (17)</span> |                 888 (21)                 |                 988 (19)                 |\r\n\r\n0002, 0200, 0300, 0408, 0500, 0602, 0788, 0804, 0900이 후보군이다.\r\n\r\n이 중 0602는 입력값인 0598과 <span class=\"lightBlue-600\">4</span>만큼 차이가 나므로 선분의 갯수가 동일한 가장 가까운 수다.\r\n\r\n얼고리즘이 요구하는 답은 <span class=\"green-500\">선분의 갯수가 동일한 가장 가까운 수가 나오는데 걸리는 시간</span>이다. 각 숫자는 1초마다 바뀌므로, 0598에서 0602가 되는데 걸리는 시간 <span class=\"lightBlue-600\">4</span>가 답이 된다.\r\n\r\n### DP배열 만들기\r\n\r\n위 예제의 경우 <span class=\"amber-600\">0598</span>의 선분합을 구하고, 0599부터 하나하나 계산하면서 나아가면 쉽게 풀 수 있을 것이다. 하지만 이 방식은 매우 비효율적이기 때문에 알고리즘의 취지와는 맞지 않다.\r\n\r\n한 자릿수, 두 자릿수에서 나올 수 있는 선분합의 최소값을 가지는 수를 정리하면 아래와 같다.\r\n\r\n* 한 자릿수\r\n\r\n| 선분 갯수 |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n* 두 자릿수\r\n\r\n| 선분 갯수 |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   숫자    |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |\r\n\r\n위 표의 값들을 계산하여 하나의 표로 만들면 <span class=\"primary\">메모이제이션</span>을 적용할 수 있을 것이다.\r\n\r\n메모이제이션을 적용할 배열 `dp[i][j]`가 있다고 가정하자. 각 인덱스의 의미는 아래와 같다.\r\n\r\n* $i$: 자릿수 $(i = 1, 2, \\, \\, \\, \\dotsm \\, \\, \\, , 14, 15)$\r\n* $j$: 선분의 합\r\n\r\n<p class=\"red-400 small\">※ i와 j엔 0이 오지 않는다. 이유는 후술</p>\r\n\r\n* $dp[1][6]$: 선분의 합이 6인 한자리 수 중 가장 작은 수\r\n* $dp[2][12]$: 선분의 합이 12인 두자리 수 중 가장 작은 수\r\n* $dp[n][m]$: 선분의 합이 m인 n자리 수 중 가장 작은 수\r\n\r\n만약 $dp[3][6]$을 구할 경우, 세 자릿수의 선분 합이 6인 숫자의 최소값이므로 111(2 + 2 + 2)가 된다. 이렇게 적절한 값이 나올 수 있도록 배열 `dp`의 표현식을 도출해야한다.\r\n\r\n### DP배열 예시\r\n\r\nDP배열의 예시는 아래와 같다.\r\n\r\n| $i$, $j$ |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |  15   |  16   |  17   |  18   |  19   |  20   |  21   |\r\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|    0     |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|    1     |   -   |   -   |   1   |   7   |   4   |   2   |   0   |   8   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|    2     |   -   |   -   |   -   |   -   |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|    3     |   -   |   -   |   -   |   -   |   -   |   -   |  111  |  117  |  114  |  112  |  011  |  017  |  014  |  012  |  001  |  007  |  004  |  002  |  000  |  008  |  088  |  888  |\r\n\r\n세 자리 숫자를 기준으로 계산한 DP배열은 위와 같다. 자릿수를 기준으로 $i$값이 비례해서 늘어난다. 하지만 배열의 값은 고정적으로, 숫자가 변한다고 해서 DP배열의 값이 이에 따라 변하지 않는다.\r\n\r\n쉽게 말하면 0598과 135 숫자를 입력값으로 했을 때, `dp[2][7]`은 둘 다 12로 동일하다.\r\n\r\n### DP배열 크기 선언하기\r\n\r\n알고리즘에서의 자릿수는 $N$이므로, `dp`의 크기를 식으로 표현하면 아래와 같다.\r\n\r\n``` java\r\nlong[] dp = new long[N + 1][(N * 7) + 1];\r\n\r\nArrays.fill(arr, Long.MAX_VALUE);\r\n```\r\n\r\n요소의 값이 크므로 `long` 배열로 선언한다. 배열 `dp`는 가급적 적절한 큰 값으로 초기화를 진행해준다.\r\n\r\n본 문서에서는 `long`의 최대값인 `Long.MAX_VALUE`로 배열 전체를 초기화한다.\r\n\r\n<br />\r\n\r\n``` java\r\nprivate static final int[] FLAG = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 5 };\r\n```\r\n\r\n숫자 선분의 갯수 또한 코드화한다. `FLAG`는 각 해당 인덱스 숫자가 가지는 선분의 합을 반환한다.\r\n\r\n`FLAG[2]`는 숫자 2의 선분합으로, 5를 반환한다.\r\n\r\n<br />\r\n\r\n$N = 3$일 경우, 세 자릿수를 가지며, 선분 합의 최대값은 21이다. 이를 배열로 초기선언하면 `new long[3][21]`로 표현할 수 있겠지만, 컴퓨터 언어의 특성으로 혼란이 생긴다.\r\n\r\n대부분의 컴퓨터 언어는 배열의 시작을 `0`으로 본다. 위와 같이 선언한 매열에서 두 자릿수를 가지며, 선분 합이 10인 값을 호출하려면 `dp[2][10]`이 아니라 `dp[1][9]`를 호출해야한다.\r\n\r\n특히 이렇게 복잡한 문제의 경우 변수를 사용하는 과정에서 많은 혼란을 야기할 수 있기 때문에, 가급적 서로 맞춰주는 것이 중요하다. 이를 위해 첫 인덱스인 0을 사용하지 않고 각 선언 크기에 1을 더하여 범위를 증가시킨다음, 시작 인덱스를 1로 사용한다.\r\n\r\n즉, 해당 문제에서 $i$와 $j$가 0인 배열은 사용하지 않으며, 어떤 의미도 가지지 않는다.\r\n\r\n### DP배열 초기값 지정하기\r\n\r\n<span class=\"primary\">다이나믹 프로그래밍</span>은 원래라면 처음부터 다시 계산해야하는 복잡한 과정을 생략하고, 이전에 계산된 내용을 토대로 추가적인 계산을 수행한다.\r\n\r\n초기엔 로직에 따른 정석적인 계산을 하지만, 이후 계산값을 누적하고 이를 활용하여 다음 값을 계산한다. 특히 데이터의 양이 많으면 많을 수록 속도에서의 우위를 가져갈 수 있다.\r\n\r\n따라서 <span class=\"primary\">다이나믹 프로그래밍</span>은 초기값 설정도 매우 중요하다. 여기서의 초기값은 <span class=\"teal-A400\">한 자리수에서 나올 수 있는 선분합의 조합</span>으로 정의할 수 있다.\r\n\r\n<br />\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   -   |   -   |   1   |   7   |   4   |   2   |   0   |   8   |\r\n\r\n위 표를 배열 `dp`에 입력하면 된다. 한 자리 숫자이므로 $i = 1$로 고정이며, $j$는 선분합이다. 값은 그 숫자다.\r\n\r\n``` java\r\ndp[1][2] = 1\r\ndp[1][3] = 7\r\ndp[1][4] = 4\r\ndp[1][5] = 2\r\ndp[1][6] = 0\r\ndp[1][7] = 8\r\n```\r\n\r\n위처럼 선언해주면 된다.\r\n\r\n<br />\r\n\r\n하드코딩이 마음에 안 든다면, 아래처럼 사용하는 방법도 있다.\r\n\r\n``` java\r\nfor (int i = 0; i < FLAG.length; i++)\r\n{\r\n\tdp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i);\r\n}\r\n```\r\n\r\n0부터 FLAG의 배열을 순차적으로 돌면서 해당 선분값을 가지는 가장 작은 값을 초기값으로 할당하게 된다.\r\n\r\n### DP배열 전개하기\r\n\r\n지정한 초기값을 토대로 배열 `dp`의 값을 전개한다. 한 자릿수는 <span class=\"teal-500\">2 ~ 7 사이의 값</span>을 가진다.\r\n\r\n그렇다면, 두 자릿수는 한 자릿수의 조합이므로, <span class=\"teal-500\">4 ~ 14 사이의 값</span>을 가질 것이다.\r\n\r\n즉, 자릿수별로 유효한 DP배열의 범위는 아래와 같다.\r\n\r\n$$\r\nn \\text{의 자리 범위} = (n - 1) * 2 \\,\\,\\, \\sim \\,\\,\\, (n - 1) * 7\r\n$$\r\n\r\n각 자릿수 별로 위 범위만큼만 신경쓰면 된다.\r\n\r\n<br />\r\n\r\n한 자릿수에서 할당된 숫자는 0, 1, 2, 4, 7, 8로 여섯 가지가 존재한다. 두 자릿수 또한 이 숫자들의 조합으로만 이루어진다.\r\n\r\n따라서 00, 01, 02, ~ 84, 87, 88을 조합하여 선분의 합을 가지는 가장 작은 수를 `dp`에 할당한다.\r\n\r\n<br />\r\n\r\n예를 들어, `dp[2][8]`의 경우 01, 10, 44 등의 숫자 조합이 올 수 있다. 그 중 가장 작은 수는 01이므로, `dp[2][8] = 1`이 될 것이다.\r\n\r\n``` java\r\nfor (int n = 2; n < dp.length; n++)\r\n{\r\n\tfor (int i = 2; i < 8; i++)\r\n\t{\r\n\t\tint start = (n - 1) * 2;\r\n\t\tint end = (n - 1) * 7 + 1;\r\n\t\t\r\n\t\tfor (int j = start; j < end; j++)\r\n\t\t{\r\n\t\t\tdp[n][i + j] = Math.min(dp[n][i + j], (long) Math.pow(10, n - 1) * dp[1][i] + dp[n - 1][j]);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n따라서 이를 식으로 표현하면 위와 같다.\r\n\r\n* $n$: 자릿수\r\n* $i$: $n$의 자리에 할당될 수의 선분합\r\n* $j$: 남은 자리에 할당될 수의 선분합\r\n\r\n$n$은 자릿수로써, 일의 자리는 일전에 이미 계산했으므로 2부터 시작한다.\r\n\r\n`start`, `end`는 $n$의 자리 범위를 코드로 나타낸 것이다.\r\n\r\n$i$와 $j$는 각각의 선분합으로, 위의 예시에서 설명한  **0_XX**에서 $i$는 `_`, $j$는 `XX`의 선분합이라 생각하면 된다.\r\n\r\n`dp[n][i + j]`와 `Math.pow(10, n - 1) * dp[1][i] + dp[n - 1][j]` 중 더 작은 값을 `dp` 배열에 할당한다.\r\n\r\n이를 배열이 끝날 때까지 반복하면 DP배열이 완성된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1020 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/08/23/a1020\">1020 풀이</a>\r\n * @since 2021.08.23 22:53:10\r\n */\r\npublic class Main\r\n{\r\n\t// 숫자 선분 갯수\r\n\tprivate static final int[] FLAG = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 5 };\r\n\t\r\n\t// 메모이제이션 배열\r\n\tprivate static long[][] dp;\r\n\t\r\n\t// 입력 숫자\r\n\tprivate static long number;\r\n\t\r\n\t// 자리별로 분리된 숫자 배열\r\n\tprivate static int[] numbers;\r\n\t\r\n\t// 숫자 자릿수\r\n\tprivate static int N;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 입력값\r\n\t\tString input = reader.readLine();\r\n\t\t\r\n\t\tnumber = Long.parseLong(input);\r\n\t\t\r\n\t\tnumbers = Arrays.stream(input.split(\"\")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tN = numbers.length;\r\n\t\t\r\n\t\tputDP();\r\n\t\t\r\n\t\tlong result = solve();\r\n\t\t\r\n\t\twriter.write(String.valueOf(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * DP 채우기 함수\r\n\t */\r\n\tprivate static void putDP()\r\n\t{\r\n\t\tdp = new long[N + 1][(N * 7) + 1];\r\n\t\t\r\n\t\t// 전체 배열을 long의 최대값으로 초기화\r\n\t\tfor (long[] arr : dp)\r\n\t\t{\r\n\t\t\tArrays.fill(arr, Long.MAX_VALUE);\r\n\t\t}\r\n\t\t\r\n\t\t// 초기값 설정\r\n\t\tfor (int i = 0; i < FLAG.length; i++)\r\n\t\t{\r\n\t\t\tdp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i);\r\n\t\t}\r\n\t\t\r\n\t\t// 배열 채우기\r\n\t\tfor (int n = 2; n < dp.length; n++)\r\n\t\t{\r\n\t\t\tfor (int i = 2; i < 8; i++)\r\n\t\t\t{\r\n\t\t\t\tint start = (n - 1) * 2;\r\n\t\t\t\tint end = (n - 1) * 7 + 1;\r\n\t\t\t\t\r\n\t\t\t\tfor (int j = start; j < end; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tdp[n][i + j] = Math.min(dp[n][i + j], dp[n - 1][j] + (long) Math.pow(10, n - 1) * dp[1][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 동작 함수\r\n\t *\r\n\t * @return [long] 동일한 선분의 갯수를 가지는 숫자가 나오기까지 걸리는 시간\r\n\t */\r\n\tprivate static long solve()\r\n\t{\r\n\t\t// 결과\r\n\t\tlong result = (long) Math.pow(10, N);\r\n\t\t\r\n\t\t// 1의 자리 숫자만 비교\r\n\t\tfor (int num = 0; num < 10; num++)\r\n\t\t{\r\n\t\t\t// 입력된 숫자의 1의 자리값\r\n\t\t\tint units = numbers[N - 1];\r\n\t\t\t\r\n\t\t\t// 1의 자리 숫자와 다른 숫자이면서 선분의 갯수는 동일할 경우\r\n\t\t\tif (FLAG[units] == FLAG[num] && units != num)\r\n\t\t\t{\r\n\t\t\t\t// num이 1의 자리 숫자보다 클 경우\r\n\t\t\t\tif (num > units)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = Math.min(result, num - units);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// num이 1의 자리 숫자보다 작을 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = Math.min(result, (long) Math.pow(10, N) + num - units);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 비교할 선분의 갯수 (1의 자리를 위에서 이미 비교했으므로 1의 자리에 해당하는 선분값을 초기값으로 지정)\r\n\t\tint count = FLAG[numbers[N - 1]];\r\n\t\t\r\n\t\t// (10^n)의 자리 숫자부터 하나씩 비교\r\n\t\tfor (int n = 2; n < N + 1; n++)\r\n\t\t{\r\n\t\t\t// (10^n-1)의 자리까지만 표기한 수\r\n\t\t\tlong digit = number % (long) Math.pow(10, n);\r\n\t\t\t\r\n\t\t\t// (10^n)의 자릿수 선분 갯수 누적\r\n\t\t\tcount += FLAG[numbers[N - n]];\r\n\t\t\t\r\n\t\t\t// (10^n)의 자릿수에 0 ~ 9를 대입하여 비교\r\n\t\t\tfor (int num = 0; num < 10; num++)\r\n\t\t\t{\r\n\t\t\t\t// 비교할 선분의 갯수와 현재 숫자의 선분의 갯수차가 양수일 경우\r\n\t\t\t\tif (count - FLAG[num] >= (n - 1) * 2)\r\n\t\t\t\t{\r\n\t\t\t\t\t// (10^n-1)의 자릿수에 현재 숫자를 곱한 수\r\n\t\t\t\t\tlong pows = (long) Math.pow(10, n - 1) * num;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// n-1 자리에서 선분의 합이 (count - FLAG[num])이 되는 가장 작은 수\r\n\t\t\t\t\tlong target = dp[n - 1][count - FLAG[num]];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// pows와 target의 합이 digit과 다르며, 유효한 값을 가지는 메모이제이션 배열일 경우\r\n\t\t\t\t\tif (digit != pows + target && target != Long.MAX_VALUE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlong val = pows + target - digit;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// 계산한 값이 음수일 경우\r\n\t\t\t\t\t\tif (val <= 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// 10^N 자리를 넘어가므로 한 주기를 돌아 다시 카운팅해야한다.\r\n\t\t\t\t\t\t\tval += (long) Math.pow(10, N);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tresult = Math.min(result, val);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다. `putDP()` 메소드는 DP배열을 전개하며, `solve()` 메소드는 알고리즘을 수행한다.\r\n\r\n``` java\r\nprivate static void putDP()\r\n{\r\n\tdp = new long[N + 1][(N * 7) + 1];\r\n\t\r\n\t// 전체 배열을 long의 최대값으로 초기화\r\n\tfor (long[] arr : dp)\r\n\t{\r\n\t\tArrays.fill(arr, Long.MAX_VALUE);\r\n\t}\r\n\t\r\n\t// 초기값 설정\r\n\tfor (int i = 0; i < FLAG.length; i++)\r\n\t{\r\n\t\tdp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i);\r\n\t}\r\n\t\r\n\t// 배열 채우기\r\n\tfor (int n = 2; n < dp.length; n++)\r\n\t{\r\n\t\tfor (int i = 2; i < 8; i++)\r\n\t\t{\r\n\t\t\tint start = (n - 1) * 2;\r\n\t\t\tint end = (n - 1) * 7 + 1;\r\n\t\t\t\r\n\t\t\tfor (int j = start; j < end; j++)\r\n\t\t\t{\r\n\t\t\t\tdp[n][i + j] = Math.min(dp[n][i + j], dp[n - 1][j] + (long) Math.pow(10, n - 1) * dp[1][i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nDP배열은 위 코드와 같이 전개하며, `Arrays.fill(arr, Long.MAX_VALUE)`를 통해 `long`의 최대값으로 배열을 초기화한다.\r\n\r\n이후 `dp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i)` 구문을 통해 한 자릿수에서 해당 선분값을 가지는 가장 작은 값을 할당한다.\r\n\r\n<br />\r\n\r\n모든 숫자의 조합은 0, 1, 2, 4, 7, 8로 이루어지므로, 각 숫자를 조합하여 나올 수 있는 모든 경우의 수를 비교하여 선분합의 최소값을 DP배열에 기록한다.\r\n\r\n**0_XXX**에서 `_`은 한 자릿수에서 나올 수 있는 수의 조합이며, `XXX`는 세 자릿수에서 나올 수 있는 수의 조합이다.\r\n\r\n즉, $i$는 `_`, $j$는 `XXX`를 표현한 것이다.\r\n\r\n예시로, $N = 3$일 경우 $2 \\leq i \\leq 7$, $4 \\leq j \\leq 14$가 된다.\r\n\r\n``` java\r\nprivate static long solve()\r\n{\r\n\t// 결과\r\n\tlong result = (long) Math.pow(10, N);\r\n\t\r\n\t// 1의 자리 숫자만 비교\r\n\tfor (int num = 0; num < 10; num++)\r\n\t{\r\n\t\t// 입력된 숫자의 1의 자리값\r\n\t\tint units = numbers[N - 1];\r\n\t\t\r\n\t\t// 1의 자리 숫자와 다른 숫자이면서 선분의 갯수는 동일할 경우\r\n\t\tif (FLAG[units] == FLAG[num] && units != num)\r\n\t\t{\r\n\t\t\t// num이 1의 자리 숫자보다 클 경우\r\n\t\t\tif (num > units)\r\n\t\t\t{\r\n\t\t\t\tresult = Math.min(result, num - units);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// num이 1의 자리 숫자보다 작을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult = Math.min(result, (long) Math.pow(10, N) + num - units);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 비교할 선분의 갯수 (1의 자리를 위에서 이미 비교했으므로 1의 자리에 해당하는 선분값을 초기값으로 지정)\r\n\tint count = FLAG[numbers[N - 1]];\r\n\t\r\n\t// (10^n)의 자리 숫자부터 하나씩 비교\r\n\tfor (int n = 2; n < N + 1; n++)\r\n\t{\r\n\t\t// (10^n-1)의 자리까지만 표기한 수\r\n\t\tlong digit = number % (long) Math.pow(10, n);\r\n\t\t\r\n\t\t// (10^n)의 자릿수 선분 갯수 누적\r\n\t\tcount += FLAG[numbers[N - n]];\r\n\t\t\r\n\t\t// (10^n)의 자릿수에 0 ~ 9를 대입하여 비교\r\n\t\tfor (int num = 0; num < 10; num++)\r\n\t\t{\r\n\t\t\t// 비교할 선분의 갯수와 현재 숫자의 선분의 갯수차가 양수일 경우\r\n\t\t\tif (count - FLAG[num] >= (n - 1) * 2)\r\n\t\t\t{\r\n\t\t\t\t// (10^n-1)의 자릿수에 현재 숫자를 곱한 수\r\n\t\t\t\tlong pows = (long) Math.pow(10, n - 1) * num;\r\n\t\t\t\t\r\n\t\t\t\t// n-1 자리에서 선분의 합이 (count - FLAG[num])이 되는 가장 작은 수\r\n\t\t\t\tlong target = dp[n - 1][count - FLAG[num]];\r\n\t\t\t\t\r\n\t\t\t\t// pows와 target의 합이 digit과 다르며, 유효한 값을 가지는 메모이제이션 배열일 경우\r\n\t\t\t\tif (digit != pows + target && target != Long.MAX_VALUE)\r\n\t\t\t\t{\r\n\t\t\t\t\tlong val = pows + target - digit;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 계산한 값이 음수일 경우\r\n\t\t\t\t\tif (val <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 10^N 자리를 넘어가므로 한 주기를 돌아 다시 카운팅해야한다.\r\n\t\t\t\t\t\tval += (long) Math.pow(10, N);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n```\r\n\r\n실제 알고리즘을 수행하는 소스는 위와 같다.\r\n\r\n`long result = (long) Math.pow(10, N)`은 알고리즘의 최대값으로 초기화하는 작업이다. 예를 들어, <span class=\"teal-500\">384</span>와 동일한 선분합을 가지는 수가 나올 시간을 찾는다고 해보자.\r\n\r\n운 나쁘게 동일한 선분합을 가지는 수가 없다면 <span class=\"teal-500\">384</span>부터 1씩 증가하여 한 사이클을 돌아 다시 <span class=\"teal-500\">384</span>로 돌아올 것이다.\r\n\r\n즉, 한 사이클 $c$의 값은 $c = 10^{N + 1}$으로 표현할 수 있다. 알고리즘의 결과는 이 값을 넘지 않는다.\r\n\r\n<br />\r\n\r\n``` java\r\n// 1의 자리 숫자만 비교\r\nfor (int num = 0; num < 10; num++)\r\n{\r\n\t// 입력된 숫자의 1의 자리값\r\n\tint units = numbers[N - 1];\r\n\t\r\n\t// 1의 자리 숫자와 다른 숫자이면서 선분의 갯수는 동일할 경우\r\n\tif (FLAG[units] == FLAG[num] && units != num)\r\n\t{\r\n\t\t// num이 1의 자리 숫자보다 클 경우\r\n\t\tif (num > units)\r\n\t\t{\r\n\t\t\tresult = Math.min(result, num - units);\r\n\t\t}\r\n\t\t\r\n\t\t// num이 1의 자리 숫자보다 작을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tresult = Math.min(result, (long) Math.pow(10, N) + num - units);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n초기값을 지정하기 위해 1의 자리 숫자를 비교하는 작업이다. 위 예제에서의 **059_** 과정에 해당한다.\r\n\r\n<br />\r\n\r\n* 1의 자리보다 클 경우\r\n\r\n\t비교하는 숫자가 나오기까지의 시간을 구하여 `result`와 비교한다. 더 작은 값이 `result`가 된다.\r\n\r\n* 1의 자리보다 작을 경우\r\n\r\n\t한 사이클을 돌고 난 뒤에 도달하는 수이므로, 최대 사이클 $c$에서 비교하는 숫자가 나오는데 걸리는 시간을 뺀다. 이를 `result`와 비교하여, 더 작은 값이 `result`가 된다.\r\n\r\n<br />\r\n\r\n비교할 선분합 `count`를 누적한다. **0598**이라는 수가 있을 때, **059_**에서 `_`는 8의 선분합인 7과 동일해야한다.\r\n\r\n만약 **05_X**에서 `_`와 `X`는 9와 8의 선분합인 12와 동일해야할 것이다. 이러한 선분합을 저장하는 변수가 `count`다.\r\n\r\n초기값으로 1의 자릿수가 가진 선분합인 `FLAG[numbers[N - 1]]`를 할당한다.\r\n\r\n<br />\r\n\r\n``` java\r\n// (10^n)의 자리 숫자부터 하나씩 비교\r\nfor (int n = 2; n < N + 1; n++)\r\n{\r\n\t// (10^n-1)의 자리까지만 표기한 수\r\n\tlong digit = number % (long) Math.pow(10, n);\r\n\t\r\n\t// (10^n)의 자릿수 선분 갯수 누적\r\n\tcount += FLAG[numbers[N - n]];\r\n\t\r\n\t// (10^n)의 자릿수에 0 ~ 9를 대입하여 비교\r\n\tfor (int num = 0; num < 10; num++)\r\n\t{\r\n\t\t// 비교할 선분의 갯수와 현재 숫자의 선분의 갯수차가 양수일 경우\r\n\t\tif (count - FLAG[num] >= (n - 1) * 2)\r\n\t\t{\r\n\t\t\t// (10^n-1)의 자릿수에 현재 숫자를 곱한 수\r\n\t\t\tlong pows = (long) Math.pow(10, n - 1) * num;\r\n\t\t\t\r\n\t\t\t// n-1 자리에서 선분의 합이 (count - FLAG[num])이 되는 가장 작은 수\r\n\t\t\tlong target = dp[n - 1][count - FLAG[num]];\r\n\t\t\t\r\n\t\t\t// pows와 target의 합이 digit과 다르며, 유효한 값을 가지는 메모이제이션 배열일 경우\r\n\t\t\tif (digit != pows + target && target != Long.MAX_VALUE)\r\n\t\t\t{\r\n\t\t\t\tlong val = pows + target - digit;\r\n\t\t\t\t\r\n\t\t\t\t// 계산한 값이 음수일 경우\r\n\t\t\t\tif (val <= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 10^N 자리를 넘어가므로 한 주기를 돌아 다시 카운팅해야한다.\r\n\t\t\t\t\tval += (long) Math.pow(10, N);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tresult = Math.min(result, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n10의 자리 이상부터는 위 소스에 의해 구분된다.\r\n\r\n`digit`는 $10^{N - 1}$의 자리에 해당하는 수가 할당된다. **05_X**에서 `X` 부분이다.\r\n\r\n`count`에 $10^N$의 선분의 합을 누적한다. `count`는 **05_X**에서 **_X**에 대한 선분 총합을 가지게 된다.\r\n\r\n<br />\r\n\r\n`_`에 0 ~ 9까지 대입되는 값을 `num`이라 한다. `X`에 대입되는 값은 DP배열에 이미 최적값을 계산해뒀으므로 그냥 꺼내서 쓰기만 하면 된다. 두 값이 `count`와 일치하면 된다.\r\n\r\n여기에선 `count`에서 `num`을 뺀다. 그럼 나머지 숫자가 있을텐데, 이를 현재 자릿수에 해당하는 DP배열에서 꺼내 사용한다.\r\n\r\n**05_X**에서 **_X**의 선분합은 12다. `_`에 3을 할당했을 경우 `X`는 `dp[1][7]`에 해당하는 숫자가 된다. 즉, **0598**과 **0538**의 선분합은 같다.\r\n\r\n<br />\r\n\r\n조건문 `if (count - FLAG[num] >= (n - 1) * 2)`을 통해 `X`가 가져야할 선분합을 계산한다.\r\n\r\n`(n - 1) * 2`인 이유는 $n = 1$일 경우 선분합의 범위는 $2 ~ 7$이기 때문, $n$에 비례하며, 일반식은 $(n - 1) * 2$와 같다. 이 최소값보다 커야 의미가 있다.\r\n\r\n* `pows` $10^{N - 1}$에 해당하는 수\r\n* `target` $10^{N - 1}$의 자리에서 `count - FLAG[num]`의 선분합을 갖는 DP배열값\r\n\r\n<br />\r\n\r\n원본값인 `digit`과 `pows + target`이 일치하지 않는 서로 다른 수이며, `target`이 DP배열의 초기값이 아닌 유효한 값을 가질 경우 이를 비교한다.\r\n\r\n`val`은 `pows + target`과 `digit` 사이의 시간차다. 이 값이 음수일 경우는 한 사이클이 돌아가므로 사이클 값인 $c$를 더해 보정한다.\r\n\r\n이후 마지막으로 계산된 `result`와 `val`을 비교하여 더 작은 값이 `result`가 된다.\r\n\r\n# 여담\r\n\r\n푼 건 7월 초에 풀었는데, 글 쓰는 와중 블로그 개편 작업을 시작하는 바람에 한 동안 못 하다가 이제서야 적는 풀이다.\r\n\r\n한달 넘게 지나서 가물가물한데, 이 문제도 이해하는 데 일주일 정도 들었던 것 같다.\r\n\r\n블로그 개편도 어느정도 마무리하고 안정화됐겠다, 다시 백준 알고리즘 풀이를 찬찬히 진행할 생각이다.\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍","url":["2021-08-24-a1020","2021","08","24","a1020"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1017번 소수 쌍","excerpt":"지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, {1, 4, 7, 10, 11, 12}가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다. 1 + 4 = $, 7 + 10 = 17$, $11 + 12 = 23 또는 1 + 10 = 11, 4 + 7 = 11, 11 + 12 = 23 수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 1 + 12 = 13으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-26T03:19:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM III","에라토스 테네스의 체","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-26-a1017.md","content":"\r\n# 소수 쌍\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1017번 문제](https://www.acmicpc.net/problem/1017)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, ${1, 4, 7, 10, 11, 12}$가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다.\r\n\r\n$1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$  \r\n또는  \r\n$1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$\r\n\r\n수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 $1 + 12 = 13$으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 리스트의 크기 $N$이 주어진다. N은 50보다 작거나 같은 자연수이며, 짝수이다. 둘째 줄에 리스트에 들어있는 수가 주어진다. 리스트에 들어있는 수는 1,000보다 작거나 같은 자연수이며, 중복되지 않는다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 정답을 출력한다. 없으면 -1을 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n6\r\n1 4 7 10 11 12\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4 10\r\n```\r\n\r\n# 풀이\r\n\r\n[1014번 컨닝](/posts/2021/06/23/a1014)문제를 통해 <span class=\"primary\">이분 매칭</span>을 접한 덕분인지, 지금까지 푼 <span class=\"teal-A400\">플래티넘</span> 중에서는 그나마 좀 이해되는 문제였다.\r\n\r\n역시 내용이 다소 난해한데, 알고리즘이 요구하는 동작은 다음과 같이 정리할 수 있다. 입력된 6개의 숫자 배열 ${ 1, 4, 7, 10, 11, 12 }$이 있다고 가정하자. 배열의 숫자를 한 쌍씩 짝지어 더하면 총 3개의 수가 나온다. 이렇게 <span class=\"red-A400\">짝지어 더한 수가 모두 소수일 경우, 입력의 첫 번째 숫자와 매칭된 숫자들을 오름차순으로 정렬하여 출력</span>하는 문제다.\r\n\r\n예제에서도 설명해주듯이, 짝지은 수가 모두 소수인 경우는 $1 + 4 = 5$, $7 + 10 = 17$, $11 + 12 = 23$과 $1 + 10 = 11$, $4 + 7 = 11$, $11 + 12 = 23$가 된다. 입력의 가장 첫 번째 숫자가 1이므로, 1와 매칭된 4, 10이 정답이 된다.\r\n\r\n## 소수 판별하기🍳\r\n\r\n이제 좀 더 세부적인 내용을 살펴보자. 문제 해결의 핵심은 <span class=\"primary\">소수</span>다. 이 알고리즘에선 소수 판별이 필요하다. 많은 판별방법이 있지만, 가장 대표적인 <span class=\"primary\">에라토스 테네스의 체</span>를 활용하면 어렵지 않게 해결할 수 있다.\r\n\r\n## 요소 한 쌍씩 그룹화하기\r\n\r\n소수 판별 방법도 마련했겠다, 입력된 숫자 배열을 적절히 짝지어야한다. <span class=\"lightBlue-A400\">핵심은 짝지은 수의 합이 소수</span>가 되는 것. 요소를 한번씩 다 더해보는 방법도 있겠지만, 배열의 크기가 커질 수록 요구되는 연산량 또한 높아지므로 적절하지 않다. 즉, 가능성 있는 조합으로만 그룹화해야한다.\r\n\r\n소수에 대해 생각해보자. <span class=\"green-A400\">소수는 1과 자기 자신으로만 나눠지는 수</span>다. 즉, 반드시 **소수는 홀수**여야 한다. 이 전제를 확장하면 <span class=\"green-A400\">짝지은 수의 합이 홀수</span>여야한다. 두 수를 더했을 때 홀수가 나오는 경우는 **홀수 + 짝수**로 한 가지 경우의 수만 존재한다.\r\n\r\n따라서 우리는 입력값을 홀수와 짝수 그룹으로 나누어 각 그룹끼리만 더하면 결과는 모두 홀수일 것이므로, 해당 수는 소수일 가능성이 있다. 두 개의 그룹을 겹치지 않게 조합해야하므로 <span class=\"primary\">이분 매칭</span>이 적절한 해답이 될 수 있다. 각 그룹은 홀수와 짝수로 나누고, 더했을 때 소수가 되는 쌍을 노드로 연결하면 <span class=\"primary\">이분 매칭</span>으로 접근 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 그림은 예제 1을 홀수와 짝수 그룹으로 나눠 이분매칭으로 표시한 그림이다. 위 숫자를 6개의 숫자를 매칭하면 3개의 노드가 나올 것이다. 각 숫자를 더하기 위해선 반드시 하나의 쌍을 이뤄야하므로, <span class=\"primary\">이분 매칭</span>의 결과는 반드시 $N \\div 2$가 되어야 한다.\r\n\r\n예제의 가장 첫 번째 수는 1이다. 즉, 우리는 <span class=\"green-A400\">모든 요소쌍의 합이 모두 소수가 되는 조합을 찾고 해당 조합들에서 각각 1과 매칭되는 숫자</span>를 구해야한다. 이를 확장시키면, 1과 짝을 이루는 수를 더한 값이 소수가 아닐 경우 애초에 비교할 필요가 없다.\r\n\r\n위 그림의 매칭 결과가 3이 나온다면, 모든 요소를 적절히 짝지어 더한 값이 모두 소수가 되는 조합이 있다는 뜻이다. 해당 조합을 저장하여 1과 짝지은 값을 찾으면 될 것이다.  \r\n만약, 홀수와 짝수의 갯수가 일치하지 않을 경우, 매칭이 불가능하므로 문제에 제시한 조건에 따라 -1을 반환해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501775-3c424280-d682-11eb-9eda-b0fe8c335122.png\" width=\"600px\" />\r\n</p>\r\n\r\n1과 더했을 때 소수가 되는 요소는 4, 10, 12 모두 해당하므로 이를 모두 노드로 연결할 수 있다. 1과 매칭 가능한 요소 중 하나를 연결하면, 나머지 4개 요소에 대해서만 <span class=\"primary\">이분 매칭</span>을 진행할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501823-9216ea80-d682-11eb-96de-8c01b66677bb.png\" width=\"600px\" />\r\n</p>\r\n\r\n만약, 1과 4를 매칭했다면 나머지 4개 요소에 대한 소수 매칭은 그림과 같이 표현할 수 있다. $[ 7, 10 ]$, $[ 11, 12 ]$ 조합의 합이 모두 소수이므로, $[ 1, 4 ]$, $[ 7, 10 ]$, $[ 11, 12 ]$ 조합은 알고리즘의 조건에 부합한다. 따라서 4는 정답에 포함된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501853-c8546a00-d682-11eb-86e2-6eef5c65ef69.png\" width=\"600px\" />\r\n</p>\r\n\r\n만약, 1과 12가 매칭된다면 어떨까? 이는 위 그림과 같이 표시할 수 있다. 7의 경우 4와 10 중 어떤걸 조합해도 소수지만, 11의 경우 4와 10 모두 소수가 아니므로 어떤식으로 매칭해도 4개 요소의 매칭 결과는 1이 된다. 즉, 1과 매칭된 조합 하나를 더한 최종 매칭 수는 2이므로 $N / 2$의 값에 부합하지 않으므로 해당 조합은 정답이 될 수 없다.  \r\n따라서 예제의 결과는 출력과 같이 `4 10`이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\n\r\n/**\r\n * 백준 전체 1017 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/26/a1017\">1017 풀이</a>\r\n * @since 2021.06.26 Sat 03:19:32\r\n */\r\npublic class Main\r\n{\r\n\t// 에라토스 테네스의 체 배열 (소수 판별용)\r\n\tprivate static final boolean[] IS_NOT_PRIME = eratosthenes();\r\n\t\r\n\t// 왼쪽 배열 (이분매칭의 기준)\r\n\tprivate static int[] left;\r\n\t\r\n\t// 오른쪽 배열\r\n\tprivate static int[] right;\r\n\t\r\n\t// 노드 연결 여부\r\n\tprivate static boolean[][] hasNode;\r\n\t\r\n\t// 방문 여부\r\n\tprivate static boolean[] isVisit;\r\n\t\r\n\t// 매칭된 수\r\n\tprivate static int[] matched;\r\n\t\r\n\t// 현재 선택 중인 수\r\n\tprivate static int selected;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 입력값 갯수\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 입력값 배열\r\n\t\tint[] numbers = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\t// 첫 번째 수가 홀수일 경우\r\n\t\tif (numbers[0] % 2 != 0)\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 홀수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 첫 번째 수가 짝수일 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\t// 왼쪽 배열에 짝수를 할당\r\n\t\t\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\t\t\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일할 경우 (이분매칭 가능)\r\n\t\tif (left.length == right.length)\r\n\t\t{\r\n\t\t\thasNode = new boolean[left.length][right.length];\r\n\t\t\t\r\n\t\t\t// left의 첫 번째 행은 기준 매칭이므로 이분 매칭에서 제외한다.\r\n\t\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t\t{\r\n\t\t\t\tfor (int j = 0; j < right.length; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint ref = left[i] + right[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// left[i] + right[j]의 값이 소수일 경우\r\n\t\t\t\t\tif (!IS_NOT_PRIME[ref])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 노드를 연결한다.\r\n\t\t\t\t\t\thasNode[i][j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tLinkedList<Integer> list = new LinkedList<>();\r\n\t\t\t\r\n\t\t\t// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\n\t\t\tfor (int i = 0; i < N / 2; i++)\r\n\t\t\t{\r\n\t\t\t\t// left[0]와 right[i]의 합이 소수일 경우\r\n\t\t\t\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\tselected = i;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint size = bipartite();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 모든 요소가 매칭될 경우\r\n\t\t\t\t\tif (size == N / 2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlist.add(right[selected]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 하나도 매칭되지 않은 경우\r\n\t\t\tif (list.size() == 0)\r\n\t\t\t{\r\n\t\t\t\twriter.write(\"-1\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 매칭이 하나 이상 있을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// 오름차순으로 정렬\r\n\t\t\t\tlist.sort(Integer::compareTo);\r\n\t\t\t\t\r\n\t\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\t\t\r\n\t\t\t\tfor (int item : list)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuilder.append(item).append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\twriter.write(builder.toString().trim());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 홀수 배열과 짝수 배열의 수가 동일하지 않을 경우 (이분매칭 불가능)\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"-1\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\t\tint size = 1;\r\n\t\t\r\n\t\tmatched = new int[left.length];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int i = 1; i < left.length; i++)\r\n\t\t{\r\n\t\t\tisVisit = new boolean[left.length];\r\n\t\t\t\r\n\t\t\t// 매칭 가능할 경우\r\n\t\t\tif (dfs(i))\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static boolean dfs(int num)\r\n\t{\r\n\t\t// 첫 방문일 경우\r\n\t\tif (!isVisit[num])\r\n\t\t{\r\n\t\t\tisVisit[num] = true;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 아레토스 테네스의 체 배열 반환 함수\r\n\t *\r\n\t * @return [boolean[]] 아레토스 테네스의 체\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tboolean[] isNotPrime = new boolean[2000];\r\n\t\t\r\n\t\tisNotPrime[0] = true;\r\n\t\tisNotPrime[1] = true;\r\n\t\t\r\n\t\tint maxPrime = (int) Math.ceil(Math.sqrt(2000));\r\n\t\t\r\n\t\tfor (int i = 2; i < maxPrime; i++)\r\n\t\t{\r\n\t\t\t// 소수일 경우\r\n\t\t\tif (!isNotPrime[i])\r\n\t\t\t{\r\n\t\t\t\tfor (int j = i + i; j < isNotPrime.length; j += i)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 소수가 아님을 표시하지 않았을 경우\r\n\t\t\t\t\tif (!isNotPrime[j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 소수의 배수는 소수가 아니므로 제외함\r\n\t\t\t\t\t\tisNotPrime[j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPrime;\r\n\t}\r\n}\r\n```\r\n\r\n편의상 항상 왼쪽을 기준으로 매칭한다. 올바른 조합 중 첫 번째 수와 매칭되는 수를 찾는 것이 목표인데, 첫 번째 수는 홀수, 짝수 모두 올 수 있다. 따라서 홀수가 먼저오냐, 짝수가 먼저오냐에 따라 해당하는 분류를 기준 배열로 할당한다.\r\n\r\n``` java\r\n// 첫 번째 수가 홀수일 경우\r\nif (numbers[0] % 2 != 0)\r\n{\r\n\t// 왼쪽 배열에 홀수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n}\r\n\r\n// 첫 번째 수가 짝수일 경우\r\nelse\r\n{\r\n\t// 왼쪽 배열에 짝수를 할당\r\n\tleft = Arrays.stream(numbers).filter(value -> value % 2 == 0).toArray();\r\n\tright = Arrays.stream(numbers).filter(value -> value % 2 != 0).toArray();\r\n}\r\n```\r\n\r\n해당 소스는 위와 같다. 왼쪽 배열 `left`를 기준으로하여 홀수가 올 경우 `left`에 홀수 배열을, 아닐 경우 짝수 배열을 할당한다.\r\n\r\n소수 판별은 <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘을 통해, 요소로 올 수 있는 최대값인 2,000개 배열에 대한 소수 배열을 준비한다.\r\n\r\n> **잠깐, 문제에서는 요소로 올 수 있는 최대값이 1,000이라는데요?**  \r\n> 홀수와 짝수를 더하므로, 요소의 최대값은 각 요소의 최대값을 더한 999 + 1,000 = 1,999가 됩니다.\r\n\r\n배열이 2000개까지밖에 안 되므로, 연산할 때마다 비교하는 것 보다 미리 배열을 선언해서 비교하는 게 훨씬 효율적이라 판단했다.  \r\n만약 연산할 때마다 비교하려면, 비교할 수의 제곱근을 구하고, 2부터 제곱근까지 나눈다. 중간에 정확히 나누어 떨어지는 수가 있을 경우, 그 수는 소수가 아니다.\r\n\r\n``` java\r\n// 대상 숫자\r\nint number = 1000;\r\n\r\n// 소수 여부\r\nboolean isPrime = true;\r\n\r\n// 가장 작은 소수인 2부터 대상의 제곱근까지 나누기\r\nfor (int i = 2; i <= Math.sqrt(number); i++)\r\n{\r\n\t// 나누어 떨어지는 수가 있을 경우\r\n\tif (number % i == 0)\r\n\t{\r\n\t\tisPrime = false;\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n대충 위 형식처럼 짜면 된다.\r\n\r\n``` java\r\n// 첫 번째 수와 상대 그룹의 요소를 하나씩 매칭해본다.\r\nfor (int i = 0; i < N / 2; i++)\r\n{\r\n\t// left[0]와 right[i]의 합이 소수일 경우\r\n\tif (!IS_NOT_PRIME[left[0] + right[i]])\r\n\t{\r\n\t\tselected = i;\r\n\t\t\r\n\t\tint size = bipartite();\r\n\t\t\r\n\t\t// 모든 요소가 매칭될 경우\r\n\t\tif (size == N / 2)\r\n\t\t{\r\n\t\t\tlist.add(right[selected]);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n그룹을 나누었으면, 입력값의 첫 번째 수 $left[0]$와 하나씩 매칭하여 기준 매칭을 선정한다. `!IS_NOT_PRIME[left[0] + right[i]]`을 통해 매칭이 소수일 경우에만 진행한다. 소수가 아닐 경우 비교해볼 필요도 없으니. `selected`는 현재 $left[0]$와 매칭된 요소를 의미한다. 이게 왜 필요하냐면, $left[0]$와 매칭된 요소의 경우 다른 요소와 매칭될 수 없으므로 매칭에서 제외해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/123501834-a3f88d80-d682-11eb-8e27-968a1c71e342.png\" width=\"600px\" />\r\n</p>\r\n\r\n이는 위 그림과 같이 나타낼 수 있다. 이미 1이 10과 매칭되었으므로, 10과 연결된 7, 11의 노드를 제거해야 정상적으로 매칭할 수 있다. 연결된 노드는 `hasNode` 배열에서 관리하고 있다. 예제 1을 기준으로 `hasNode`의 값은 다음과 같다.\r\n\r\n| $N, M$ |   4   |  10   |  12   |\r\n| :----: | :---: | :---: | :---: |\r\n|   1    | true  | true  | true  |\r\n|   7    | true  | true  | true  |\r\n|   11   | false | false | true  |\r\n\r\n만약 여기서, 1과 10을 매칭할 경우 hasNode는 아래와 같다.\r\n\r\n| $N, M$ |     4     |  **10**   |    12     |\r\n| :----: | :-------: | :-------: | :-------: |\r\n| **1**  | **false** | **true**  | **false** |\r\n|   7    |   true    | **false** |   true    |\r\n|   11   |   false   | **false** |   true    |\r\n\r\n1과 10에 연결된 다른 노드를 모두 제거하고, `hasNode[1][10] = true`로 지정해야 한다. 임시 배열을 선언해서 변경하는 경우도 있겠지만, 배열 연산 오버헤드를 줄이기 위해 `selected = 10`으로 지정하여 DFS 알고리즘 수행 시 `selected`와 동일한 인덱스를 false로 인식하게끔 설계했다.\r\n\r\n``` java\r\n/**\r\n * 이분 매칭 갯수 반환 함수\r\n *\r\n * @return [int] 이분 매칭 갯수\r\n */\r\nprivate static int bipartite()\r\n{\r\n\t// 이미 left[0]과 right 요소 하나가 선택됨\r\n\tint size = 1;\r\n\t\r\n\tmatched = new int[left.length];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int i = 1; i < left.length; i++)\r\n\t{\r\n\t\tisVisit = new boolean[left.length];\r\n\t\t\r\n\t\t// 매칭 가능할 경우\r\n\t\tif (dfs(i))\r\n\t\t{\r\n\t\t\tsize++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n\r\n/**\r\n * DFS 알고리즘 결과 반환 함수\r\n *\r\n * @param num: [int] 시작점\r\n *\r\n * @return [int] 매칭 갯수\r\n */\r\nprivate static boolean dfs(int num)\r\n{\r\n\t// 첫 방문일 경우\r\n\tif (!isVisit[num])\r\n\t{\r\n\t\tisVisit[num] = true;\r\n\t\t\r\n\t\tfor (int i = 0; i < right.length; i++)\r\n\t\t{\r\n\t\t\t// 연결된 노드가 있으며, 첫 번째 숫자와 매칭된 숫자가 아니며, 소수일 경우\r\n\t\t\tif (hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]])\r\n\t\t\t{\r\n\t\t\t\t// 매칭이 아직 되지 않았거나, 매칭된 숫자가 다른 숫자와 매칭될 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n<span class=\"primary\">이분 매칭</span> 소스는 위와 같다. `bipartite()`는 기본적인 이분 매칭 알고리즘과 크게 다르지 않다. `size`가 1부터 시작하는 이유는, 이미 입력의 첫 번째 수 `left[0]`과 합이 소수를 만족하는 `right[m]`과 매칭되었기 때문이다.\r\n\r\n`dfs()`에서 조건에 따라 필터링이 진행된다. 조건식은 `hasNode[num][i] && i != selected && !IS_NOT_PRIME[left[num] + right[i]]`와 같다.\r\n\r\n* `hasNode[num][i]`: `left[num]`과 `right[i]`가 서로 연결되어 있는지 (소수)\r\n* `i != selected`: `left[num]`이 `right[i]`와 매칭되지 않았는지\r\n* `!IS_NOT_PRIME[left[num] + right[i]]`: `left[num]`과 `right[i]` 소수인지\r\n\r\n위 조건식을 모두 만족할 경우에만 매칭을 수행한다.\r\n\r\n$N$이 반드시 짝수거나, 입력된 숫자의 홀수, 짝수가 반드시 동일하다는 조건이 존재하지 않으므로, 이 경우 -1을 출력해야한다. 또한, 모든 조건이 일치해도 매칭이 하나도 되지 않을 경우 역시 -1을 출력해야한다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 이분 매칭\r\n* 에라토스 테네스의 체","url":["2021-06-26-a1017","2021","06","26","a1017"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1014번 컨닝","excerpt":"최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다. 시험은 N행 X M열 크기의 직사각형 교실에서 이루어진다. 교실은 1 X 1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다. 최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-18T16:42:44","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","PLATINUM","PLATINUM IV","네트워크 플로우","최소 버텍스 커버","이분 매칭"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-18-a1014.md","content":"\r\n# 컨닝\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1014번 문제](https://www.acmicpc.net/problem/1014)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.\r\n\r\n시험은 $N$행 $\\times$ $M$열 크기의 직사각형 교실에서 이루어진다. 교실은 $1 \\times 1$ 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.\r\n\r\n최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122051353-78bea480-ce1f-11eb-92c3-5fa4e3dc96b9.png\" width=\"500px\" />\r\n</p>\r\n\r\n위의 그림을 보자. $A$, $C$, $D$ 혹은 $E$에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, $B$에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.\r\n\r\n위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.\r\n\r\n최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트케이스의 개수 $C$가 주어진다. 각각의 테스트 케이스는 아래와 같이 두 부분으로 이루어진다.\r\n\r\n첫 번째 부분에서는 교실의 세로길이 N과 가로길이 M이 한 줄에 주어진다. $(1 ≤ M ≤ 10, 1 ≤ N ≤ 10)$\r\n\r\n두 번째 부분에서는 정확하게 N줄이 주어진다. 그리고 각 줄은 M개의 문자로 이루어져있다. 모든 문자는 ‘.’(앉을 수 있는 자리) 또는 ‘x’(앉을 수 없는 자리, 소문자)로 구성된다.\r\n\r\n## 출력\r\n\r\n각각의 테스트 케이스에 대해 그 교실에서 시험을 볼 수 있는 최대 학생의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n4\r\n2 3\r\n...\r\n...\r\n2 3\r\nx.x\r\nxxx\r\n2 3\r\nx.x\r\nx.x\r\n10 10\r\n....x.....\r\n..........\r\n..........\r\n..x.......\r\n..........\r\nx...x.x...\r\n.........x\r\n...x......\r\n........x.\r\n.x...x....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n4\r\n1\r\n2\r\n46\r\n```\r\n\r\n# 풀이\r\n\r\n또 한번의 <span class=\"teal-A400\">플래티넘</span> 문제. 하....\r\n\r\n문제 이름 그대로 컨닝을 못 참게 만드는 문제다. 문제를 푸는 방식에는 두 가지가 있다. <span class=\"primary\">네트워크 플로우</span>와 <span class=\"primary\">비트마스킹</span>. 본 포스팅에서는 <span class=\"primary\">네트워크 플로우</span> 방식을 차용한다. 이게 정석이라고 하기도 하고, JAVA 풀이는 죄다 <span class=\"primary\">비트마스킹</span> 방식이라서.\r\n\r\n나 같이 전공지식이 전무한 코더에게는 너무나도 가혹한 문제다. 지금까지 살면서 하나 깨달은 게 있다면, 아무리 처음 보는 개념이라도 계속 쳐다보면 언젠가 이해된다. 하루가 됐든 한 달이 됐든. 그 난리를 펴가며 이해한 내용은 아래와 같다.\r\n\r\n## 문제 분석하기\r\n\r\n문제 해결에 영향을 미치는 조건은 아래와 같다.\r\n\r\n1. 임의의 자리를 기준으로 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위 자리를 컨닝할 수 있다.\r\n2. 파손되어 앉을 수 없는 자리가 존재한다.\r\n\r\n임의의 자리가 있다고 가정하고 이를 도식화해보자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956338-de7cd480-d3bb-11eb-93ce-5c1ea19185af.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진과 같이 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 자신의 주변엔 최대 8개의 <span class=\"indigo-200\">자리</span>가 존재할 수 있다. 1번 규칙에 따라 컨닝이 가능한 자리를 도식하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956398-eccaf080-d3bb-11eb-9d2b-91e4aaa7ea40.png\" width=\"600px\" />\r\n</p>\r\n\r\n<span class=\"red-400\">컨닝 가능한 자리</span>는 위와 같이 6개로 표시된다. 엥? 분명히 1번 규칙에서는 <span class=\"indigo-A400\">특정 자리</span>를 기준으로 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위만 가능하다고 했다. 해당 규칙에 따르면 4개 자리여야 할텐데, 왼쪽 대각선 아래, 오른쪽 대각선 아래는 왜 해당되는걸까?\r\n\r\n<span class=\"indigo-A400\">특정 자리</span>에서 왼쪽 대각선 아래, 오른쪽 대각선 아래를 컨닝할 순 없지만, 반대로 왼쪽 대각선 아래, 오른쪽 대각선 아래에선 <span class=\"indigo-A400\">특정 자리</span>를 컨닝할 수 있기 때문. <span class=\"lightBlue-A400\">컨닝을 할 수 있는 자리와 당할 수 있는 자리</span> 모두를 고려해야한다.\r\n\r\n반대로 컨닝이 불가능한 자리를 도식하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956442-f7858580-d3bb-11eb-8154-2bfe476ae278.png\" width=\"600px\" />\r\n</p>\r\n\r\n<span class=\"green-A400\">컨닝이 불가능한 자리</span>는 위와 같이 2개로 표시된다. 자신의 앞 뒤는 컨닝할 수 없다. 우리가 설계한 알고리즘이 이와 같은 결과를 계산할 수 있어야 한다. 그렇다면 이를 어떤 방법으로 해결할 수 있을까?\r\n\r\n이 문제를 해결하는 방법은 크게 두 가지가 있다.\r\n\r\n1. 최소 버텍스 커버, 이분 매칭\r\n2. DP, 비트마스킹\r\n\r\n이 중 1번 최소 버텍스 커버와 이분 매칭을 사용하여 풀고자 한다.\r\n\r\n## Miminum Vertex Cover(최소 버텍스 커버)\r\n\r\n<span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>는 모든 노드가 연결된 점(Vertex)의 최소 집합을 의미한다. 예를 들어, 아래와 같은 그림이 있다고 가정하자.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956504-05d3a180-d3bc-11eb-8006-7f22037020b9.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진에서의 $A$ ~ $I$에 해당하는 9개 점이 Vertex, 각 점마다 연결된 선이 노드가 된다. 버텍스가 모든 노드를 커버할 수 있다면 <span class=\"amber-A400\">버텍스 커버</span>라 볼 수 있다. 그 중 <span class=\"green-A400\">모든 노드를 커버하는 가작 적은 버텍스의 집합</span>이 <span class=\"amber-A400\">Miminum Vertex Cover(최소 버텍스 커버)</span>라 할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956549-108e3680-d3bc-11eb-802e-53765cacf3ed.png\" width=\"600px\" />\r\n</p>\r\n\r\n버텍스 $E$의 경우, 대다수의 노드를 포함하고 있지만 $\\overline{AB}$, $\\overline{BC}$, $\\overline{FI}$ 노드를 포함하지 않으므로 버텍스 $E$만으로는 <span class=\"amber-A400\">최소 버텍스 커버</span> 조합이 될 수 없다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956594-1b48cb80-d3bc-11eb-8b48-cf263fd7bcfe.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같이 $B$, $F$ 버텍스를 포함할 경우 존재하는 모든 노드를 포함하는 가장 적은 버텍스의 조합이므로 <span class=\"amber-A400\">최소 버텍스 커버</span>가 된다.\r\n\r\n유의깊게 봐야할 점은, <span class=\"amber-A400\">최소 버텍스 커버</span>를 통해 <span class=\"primary\">최대 독립 집합</span>을 구할 수 있다. <span class=\"amber-A400\">최소 버텍스 커버</span>에 해당하는 버텍스와 모든 노드를 제거해보자. 아래와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956663-2996e780-d3bc-11eb-97f7-d24bd59126fd.png\" width=\"600px\" />\r\n</p>\r\n\r\n이처럼, 전체 그룹에서 <span class=\"amber-A400\">최소 버텍스 커버</span>를 제거하면 <span class=\"orange-A400\">나머지 버텍스들은 그 어떤 버텍스끼리도 연결되지 않는 독립 버텍스</span>다. <span class=\"amber-A400\">최소 버텍스 커버</span>가 모든 노드를 연결한 버텍스의 최소 집함임을 생각한다면, 이를 뺀 나머지는 어떤 버텍스와도 연결되지 않는 버텍스 집합의 최대 조합이라고 할 수 있다. 즉, 최대 독립 집합 $=$ 전체 그룹 $-$ 최소 버텍스 커버로 표현할 수 있다.\r\n\r\n그래, 그건 그렇다 치고, 위 개념이 이 문제와 무슨 연관성이 있길래 이렇게 장황하게 서술할까? 이번엔 조금 다르게 이 문제와 연관지어 예시를 들어본다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956705-33204f80-d3bc-11eb-8e58-c1c96509d4fe.png\" width=\"600px\" />\r\n</p>\r\n\r\n그 어떤 자리도 파손되지 않은 온전한 9개 자리가 있다고 가정하자. 각 자리별로 컨닝이 가능한 자리를 노드로 연결하면 위와 같이 도식할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956771-42070200-d3bc-11eb-908c-fc5c5db4f583.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진에서 <span class=\"amber-A400\">최소 버텍스 커버</span>는 $B$, $E$, $H$가 된다. 이 자리 3개로 위 사진의 모든 노드를 포함할 수 있기 때문이다. 이 자리들을 제거하여 <span class=\"primary\">최대 독립 집합</span>을 표현하면 어떻게 될까?\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956808-4cc19700-d3bc-11eb-82ff-dc32d98960c4.png\" width=\"600px\" />\r\n</p>\r\n\r\n나머지 자리인 $A$, $C$, $D$, $F$, $G$, $H$만 남게 되며, 각 자리는 그 어떤 노드와도 연결되어있지 않다. 이 사진에서의 노드는 컨닝 가능한 자리이므로, **노드가 없다는 것은 컨닝할 수 있는 자리가 없다**는 뜻이 된다. 즉, <span class=\"amber-A400\">최소 버텍스 커버</span> 로직을 설계하는 것이 이번 알고리즘의 키 포인트다.\r\n\r\n## 이분 매칭\r\n\r\n자, <span class=\"amber-A400\">최소 버텍스 커버</span>가 알고리즘의 키인 건 알았으니, 이를 구현하기만 하면 된다. 안타깝게도 <span class=\"amber-A400\">최소 버텍스 커버</span>를 코딩으로 계산하는 것은 매우 복잡한 일이다.\r\n\r\n**König's Theorem**(쾨닉의 정리)에 의하면 <span class=\"red-400\">모든 이분 그래프의 최대 매칭은 최소 버텍스 커버와 같다</span>고 증명한다. 즉, 위 그래프를 이분 그래프로 변경하여 최대 매칭을 구하면 <span class=\"amber-A400\">최소 버텍스 커버</span>를 구할 수 있다는 뜻이다.\r\n\r\n결론적으로, <span class=\"amber-A400\">최소 버텍스 커버</span>를 구하기 위해 <span class=\"teal-A400\">이분 매칭</span> 알고리즘을 구현해야 한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>의 연산에 사용하는 **이분 그래프**는 아래와 같은 특징을 가진다.\r\n\r\n* 모든 정점을 두 그룹으로 나눌 수 있다.\r\n* 모든 노드는 한 그룹에서 다른 그룹으로 연결된다.\r\n* 같은 그룹끼리는 연결되지 않는다.\r\n\r\n고등수학을 배웠다면 우리는 이미 이분 그래프를 접한적이 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956906-6367ee00-d3bc-11eb-8612-b27579146961.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 사진은 임의의 함수 $f(x)$에 대한 식을 도식화한 것이다. 위 함수 도식은 이분 그래프의 적절한 예시가 될 수 있다. 모든 그룹이 $x$ 혹은 $y$그룹으로 나뉘며, 모든 노드가 $x$에서 $y$로 연결된다.\r\n\r\n**이분 그래프의 매칭**은 각 그룹의 버텍스를 매칭하는 노드의 집합이다. 단, 각 노드의 끝 점은 다른 노드와 중복되지 않는다. **이분 그래프의 최대 매칭**은 이분 그래프의 매칭의 노드 수가 최대인 조합이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122956970-71b60a00-d3bc-11eb-9019-0ffaef2ac35b.png\" width=\"600px\" />\r\n</p>\r\n\r\n위와 같이 연결된 이분 그래프가 있다고 가정하자. $1$번 버텍스를 기준으로 $A$와 $B$에 노드가 연결되어있다. $\\overline{A1}$을 선택할 경우, $\\overline{B1}$은 매칭에서 제외된다. 노드의 끝 선이 $1$번 버텍스로 동일하기 때문이다. 각 노드의 끝 점은 다른 노드와 중복되지 않는다는 말의 의미는 이와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957021-7e3a6280-d3bc-11eb-8b24-07a0662def70.png\" width=\"600px\" />\r\n</p>\r\n\r\n1. $A$와 $1$번 버텍스를 잇는 노드 $\\overline{A1}$을 선택한다.\r\n2. $B$와 $1$번 버텍스를 잇는 노드 $\\overline{B1}$은 노드 $\\overline{A1}$이 $1$번 버텍스를 포함하므로 선택할 수 없다.\r\n3. 노드 $\\overline{A1}$의 시작 버텍스인 $A$에부터 다른 노드가 있는지 탐색한다.\r\n4. $A$ 버텍스와 연결된 다른 노드가 없으므로 노드 $\\overline{A1}$의 선택을 유지한다.\r\n5. $C$와 $1$번 버텍스를 잇는 노드 $\\overline{C1}$을 선택한다.\r\n6. 마지막 버텍스이므로 탐색을 종료하고 갯수를 계산한다.\r\n\r\n이와 같은 과정으로 이분 그래프의 최대 매칭의 수는 `2`가 된다. 물론 최대 매칭의 조합은 여러개가 될 수 있겠지만, 이 알고리즘에선 \"조합\"이 아니라 \"수\"가 중요하므로 경우의 수를 구할 필요는 없다.\r\n\r\n> **이분 그래프의 최대 매칭 조합**  \r\n> 위 그래프의 최대 매칭 조합은 $[ \\overline{A1}, \\overline{C2} ]$, $[ \\overline{A1}, \\overline{C3} ]$, $[ \\overline{B1}, \\overline{C2} ]$, $[ \\overline{B1}, \\overline{C3} ]$으로 최대 매칭의 수는 2이며 4가지 경우의 수가 존재한다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>을 문제에 적용하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957080-898d8e00-d3bc-11eb-84f6-7b504b2d93b3.png\" width=\"600px\" />\r\n</p>\r\n\r\n이번엔 조금 복합적인 예시다. 버텍스 $A$와 $E$가 파손되어 앉을 수 없는 상황이다. 이러한 조건에서 컨닝 가능한 자리를 노드로 표현하면 위 사진과 같이 표현할 수 있다. 규칙의 특성 상, 한 쪽 열은 양 옆의 열에 영향을 준다. 즉, 홀수열과 짝수열로 그룹을 나눌 수 있다. 열의 홀짝을 기준으로 나눠 이분 그래프를 표시하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/122957152-9ca05e00-d3bc-11eb-8a63-1c7ae6e5edfb.png\" width=\"600px\" />\r\n</p>\r\n\r\n위 이분 그래프의 최대 매칭은 2가 된다. 즉, 최소 버텍스 커버의 조합은 $B$, $H$고 파손되서 착석이 불가능한 자리는 $A$, $E$가 된다. 따라서 $C$, $D$, $F$, $G$, $I$가 컨닝 불가능한 자리가 된다. 단순히 자리의 \"수\"만 계산하면 되므로 `컨닝 불가능한 자리 = 전체 자리 - 최소 버텍스 커버 수 - 파손된 자리`가 된다. 따라서 위 그래프의 알고리즘 수행 결과는 5가 된다.\r\n\r\n<span class=\"teal-A400\">이분 매칭</span>은 <span class=\"blue-400\">BFS(Breadth First Search, 너비 우선 탐색)</span> 혹은 <span class=\"blue-400\">DFS(Depth First Search, 깊이 우선 탐색)</span>으로 구현할 수 있다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1014 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/18/a1014\">1014 풀이</a>\r\n * @since 2021.06.18 Fri 16:42:44\r\n */\r\npublic class Main\r\n{\r\n\t// 교실 세로 길이 (y)\r\n\tprivate static int N;\r\n\t\r\n\t// 교실 가로 길이 (x)\r\n\tprivate static int M;\r\n\t\r\n\t// 자리 번호\r\n\tprivate static int[][] room;\r\n\t\r\n\t// 컨닝 가능한 자리\r\n\tprivate static boolean[][] nodes;\r\n\t\r\n\t// 방문 횟수\r\n\tprivate static int visitCount;\r\n\t\r\n\t// 버텍스별 방문 횟수\r\n\tprivate static int[] visit;\r\n\t\r\n\t// 버텍스 매칭 여부\r\n\tprivate static int[] matched;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 현재 자리에서 컨닝이 가능한 자리의 위치 상대좌표\r\n\t\tint[][] scopes = { { -1, 1 }, { -1, 0 }, { -1, -1 }, { 1, 1 }, { 1, 0 }, { 1, -1 } };\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint C = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\twhile (C-- > 0)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\tM = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 자리의 파손 여부\r\n\t\t\tboolean[][] canSit = new boolean[N][M];\r\n\t\t\t\r\n\t\t\t// 자리의 번호\r\n\t\t\tint numbering = 1;\r\n\t\t\t\r\n\t\t\t// 파손된 자리의 총 갯수\r\n\t\t\tint broken = 0;\r\n\t\t\t\r\n\t\t\troom = new int[N][M];\r\n\t\t\tnodes = new boolean[N * M][N * M];\r\n\t\t\t\r\n\t\t\tvisitCount = 1;\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\"\");\r\n\t\t\t\t\r\n\t\t\t\tfor (int m = 0; m < M; m++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 자리 번호 기록\r\n\t\t\t\t\troom[n][m] = numbering++;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 앉을 수 있는 경우\r\n\t\t\t\t\tif (temp[m].equals(\".\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 파손된 경우\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcanSit[n][m] = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// 파손 갯수 1 추가\r\n\t\t\t\t\t\tbroken++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int n = 0; n < N; n++)\r\n\t\t\t{\r\n\t\t\t\t// 홀수 열만 대상으로 동작함\r\n\t\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 앉을 수 있는 좌석일 경우\r\n\t\t\t\t\tif (canSit[n][m])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int[] scope : scopes)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// 컨닝 가능성 있는 자리의 상대좌표\r\n\t\t\t\t\t\t\tint no = n + scope[1];\r\n\t\t\t\t\t\t\tint mo = m + scope[0];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 상대좌표가 교실을 벗어나지 않으면서, 앉을 수 있을 경우\r\n\t\t\t\t\t\t\tif (no > -1 && mo > -1 && no < N && mo < M && canSit[no][mo])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// 노드 연결 표시\r\n\t\t\t\t\t\t\t\tnodes[room[n][m] - 1][room[no][mo] - 1] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tint result = bipartite();\r\n\t\t\t\r\n\t\t\twriter.write(Integer.toString(N * M - broken - result));\r\n\t\t\twriter.newLine();\r\n\t\t\twriter.flush();\r\n\t\t}\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이분 매칭 갯수 반환 함수\r\n\t *\r\n\t * @return [int] 이분 매칭 갯수\r\n\t */\r\n\tprivate static int bipartite()\r\n\t{\r\n\t\t// 매칭 갯수\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tvisit = new int[N * M];\r\n\t\t\r\n\t\tmatched = new int[N * M];\r\n\t\t\r\n\t\tArrays.fill(matched, -1);\r\n\t\t\r\n\t\tfor (int n = 0; n < N; n++)\r\n\t\t{\r\n\t\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t\t{\r\n\t\t\t\tvisitCount++;\r\n\t\t\t\t\r\n\t\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * DFS 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param num: [int] 시작점\r\n\t *\r\n\t * @return [int] 매칭 갯수\r\n\t */\r\n\tprivate static int dfs(int num)\r\n\t{\r\n\t\t// 같은 버텍스가 아닐 경우\r\n\t\tif (visit[num] != visitCount)\r\n\t\t{\r\n\t\t\tvisit[num] = visitCount;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t\t{\r\n\t\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\t\tif (nodes[num][i])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn 0;\r\n\t}\r\n}\r\n```\r\n\r\n유의깊게 봐야할 코드는 아래와 같다.\r\n\r\n``` java\r\nprivate static int bipartite()\r\n{\r\n\t// 매칭 갯수\r\n\tint size = 0;\r\n\t\r\n\tvisit = new int[N * M];\r\n\t\r\n\tmatched = new int[N * M];\r\n\t\r\n\tArrays.fill(matched, -1);\r\n\t\r\n\tfor (int n = 0; n < N; n++)\r\n\t{\r\n\t\tfor (int m = 0; m < M; m += 2)\r\n\t\t{\r\n\t\t\tvisitCount++;\r\n\t\t\t\r\n\t\t\tsize += dfs(room[n][m] - 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn size;\r\n}\r\n```\r\n\r\n위 코드가 이분매칭을 <span class=\"primary\">DFS 알고리즘</span>을 통해 구현한 것이다.  `for`문의 변수 선언 중 `m += 2`인 이유는 홀수열만 체크하기 위함이다.\r\n\r\n``` java\r\nprivate static int dfs(int num)\r\n{\r\n\t// 같은 버텍스가 아닐 경우\r\n\tif (visit[num] != visitCount)\r\n\t{\r\n\t\tvisit[num] = visitCount;\r\n\t\t\r\n\t\tfor (int i = 0; i < N * M; i++)\r\n\t\t{\r\n\t\t\t// num과 i 버텍스 사이에 노드가 존재할 경우\r\n\t\t\tif (nodes[num][i])\r\n\t\t\t{\r\n\t\t\t\t// 아직 매칭되지 않았거나, 이미 i와 매칭된 버텍스가 다른 버텍스와 매칭할 수 있을 경우\r\n\t\t\t\tif (matched[i] == -1 || dfs(matched[i]) == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tmatched[i] = num;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n이분매칭을 구현하는 <span class=\"primary\">DFS 알고리즘</span>의 코드는 위와 같다. `matched` 배열은 -1로 초기화되며, 매칭되는 버텍스의 번호를 할당받는다.\r\n\r\n$A$ 버텍스가 $B$ 버텍스와 연결된 노드 $\\overline{AB}$를 가질 경우, 이를 `matched[A] = B`와 같이 표시한다. 만약, $A$ 버텍스가 $B$ 버텍스를 연결하는 와중에 이미 $B$가 $C$와 연결되어있을 경우, $C$ 버텍스에 $B$가 아닌 다른 버텍스와 연결된 노드가 있는지 확인한다. 만약 가능할 경우, $\\overline{BC}$를 제거하고 $C$와 연결할 수 있는 다른 버텍스를 연결한다. 이후 $\\overline{AB}$를 연결한다.\r\n\r\n이 과정을 반복하여 연결을 수립할 수 있을 경우 1, 없을 경우 0을 반환한다. 이는 `boolean` 타입으로도 대체할 수 있으나, `dfs()`연산 결과를 더하기 때문에 편의상 `int`로 반환한다.\r\n\r\n## 비공식 케이스\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n10 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n42\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 10\r\n.X.X...X..\r\n.X..X.....\r\nX.X.......\r\n.X.X......\r\nX...X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n21\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 8\r\n.X...X..\r\n..X.....\r\nX.......\r\n.X......\r\n..X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n18\r\n```\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n5 7\r\nX...X..\r\n.X.....\r\n.......\r\nX......\r\n.X.....\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n17\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 비트마스킹\r\n* 최대 유량\r\n* 비트필드를 이용한 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n[습격자 초라기](/posts/2021/06/06/a1006)가 매우 복잡한 케이스들을 이해하는데 할애했다면, 이 문제는 케이스가 복잡하다기 보단, 네트워크 플로우를 이해하고 적용하는데 대부분의 시간을 할애했다. 문제 보니까 가면 갈수록 플래티넘이 계속해서 나오는 구간도 있던데, 순서대로 푸는 규칙에 대해 진지하게 생각해봐야하나 싶다.\r\n\r\n## 참고\r\n\r\n* [개발괴발](https://m.blog.naver.com/kelle111/221537563173)\r\n* [Crocus](https://www.crocus.co.kr/814)","url":["2021-06-18-a1014","2021","06","18","a1014"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1006번 습격자 초라기","excerpt":"초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.) 초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-06T22:42:02","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","PLATINUM","PLATINUM III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-06-a1006.md","content":"\r\n# 습격자 초라기\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)\r\n\r\n🔗 [전체 1006번 문제](https://www.acmicpc.net/problem/1006)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg\" width=\"400px\" />\r\n</p>\r\n\r\n초라기는 각각 $W$명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.\r\n\r\n1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.\r\n2. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.\r\n3. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 $W$ 보다 작거나 같아야 한다.\r\n\r\n이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n첫째 줄에는 (구역의 개수)/2 값 $N$과 특수 소대원의 수 $W$가 주어진다. ($1 ≤ N ≤ 10000$, $1 ≤ W ≤ 10000$).\r\n\r\n둘째 줄에는 $1 ~ N$번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 $N + 1 ~ 2N$번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ $W$)\r\n\r\n## 출력\r\n\r\n각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1\r\n8 100\r\n70 60 55 43 57 60 44 50\r\n58 40 47 90 45 52 80 40\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n## 힌트\r\n\r\n하나의 특수 소대로 인접한 두 영역을 커버할 수 있는 배치는 (2,10), (9,16), (4,5), (7,8), (13,14) 이다. 그리고 나머지 6개 구역은 각각 하나의 특수 소대로 커버할 수 있다. 그러므로 최소 11개 특수 소대를 침투시켜야 한다.\r\n\r\n# 풀이\r\n\r\n백준 알고리즘을 순서대로 푸는 나 같은 초심자들에게 <span class=\"red-A400\">힘의 차이</span>를 느끼게 해주는 문제라고 한다. [solved.ac](https://solved.ac/)에 의하면 문제 등급이 무려 <span class=\"teal-A400\">PLATINUM III</span> 수준. 지금까지 푼 문제 중 가장 높은 등급이 [ACM Craft](/posts/2021/06/01/a1005) (<span class=\"amber-A400\">GOLD III</span>) 수준임을 감안하면 월등히 높은 수준의 문제. 실제로 풀면서도 혼자서는 도저히 방법이 안 떠오르는데다, 풀이를 봐도 이해가 잘 안 됐다.\r\n\r\n해당 문제에 주어지는 <span class=\"primary\">구역</span>은 원형이다. 문제를 쉽게 접근하기 위해선 이 원형을 임의로 잘라 직사각형 형태로 전개해야 한다. 즉, <span class=\"error\">풀 때는 직사각형 형태지만, 실제로는 원형이므로 직사각형의 잘린 양 끝부분까지 염두하여 계산</span>을 해야한다. 난이도를 상승시키는 요인 중 하나.\r\n\r\n케이스에 제시된 예제를 기준으로 구역을 사각형으로 도식화하면 아래와 같다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n위 사진과 같이 8x8 배열로 표현할 수 있다. 여기서 여기서 6번째 행까지 특수소대로 채울 수 있는 최소값은 어떻게 구할 수 있을까?\r\n\r\n역으로 한번 생각해보자. 우리 특수소대는 너무나 유능해서 항상 최소의 팀만으로 목표 구역을 점령한다고 해보자. 작전 보고서엔 아래와 같이 점령한 구역을 표시하며, 이를 <span class=\"yellow-a500\">노란색</span> 영역으로 마킹해서 보여준다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926996-378d0d00-c71a-11eb-9b0f-baacb8da1647.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, <span class=\"yellow-a500\">노란색</span> 영역은 최소의 특수소대팀이 투입된 것이며, 우리가 실제로 구현할 알고리즘의 결과물이기도 하다.\r\n\r\n문제의 설정 상, 특수소대는 반드시 한 팀이 온전히 투입되어야 하며, 최소로 투입 가능한 인원 역시 한 팀이다. 그렇다면 위 사진에서 특수소대 한 팀이 커버할 수 있는 영역을 제외해보면 아래와 같이 세 케이스 $a$, $b$, $c$로 나눌 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927024-568b9f00-c71a-11eb-9309-7e4ef2f06ac2.png\" width=\"512px\" />\r\n</p>\r\n\r\n즉, 우리가 저 세 케이스에 대한 특수소대팀의 최소값을 계산할 수 있다면, 결과적으로 6번째 행 전체를 커버하는 특수소대팀의 수를 구할 수 있다. 이미 최소 인원이 나머지 구역을 점령한 상황에서, 투입할 수 있는 최소 인원인 한 팀만 투입할 수 있기 때문.\r\n\r\n여러 블로그에서 위 세 그림을 많이 봤을 텐데, 뜬금없이 저런 그림이 등장함에는 이와같은 배경이 있는 것이다.\r\n\r\n## 변수\r\n\r\n알고리즘 설계에 사용할 변수는 아래와 같다.\r\n\r\n* $T$: 케이스 수\r\n* $N$: 구역의 행 수\r\n* $e$: 구역별 적의 수\r\n* $a_i$: 첫 번째 케이스의 특수소대 최소 투입 수\r\n* $b_i$: 두 번째 케이스의 특수소대 최소 투입 수\r\n* $c_i$: 세 번째 케이스의 특수소대 최소 투입 수\r\n\r\n## a 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927050-77ec8b00-c71a-11eb-8034-5b02a6c04246.png\" width=\"512px\" />\r\n</p>\r\n\r\n첫번째 케이스로 $a_5$의 최소값 공식을 설계하자.\r\n\r\n위에서 했던 방식과 마찬가지로 추론하면 $a_5$에서 한팀을 뺀 $a_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927077-90f53c00-c71a-11eb-96cd-38edba684b10.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = c_5$ 이므로 $a_5 = c_5 + 1$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{05} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927092-9c486780-c71a-11eb-91c7-1922f98a1b01.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_5 - 1 = b_4$ 이므로 $a_5 = b_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $a_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $a_5 = c_5 + 1$ -> $a_{i+1} = c_{i+1} + 1$\r\n* $a_5 = b_4 + 1$ -> $a_{i+1} = b_i + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## b 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927110-ac604700-c71a-11eb-989a-3d97d8e6a3ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5$의 최소값 공식을 설계하자.\r\n\r\n$b_5$에서 한팀을 뺀 $b_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 두 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927135-c0a44400-c71a-11eb-9c22-4e1303799b3b.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = c_5$ 이므로 $b_5 = c_5 + 1$\r\n\r\n$a_5$의 식과 동일하다.\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{14} + e_{15} ≤ W$일 경우에 한해 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927154-d285e700-c71a-11eb-8b25-14fd85e1b1b0.png\" width=\"512px\" />\r\n</p>\r\n\r\n$b_5 - 1 = a_4$ 이므로 $b_5 = a_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $b_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $b_5 = c_5 + 1$ -> $b_{n+1} = c_{n+1} + 1$\r\n* $b_5 = a_4 + 1$ -> $b_{n+1} = a_n + 1$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## c 공식\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927173-e3365d00-c71a-11eb-9c1b-dfb34ab3b444.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5$의 최소값 공식을 설계하자. ($c_5$는 4행까지 채워짐에 유의하자)\r\n\r\n$c_5$에서 한팀을 뺀 $c_5 - 1$을 구해야 하며, 이는 $e$의 조건에 따라 여러 케이스로 나눌 수 있다.\r\n\r\n### 일반적인 케이스\r\n\r\n일반적으로 아래의 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927189-f47f6980-c71a-11eb-8c17-2120a82b4b6e.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 - 1 = a_4$ 이므로 $c_5 = a_4 + 1$\r\n\r\n$c_5 - 1 = b_4$ 이므로 $c_5 = b_4 + 1$\r\n\r\n두 케이스 중 더 작은 케이스가 $c_5$이므로 아래의 식으로 귀결된다.\r\n\r\n$c_5 = min(a_4 + 1, b_4 + 1)$\r\n\r\n### 한팀이 두개의 구역을 커버할 수 있을 경우\r\n\r\n$e_{04} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927199-ff39fe80-c71a-11eb-8b45-bb4f13aadf08.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_4 + 1$\r\n\r\n일반적인 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 한팀이 네개의 구역을 커버할 수 있을 경우\r\n\r\n$c_i$의 경우 한 가지 특이 케이스가 발생한다. $a_i$, $b_i$의 경우 최소 투입인원인 1을 뺀 값만을 계산했다. $c_i$의 경우 직사각형이라는 특징 때문에 최대 4개 구역을 2팀이 점령할 수 있다.\r\n\r\n$e_{03} + e_{04} ≤ W$ 이고 $e_{13} + e_{14} ≤ W$일 경우 아래와 같은 케이스가 해당된다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927226-11b43800-c71b-11eb-8845-7597a3a502b8.png\" width=\"512px\" />\r\n</p>\r\n\r\n$c_5 = c_3 + 2$\r\n\r\n모든 케이스와 비교했을 때, 더 작은 값이 $c_5$가 된다.\r\n\r\n### 일반화\r\n\r\n케이스별로 구한 식의 일반화는 아래와 같다.\r\n\r\n* $c_{i+1} = min(a_{i} + 1, b_{i} + 1)$\r\n* $c_{i+1} = c_{i} + 1$\r\n* $c_{i+1} = c_{i-1} + 2$\r\n\r\n즉, 최종 일반식은 아래와 같다.\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 최종 일반식\r\n\r\n구한 일반식을 정리하면 아래와 같다.\r\n\r\n$$\r\na_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, b_i + 1), & (e_{0i} + e_{0(i + 1)} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_{i+1} = \r\n\\begin{cases}\r\n\tc_{i+1} + 1, & (\\text{default})\\\\\r\n\tmin(c_{i+1} + 1, a_i + 1), & (e_{0(i-1)} + e_{0i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_{i+1} = \r\n\\begin{cases}\r\n\tmin(a_{i} + 1, b_{i} + 1), & (e_{0i} + e_{1i} > W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1), & (e_{0(i-1)} + e_{1(i-1)} ≤ W)\\\\\r\n\tmin(a_{i} + 1, b_{i} + 1, c_{i} + 1, c_{i-1} + 2), & (e_{0(i-1)} + e_{0i} ≤ W,e_{1(i-1)} + e_{1i} ≤ W)\r\n\\end{cases}\r\n$$\r\n\r\n## 원형 구조 적용을 위한 초기값 지정하기\r\n\r\n위 수식을 코드로 녹여내면 되지만, 완벽한 건 아니다. 왜냐하면 이 구역이 <span class=\"red-A400\">선형이 아닌 원형 구조</span>이기 때문.\r\n\r\n지금까지 우리는 원리 이해 및 수식 도출의 편의를 위해 원타곤을 임의로 잘라 표타곤으로 전개하여 수식을 계산했다. 이러한 <span class=\"green-A700\">선형 구조는 시작점과 도착점이 있지만 원형은 순환 구조</span>이므로 이에 맞춰 조건식을 작성해야 한다. 즉, <span class=\"red-A400\">원형 구조에 호환되도록 일부 케이스에 초기값을 지정</span>해야 최종적으로 원하는 알고리즘을 작성할 수 있다.\r\n\r\n아래의 사진은 원타곤과 표타곤을 비교한 것이다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927246-2b557f80-c71b-11eb-92bf-fe5f92cf5504.png\" width=\"512px\" />\r\n</p>\r\n\r\n이 처럼, 원형 구조는 $e_{00}, e_{07}$끼리도 연결이 가능하지만, 선형 구조는 구조상 불가능하다. 때문에 이러한 케이스들의 초기값을 지정해줘야한다.\r\n\r\n대충 감이 오겠지만, 걸친 모양에 따라 총 4가지 케이스가 존재한다.\r\n\r\n### 걸치지 않을 경우 (기본)\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120926986-2e9c3b80-c71a-11eb-8750-5bc4477e10ca.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$ 혹은 $e_{10}, e_{17}$과 같이 영역이 겹치지 않을 경우. 선형 구조에서도 적용 가능한 기본적인 케이스다. $a_i, b_i, c_i$의 모양과 연관지어 생각하면 아래와 같이 도식이 가능하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927267-4a541180-c71b-11eb-8596-497ba12219e4.png\" width=\"512px\" />\r\n</p>\r\n\r\n$a_i$는 $i$열의 윗 칸만 채우므로 $e_{00}$만 점령한 상태이므로 1\r\n\r\n$b_i$는 $i$열의 아래 칸만 채우므로 $e_{01}$만 점령한 상태이므로 1\r\n\r\n$c_i$는 $i - 1$열을 채우는데, $c_{-1}$은 논리상 불가능하므로 0\r\n\r\n즉 초기값은 아래와 같다.\r\n\r\n$$\r\na_0 = 1\r\n$$\r\n\r\n$$\r\nb_0 = 1\r\n$$\r\n\r\n$$\r\nc_0 = 0\r\n$$\r\n\r\n$i = 0$일 때의 초기값을 지정한다.\r\n\r\n이 케이스일 경우 $c_N$이 알고리즘의 답이 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_8$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927320-88e9cc00-c71b-11eb-8ae4-3dfb03d4e0f0.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 윗 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927336-9bfc9c00-c71b-11eb-837d-77c000661702.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$을 점령할 경우. 원형 구조에서만 가능한 케이스다. **걸치지 않는 경우**를 제외한 나머지 케이스는 전부 원형 구조에서만 가능한 케이스이니 참고할 것. $i = 0$일 때는 영향을 받지 않아 **걸치지 않는 경우**와 동일하다. 걸치기 위해선 반드시 두 행 이상이 필요하기 때문에, $N > 1$을 충족해야 한다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927372-a880f480-c71b-11eb-84cc-689658a3a89c.png\" width=\"512px\" />\r\n</p>\r\n\r\n연결된 부분을 체크패턴으로 하이라이팅 했다. 이 둘이 서로 연결되기 때문에, 다른 구역의 특수소대가 점령할 수 없다. 따라서 <b class=\"red-A400\">해당 부분은 초기값 계산 시 없는 영역으로 생각하면 된다.</b> 이러한 특징을 감안하면 아래와 같이 초기값을 지정할 수 있다.\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 2\r\n$$\r\n\r\n$$\r\nb_1 = \r\n\\begin{cases}\r\n\t1, & (e_{10} + e_{11} ≤ W)\\\\\r\n\t2, & (e_{10} + e_{11} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $b_{N-1} + 1$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927427-b767a700-c71b-11eb-9306-0931ede25cba.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 아래 행만 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927442-c6e6f000-c71b-11eb-8f51-2fab907fbcc2.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927459-d1a18500-c71b-11eb-9c6c-07919e9f4f8d.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = \r\n\\begin{cases}\r\n\t1, & (e_{00} + e_{01} ≤ W)\\\\\r\n\t2, & (e_{00} + e_{01} > W)\r\n\\end{cases}\r\n$$\r\n\r\n$$\r\nb_1 = 2\r\n$$\r\n\r\n$$\r\nc_1 = 1\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $a_{N-1} + 1$이 알고리즘의 답이 된다. $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $b_7 + 1$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927475-e120ce00-c71b-11eb-8bd6-c44d4137fae8.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 두 행 모두 걸칠 경우\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927491-ee3dbd00-c71b-11eb-98b9-f0d4209ec965.png\" width=\"512px\" />\r\n</p>\r\n\r\n$e_{00}, e_{07}$, $e_{10}, e_{17}$을 점령할 경우. 세부 사항은 **윗 행만 걸칠 경우와 동일**하다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927507-fd246f80-c71b-11eb-8e78-f08c15922ad8.png\" width=\"512px\" />\r\n</p>\r\n\r\n예제에서 $N = 8$이므로, 조건의 일반식은 $e_{00}, e_{0(N-1)}$, $e_{10}, e_{1(N-1)}$이 된다.\r\n\r\n$$\r\na_1 = 1\r\n$$\r\n\r\n$$\r\nb_1 = 1\r\n$$\r\n\r\n$$\r\nc_1 = 0\r\n$$\r\n\r\n$i = 1$일 때의 초기값을 추가로 지정한다.\r\n\r\n이 케이스일 경우 $c_{N-1} + 2$이 알고리즘의 답이 된다. $e_{00}$, $e_{07}$을 합쳐 $e_{00}$, $e_{10}$, $e_{17}$을 합쳐 $e_{10}$이라고 생각하면 된다.\r\n\r\n예를 들어, $N=8$일 경우 $c_{N-1} + 2$이 되므로 가장 적합한 최소값을 구할 수 있다.\r\n\r\n<p align=\"center\">\r\n\t<img src=\"https://user-images.githubusercontent.com/50317129/120927519-07df0480-c71c-11eb-9fdf-c8f05858b72d.png\" width=\"512px\" />\r\n</p>\r\n\r\n### 최종 케이스\r\n\r\n* 기본\r\n  * $a_0 = 1$\r\n  * $b_0 = 1$\r\n  * $c_0 = 0$\r\n\r\n<br />\r\n\r\n* 윗 행만 걸칠 경우 $(e_{00} + e_{0(N-1))} ≤ W)$\r\n  * $a_1 = 2$\r\n  * $b_1 = \\begin{cases} 1, & (e_{10} + e_{11} ≤ W)\\\\ 2, & (e_{10} + e_{11} > W) \\end{cases}$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 아래 행만 걸칠 경우 $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = \\begin{cases} 1, & (e_{00} + e_{01} ≤ W)\\\\ 2, & (e_{00} + e_{01} > W) \\end{cases}$\r\n  * $b_1 = 2$\r\n  * $c_1 = 1$\r\n\r\n<br />\r\n\r\n* 두 행 모두 걸칠 경우 $(e_{00} + e_{0(N-1)} ≤ W)$, $(e_{10} + e_{1(N-1)} ≤ W)$\r\n  * $a_1 = 1$\r\n  * $b_1 = 1$\r\n  * $c_1 = 0$\r\n\r\n비로소 알고리즘을 구현하기 위한 모든 준비물이 갖춰졌다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1006 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://rwb0104.github.io/posts/2021/06/06/a1006\">1006 풀이</a>\r\n * @since 2021.06.06 Sun 22:44:45\r\n */\r\npublic class Main\r\n{\r\n\tprivate static int N;\r\n\tprivate static int W;\r\n\t\r\n\tprivate static int[][] e;\r\n\t\r\n\tprivate static int[] a;\r\n\tprivate static int[] b;\r\n\tprivate static int[] c;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tint result = 2147483647;\r\n\t\t\t\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\t// 행 수\r\n\t\t\tN = Integer.parseInt(temp[0]);\r\n\t\t\t\r\n\t\t\t// 특수소대원 수\r\n\t\t\tW = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\t// 구역별 적 배열\r\n\t\t\te = new int[2][N];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < 2; j++)\r\n\t\t\t{\r\n\t\t\t\ttemp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tfor (int k = 0; k < N; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\te[j][k] = Integer.parseInt(temp[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ta = new int[N];\r\n\t\t\tb = new int[N];\r\n\t\t\tc = new int[N + 1];\r\n\t\t\t\r\n\t\t\ta[0] = 1;\r\n\t\t\tb[0] = 1;\r\n\t\t\tc[0] = 0;\r\n\t\t\t\r\n\t\t\t// 인덱스 0부터 시작\r\n\t\t\tsolve(0);\r\n\t\t\t\r\n\t\t\tresult = Math.min(result, c[N]);\r\n\t\t\t\r\n\t\t\t// 두 행 이상일 경우\r\n\t\t\tif (N > 1)\r\n\t\t\t{\r\n\t\t\t\t// 두 행 모두 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W && e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 1;\r\n\t\t\t\t\tb[1] = 1;\r\n\t\t\t\t\tc[1] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, c[N - 1] + 2);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 윗 행만 걸칠 경우\r\n\t\t\t\tif (e[0][0] + e[0][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = 2;\r\n\t\t\t\t\tb[1] = e[1][0] + e[1][1] > W ? 2 : 1;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, b[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아래 행만 걸칠 경우\r\n\t\t\t\tif (e[1][0] + e[1][N - 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[1] = e[0][0] + e[0][1] > W ? 2 : 1;\r\n\t\t\t\t\tb[1] = 2;\r\n\t\t\t\t\tc[1] = 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 인덱스 1부터 시작 (1까지 초기값이 있기 때문)\r\n\t\t\t\t\tsolve(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = Math.min(result, a[N - 1] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 함수\r\n\t *\r\n\t * @param num: [int] 시작 인덱스\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\tfor (int i = num; i < N; i++)\r\n\t\t{\r\n\t\t\tc[i + 1] = Math.min(a[i] + 1, b[i] + 1);\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\tif (e[0][i] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i] + 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// c팀이 인접한 두개의 구역 2개를 점령할 수 있을 경우\r\n\t\t\tif (i > 0 && e[0][i - 1] + e[0][i] <= W && e[1][i - 1] + e[1][i] <= W)\r\n\t\t\t{\r\n\t\t\t\tc[i + 1] = Math.min(c[i + 1], c[i - 1] + 2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// a, b팀의 인덱스 보정 (c팀은 인덱스가 하나 더 많음)\r\n\t\t\tif (i < N - 1)\r\n\t\t\t{\r\n\t\t\t\ta[i + 1] = c[i + 1] + 1;\r\n\t\t\t\tb[i + 1] = c[i + 1] + 1;\r\n\t\t\t\t\r\n\t\t\t\t// a팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[0][i] + e[0][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\ta[i + 1] = Math.min(a[i + 1], b[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// b팀이 인접한 두 개의 구역을 점령할 수 있을 경우\r\n\t\t\t\tif (e[1][i] + e[1][i + 1] <= W)\r\n\t\t\t\t{\r\n\t\t\t\t\tb[i + 1] = Math.min(b[i + 1], a[i] + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n\r\n# 여담\r\n\r\n6월 1일부터 풀기 시작해서 이 문제를 완전히 이해하는데 근 일주일 가까이 걸렸다. 나름의 풀이를 작성해야하는데, 남의 풀이가 아닌 내 풀이를 작성하기 위해선 해당 문제를 온전히 이해할 필요가 있었다. 내가 다른 사람들의 풀이를 보면서 이해하지 못해서 내 스스로 생각하고 이해한 걸 나름대로 녹여냈다. 다른 사람이 내 글을 보고 이 어려운 문제를 쉽게 이해할 수 있었으면 좋겠다.\r\n\r\n이해하고 봐도 다소 난해한데, 이걸 원리부터 코드까지 이끌어내어 풀어내는 사람은 정말 대단한 거 같다. 아님 내가 실력이 없는건가.\r\n\r\n## 참고\r\n\r\n* [The Casterian](https://casterian.net/archives/1356)\r\n* [굳건하게](https://travelbeeee.tistory.com/354)\r\n* [테스트 케이스](https://www.acmicpc.net/board/view/11381)","url":["2021-06-06-a1006","2021","06","06","a1006"]}],"categories":{"알고리즘":{"count":32,"flag":true},"잡담":{"count":2,"flag":true},"WEB":{"count":7,"flag":true},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"PLATINUM","page":1},"__N_SSG":true}