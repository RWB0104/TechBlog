{"pageProps":{"posts":[{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 의존성 역전 원칙 (Dependency Inversion Principle)","excerpt":"의존성 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다. 말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가? 고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, 객체는 객체보다 인터페이스에 의존해야한다로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-17T03:06:35","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-17-dependency-inversion-principle.md","content":"\r\n# 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n<span class=\"orange-400\">의존성 역전 원칙</span>이란 <span class=\"red-600\">객체는 저수준 모듈보다 고수준 모듈에 의존해야한다</span>는 원칙이다.\r\n\r\n말이 좀 어렵다. 고수준 모듈은 뭐고, 저수준 모듈은 또 뭐란 말인가?\r\n\r\n* <span class=\"primary\">고수준 모듈</span>: 인터페이스와 같은 객체의 형태나 추상적 개념\r\n* <span class=\"primary\">저수준 모듈</span>: 구현된 객체\r\n\r\n고/저수준 모델의 정의는 위와 같다. 위 정의를 의존성 역전 원칙에 대입하면, <span class=\"red-600\">객체는 객체보다 인터페이스에 의존해야한다</span>로 치환할 수 있다. 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.\r\n\r\n# 코드로 보는 의존성 역전 원칙\r\n\r\n예시를 통해 의존성 역전 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 의존성 역전 원칙을 준수하지 않은 코드\r\n\r\n어렸을 적 누구나 한 번씩 단풍에 대한 이야기를 다룬 게임을 해본적이 있을 것이다. 비록 이젠 죽어버렸지만 필자도 매우 좋아했었고, 성인이 된 후에도 방학시즌 이벤트만 되면 으레 복귀해서 게임을 즐기곤 했었다.\r\n\r\n그 게임은 RPG 장르로, RPG가 그렇듯 다양한 직업군과 그에 맞는 스킬/무기 시스템이 갖춰져있다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n수 많은 무기 가운데 하나인 한손검을 구현한 `OneHandSword` 객체가 있다. 캐릭터는 위와 같은 무기를 장비할 수 있을 것이다. 인스턴스 생성 시 무기의 이름과 데미지를 입력하여 생성한다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate OneHandSword weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic Character(String name, int health, OneHandSword weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [OneHandSword] 무기\r\n\t */\r\n\tpublic void chageWeapon(OneHandSword weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터를 구현한 `Character` 객체다. 게임 캐릭터가 취할 수 있는 기본적인 행동 일부가 구현되어있으며, 인스턴스 생성 시 캐릭터 이름, 체력, 무기를 입력하여 생성한다.\r\n\r\n하지만 다들 알다시피, 무기엔 한손검만 있는 게 아니다. 근접계열 무기만 하더라도 두손검, 단검, 창, 도끼, 둔기 등 다양한 종류가 존재할 수 있다. 그러나 이 `Character` 객체. 애초에 한손검 외엔 쓸 수가 없는 구조다. `Character`의 인스턴스 생성 시 `OneHandSword`에 의존성을 가지기 때문. \t공격 동작을 담당하는 `attack()` 메소드 역시 `OneHandSword`에 의존성을 가진다.\r\n\r\n이 상황에서 한손검을 제외한 다른 무기를 사용하려면 `Character`의 코드를 바꿔야한다. 즉, 이전에 다뤘던 [개방-폐쇄 원칙](/posts/2021/08/14/open-closed-principle)을 위배한다. 더 큰 문제는 무기가 바뀔 때마다 이 짓을 해줘야한다. \r\n\r\n## 의존성 역전 원칙을 준수한 코드\r\n\r\n만약 위 코드가 의존성 역전 원칙을 잘 지켰다면 고민할 필요가 없는 문제다. 위 코드의 <span class=\"red-400\">가장 큰 문제는 이미 완전하게 구현된 저수준 모듈을 의존하고 있다는 점</span>이다. 즉, 추상적인 고수준 모듈을 의존하도록 리팩토링해야한다.\r\n\r\n``` java\r\n/**\r\n * 공격 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 02:07:19\r\n */\r\npublic interface Attackable\r\n{\r\n\t/**\r\n\t * 공격 추상 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tint attack();\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 추상 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tString toString();\r\n}\r\n```\r\n\r\n우선 고수준 모듈인 `Weapon` 인터페이스를 생성한다. 공격 데미지를 반환하는 추상 함수 `attack()`과 무기 이름을 반환하는 추상 함수 `toString()`가 선언되어있다. 앞으로 모든 공격 가능한 무기 객체는 이 인터페이스를 상속받게 될 것이다.\r\n\r\n``` java\r\nimport java.util.Random;\r\n\r\n/**\r\n * 한손검 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 01:36:44\r\n */\r\npublic class OneHandSword implements Attackable\r\n{\r\n\tprivate final String NAME;\r\n\tprivate final int DAMAGE;\r\n\t\r\n\t/**\r\n\t * OneHandSword 생성자 함수\r\n\t *\r\n\t * @param name: [String] 무기 이름\r\n\t * @param damage: [int] 데미지\r\n\t */\r\n\tpublic OneHandSword(String name, int damage)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tDAMAGE = damage;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지 (데미지 +-5)\r\n\t */\r\n\t@Override\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn DAMAGE + new Random().nextInt(10) - 5;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 객체 문자열 반환 함수\r\n\t *\r\n\t * @return [String] 이름\r\n\t */\r\n\t@Override\r\n\tpublic String toString()\r\n\t{\r\n\t\treturn NAME;\r\n\t}\r\n}\r\n```\r\n\r\n`Attackable`를 상속받은 한손검 객체 `OneHandSword` 객체다. 상속받은 점 외에 크게 달라진 점은 없다.\r\n\r\n``` java\r\n/**\r\n * 캐릭터 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.17 Tue 00:46:15\r\n */\r\npublic class Character\r\n{\r\n\tprivate final String NAME;\r\n\tprivate int health;\r\n\tprivate Attackable weapon;\r\n\t\r\n\t/**\r\n\t * Character 생성자 함수\r\n\t *\r\n\t * @param name: [String] 이름\r\n\t * @param health: [int] 체력\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic Character(String name, int health, Attackable weapon)\r\n\t{\r\n\t\tNAME = name;\r\n\t\tthis.health = health;\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 공격 데미지 반환 함수\r\n\t *\r\n\t * @return [int] 공격 데미지\r\n\t */\r\n\tpublic int attack()\r\n\t{\r\n\t\treturn weapon.attack();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 피격 함수\r\n\t *\r\n\t * @param amount: [int] 피격 데미지\r\n\t */\r\n\tpublic void damaged(int amount)\r\n\t{\r\n\t\thealth -= amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무기 교체 함수\r\n\t *\r\n\t * @param weapon: [Attackable] 무기\r\n\t */\r\n\tpublic void chageWeapon(Attackable weapon)\r\n\t{\r\n\t\tthis.weapon = weapon;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 캐릭터 정보 출력 함수\r\n\t */\r\n\tpublic void getInfo()\r\n\t{\r\n\t\tSystem.out.println(\"이름: \" + NAME);\r\n\t\tSystem.out.println(\"체력: \" + health);\r\n\t\tSystem.out.println(\"무기: \" + weapon);\r\n\t}\r\n}\r\n```\r\n\r\n게임 캐릭터 `Character` 객체다. 기존의 `OneHandSword`를 파라미터에서 좀 더 고수준 모듈인 `Attackable`을 파라미터로 받는 걸 확인할 수 있다. 그 밖의 무기와 관련된 메소드 전부가 그렇다.\r\n\r\n하나의 객체였던 저수준 모듈에서 고수준 모듈로 의존성이 바뀌게 되니, `Attackable`을 상속하는 모든 객체를 다룰 수 있다. 게임 시스템 내부적으로 모든 공격 가능한 무기는 `Attackable`을 상속받기로 가정했으므로, 공격 가능한 모든 무기를 사용할 수 있는 셈이다.\r\n\r\n이러한 변경으로 무기의 변경에 따라 `Character`의 <span class=\"green-600\">코드를 변경할 필요가 없으므로, 개방-폐쇄 원칙 또한 준수</span>할 수 있다.\r\n\r\n# 정리\r\n\r\n의존성 역전 원칙은 코드의 확장성 및 재사용성을 추구하기 위한 원칙이다. 경직된 객체보다 구현되지 않아 유연한 인터페이스가 더욱 확장 가능성이 높을 것이다.\r\n\r\n다른 원칙에 비해 <span class=\"orange-400\">의존성 역전 원칙은 중요도가 좀 떨어지는데, 그 이유는 타 원칙의 하위호환 격이기 때문</span>이다. 당장 위에서도 언급했듯이, 의존성 역전 원칙은 개방-폐쇄 원칙을 준수할 경우 자연스레 준수하기이다. 뿐만 아니라 1객체 = 1책임인 단일 책임 원칙, 기능별 인터페이스화를 추구하는 인터페이스 분리 원칙을 준수할 경우 역시 마찬가지다.\r\n\r\n객체 생성 시 객체로 구현해야할 것과 인터페이스로 구현해야할 것을 적절히 구분하여 올바른 의존 관계를 가지도록 구현하자. 이왕이면 방금 언급한 원칙들을 준수하여 두 마리 토끼를 잡는 것도 매우 좋은 방법일 것이다.\r\n\r\n# 마치며\r\n\r\n이 장을 끝으로 객체지향에 대한 글을 마무리한다. 지금껏 JAVA라는 객체지향 언어를 사용하고 있었음에도, 정작 객체지향에 대해 너무 몰랐다는 것을 새삼 느낀다. 내가 얼마나 비객체지향적으로 코딩했는지도....\r\n\r\n객체지향에서의 가장 큰 특징이라면 바로 <span class=\"primary\">상속</span>일 것이다. 객체지향의 5원칙 중 대부분이 상속과 직/간접적으로 연관된 것만 봐도, 객체지향의 아이덴티티는 상속이라고 할 수 있을 것이다. 그 만큼 객체지향에서 상속은 중요하면서 동시에 이해하기 어려운 개념이다. 잘 쓰기는 더더욱 어렵다.\r\n\r\n물론 객체지향의 의의를 온전히 구현하고, 수립된 원칙들을 전부 지키는 것은 시니어급 개발자라도 매우 어려운 일일 것이다. 당장 나 같아도 \"이 많은 걸 다 지켜가며 설계하라고?\"라는 생각이 들고, 대부분의 개발은 구현 과정보단 동작 결과에 치중하기 때문이다.\r\n\r\n탄탄한 기획과 이에 동반되는 고민은 견고한 설계가 가능하지만, 언제까지나 시간을 낭비할 수 없는 노릇이다. 아무리 탄탄하게 설계 중인 프로젝트라도 개발 기간을 준수하지 못 하면 결과물은 물론, 이 결과물을 내기까지 했던 모든 고민들이 시간낭비로 치부되는 것을 뻔하다.\r\n\r\n이러한 원칙을 정해진 시간 내에 구현해야 하므로, 객체지향을 잘 다루기 위해선 많은 노력이 필요할 것이다.","url":["2021-08-17-dependency-inversion-principle","2021","08","17","dependency-inversion-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"인터페이스 분리 원칙이란 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙이다. 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다. 위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다. 왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, Method1을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다. 하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-16T19:24:57","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-16-interface-segregation-principle.md","content":"\r\n# 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n\r\n<span class=\"orange-400\">인터페이스 분리 원칙</span>이란 <span class=\"red-600\">객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다</span>는 원칙이다.\r\n\r\n구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다. 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/128585790-a761f795-b4da-4a52-865d-d2dd4b858f20.png)\r\n\r\n위 그림은 규모가 너무 큰 객체를 상속했을 때 발생하는 문제와, 이를 인터페이스로 분리하여 해결하는 방법을 도식한 것이다.\r\n\r\n왼쪽과 오른쪽 객체가 가운데 객체를 각각 상속할 경우, 왼쪽 객체는 필요한 메소드가 모두 구현되기 때문에 아무런 문제가 없다. 그러나 오른쪽 객체의 경우, `Method1`을 제외한 나머지 메소드는 필요가 없다. 하지만 이를 상속했기 때문에, 좋든 싫든 해당 메소드를 가지고 있거나, 최악의 경우 필요 없는 메소드를 구현까지 해야만한다.\r\n\r\n하지만 상속 대상인 객체의 메소드를 각 동작별로 구분해 인터페이스를 만들어보자. 각 객체가 필요한 인터페이스만을 상속하여 구현하면 되므로 각자가 필요한 메소드만을 가지게 된다. 이 것이 인터페이스 분리 원칙이 지향하는 바다.\r\n\r\n# 코드로 보는 인터페이스 분리 원칙\r\n\r\n예시를 통해 인터페이스 분리 원칙을 준수하지 않은 경우와 준수한 경우 어떠한 차이가 있는지 코드를 통해 알아보자.\r\n\r\n## 인터페이스 분리 원칙을 준수하지 않은 코드\r\n\r\n예를 들어, 스마트폰이라는 객체가 있다고 가정하자. 이 스마트폰 객체는 비교적 최신에 나온 덕분에 일반적인 스마트폰 기능 외에도 무선 충전, AR 뷰어, 생체인식 등의 다채로운 기능을 포함하고 있다.\r\n\r\n이를 가지고 S20을 구현하면 스마트폰 객체의 동작 모두가 필요하므로 ISP를 만족한다. 그러나 S2를 구현할 경우, 무선 충전, 생체인식과 같은 기능을 제공하지 않는다. 그럼에도 불구하고 부모 객체인 스마트폰에 이러한 인터페이스가 포함되어 있으므로, S2 입장에서는 필요하지도 않은 기능을 구현해야하는 낭비가 발생한다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\nabstract public class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선 충전\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tabstract public void biometrics();\r\n}\r\n```\r\n\r\n위와 같이 구현된 `SmartPhone` 객체가 있다. 생체인식을 담당하는 `biometrics()` 메소드의 경우, 기기에 등록된 생체정보를 활용해야 하므로 추상 메소드로 선언되어있다. 이 객체를 상속하여 `S20`과 `S2`를 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"S20 생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20`은 모든 기능이 필요하기 때문에, `SmartPhone`의 모든 메소드를 사용해야하므로, 불필요한 메소드가 없는 상태다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"지원 불가능한 기기\");\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 무선충전, AR, 생체인식이 지원되지 않는 기기다. 그럼에도 불구하고 `SmartPhone`의 상속으로 인해 해당 기능의 메소드를 강제로 상속받게 된다. 더군다나 `biometrics()`의 경우 추상 메소드이므로 필요하지도 않은 기능을 구현까지 해야한다. 이러한 상속의 특징은 부모 객체의 규모가 매우 클 경우, 개발 편의성의 극심한 저하로 이뤄진다. 필요하지도 않은 수십개의 메소드를 일일히 오버라이딩하여 적절한 처리를 해준다고 생각해보자.\r\n\r\n## 인터페이스 분리 원칙을 준수한 코드\r\n\r\n객체의 특성을 확장을 통해 다른 객체를 편하게 구현하기 위한 것이 상속인데, 위와 같은 상황은 전혀 편하지 않다. 이는 부모 객체의 설계가 잘 못 됐을 수도 있고, 취지에 맞지 않는 객체를 상속했을 수도 있다. 이유야 어찌됐든 해결해야한다는 사실엔 변함이 없다.\r\n\r\n그렇다면 이 현상은 어떻게 해결할 수 있을까? 객체의 메소드를 각각 인터페이스로 만들면 된다. 각 객체는 필요한 인스턴스만 상속하면 되므로 필요한 동작만을 상속/구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * 스마트폰 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 16:48:03\r\n */\r\npublic class SmartPhone\r\n{\r\n\t/**\r\n\t * 통화 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t */\r\n\tpublic void call(String number)\r\n\t{\r\n\t\tSystem.out.println(number + \" 통화 연결\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(number + \": \" + text);\r\n\t}\r\n}\r\n```\r\n\r\n`SmartPhone` 객체는 모든 스마트폰에 적용되는 보편적인 동작만을 가지도록 변경했다.\r\n\r\n``` java\r\n/**\r\n * 무선충전 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:23:33\r\n */\r\npublic interface WirelessChargable\r\n{\r\n\t/**\r\n\t * 무선충전 추상 함수\r\n\t */\r\n\tvoid wirelessCharge();\r\n}\r\n\r\n/**\r\n * AR 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:24:29\r\n */\r\npublic interface ARable\r\n{\r\n\t/**\r\n\t * AR 추상 함수\r\n\t */\r\n\tvoid ar();\r\n}\r\n\r\n/**\r\n * 생체인식 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 18:25:08\r\n */\r\npublic interface Biometricsable\r\n{\r\n\t/**\r\n\t * 생체인식 추상 함수\r\n\t */\r\n\tvoid biometrics();\r\n}\r\n```\r\n\r\n각 기능의 인터페이스는 위와 같다. 원래 `SmartPhone`의 객체의 메소드였던 각 기능은 인터페이스 단위로 나뉘어졌음에 주목하자.\r\n\r\n이를 통해 `S20`과 `S2` 모두 필요한 객체만을 상속받아 구현할 수 있을 것이다.\r\n\r\n``` java\r\n/**\r\n * S20 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:12:23\r\n */\r\npublic class S20 extends SmartPhone implements WirelessChargable, ARable, Biometricsable\r\n{\r\n\t/**\r\n\t * 무선충전 함수\r\n\t */\r\n\t@Override\r\n\tpublic void wirelessCharge()\r\n\t{\r\n\t\tSystem.out.println(\"무선충전 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * AR 함수\r\n\t */\r\n\t@Override\r\n\tpublic void ar()\r\n\t{\r\n\t\tSystem.out.println(\"AR 기능\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 생체인식 함수\r\n\t */\r\n\t@Override\r\n\tpublic void biometrics()\r\n\t{\r\n\t\tSystem.out.println(\"생체인식 기능\");\r\n\t}\r\n}\r\n```\r\n\r\n`S20` 객체의 코드다. `SmartPhone`을 상속받았으며, 인터페이스로 `WirelessChargable`, `ARable`, `Biometricsable`을 모두 상속받아 구현하고 있다.\r\n\r\n``` java\r\n/**\r\n * S2 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.16 Mon 17:13:27\r\n */\r\npublic class S2 extends SmartPhone\r\n{\r\n\t/**\r\n\t * 문자 메시지 전송 함수\r\n\t *\r\n\t * @param number: [String] 번호\r\n\t * @param text: [String] 내용\r\n\t */\r\n\t@Override\r\n\tpublic void message(String number, String text)\r\n\t{\r\n\t\tSystem.out.println(\"In S2\");\r\n\t\t\r\n\t\tsuper.message(number, text);\r\n\t}\r\n}\r\n```\r\n\r\n`S2`는 특수 기능이 구현되어있지 않으므로, 기본적인 `SmartPhone` 객체만을 상속받아 구현된다.\r\n\r\n인터페이스는 다중 상속을 지원하므로, 필요한 기능을 인터페이스로 나누면 해당 기능만을 상속받을 수 있다. 그 밖에 추후 업데이트 등을 통해 추가적인 기능이 탑재된다면, 같은 원리로 인터페이스를 설계해서 사용하면 필요한 객체에 필요한 기능을 쉽게 추가할 수 있다.\r\n\r\n# 정리\r\n\r\n인터페이스 분리 원칙은 객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙이다. 불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제가한다. 큰 규모의 객체는 필요에 따라 인터페이스로 잘게 나누어 확장성을 향상시킨다.\r\n\r\n객체를 상속할 땐 해당 객체가 상속 받는 객체에 적합한 객체인지, 의존적인 기능이 없는 지 판단하여 올바른 객체를 구현, 상속하도록 하자.","url":["2021-08-16-interface-segregation-principle","2021","08","16","interface-segregation-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 인터페이스 분리 원칙 (Interface Segregation Principle)","excerpt":"리스코프 치환 원칙은 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다. 객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다. 리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-15T13:42:11","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-15-liskov-subsitution-principle.md","content":"\r\n# 리스코프 치환 원칙 (Liskov Subsitution Principle)\r\n\r\n<span class=\"orange-400\">리스코프 치환 원칙</span>은 부모 객체와 이를 상속한 자식 객체가 있을 때 <span class=\"red-600\">부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다</span>는 원칙이다.\r\n\r\n객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다.\r\n\r\n리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.\r\n\r\n# 코드로 보는 리스코프 치환 원칙\r\n\r\n리스코프 치환 원칙을 설명할 때 많이 사용하는 예제로 직사각형과 정사각형의 관계가 있다.\r\n\r\n## 리스코프 치환 원칙을 위배한 코드\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\npublic class Rectangle\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n`Rectangle`은 직사각형을 구현한 객체다. 너비와 높이를 지정, 반환할 수 있으며, 지정된 값을 통해 자신의 넓이를 계산할 수 있다.\r\n\r\n정사각형 역시 넓게 보면 직사각형의 한 종류이니, <span class=\"red-400\">직사각형을 상속하여 정사각형 객체를 빠르게 만들 수 있을 것이라 생각했다.</span>\r\n\r\n``` java\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\npublic class Square extends Rectangle\r\n{\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\t@Override\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tsuper.setWidth(width);\r\n\t\tsuper.setHeight(getWidth());\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\t@Override\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tsuper.setHeight(height);\r\n\t\tsuper.setWidth(getHeight());\r\n\t}\r\n}\r\n```\r\n\r\n위 처럼 정사각형 객체 `Square`를 `Rectangle`의 상속을 통해 쉽게 구현할 수 있었다.\r\n\r\n정사각형의 경우 직사각형과 달리 너비와 높이가 같으니, 너비나 높이를 지정하면 그에 맞게 너비와 높이를 모두 일치시켜주도록 오버라이딩을 수행했다.\r\n\r\n구현한 `Rectangle`의 넓이를 구해보자.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Rectangle();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n```\r\n\r\n`Rectangle`의 넓이를 구하는 소스는 이와 같다. 너비가 10, 높이가 5로 할당됐으므로 넓이 50이 정상적으로 반환된다.\r\n\r\n리스코프 치환 원칙에 의하면, 자식 객체는 부모 객체를 완전히 대체할 수 있다고 했으므로, `Rectangle`을 상속받은 `Square`로 대체하여 넓이를 구해보자.\r\n\r\n`Square`가 `Rectangle`을 완전히 대체했다면 동일한 결과인 50이 반환되어야 한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tRectangle rectangle = new Square();\r\n\t\trectangle.setWidth(10);\r\n\t\trectangle.setHeight(5);\r\n\t\t\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n25\r\n```\r\n\r\n어째서인지 넓이는 50이 아닌 25로 반환됐다. 자세히 살펴보니, 마지막에 수행된 `setHeight(5)`가 객체의 너비/높이를 모두 5로 할당했다. 그러니 넓이도 당연히 25가 출력될 수밖에 없었던 걸로 보인다. 즉, 이 객체는 리스코프 치환 원칙에 위배되는 코드다.\r\n\r\n곰곰히 생각해보면, 직사각형과 정사각형은 상속관계가 전혀 될 수 없다. 사각형의 특징을 서로 갖고있긴 하지만, 두 사각형 모두 사각형의 한 종류일 뿐으로, 하나가 다른 하나를 완전히 포함하지 못 하는 구조다.\r\n\r\n이렇게 잘못된 객체를 상속하거나, 올바르게 확장하지 못 할 경우 겉으로 보기엔 정상적이지만 올바른 객체는 아니다.\r\n\r\n## 리스코프 치환 원칙을 준수한 코드\r\n\r\n그렇다면 이 코드를 어떻게 리스코프 치환 원칙에 부합하게끔 구성할 수 있을까?\r\n\r\n답은 올바른 상속과 구현에 있다. 앞서 설명했다시피, 직사각형과 정사각형은 상속의 관계가 성립되기 어렵다. 따라서 이보다 더 상위 개념인 사각형 객체를 구현하고 정사각형, 직사각형이 이를 상속받으면 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 사각형 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:39:02\r\n */\r\npublic class Shape\r\n{\r\n\tprotected int width;\r\n\tprotected int height;\r\n\t\r\n\t/**\r\n\t * 너비 반환 함수\r\n\t *\r\n\t * @return [int] 너비\r\n\t */\r\n\tpublic int getWidth()\r\n\t{\r\n\t\treturn width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 반환 함수\r\n\t *\r\n\t * @return [int] 높이\r\n\t */\r\n\tpublic int getHeight()\r\n\t{\r\n\t\treturn height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 너비 할당 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t */\r\n\tpublic void setWidth(int width)\r\n\t{\r\n\t\tthis.width = width;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 높이 할당 함수\r\n\t *\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic void setHeight(int height)\r\n\t{\r\n\t\tthis.height = height;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 넓이 반환 함수\r\n\t *\r\n\t * @return [int] 넓이\r\n\t */\r\n\tpublic int getArea()\r\n\t{\r\n\t\treturn width * height;\r\n\t}\r\n}\r\n```\r\n\r\n위와 같이 `Shape`라는 사각형 객체를 구현한다.\r\n\r\n``` java\r\n/**\r\n * 직사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:12:44\r\n */\r\nclass Rectangle extends Shape\r\n{\r\n\t/**\r\n\t * Rectangle 생성자 함수\r\n\t *\r\n\t * @param width: [int] 너비\r\n\t * @param height: [int] 높이\r\n\t */\r\n\tpublic Rectangle(int width, int height)\r\n\t{\r\n\t\tsetWidth(width);\r\n\t\tsetHeight(height);\r\n\t}\r\n}\r\n\r\n/**\r\n * 정사각형 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 11:19:07\r\n */\r\nclass Square extends Shape\r\n{\r\n\t/**\r\n\t * Square 생성자 함수\r\n\t *\r\n\t * @param length: [int] 길이\r\n\t */\r\n\tpublic Square(int length)\r\n\t{\r\n\t\tsetWidth(length);\r\n\t\tsetHeight(length);\r\n\t}\r\n}\r\n```\r\n\r\n`Shape`를 상속받는 두 사각형 `Rectangle`과 `Square` 객체는 위와 같다. `Rectangle`은 인스턴스 생성 시 `width`와 `height`를 파라미터로 받으며, `Square`는 각 변의 길이가 모두 동일하므로 `length` 하나만을 파라미터로 받는다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tShape rectangle = new Rectangle(10, 5);\r\n\t\tShape square = new Square(5);\r\n\r\n\t\tSystem.out.println(rectangle.getArea());\r\n\t\tSystem.out.println(square.getArea());\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\n50\r\n25\r\n```\r\n\r\n이제 더 이상 `Rectangle`과 `Square`가 상속 관계가 아니므로, 리스코프 치환 원칙의 영향에서 벗어났다.\r\n\r\n# 정리\r\n\r\n리스코프 치환 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체해도 아무런 문제가 없도록 권고한다. 위의 직사각형과 정사각형의 케이스처럼 올바르지 못한 상속관계는 제거하고, 부모 객체의 동작을 완벽하게 대체할 수 있는 관계만 상속하도록 코드를 설계해야한다.\r\n\r\n리스코프 치환 원칙을 지키기 위해선 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요하다.\r\n\r\n부모 객체의 오버라이딩은 주로 동일한 메소드를 자식 객체만의 동작을 추가하기 위해 한다는 걸 감안하면 매우 준수하기 까다로운 원칙.\r\n","url":["2021-08-15-liskov-subsitution-principle","2021","08","15","liskov-subsitution-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 개방-폐쇄 원칙 (Open-Closed Principle)","excerpt":"개방 폐쇄 원칙이란 객체를 다룸에 있어서 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미. 좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다. 만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다. 이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-14T04:04:40","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-14-open-closed-principle.md","content":"\r\n# 개방-폐쇄 원칙 (Open-Closed Principle)\r\n\r\n<span class=\"orange-400\">개방 폐쇄 원칙</span>이란 객체를 다룸에 있어서 <span class=\"red-600\">객체의 확장은 개방적으로, 객체의 수정은 폐쇄적</span>으로 대하는 원칙이다. 한 마디로, 보여줄 건 보여주고, 숨길 건 숨긴다는 의미.\r\n\r\n좀 더 쉽게 말하자면, 기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다는 뜻이다. 그런데 이 원칙, 말이 좀 이상하다. 기능이 변하는 거 OK. 확장되는 거 OK. 근데 코드를 수정하면 안 된다?? 다소 이해가 되지 않는 요구사항이다.\r\n\r\n만약, 객체 하나를 수정한다고 가정하자. 이 때 단순히 해당 객체만 수정하는 것 뿐만 아니라 해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계로 보기 힘들다. 대표적으로 라이브러리를 생각해보자. 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지 않는다.\r\n\r\n이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며, 이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.\r\n\r\n# 코드로 보는 개방-폐쇄 원칙\r\n\r\n<br />\r\n<p class=\"large grey-600\" align=\"center\"><i>If...</i></p>\r\n<br />\r\n\r\n저명한 IT업체에서 일하는 당신. 어느덧 정년을 바라보고 있다. 노후 대비를 위해 작은 편의점의 점주로 새로운 시작을 하는 당신. 예전부터 봐뒀던 곳에 적지 않은 비용을 지불하기까지 했다.\r\n\r\n다행히 안목이 틀리지 않았는지, 아침은 아침대로, 새벽은 새벽대로 끊임없는 유동인구 덕분에 생각했던 것 이상으로 수입이 들어오고 있다. 좀 더 일찍 시작했어도 됐으려나...\r\n\r\n여기저기 신경쓰다보니 초기 비용이 여의치 않아, POS기기는 저렴한 걸 선택했다. 영업사원이 사용 카드가 어쩌네 넌지시 얘기한 거 같은데, 그래봐야 POS가 거기서 거기겠지 뭐.\r\n\r\n<br />\r\n\r\n요즘 들어 매체에 신생 카드 업체에 대한 주제가 끊이질 않는다. 공격적인 혜택과 이전 카드에선 찾아볼 수 없었던 아기자기한 디자인이 그렇게 인기랜다. 이름이 초콜릿뱅크였나..? 혜택은 좋은데, 카드에 저런 디자인이 무슨 소용이람.\r\n\r\n<br />\r\n\r\n요즘들어 그 초코 뭐시긴가 하는 카드를 쓰는 사람이 많아졌다. 문제는 저 놈의 POS기가 새로운 카드는 전혀 인식을 못 한다. 이 문제 때문에 이번 주에만 반 이상이 넘는 고객을 돌려보냈다. 매출도 문제지만, 손님한테 아쉬운 소리하면서 사과하는 게 더 고역이다.\r\n\r\nPOS 업체에 전화해봤는데, 구조 상 그런거라며 계약 이전에 다 설명하고 서명받은 내용이란다. 난 그런 기억이 없는데....? 어쨌든 내게 남은 선택지라곤 지금 유지비용의 두 배 가까이 되는 신규 POS로 교체하던가, 위약금을 물고 새로운 POS 업체로 갈아타는 것 뿐이다. 이 문제 때문에 잠을 통 잘 수가 없다.\r\n\r\n<br />\r\n\r\n그래도 명색이 개발자인 당신. 어쩌면 내가 해결할 수도 있지 않을까? 수 십년 간의 경험을 토대로 기억을 되짚어가며 기기를 분석해보기 시작했다.\r\n\r\n``` java\r\n/**\r\n * 포스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:10:12\r\n */\r\npublic class Pos\r\n{\r\n\t/**\r\n\t * 결제 및 결과 반환 함수\r\n\t *\r\n\t * @param card : [Object] 카드 객체\r\n\t * @param name : [String] 카드사명\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 결제 결과\r\n\t */\r\n\tpublic boolean purchase(Object card, String name, int price)\r\n\t{\r\n\t\tboolean result;\r\n\t\t\r\n\t\tswitch (card.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\t\t\r\n\t\t\tdefault -> {\r\n\t\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n다행히 아직 감이 죽진 않았는지, 어렵지 않게 관련 모듈을 특정할 수 있었다. 카드 리더기에서 카드 인식 시 카드 정보가 담긴 객체를 `Object`로 캐스팅하여 전송한다. 정보 구분을 위해 카드사명까지 같이 전송하는 모양이다.\r\n\r\n딱 봐도 난감하기 그지없는 구조다. 실제로 초콜릿뱅크의 카드 정보는 리더기에서 잘 전달되고 있으나, `purchase` 메소드에서 초콜릿뱅크 카드를 구분하는 로직이 없어서 결제가 되지 않는다.\r\n\r\n``` java\r\npublic boolean purchase(String card, int price)\r\n{\r\n\tboolean result;\r\n\t\r\n\tswitch (card.toUpperCase())\r\n\t{\r\n\t\t// 신생 업체가 생길 때마다 해당 업체를 구분하는 로직을 추가한다.\r\n\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\tcase \"D\" -> result = ((CardD) card).send(price);\r\n\t\tcase \"E\" -> result = ((CardE) card).send(price);\r\n\t\tcase \"F\" -> result = ((CardF) card).send(price);\r\n\t\t\r\n\t\tdefault -> {\r\n\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\tresult = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n```\r\n그렇다면 `case` 구문에서 초콜릿뱅크를 구분하여 결제 정보를 전송하면 해결되지 않을까? 이 방식을 쓴다면 급한 불은 끌 수 있겠지만, 후에 또 다른 신생업체가 생기면 같은 문제가 반복될 게 뻔하다.\r\n\r\n이 방법은 매우 비효율적이다. 동작의 범위만 넓혔을 뿐, 근본적인 문제는 전혀 해결되지 않는다.\r\n\r\n당신은 이 코드를 좀 더 객체지향의 관점으로 접근하여 리팩토링을 실시한다.\r\n\r\n``` java\r\n/**\r\n * 결제 인터페이스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:28:22\r\n */\r\npublic interface Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\tboolean send(int price);\r\n}\r\n```\r\n\r\n공통된 형태로 로직을 수행하기 위해 `Purchasable` 인터페이스를 구현했다. 또한 리더기에서 전송하는 모든 카드 객체는 `Purchasable`를 상속받도록 강제했다.\r\n\r\n``` java\r\n/**\r\n * A 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:36:11\r\n */\r\nclass CardA implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * B 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:38:00\r\n */\r\nclass CardB implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * C 카드 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:39:51\r\n */\r\nclass CardC implements Purchasable\r\n{\r\n\t/**\r\n\t * 카드사 정보 전송 및 결과 반환 함수\r\n\t *\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 전송 결과\r\n\t */\r\n\t@Override\r\n\tpublic boolean send(int price)\r\n\t{\r\n\t\tSystem.out.println(getClass().getSimpleName() + \" \" + price + \"원 결제 요청\");\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n이제 리더기에서 전달하는 모든 카드 객체는 `Purchasable` 인터페이스를 상속받는다. 카드 객체를 부모 객체인 `Purchasable`로 다룰 수 있을 것이다. 각 카드 객체의 동작에 전송이 각각 구현되어있어, 타 객체의 코드에 의존하지 않는다.\r\n\r\n``` java\r\n/**\r\n * 포스 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.14 Sat 02:10:12\r\n */\r\npublic class Pos\r\n{\r\n\t/**\r\n\t * 결제 및 결과 반환 함수\r\n\t *\r\n\t * @param purchasable : [Purchasable] Purchasable 인터페이스\r\n\t * @param price: [int] 금액\r\n\t *\r\n\t * @return [boolean] 결제 결과\r\n\t */\r\n\tpublic boolean purchase(Purchasable purchasable, int price)\r\n\t{\r\n\t\treturn purchasable.send(price);\r\n\t}\r\n}\r\n```\r\n\r\n이제 결제 함수를 리팩토링 해보자. `CardA`, `CarB`, `CardC` 등 각각 개별적인 객체지만, 이제 `Purchasable`이라는 부모 객체가 있으므로 이를 묶을 수 있다. 우리는 리더기에서 주는 인터페이스 객체만 받아서 해당 객체의 `send`를 호출하면 된다.\r\n\r\n성공적으로 리팩토링을 마친 당신. 이제 어떤 카드든 결제가 가능하고 리더기가 정상적으로 인식만 한다면 결제를 진행할 수 있게됐다.\r\n\r\n당신이 한 각고의 노력과 빠른 대처로 인해 얼마 안 가 다시금 매출을 정상화시킬 수 있었다.\r\n\r\n# 정리\r\n\r\n리팩토링 전과 후를 비교해보자.\r\n\r\n``` java\r\npublic boolean purchase(Object card, String name, int price)\r\n{\r\n\tboolean result;\r\n\t\r\n\tswitch (card.toUpperCase())\r\n\t{\r\n\t\tcase \"A\" -> result = ((CardA) card).send(price);\r\n\t\tcase \"B\" -> result = ((CardB) card).send(price);\r\n\t\tcase \"C\" -> result = ((CardC) card).send(price);\r\n\t\t\r\n\t\tdefault -> {\r\n\t\t\tSystem.out.println(\"유효하지 않은 카드사\");\r\n\t\t\tresult = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n\r\npublic boolean purchase(Purchasable purchasable, int price)\r\n{\r\n\treturn purchasable.send(price);\r\n}\r\n```\r\n\r\n위는 이전 코드, 아래는 리팩토링한 코드다. <span class=\"amber-600\">기능이 변하거나 확장 가능하지만, 해당 기능의 코드는 수정하면 안 된다</span>는 의미를 여기에서 찾을 수 있다.\r\n\r\n리팩토링 이전 코드의 경우, 새로운 카드 인식. 즉, 기능 추가를 위해선 코드의 추가가 요구됐다. 다시 말해, <span class=\"red-600\">기능을 확장하기 위해선 코드의 수정이 필요</span>하다는 의미다.\r\n\r\n반대로 리팩토링 후의 코드를 보자. `Purchasable`라는 통합된 인터페이스를 사용하기 때문에 카드 추가에 따라 코드 단계에서 대응할 필요가 없다. 즉, <span class=\"red-600\">코드의 변경 없이 기능이 확장</span>된다.\r\n\r\n단일 책임 원칙과 마찬가지로, 비슷한 형태의 분기가 반복될 경우 개방-폐쇄 원칙을 준수하지 않았을 가능성이 높다. 이는 곧 높은 리팩토링 비용으로 직결되니, 이를 잘 준수하여 독립적인 모듈을 설계하자.","url":["2021-08-14-open-closed-principle","2021","08","14","open-closed-principle"]},{"header":{"title":"[OOP] 객체지향 5원칙(SOLID) - 단일 책임 원칙 (Single Responsibility Principle)","excerpt":"올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 객체지향 5원칙(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다. 이 다섯가지 원칙은 아래와 같다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-13T01:37:48","type":"posts","category":"CS","tag":["CS","객체지향","객체지향 5원칙"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-13-single-responsibility-principle.md","content":"\r\n# 객체지향 5원칙\r\n\r\n올바른 객체지향 설계를 위해 수립한 원칙이 있으며, 이 다섯 가지 원칙을 통틀어 <span class=\"amber-600\">객체지향 5원칙</span>(SOLID)이라 명명한다. 필수로 적용하지는 않지만, 적어도 이 규칙을 준수하면 준수할 수록 올바르게 설계된 객체지향이라 할 수 있다.\r\n\r\n이 다섯가지 원칙은 아래와 같다.\r\n\r\n1. 단일 책임 원칙 (Single Responsibility Principle)\r\n2. 개방-폐쇄 원칙 (Open-Closed Principle)\r\n3. 리스코프 치환 원칙 (Liskov Substitution Principle)\r\n4. 인터페이스 분리 원칙 (Interface Segregation Principle)\r\n5. 의존성 역전 원칙 (Dependency Inversion Principle)\r\n\r\n각 원칙의 영어 앞글자를 따 <span class=\"primary\">SOLID</span>원칙이라고도 한다.\r\n\r\n# 단일 책임 원칙 (Single Responsibility Principle)\r\n\r\n<span class=\"orange-400\">단일 책임 원칙</span>이란 <span class=\"orange-400\">하나의 객체는 반드시 하나의 동작만의 책임을 갖는다</span>는 원칙이다.\r\n\r\n모듈화가 강해질수록 다른 객체와의 의존/연관성이 줄어든다. 반대로 이야기하면 모듈화가 약해질수록 다른 객체와의 의존/연관성은 크게 늘어나며, 최악의 경우 어떠한 은닉화 정책도 존재하지 않아 모듈의 메소드에 무분별하게 접근할 수도 있게된다.\r\n\r\n객체가 담당하는 동작. 즉, 책임이 많아질 수록 해당 객체의 변경에 따른 영향도의 양과 범위가 매우 커진다. 단일 책임 원칙은 특정 객체의 책임 의존성 과중을 최대한 지양하기 위한 원칙이다.\r\n\r\n# 코드로 보는 단일 책임 원칙\r\n\r\n자동차는 휠의 구동 특성에 따라 전륜(FWD), 후륜(RWD), 사륜(AWD)로 나뉘며, 그 특성은 아래와 같다.\r\n\r\n* 전륜 구동인 경우 앞의 두 바퀴에만 동력을 전달한다.\r\n* 후륜 구동인 경우 뒤의 두 바퀴에만 동력을 전달한다.\r\n* 사륜 구동인 경우 전체 바퀴에 동력을 전달한다.\r\n\r\n이를 객체로 구현해보자.\r\n\r\n``` java\r\n/**\r\n * 자동차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\npublic class Car\r\n{\r\n\tprivate final String WD;\r\n\t\r\n\tprivate final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tswitch (WD.toUpperCase())\r\n\t\t{\r\n\t\t\tcase \"FWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"RWD\" -> {\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase \"AWD\" -> {\r\n\t\t\t\tWHEEL[0] = power;\r\n\t\t\t\tWHEEL[1] = power;\r\n\t\t\t\tWHEEL[3] = power;\r\n\t\t\t\tWHEEL[4] = power;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n여기 `Car` 객체가 있다. `Car`는 생성 시 파라미터로 <span class=\"orange-400\">휠 구동 방식</span>을 받는다.\r\n\r\n`Car`에는 주행 동작을 구현하는 `run()`메소드가 있으며, 이 메소드는 파라미터로 <span class=\"orange-400\">동력</span>을 받는다. 이후 휠 구동 방식에 따라 올바른 휠에 동력을 할당하고 휠의 상태를 출력한다.\r\n\r\n휠의 구동 방식 별 동작이 하나의 책임으로 본다면 이 객체가 짊어지는 책임은 무려 세 가지나 된다. 이렇게 하나의 객체에 너무 많은 책임이 몰려있을 경우, 프로젝트에서 해당 객체의 의존성이 높아지게된다. 이러한 현상은 객체지향의 주요 특징 중 하나인 캡슐화를 정면으로 부정한다. 그 뿐만 아니라, 각자의 코드가 서로 의존될 경우, 코드 수정에 따른 영향도 역시 높아지고, 범위 또한 넓어진다.\r\n\r\n위의 예시는 단일 책임 원칙을 설명하기 위한 단순한 예시로, 만약 코드의 규모가 크거나 복잡성이 심하다면 코드 수정 시 마다 오만가지 오류가 발생할 것이다. 그 뿐만 아니라 코드가 변경되는 과정에서 이미 정해진 코드의 리팩토링도 필요할 수 있다. 리팩토링이 리팩토링을 부르는 참사가 일어날 수도 있다. 여기서부터 코드가 지저분해지기 쉽다.\r\n\r\n단일 책임 원칙은 바로 이와 같은 상황을 방지하고자 수립된 원칙으로, <span class=\"red-400\">1객체 = 1책임</span>으로 최대한 객체를 간결하고 명확하게 설계할 것을 요구한다. 위 코드의 책임을 줄여 단일 책임 원칙을 지키려면 어떻게 해야할까?\r\n\r\n``` java\r\n/**\r\n * 자동차 추상 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 00:14:14\r\n */\r\nabstract public class Car\r\n{\r\n\tprotected final String WD;\r\n\t\r\n\tprotected final int[] WHEEL = { 0, 0, 0, 0 };\r\n\t\r\n\t/**\r\n\t * Car 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic Car(String wd)\r\n\t{\r\n\t\tWD = wd;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\tabstract public void run(int power);\r\n}\r\n```\r\n\r\n우선 공통된 인터페이스 내지는 상위 객체를 구현할 필요가 있다. 이 객체의 경우 생성자가 필요하므로 인터페이스 보단 상위 객체가 적합하다.\r\n\r\n> **네? 인터페이스 차별이요??**  \r\n> 인터페이스는 일반적인 객체 혹은 추상 객체와 달리 생성자를 강제할 수 없습니다.\r\n\r\n객체 `Car`를 상위 객체에 적용될 수 있게끔 구현한다. `run()` 메소드는 훨 구동 타입에 따라 동작이 달라지므로, `abstract` 지시자를 통해 추상 메소드로 선언한다. 해당 객체의 인스턴스를 생성하거나, 상속받는 객체가 직접 구현하게 될 것이다.\r\n\r\n``` java\r\n/**\r\n * 전륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:03:13\r\n */\r\nclass FrontWheelCar extends Car\r\n{\r\n\t/**\r\n\t * FrontWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic FrontWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 후륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\nclass RearWheelCar extends Car\r\n{\r\n\t/**\r\n\t * RearWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic RearWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n\r\n/**\r\n * 사륜차 객체\r\n *\r\n * @author RWB\r\n * @since 2021.08.13 Fri 01:05:57\r\n */\r\npublic class AllWheelCar extends Car\r\n{\r\n\t/**\r\n\t * AllWheelCar 생성자 함수\r\n\t *\r\n\t * @param wd: [String] 휠 구동 방식\r\n\t */\r\n\tpublic AllWheelCar(String wd)\r\n\t{\r\n\t\tsuper(wd);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 주행 함수\r\n\t *\r\n\t * @param power: [int] 동력\r\n\t */\r\n\t@Override\r\n\tpublic void run(int power)\r\n\t{\r\n\t\tWHEEL[0] = power;\r\n\t\tWHEEL[1] = power;\r\n\t\tWHEEL[2] = power;\r\n\t\tWHEEL[3] = power;\r\n\t\t\r\n\t\tSystem.out.println(\"휠 동력 상태: \" + WHEEL[0] + \", \" + WHEEL[1] + \", \" + WHEEL[2] + \", \" + WHEEL[3]);\r\n\t}\r\n}\r\n```\r\n\r\n전륜, 후륜, 사륜에 해당하는 객체를 생성한다. 이 세 객체는 모두 `Car`에 포함되므로 `Car`를 상속받아 구현한다. 각 객체의 `run()` 메소드에 동작을 구현함으로써, 각각의 객체가 하나의 책임을 가지게 된다.\r\n\r\n이렇게 객체별로 책임을 나누면, 코드 변경 시에도 해당하는 객체만 수정하면 되므로, 의존성이 낮아져 올바른 모듈화를 구현할 수 있다. 그 뿐만 아니라 코드가 간결해져 유지보수가 쉬워질 뿐만 아니라 수정에 따른 영향도도 매우 작아진다.\r\n\r\n# 정리\r\n\r\n코드를 설계하다보면 하나의 객체가 너무 많은 동작을 담당하는 경우가 자주 발생한다. 필자 또한 무의식적으로 하나의 객체/메소드에 너무 많은 책임을 할당하는 일이 비일비재했다. 단일 책임 원칙은 이러한 개발 방향을 올바르게 잡아준다.\r\n\r\n가급적 단일 책임 원칙을 고수하여 올바른 객체를 구현할 수 있도록 해보자.","url":["2021-08-13-single-responsibility-principle","2021","08","13","single-responsibility-principle"]}],"categories":{"알고리즘":{"count":32,"flag":true},"잡담":{"count":2,"flag":true},"WEB":{"count":7,"flag":true},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"객체지향 5원칙","page":1},"__N_SSG":true}