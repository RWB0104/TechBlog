{"pageProps":{"posts":[{"header":{"title":"[라즈베리파이 4] Let's Ecrypt로 Ubuntu 서버에 HTTPS 통신 제공하기","excerpt":"이전 장에서 Google Domains를 통해 dev 도메인을 발급받았다. 이 블로그의 주소는 실제로 구입한 https://blog.itcode.dev 도메인이 적용되어있다. dev 도메인은 강화된 보안정책이 적용되어있다. 해당 도메인으로의 모든 HTTP 통신은 반드시 HTTPS 보안 통신으로만 제공된다. 네트워크 계층에서 https 프로토콜로 라우팅하므로 좋든 싫든 HTTPS 서비스를 제공해야만 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-09-06T16:50:40","type":"posts","category":"RaspberryPi","tag":["라즈베리파이","Ubuntu","Tomcat(톰캣)","SSL"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-09-06-raspberry-ssl-domain.md","content":"\r\n# 개요\r\n\r\n이전 장에서 Google Domains를 통해 `dev` 도메인을 발급받았다. 이 블로그의 주소는 실제로 구입한 https://blog.itcode.dev 도메인이 적용되어있다.\r\n\r\n`dev` 도메인은 강화된 보안정책이 적용되어있다. 해당 도메인으로의 모든 HTTP 통신은 반드시 HTTPS 보안 통신으로만 제공된다. 네트워크 계층에서 https 프로토콜로 라우팅하므로 좋든 싫든 HTTPS 서비스를 제공해야만 한다.\r\n\r\n<br />\r\n\r\n이 장에서는 Let's Encrypt로 SSL 인증서를 발급받아 라즈베이파이서버의 Tomcat에 적용한다. 기존의 1:1 도메인 매칭 SSL이 아니라, 여러 서브도메인에 전부 대응 가능한 와일드카드 인증서를 받을 것이다.\r\n\r\n> <b class=\"teal-600\">와일드카드(Wildcard) 인증서?</b>  \r\n> 프로그래밍에서의 <span class=\"primary\">와일드카드</span>란 무작위 대상의 허용이란 의미를 가진다. 도메인과 1:1 매칭되는 기존의 인증서와 달리, 와일드카드 인증서는 주체가 `*.example.com`로 표기되며, 모든 서브도메인에 적용이 가능하다.\r\n\r\n# Cerbot으로 SSL 인증서 발급하기\r\n\r\nUbuntu 서버에서 SSL 인증서를 발급받아보자. 일반적인 SSL 인증서는 인증 과정에서 웹 서버에 특정 파일을 배포한 뒤, 인증 서버에서 해당 파일의 접근 및 유효성 검증을 통해 도메인의 소유권을 확인한다.  \r\n하지만 와일드카드 인증서는 여러 서브도메인에 전부 적용되는 특별한 인증서라 위의 인증방식을 사용하지 않는다. 위의 인증방식은 하나의 도메인의 소유권만 보증하기 때문. <span class=\"orange-600\">와일드카드 인증서는 DNS 레코드를 통해 소유권을 인증</span>한다. DNS 레코드는 도메인의 소유권자만 설정 가능하기 때문.\r\n\r\n만약, 어떠한 이유로든 도메인의 DNS 설정을 변경할 수 없다면 와일드카드 인증서를 발급받을 수 없다.\r\n\r\n## 어? 전 윈도우로 하고싶은데....\r\n\r\nDNS 레코드 인증으로 진행하기 때문에 Tomcat에 파일을 배포할 필요가 없어서 아무데서나 진행해도 상관 없다.\r\n\r\nWindows 환경에서 인증서를 발급받는 방법은 이전에 작성한 게시물 [[SSL] Windows 10에서 Let's Encrypt로 SSL 인증서 무료 발급받기](/posts/2021/08/19/lets-encrypt)을 참고하길 바란다.\r\n\r\n## 준비물\r\n\r\n* Ubuntu OS\r\n* DNS Record 설정 권한\r\n\r\n필자는 Google Domains에서 도메인을 구입했으므로, Google Domains에서 DNS 설정을 관리할 수 있다. 만약, 가비아나 후이즈, 도레지 등 다른 도메인 사이트에서 도메인을 구매했다면 그 사이트에서 DNS 설정을 할 수 있으니 참고할 것.\r\n\r\n이 장에서는 Google Domains를 기준으로 진행한다.\r\n\r\n## 1. Certbot 설치하기\r\n\r\nUbuntu에서 Certbot을 설치한다.\r\n\r\n``` bash\r\nsudo apt-get install certbot\r\n```\r\n\r\n## 2. Certbot으로 인증 수행하기\r\n\r\nCertbot을 수행하여 인증서 발급을 수행한다.\r\n\r\n<p class=\"red-500\" align=\"center\">※ 아래의 itcode.dev 도메인은 예시로, 실제로 입력 시엔 직접 사용할 자신의 도메인을 입력한다.</p>\r\n\r\n``` bash\r\nsudo certbot certonly --manual --preferred-challenges dns --email psj2716@gmail.com -d *.itcode.dev\r\n```\r\n\r\n* `--manual` - 수동 설정\r\n* `--preferred-challenges` - 인증방식 지정\r\n* `--email` 소유주 이메일\r\n* `-d` - 도메인 지정\r\n\r\n위 명령어를 사용하면 별다른 명령어 입력 없이 즉시 인증을 수행할 수 있다. `-d`의 인자값으로 구입한 도메인을 입력하되, 서브도메인을 `*`로 지정함을 잊지말자.\r\n\r\n``` output\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\nPlease read the Terms of Service at\r\nhttps://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must\r\nagree in order to register with the ACME server at\r\nhttps://acme-v02.api.letsencrypt.org/directory\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n(A)gree/(C)ancel:\r\n```\r\n\r\n<span class=\"pink-600\">서비스 이용 약관에 동의</span>해달라는 의미로, A를 입력하여 동의한다. 동의하지 않으면 SSL 발급을 진행할 수 없다.\r\n\r\n``` output\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\nWould you be willing to share your email address with the Electronic Frontier\r\nFoundation, a founding partner of the Let's Encrypt project and the non-profit\r\norganization that develops Certbot? We'd like to send you email about our work\r\nencrypting the web, EFF news, campaigns, and ways to support digital freedom.\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n(Y)es/(N)o:\r\n```\r\n\r\nCertbot 개발기관에서 웹 암호화, EFF 뉴스, 이벤트 등의 <span class=\"pink-600\">정보를 소유주의 이메일로 발송</span>하는데 동의하냐는 질문이다.\r\n\r\n좋으면 Y, 싫으면 N을 입력하자. <span class=\"red-400\">동의하지 않아도 SSL 발급엔 지장없다.</span>\r\n\r\n``` output\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\nNOTE: The IP of this machine will be publicly logged as having requested this\r\ncertificate. If you're running certbot in manual mode on a machine that is not\r\nyour server, please ensure you're okay with that.\r\n\r\nAre you OK with your IP being logged?\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n(Y)es/(N)o:\r\n```\r\n\r\n<span class=\"pink-600\">IP 수집에 동의</span>하냐는 질문으로, Y를 입력하여 동의한다. 동의하지 않으면 SSL 발급을 진행할 수 없다.\r\n\r\n``` output\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\nPlease deploy a DNS TXT record under the name\r\n_acme-challenge.itcode.dev with the following value:\r\n\r\n1sz-pJgM-3jL7mZacyByOO0S2lclAF0QmxtqujRuRHM\r\n\r\nBefore continuing, verify the record is deployed.\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\nPress Enter to Continue\r\n```\r\n\r\ncertbot에서 서브도메인명 `_acme-challenge`과 랜덤한 문자열을 제공한다. 제시한 도메인 `_acme-challenge.itcode.dev`의 DNS TXT Record에 제공한 값 `O3WQbIWv73aOzneZBu_4XAoE9ieZT1ZLdvbX7UPCkyk`을 할당하면 된다.\r\n\r\n도메인은 사용자가 입력한 값에 따라 달라지니 참고할 것.\r\n\r\n## 3. DNS TXT Record 설정\r\n\r\nDNS Record 종류엔 A, CNAME 등 여러 종류가 존재한다. 이 중 TXT 레코드에 값을 할당하면 된다.\r\n\r\nGoogle Domains의 DNS 설정에서 Record 하나를 추가하고, 타입을 TXT로 설정한다. 이후 certbot에서 제시한 값을 입력한다. 설정한 DNS 정보가 전파되기까지 수 분의 시간이 걸릴 수 있다. Google Domains의 경우 전파속도는 빠른 것 같다.\r\n\r\n``` bash\r\nnslookup -q=txt _acme-challenge.itcode.dev\r\n```\r\n\r\nTXT Record이므로 브라우저에서 해당 도메인에 접근해도 별다른 내용이 출력되지 않는다. `nslookup` 명령어를 통해 Record의 종류를 지정하여 조회해야한다.\r\n\r\n``` output\r\nServer:         127.0.0.53\r\nAddress:        127.0.0.53#53\r\n\r\nNon-authoritative answer:\r\n_acme-challenge.itcode.dev      text = \"1sz-pJgM-3jL7mZacyByOO0S2lclAF0QmxtqujRuRHM\"\r\n\r\nAuthoritative answers can be found from:\r\n```\r\n\r\n위 처럼 해당 도메인의 TXT Record에 입력한 문자열이 나오면 DNS 설정이 전파된 것으로, 인증을 진행할 수 있다. 만약, 값이 나오지 않는다면 시간을 두고 기다리자.\r\n\r\nEnter를 누르면 인증확인을 시도하는데, DNS 레코드 설정이 완료될 때까지 절대로 진행하지 말자.\r\n\r\n### 주의점\r\n\r\nDNS TXT Record가 미처 전파되지 않았음에도 불구하고 한국인 특성이 발동하여 certbot에 Enter를 눌러 인증확인 단계로 넘어가는 경우가 왕왕 발생한다.\r\n\r\n만약, TXT Record가 확인되지 않는다면, 관련 메시지와 함께 인증과정을 다시 시작한다. 문제는 이 때 <span class=\"red-600\">TXT Record에 등록할 문자열을 새로 갱신</span>한다. 즉, DNS TXT Record을 갱신된 값으로 재지정해야한다.\r\n\r\nDNS 전파가 느리다면 대기시간이 많이 늘어나버리니 주의할 것. 반드시 `nslookup` 명령어를 통해 DNS 적용 여부를 확인하자.\r\n\r\n## 4. 인증 확인 요청\r\n\r\nDNS TXT Record가 정상적으로 전파됐다면, 콘솔에서 Enter를 눌러 다음 단계로 넘어간다. certbot이 인증확인을 시도하며, 인증이 완료되면 <span class=\"blue-600\">인증서를 발급</span>해준다.\r\n\r\n``` bash\r\n# itcode.dev는 인증한 도메인 이름\r\ncd /etc/letsencrypt/live/itcode.dev\r\n```\r\n\r\n기본적으로 위 경로에 인증서가 생성된다. 마지막 폴더 `itcode.dev`는 도메인 이름이니, 각자가 입력한 도메인으로 변경하여 입력한다.\r\n\r\n* `cert.pem` - 도메인의 인증서\r\n* `chain.pem` - 발급기관의 인증서\r\n* `fullchain.pem` - 도메인과 발급기관의 통합 인증서\r\n* `privkey.pem` - 인증서의 개인키\r\n\r\nSSL은 도메인의 인증서 뿐만 아니라, 이를 발급해준 CA의 인증서까지 같이 검증한다. 도메인의 인증이 올바르더라도, 이를 발급해준 기관이 이상할 경우 해당 인증서 또한 믿을 수 없기 때문. 일종의 보증서라고 봐도 무방하다.\r\n\r\n일례로, 한국의 화폐 만원권이 만원의 가치를 가질 수 있는 이유는 한국은행이 이를 보증하기 때문. 반대로 핫한 가상화폐의 경우, 가상화폐의 가치를 보증해주는 기관이 없다. 때문에 가치가 수시로 변동하며, 언제든 그 가치와 기능을 잃을 수 있다.\r\n\r\n> <b class=\"teal-600\">fullchain.pem</b>의 존재의미  \r\n> 어차피 `cert.pem`과 `chain.pem`이 제공되는데, 둘의 통합인증서가 무슨 의미가 있냐고 생각할 수 있다. `fullchain.pem`은 두 인증서를 통합함으로써, `cert.pem`과 `chain.pem`의 매칭여부를 확인할 수 있다.\r\n\r\n# Tomcat에 SSL 인증서 적용하기\r\n\r\nTomcat Native 설치여부에 따라 적용방법이 조금씩 달라진다. SSL 인증서는 기본적으로 `pem` 확장자로 제공된다.\r\n\r\nTomcat Native는 `pem` 확장자 인증서를 바로 인식할 수 있지만, 일반적인 Tomcat은 `pem`을 인식할 수 없어 `jks` 등 다른 형태의 인증서로 변환해야한다.\r\n\r\n## Tomcat Native 설치\r\n\r\n``` bash\r\nsudo apt-get install libtcnative-1\r\n```\r\n\r\nUbuntu에선 위 라이브러리 설치를 통해 Tomcat Native를 적용할 수 있다.\r\n\r\n## Tomcat의 server.xml에 인증서 적용하기\r\n\r\n[[SSL] Tomcat에 SSL 적용하기](/posts/2021/08/20/apply-ssl#SSL-인증서%20적용하기) 게시글에서 자세한 내용을 확인할 수 있다.\r\n\r\n위 게시글의 방법대로 인증서를 적용하고 Tomcat을 재기동한 뒤 `https://itcode.dev`와 같이 HTTPS 프로토콜을 사용하여 접속을 시도하자. 반드시 접속 전에 HTTPS의 서비스 포트를 확인하자. Tomcat의 기본 HTTPS 포트는 8443이다.\r\n\r\nHTTPS 접속이 정상적이라면 성공이다. 인증서 정보 또한 확인할 수 있다.\r\n\r\n# 목표\r\n\r\n* <del class=\"grey-400\">라즈베리파이에 Ubuntu 서버를 구축한다.</del>\r\n* <del class=\"grey-400\">Tomcat을 구동하여 페이지를 호스팅한다.</del>\r\n* <del class=\"grey-400\">도메인을 입힌다.</del>\r\n* <del class=\"grey-400\">SSL 인증서를 발급하여 HTTPS 통신을 제공한다.</del>\r\n* SSH, RDP 등의 원격 통신환경을 구축한다.\r\n* MariaDB를 설치하여 DB 통신을 수행한다.","url":["2021-09-06-raspberry-ssl-domain","2021","09","06","raspberry-ssl-domain"]},{"header":{"title":"[SSL] Tomcat에 SSL 적용하기","excerpt":"SSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다. 이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.","coverImage":"https://user-images.githubusercontent.com/50317129/129755999-c5d6c474-d5c0-442a-b7c5-37b3cdf703a9.png","date":"2021-08-20T00:35:21","type":"posts","category":"WEB","tag":["CS","객체지향","SSL","Tomcat(톰캣)"],"group":"SSL","comment":true,"publish":true},"name":"2021-08-20-apply-ssl.md","content":"\r\n# 개요\r\n\r\nSSL 인증서를 받았으니, 이를 적용해보자. 보통 Nginx 같은 웹서버나, Tomcat과 같은 WAS에 적용한다.\r\n\r\n이 장에서는 Tomcat 9.0.50을 기준으로 설명한다.\r\n\r\n# Tomcat에 인증서 적용하기\r\n\r\nTomcat에 인증서를 적용한다. Tomcat Native가 설치되어있는지, 없는지에 따라 방법이 다르다.\r\n\r\n> <b class=\"orange-400\">Tomcat Native</b>  \r\n> Tomcat의 성능 향상을 위해 C, JAVA 같은 네이티브 모듈이 추가된다. Windows의 경우 dll 파일 하나만 옮기면 된다.\r\n\r\nTomcat Native가 적용되어 있다면 `pem` 파일을 바로 적용할 수 있으며, 아니라면 `pem`을 `jks`와 같은 호환 가능한 확장자로 적절히 변경해야한다.\r\n\r\n# Tomcat Native 설치방법\r\n\r\nOS에 따라 Tomcat Native를 설치하는 방법이 다르다. Tomcat Native를 설치하지 않고도 SSL을 적용할 수 있으니, 관심이 없다면 이 단계를 패스해도 무방하다.\r\n\r\n## Windows 10\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 Tomcat Native 라이브러리를 다운로드 받는다. 중간에 [Native 1.2.30 Windows Binaries.zip]을 다운로드 받으면 된다.\r\n\r\n압축 풀면 [bin] 폴더에 `tcnative-1.dll` 파일이 있을텐데, 해당 DLL을 `TOMCAT_HOME_HOME/bin`에 옮기는 것으로 설치가 끝난다.\r\n\r\n## Linux(CentOS 7 이상)\r\n\r\n``` bash\r\nyum -y install tomcat-native\r\n```\r\n\r\nCentOS 7을 기준으로 위 명령어를 입력하면 된다. 만약 위와 같은 명령어를 사용할 수 없다면 직접 [이 링크](https://tomcat.apache.org/download-native.cgi)에서 컴파일해서 적용해야한다.\r\n\r\n## Linux(컴파일)\r\n\r\n직접 소스를 컴파일해서 사용한다. <span class=\"pink-400\">CentOS</span>를 기준으로 설명한다.\r\n\r\n``` bash\r\nyum install apr-devel openssl-devel\r\n```\r\n\r\n혹은 <span class=\"pink-400\">Devian</span> 계열일 경우\r\n\r\n``` bash\r\napt-get install libapr1.0-dev libssl-dev\r\n```\r\n\r\n컴파일 이전에 위 도구들이 설치되어있어야 한다.\r\n\r\n[이 링크](https://tomcat.apache.org/download-native.cgi)에서 [Native 1.2.30 Source Release tar.gz]를 다운로드 받아 압축을 푼다.\r\n\r\n``` bash\r\ntar -zxvf Native 1.2.30 Source Release tar.gz\r\n```\r\n\r\n압축은 위 명령어로 해제하면 되며, OS에 따라 명령어가 다를 수 있다.\r\n\r\n``` bash\r\ncd ${압축 해제 경로}\r\n./configure --with-apr=/usr --prefix=${현재경로} --with-java-home=${JAVA_HOME}\r\nmake\r\nmake install\r\n```\r\n\r\n위 명령어를 순차적으로 입력해주면 된다.\r\n\r\n# SSL 인증서 적용하기\r\n\r\nSSL 인증서를 적용하자. <span class=\"orange-400\">Tomcat Native</span> 적용 여부에 따라 방법이 다르다.\r\n\r\n## Tomcat Native로 PEM 파일 적용하기\r\n\r\n`TOMCAT_HOME/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tSSLCertificateFile=\"example.com-crt.pem\"\r\n\tSSLCertificateKeyFile=\"example.com-key.pem\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n위와 같이 수정해주면 된다. `SSLCertificateFile`에 `crt.pem` 파일을, `SSLCertificateKeyFile`에 `key.pem` 파일 경로를 지정한다.\r\n\r\n## 일반 Tomcat에 PEM to JKS로 변환하여 적용하기\r\n\r\n어떠한 이유로든 Tomcat Native를 설치하지 못 할 경우, <span class=\"red-400\">일반 Tomcat은 PEM 파일을 인식할 수가 없다.</span> 따라서 Tomcat이 지원하는 포맷으로 변환하여 사용해야한다. 이 문서에선 `.jks` 파일으로 변환하여 적용한다.\r\n\r\n준비물은 아래와 같다.\r\n\r\n* OpenSSL\r\n* keytool (JAVA 깔면 있음)\r\n\r\n[OpenSSL](https://www.openssl.org/source/)은 직접 설치해야하고, <span class=\"orange-400\">keytool</span>은 `JAVA_HOME/bin`에 있으므로 JAVA가 있다면 따로 설치하지 않아도 된다.\r\n\r\n``` batch\r\n# pem to p12\r\nopenssl pkcs12 -export -out {name}.p12 -in {crt}.pem -inkey {key}.pem\r\n\r\n# p12 to jks\r\nkeytool -importkeystore -srckeystore {name}.p12 -srcstoretype pkcs12 -destkeystore {name}.jks -deststoretype jks\r\n```\r\n\r\n위 명령어를 순서대로 입력하면 된다. <span class=\"red-400\">변환 과정에서 인증서에 저장할 비밀번호를 요구한다. 추후 웹서버에 해당 비밀번호를 제공</span>해야하니, 잘 기억해두자.\r\n\r\n4개였던 `.pem`파일과 달리 `.jks`는 심플하게 하나만 생성된다. 생성이 완료되면 `TOMCAT_HOME/conf/server.xml` 파일을 열어보자.\r\n\r\n``` xml\r\n<Connector protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\r\n\tport=\"443\"\r\n\tscheme=\"https\"\r\n\tsecure=\"true\"\r\n\tSSLEnabled=\"true\"\r\n\tkeystoreFile=\"example.com.jks\"\r\n\tkeystorePass=\"비밀번호\"\r\n\tsslProtocol=\"TLS\" />\r\n```\r\n\r\n`keystoreFile`에 생성한 `.jks` 파일을, `keystorePass`에 변환 과정에서 입력한 비밀번호를 입력한다.\r\n\r\n# 확인\r\n\r\n본 문서에선 SSL 포트를 `443`으로 설정했다. SSL의 기본 포트는 443이므로, 별도의 포트 표시를 하지 않아도 자동으로 연결될 것이다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/130097706-8a3cc174-e35d-46db-9f60-caa585a59d98.png)\r\n\r\n이제 톰캣을 기동하여, 도메인에 접속해보자. 인증서 정보가 확인되면 성공이다.\r\n\r\n참고로, 인증서는 도메인을 기준으로 동작한다. 만약 `localhost` 내지는 `127.0.0.1`, IP를 입력하여 들어오면 인증서 오류가 뜨니 참고할 것.\r\n\r\n# 정리\r\n\r\n이로써 SSL 적용이 완료됐다. 처음엔 뭔가 복잡해보여도, 한 번 해두면 크게 어려운 부분은 없다.\r\n\r\nLet's Encrypt는 DV 인증서를 무료로 받을 수 있는 가장 쉽고 빠른 방법이므로, SSL이 필요하다면 적극적으로 활용해보자.","url":["2021-08-20-apply-ssl","2021","08","20","apply-ssl"]},{"header":{"title":"Unsupported major.minor version 에러 해결하기 (+Servlet 404 에러)","excerpt":"간혹 JAVA 프로그램을 실행하다보면 Unsupported major.minor version 52(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다. Unsupported major.minor version 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.","coverImage":"https://user-images.githubusercontent.com/50317129/120079117-78b76880-c0ed-11eb-944d-c0d020228db3.png","date":"2021-05-30T02:16:35","type":"posts","category":"JAVA","tag":["JAVA","WAS","Tomcat(톰캣)","오류 해결책"],"comment":true,"publish":true},"name":"2021-05-30-unsupported-version-error.md","content":"\r\n# Unsupported major.minor version\r\n\r\n간혹 JAVA 프로그램을 실행하다보면 <span class=\"error\">Unsupported major.minor version 52</span>(숫자는 class 버전에 따라 다름) 오류가 출력되면서 정상적으로 동작하지 않는 오류가 발생한다.  \r\n<span class=\"error\">Unsupported major.minor version</span> 오류는 직역하면 \"지원하지 않는 주/부 버전\"이다. JAVA 버전관련 오류라고 보면 된다.\r\n\r\n# 원인\r\n\r\nJAVA는 컴파일 언어로, 개발자가 작성한 코드는 `.java` 파일이다. 이를 컴파일하면 JVM(Java Virtual Machine, 자바 가상머신)이 읽을 수 있는 `.class` 파일로 번역한다. 코딩은 사람이 이해할 수 있는 언어로 작성하고, 실제 동작은 컴파일을 통해 컴퓨터가 이해할 수 있는 언어를 사용하는 셈이다.  \r\nJAVA는 작성일 기준으로 16까지 릴리즈됐다. JAVA의 역사가 짧지 않고, 이 시간동안 크고작은 버전 업데이트가 지속적으로 이루어졌다.  \r\n문제는 이 과정에서 생긴 호환성 문제다. 1.5 버전으로 컴파일한 `.class` 파일을 1.8 버전의 환경에서 구동한다거나, 그 반대의 경우가 그 예시다. 다행스럽게도, JAVA는 하위 버전에 대한 호환성을 보장한다. 1.8 버전의 환경에서는 1.8 이하로 컴파일된 `.class` 파일의 실행을 보장한다. 하지만 반대로 상위 버전에 대한 호환성은 제공하지 않는다. 그도 그럴 것이, 호환성을 지키기 위해선, 각 버전 간의 구성을 알맞게 변환해야 하는데, 아직 개발되지 않은 미래 버전의 구성을 알 순 없는 노릇이니...\r\n\r\n| 프로그램 JAVA 버전 | PC JAVA 버전 | Unsupported 오류 발생여부 |              해결책              |\r\n| :----------------: | :----------: | :-----------------------: | :------------------------------: |\r\n|         14         |     1.8      |             O             | JAVA 14 버전 이상으로 업그레이드 |\r\n|        1.6         |     1.7      |             X             |              칼퇴근              |\r\n\r\n즉, <span class=\"green-A400\">Unsupported major.minor version 오류는 내가 실행하려는 JAVA 코드가 내 PC의 JAVA 환경보다 높은 버전에서 컴파일된 경우 발생</span>한다.\r\n\r\n# 해결\r\n\r\n결과적으로, JAVA 버전을 동등 혹은 그 이상의 상위버전으로 업그레이드하면 된다. 크게 두 가지 방법이 있다.\r\n\r\n## 프로그램 코드의 버전 다운그레이드\r\n\r\n만약 본인이 온전한 프로그램 코드를 갖고 있을 경우, 시도해볼 수 있는 방법이다.  \r\n<span class=\"green-A400\">JAVA 버전을 다운그레이드하고 컴파일을 진행</span>하면, 프로그램의 JAVA 버전이 낮아져 기존의 버전보다 훨씬 낮은 버전의 환경에서 구동이 가능하다.\r\n\r\n단, 조건이 있다. JAVA 버전이 업그레이드됨에 따라 여러 신규 패턴, 문법 등이 추가됐다. 만약 <span class=\"red-A400\">1.8 버전부터 새로 생긴 기능을 적극적으로 활용했다면, 1.7 이하의 버전에선 컴파일 오류가 발생</span>한다.  \r\n그도 그럴것이, 1.8 부터 생긴 기능은 1.7에서는 구현되지 않은 기능이기 때문.\r\n\r\n이 경우 프로그램의 코드를 좀더 범용적인 방식으로 리팩토링해야한다.\r\n\r\n## PC의 버전 업그레이드\r\n\r\n만약 본인이 `.class` 파일만 갖고있다거나, 상기한 문제로 다운그레이드가 어려울 경우 혹은 간단한 방법을 찾을 경우 시도해볼 수 있는 방법이다.\r\n<span class=\"green-A400\">PC의 JAVA 버전을 업그레이드하고 프로그램을 실행</span>하면 된다.\r\n\r\nJAVA는 하위 호환성을 지키기 때문에, 별다른 조건이 존재하지 않는다.\r\n\r\n# 아니 버전 맞췄다고 아ㅋㅋ\r\n\r\n톰캣을 사용하다보면, 이 오류가 뜨는 경우가 있다. 그런데 간혹 PC에 설치된 JAVA 버전에 맞게 컴파일을 해줬음에도 오류가 사라지지 않는 현상이 발생하기도 한다.  \r\n이 경우 동반되는 증상이, Servlet Context에 접근할 경우, 첫 접속시 500 에러(Unsupported major.minor version 오류로 인해 발생)가 발생하고, 이후부터는 404 에러만 발생한다. 이러한 현상을 겪어보지 않았거나, 경험이 적은 개발자가 이러한 문제에 부딪히면 십중팔구 고생한다. 원인인 Unsupported major.minor version 오류가 보이지 않아 Servlet 동작의 404 오류와 관련된 정보를 검색하거나 질문하기 때문. 당연히 이러한 사정을 모르는 다른 사람들은 404 오류에 관한 답변을 줄 수 밖에 없다. 이런 경우 정말 난감하기 그지없다. 절대 경험담이라서가 아니다.\r\n\r\n혹시 위 처럼 정상적인 Servlet(서블릿)임에도 불구하고 404 오류가 뜰 경우 아래의 환경변수에서 JRE_HOME이 설정돼있는지 확인해보자.  \r\n간혹 개발 프로그램 중 임의로 JRE_HOME을 설정해버리는 프로그램이 존재한다. 문제는 여기서 발생하는데, JAVA_HOME과 JRE_HOME 환경변수가 둘 다 설정되어있을 경우, <span class=\"red-A400\">톰캣은 JRE_HOME을 우선</span>한다. 즉 JRE의 버전이 적용된다.\r\n\r\n예를 들어, JAVA_HOME이 1.8 버전, JRE_HOME이 1.6 버전이라 가정하자. 컴파일은 반드시 JDK가 필요하므로 JAVA_HOME의 버전인 1.8로 컴파일이 수행된다. 그러나 톰캣 실행 시, JRE_HOME을 우선하는 특징으로 인해 1.6 버전으로 실행된다. 결과적으로 **1.8 버전으로 컴파일된 코드를 1.6으로 실행하는 셈**이니, 버전이 맞지 않아 오류가 발생한다.","url":["2021-05-30-unsupported-version-error","2021","05","30","unsupported-version-error"]},{"header":{"title":"Tomcat(톰캣) 현재 콘솔창에서 구동하기","excerpt":"오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-26T16:32:16","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-26-tomcat-current-window.md","content":"\r\n# 왜 자꾸 꺼지는거야!\r\n\r\n오늘도 어느때와 다름없이 톰캣을 구동하는 A씨. 어제까지만 해도 잘 되던 톰캣이 무슨 오류가 있는지 구동 중에 바로 꺼져버린다. 꺼지기 직전의 순간 무슨 오류가 뜬 거 같은데..... 너무 빨라서 도통 확인할 수가 없다. 할 수 없이 일일이 로그를 찾아보며 오류를 수정하는 A씨. 건드린 것도 없는데, 왜 이러는 걸까?\r\n\r\n# 왜?\r\n\r\n톰캣이 콘솔 형태로 실행되는 것은 맞지만, 실행되는 프로세스를 보면 살짝 다르다. `startup.bat`을 실행하면 cmd창이 뜬 뒤 꺼지면서 곧바로 Tomcat 창이 표시된다. <span class=\"primary\">톰캣을 구동하면 항상 새로운 창이 뜨기 때문에, 톰캣이 오류로 인해 동작이 중지되면 창이 곧바로 닫히게 된다.</span>\r\n\r\n# 해결책?\r\n\r\n그렇다고 해결책이 없는 건 아니고, `startup.bat`의 간단한 수정을 통해 톰캣이 <span class=\"primary\">현재 창에서 동작</span>하도록 수정할 수 있다. \r\n\r\n`startup.bat`을 메모장으로 열면, 맨 아래에 `call \"%EXECUTABLE%\" run %CMD_LINE_ARGS%` 구문이 존재한다. 여기서 가운데 `run`을 `start`로 변경한다.\r\n\r\n즉 `call \"%EXECUTABLE%\" start %CMD_LINE_ARGS%`로 구문을 변경하고 저장하면 된다.\r\n\r\n이후 `startup.bat`을 클릭하여 실행하지 말고, `cmd`창 하나를 킨 다음에, 해당 콘솔에서 `startup.bat`을 호출하면 새 창이 뜨지 않고 호출한 콘솔에서 톰캣이 구동된다.  \r\n톰캣이 종료돼도 콘솔창이 꺼지지 않으므로, 편하게 메시지를 확인할 수 있다.","url":["2021-05-26-tomcat-current-window","2021","05","26","tomcat-current-window"]},{"header":{"title":"Tomcat(톰캣) 콘솔창 한글 인코딩 깨짐 현상 해결하기","excerpt":"톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상. Windows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.","coverImage":"https://user-images.githubusercontent.com/50317129/119212068-1b218b80-baf1-11eb-9a42-85945bceb7d9.png","date":"2021-05-22T12:52:51","type":"posts","category":"WAS","tag":["WAS","Tomcat(톰캣)","Console(콘솔)"],"comment":true,"publish":true},"name":"2021-05-22-tomcat-encoding-euckr.md","content":"\r\n# 와장창!\r\n\r\n![Encoding Broken](https://user-images.githubusercontent.com/50317129/119212087-342a3c80-baf1-11eb-89bc-06829a5f7c16.png)\r\n\r\n톰캣을 구동하다보면 심심치않게 마주하는 오류(?)는 아니고 현상.  \r\nWindows Console의 기본 인코딩과 Tomcat이 출력하는 인코딩이 서로 달라서 생긴다.\r\n\r\n# 도대체 왜?\r\n\r\n실력 좋은 개발자가 아니더라도, 컴퓨터와 친분이 있다면 언어가 깨짐은 곧 인코딩의 불일치라는 걸 개괄적으로 이해하고 있다. 이러한 현상이 일어나는 이유는 아래와 같은데,\r\n\r\n* <span class=\"primary\">Windows Console</span>: Windows OS 설정 언어의 기본 인코딩 (한국어는 **EUC-KR**)\r\n* <span class=\"primary\">Tomcat Console</span>: 설정파일의 인코딩 (**기본 UTF-8**)\r\n\r\n이 처럼, 기본 인코딩이 서로 다르다.\r\n\r\n# 해결책\r\n\r\n이를 해결하는 방법은 크게 두 가지가 존재한다. 개인적으로 <span class=\"red-300\">두 번째 방법을 추천</span>한다.\r\n\r\n### Windows Console 인코딩 변경하기\r\n\r\n첫 번째로, Windows Console의 인코딩을 변경한다. Windows 10 기준으로 OS의 기본 콘솔은 <span class=\"green-500\">cmd</span>와 <span class=\"green-500\">PowerShell</span> 두 가지다. **사용할 콘솔의 기본 인코딩을 EUC-KR에서 UTF-8로 변경**해주면 된다.\r\n\r\n애석하게도, 두 콘솔 모두 인코딩을 변경하는 옵션을 제공하지 않는다. 그렇다고 방법이 없는 건 아니고, 레지스트리 수정을 통해 문제를 해결할 수 있다.\r\n\r\n<br />\r\n\r\n1. 작업표시줄에서 `regedit`을 입력하여 <span class=\"blue-500\">레지스트리 편집기</span>를 띄운다.\r\n2. `HKEY_CURRENT_USER\\Console` 경로에 접근한다. 사용자 계정에 설치된 콘솔들이 출력된다. (cmd, PowerShell, Git 등)\r\n\r\n![Registry](https://user-images.githubusercontent.com/50317129/119212160-83706d00-baf1-11eb-92c8-b41458950f20.png)\r\n\r\n3. 인코딩을 변경하려는 콘솔의 폴더를 클릭한다.\r\n   * **%SystemRoot%_system32_cmd.exe**: cmd\r\n   * **%SystemRoot%_System32_WindowsPowerShell_v1.0_powershell.exe**: 32비트 PowerShell\r\n   * **%SystemRoot%_SysWOW64_WindowsPowerShell_v1.0_powershell.exe**: 64비트 PowerShell\r\n4. `CodePage` 키를 더블클릭하여 편집을 수행한다.\r\n   `CodePage`가 없을 경우, 오른쪽 마우스 버튼을 클릭하여 새 DWORD(32비트) 키를 동일한 이름으로 생성한다.\r\n5. 값 데이터를 10진수 `65001`로 변경한다.\r\n\r\n![Registry](https://user-images.githubusercontent.com/50317129/119212198-ab5fd080-baf1-11eb-981b-82599148c8f8.png)\r\n\r\n6. 앞으로 실행되는 Windows Console은 해당 인코딩이 적용된다.\r\n\r\n이렇게 하면 Windows Console과 Tomcat의 기본 인코딩이 UTF-8로 서로 일치하므로, 한글이 정상적으로 출력된다.  \r\n하지만 이 방법은 Windows Console의 인코딩을 바꾸므로, 차후 해당 <span class=\"red-500\">콘솔을 통해 다른 작업이나 프로그램이 실행될 경우 엉뚱한 프로그램의 한글이 깨질 우려</span>가 있다.  \r\n(대부분은 OS 언어의 기본 인코딩을 따라가도록 설계함)\r\n\r\nWindows Console은 범용적으로 사용되는 프로그램이므로, 다른 작업에 영향을 줄 수 있다. 내가 이 방법을 굳이 추천하지 않는 이유이기도 하다.  \r\n\r\n### Tomcat Console 인코딩 변경하기\r\n\r\n두 번째로, Tomcat Console의 인코딩을 변경한다. 첫 번째 방법보다 이 방법이 나은 이유는, Tomcat이라는 제한적인 용도의 콘솔에만 영향을 미치기 때문. 어차피 Tomcat Console의 인코딩이 불일치해서 생기는 문제이므로, 이쪽을 바꾸는게 상식적으로도 맞다.\r\n\r\n대부분 마찬가지로 위 방법처럼 레지스트리를 수정하라고 안내할텐데, Tomcat은 굳이 그렇게 바꿔줄 필요 없다.\r\n\r\n1. `%TOMCAT_HOME%\\conf\\logging.properties`을 연다.\r\n2. **java.util.logging.ConsoleHandler.encoding**의 값을 **EUC-KR**로 변경한다.\r\n   별다른 설정이 없었다면, UTF-8이 기본으로 설정되어 있다.\r\n3. 앞으로 실행되는 Tomcat은 해당 인코딩이 적용된다.\r\n\r\nTomcat을 실행하면 한글이 정상적으로 출력된다.","url":["2021-05-22-tomcat-encoding-euckr","2021","05","22","tomcat-encoding-euckr"]}],"categories":{"All":{"count":70,"flag":true},"Ubuntu":{"count":2,"flag":true},"RaspberryPi":{"count":7,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"Tomcat(톰캣)","page":1,"hash":"c75a1fd9f41"},"__N_SSG":true}