{"pageProps":{"posts":[{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1019번 책 페이지","excerpt":"지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1페이지이고, 마지막 페이지는 N페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-28T12:28:50","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-28-a1019.md","content":"\r\n# 책 페이지\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/15.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1019번 문제](https://www.acmicpc.net/problem/1019)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 전체 페이지의 수가 $N$인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 $N$페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$이 주어진다. $N$은 $1,000,000,000$보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 4 1 1 1 1 1 1 1 1\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 명확하고 직관적이다. 1페이지부터 $N$페이지까지 나열할 때, <span class=\"green-400\">숫자가 사용된 수를 각 숫자별로 나타내는 문제</span>.\r\n\r\n165라는 숫자를 표기하기 위해선 $[ 1, 5, 6 ]$이 사용된다. 이렇게 <span class=\"green-400\">1부터 해당 숫자까지의 모든 숫자를 표현하기 위해 사용한 숫자의 수를 0부터 오름차순으로 출력</span>하면 된다. \r\n\r\n즉, $N = 5$라고 가정하면, 페이지 배열은 $[ 1, 2, 3, 4, 5 ]$까지 나열된다. 각 숫자가 사용된 수를 표로 나타내면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n1부터 5까지 나열하는데, 각각 숫자 하나씩 사용했으니 위 처럼 표시할 수 있다. 그렇다면 예제의 11은 어떨까?\r\n\r\n$[ 1, 2, 3, \\dots, 10, 11 ]$까지 나열된다. \r\n\r\n1부터 9까지는 각각 숫자가 하나씩 사용되며, 10은 1과 0이 사용되고, 11은 1이 두 개 사용된다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n위의 표만큼 숫자가 사용됐다. 이해를 위해 $N = 13$일 경우를 하나 더 해보자.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n$12 = [ 1, 2 ]$, $13 = [ 1, 3 ]$이 된다. 1 ~ 13에는 11도 포함되기 때문에, 11의 결과에 12, 13의 값을 각각 더해줘도 상관없다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n이 정도면 알고리즘이 원하는 게 무엇인지 이해했으리라 생각한다.\r\n\r\n## 🔎규칙 찾아보기\r\n\r\n사실 무식하게 접근하면, 그리 어려운 문제는 아니다. 하나하나 반복문 돌려가며 숫자 분해해서 해당하는 숫자의 배열에 집어넣으면 그만이니. 하지만 안타깝게도, 변수 $N$의 최대값은 10억 ~~(다행히 int의 최대값은 넘지 않는다.)~~ 에 육박한다. 그 말인즉는 무식하게 접근하면 안 된다는 의미.\r\n\r\n그렇다면 어딘가에 존재하는 규칙성을 발견해서 일반식을 설계해야한다는 뜻인데, 이럴땐 하나하나 나열해보면 알 수 있을 것이다.\r\n\r\n|   N   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   0   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   2   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   3   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   4   |   0   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |\r\n|   5   |   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   6   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |\r\n|   7   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |\r\n|   8   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |\r\n|   9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  10   |   1   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  11   |   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  12   |   1   |   5   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  13   |   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  14   |   1   |   7   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |\r\n|  15   |   1   |   8   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |\r\n|  16   |   1   |   9   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |\r\n|  17   |   1   |  10   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |\r\n|  18   |   1   |  11   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |\r\n|  19   |   1   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  20   |   2   |  12   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  21   |   2   |  13   |   4   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  22   |   2   |  13   |   6   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  23   |   2   |  13   |   7   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n\r\n규칙성을 찾아보기 위해 20 받고 살짝 더 얹어서 사용된 숫자를 나열해보았다. 어떤 패턴이 보이는 것 같긴 하다.\r\n\r\n1. 0은 10의 배수마다 1씩 증가한다.\r\n2. 각 1의 자리마다 해당하는 숫자가 1씩 증가하며, 값은 10의 자릿수 + 1이다.\r\n3. 10의 자릿수는 해당하는 숫자를 1씩 증가시킨다.\r\n\r\n그냥 쳐다보면 규칙성을 찾기 좀 어려울 수 있다. 해답은 <span class=\"red-400\">*0 ~ *9</span> 구간에 있다. 예를 들어, 10 ~ 29까지 나열해보자. 1부터 시작하는 것이 아니라, 임의의 구간 $A ~ B$를 기준으로 알고리즘을 계산한다고 가정하는 것이다.\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>10</td>\r\n\t\t\t\t<td>11</td>\r\n\t\t\t\t<td>12</td>\r\n\t\t\t\t<td>13</td>\r\n\t\t\t\t<td>14</td>\r\n\t\t\t\t<td>15</td>\r\n\t\t\t\t<td>16</td>\r\n\t\t\t\t<td>17</td>\r\n\t\t\t\t<td>18</td>\r\n\t\t\t\t<td>19</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>20</td>\r\n\t\t\t\t<td>21</td>\r\n\t\t\t\t<td>22</td>\r\n\t\t\t\t<td>23</td>\r\n\t\t\t\t<td>24</td>\r\n\t\t\t\t<td>25</td>\r\n\t\t\t\t<td>26</td>\r\n\t\t\t\t<td>27</td>\r\n\t\t\t\t<td>28</td>\r\n\t\t\t\t<td>29</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n위 표의 숫자들을 잘 보면, 1의 자리 숫자는 각각 하나씩 사용하는 것을 확인할 수 있다.\r\n\r\n## 1의 자리에서의 규칙\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>1<span class=\"red-A400\">0</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">1</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">2</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">3</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">4</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">5</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">6</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">7</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">8</span></td>\r\n\t\t\t\t<td>1<span class=\"red-A400\">9</span></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>2<span class=\"red-A400\">0</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">1</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">2</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">3</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">4</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">5</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">6</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">7</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">8</span></td>\r\n\t\t\t\t<td>2<span class=\"red-A400\">9</span></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n이제 좀 규칙성이 눈에 띄기 시작한다. 20 ~ 39와 같은 <span class=\"red-400\">*0 ~ *9</span> 형태의 범위에선 1의 자리에 해당하는 모든 숫자가 동일하게 사용된다. 10 ~ 19, 20 ~ 29 두 구간이 있으므로 각 구간별로 1씩 모든 숫자가 두 번 사용됐다.\r\n\r\n시작 페이지를 $n$, 마지막 페이지를 $N$이라고 가정할 때, 위 규칙을 일반식으로 표현하면 아래와 같다.\r\n\r\n$$\r\n(N \\div 10) - (n \\div 10) + 1 = \\text{1의 자리에 사용된 각각의 숫자 갯수}\r\n$$\r\n\r\n따라서 10 ~ 29 범위에서 모든 숫자는 두 번 사용된 것임을 알 수 있다.\r\n\r\n## p의 자리에서의 규칙\r\n\r\n문제는 위 식은 <span class=\"orange-400\">1의 자리에서만 적용되는 수식</span>이다. 페이지는 최대 10의 자리까지 존재할 수 있다. 즉, 통용되는 일반식을 구해야한다.\r\n\r\n<div class=\"table-wrapper\">\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th colspan=\"10\">숫자 현황</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>0</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>1</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>2</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>3</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>4</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>5</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>6</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>7</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>8</td>\r\n\t\t\t\t<td><span class=\"red-A400\">1</span>9</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>0</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>1</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>2</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>3</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>4</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>5</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>6</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>7</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>8</td>\r\n\t\t\t\t<td><span class=\"red-A400\">2</span>9</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n\r\n반대로 10의 자리수를 자세히 보자. 1이 10번 사용된다. 만약 100 ~ 199 구간이라면 1은 100개가 사용될 것이고, 1000 ~ 1999 구간이라면 1은 1000개가 사용될 것이다.\r\n\r\n쉽게 설명하기 위해 10 ~ 19, 100 ~ 199, 1000 ~ 1999 등 $n0* ~ n9*$ 같은 형태의 구간을 단위 구간이라고 정의하자. 이 때, 해당 구간에서 $n$이 사용되는 갯수는 아래와 같이 정의할 수 있다.\r\n\r\n$$\r\n((N \\div 10) - (n \\div 10) + 1) \\times \\text{p} = \\text{각각의 숫자 갯수}\r\n$$\r\n\r\n* $n$: 구간 시작 값\r\n* $N$: 구간 끝 값\r\n* $p$: 자릿수\r\n\r\n## 구간 보정하기\r\n\r\n이제 구간만 맞으면 호출되는 숫자를 구할 수는 있지만, 아직 제한적이다.\r\n\r\n우선, 본 알고리즘에서 시작 값은 1로 고정이다. 끝 값인 $N$ 역시 반드시 199와 같은 단위 구간의 형태로 들어오지도 않는다. 만약 $N = 35$라면 우리는 1 ~ 35 구간에 알고리즘을 적용해야 한다. 구간이 10 ~ 39라면 모를까, 형태가 전혀 다른 구간에는 위 일반식이 적용되지 않는다.\r\n\r\n해결 방법은 간단하다. 가늠좌 클리크 조정하듯이 구간에 맞게 값을 더하고 빼서 조정해주면 된다.\r\n\r\n1 ~ 35 구간에서, 1의 경우, 1보다 크며 0을 포함한 수 중 가장 가까운 값은 10이다. 따라서, 시작 값은 10까지 증가시키며, 증가시킨 숫자를 카운팅한다. 1부터 9까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n35의 경우 35보다 작으며 9를 포함한 수 중 가장 가까운 수는 29다. 마찬가지로 마지막 값은 29까지 감소시키며, 감소한 숫자를 카운팅한다. 35부터 30까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n즉, 초기값은 위 보정값을 더한 배열이며, 이후 계산은 계산된 초기값에 누적한다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| **1** | **2** | **2** | **8** | **2** | **2** | **1** | **1** | **1** | **1** |\r\n\r\n## 자릿수 보정하기\r\n\r\n$N = 1999$, $n = 1000$일 때, 1의 자리에 사용된 숫자의 갯수를 구하면 아래와 같다.\r\n\r\n$$\r\n((1999 / 10) - (1000 / 10) + 1) \\times 1 = 100\r\n$$\r\n\r\n1의 자리에서 각 숫자는 100개씩 사용됐다. 10의 자리에서는 어떨까?\r\n\r\n$N$, $n$을 각각 10으로 나누면 10의 자리에 대한 구간을 얻을 수 있다. 나눠진 숫자를 위의 일반식에 적용하면 된다.\r\n\r\n$$\r\n((199 / 10) - (100 / 10) + 1) \\times 10 = 100\r\n$$\r\n\r\n100의 자리는 $N$, $n$을 각각 100으로 나누어 계산하면 된다.\r\n\r\n$$\r\n((19 / 10) - (10 / 10) + 1) \\times 100 = 100\r\n$$\r\n\r\n1000의 자리는 $N$, $n$을 각각 1000으로 나누어 계산하면 된다. 그러나 $N = n = 1$이므로, 1에만 1000개가 사용된다.\r\n\r\n|  $p$  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  10   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n| 1000  |   0   | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|       |  300  | 1300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n따라서 1000 ~ 1999 구간은 위와 같이 계산된다.\r\n\r\n## 📃일반식 적용하기\r\n\r\n완벽한 이해를 위해, 위 개념을 토대로 $N = 4153$일 경우의 알고리즘을 계산해보자.\r\n\r\n$N = 4153$이므로, 구간은 1 ~ 4153이다.\r\n\r\n### 시작 페이지 구간 보정하기\r\n\r\n1보다 큰 수 중 1의 자리가 0인 가장 가까운 수 10까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n1부터 9까지 이동하여 10에 도착하므로, 1 ~ 9를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n### 마지막 페이지 구간 보정하기\r\n\r\n4153보다 작은 수 중 1의 자리가 9인 가장 가까운 수 4149까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n4153부터 4150까지 이동하여 4149까지 도착하므로, 이를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 4153  |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4152  |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4151  |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4150  |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n### 1의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 4149을 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((4149 / 10) - (10 / 10) + 1) \\times 1 = 414 - 1 + 1 = 414\r\n$$\r\n\r\n|   구분   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1의 자리 |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n\r\n### 10의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 1의 자리 일반식 구간 4149, 10을 각각 10으로 나눈다.\r\n\r\n10의 자리에 대한 구간은 $1 ~ 414$가 된다. 마찬가지로 일반식 적용을 위해 구간을 보정한다. 10의 자리이므로, <span class=\"red-400\">1 -> 2로의 이동은 실제로 10 -> 20으로의 이동임에 주의</span>하자.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  414  |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|  413  |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  412  |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  411  |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  410  |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 10의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 409를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((409 / 10) - (10 / 10) + 1) \\times 10 = (40 - 1 + 1) \\times 10 = 400\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n\r\n### 100의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 10의 자리 일반식 구간 409, 10을 각각 10으로 나눈다.\r\n\r\n100의 자리에 대한 구간은 $1 ~ 40$이 된다. 나머지는 10의 자리 프로세스와 동일하다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  40   |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 100의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 39를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((39 / 10) - (10 / 10) + 1) \\times 100 = (3 - 1 + 1) \\times 100 = 300\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n### 1000의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 100의 자리 일반식 구간 39, 10을 각각 10으로 나눈다.\r\n\r\n1000의 자리에 대한 구간은 $1 ~ 3$이 된다.\r\n\r\n여기서 문제가 하나 있는데, 마지막 구간에서 일의 자리가 9인 가장 작은 수는 -9다. 음수가 올 수 없으므로, 더 이상의 일반식 연산은 불가능하며, 개별적으로 더해주면 된다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 3 |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 총합 계산하기\r\n\r\n단계별로 구한 숫자를 정리하여 총합을 표로 나타낸다.\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1 ~ 9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   4153    |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4152    |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4151    |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4150    |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 1의 자리  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n|   1 ~ 9   |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n|    414    |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|    413    |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    412    |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    411    |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    410    |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n|   1 ~ 9   |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|    40     |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n|   1 ~ 3   |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   총합    | 1225  | 2290  | 2236  | 2236  | 1389  | 1229  | 1225  | 1225  | 1225  | 1225  |\r\n\r\n구간 1 ~ 4153에 대한 알고리즘 결과는 위와 같다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 백준 전체 1019 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/28/a1019\">1019 풀이</a>\r\n * @since 2021.06.28 Mon 12:28:50\r\n */\r\npublic class Main\r\n{\r\n\t// 숫자 카운트 배열\r\n\tprivate static final int[] COUNTER = new int[10];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 마지막 페이지\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tsolve(N);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int item : COUNTER)\r\n\t\t{\r\n\t\t\tbuilder.append(item).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(builder.toString().trim());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\treader.close();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 동작 함수\r\n\t *\r\n\t * @param num: [int] 마지막 페이지\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\t// 시작 페이지\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 자릿수\r\n\t\tint digit = 1;\r\n\t\t\r\n\t\twhile (start <= num)\r\n\t\t{\r\n\t\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\t\tcount(num, digit);\r\n\t\t\t\t\r\n\t\t\t\tnum--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\t\tif (num < start)\r\n\t\t\t{\r\n\t\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t\t{\r\n\t\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\t\tcount(start, digit);\r\n\t\t\t\t\r\n\t\t\t\tstart++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstart /= 10;\r\n\t\t\tnum /= 10;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 10; i++)\r\n\t\t\t{\r\n\t\t\t\tCOUNTER[i] += (num - start + 1) * digit;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 자릿수 증가\r\n\t\t\tdigit *= 10;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 카운트 함수\r\n\t *\r\n\t * @param num: [int] 대상 숫자\r\n\t * @param digit: [int] 자릿수\r\n\t */\r\n\tprivate static void count(int num, int digit)\r\n\t{\r\n\t\twhile (num > 0)\r\n\t\t{\r\n\t\t\tCOUNTER[num % 10] += digit;\r\n\t\t\tnum /= 10;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$N = 4153$일 때, 구간을 보정하는 과정에서 4153, 4152와 같은 수를 별도로 카운팅해야한다.\r\n\r\n``` java\r\n/**\r\n * 카운트 함수\r\n *\r\n * @param num: [int] 대상 숫자\r\n * @param digit: [int] 자릿수\r\n */\r\nprivate static void count(int num, int digit)\r\n{\r\n\twhile (num > 0)\r\n\t{\r\n\t\tcounter[num % 10] += digit;\r\n\t\tnum /= 10;\r\n\t}\r\n}\r\n```\r\n\r\n로직은 어렵지 않다. 4152의 경우 $[ 4, 1, 5, 2 ]$로 이루어져있으므로, 해당하는 숫자에 자릿수만큼 카운팅(1이면 1개, 10이면 10개)하면 된다.\r\n\r\n1의 자리는 $4152 \\,\\,\\, \\% \\,\\,\\, 10 = 2$와 같이 구할 수 있다. 10의 자리는 4152를 10으로 한 번 나누고 방금의 연산을 다시 진행하면 된다.  \r\n100, 1000 등 자릿수만큼 반복하여 계산하면 된다.\r\n\r\n``` java\r\n/**\r\n * 알고리즘 동작 함수\r\n *\r\n * @param num: [int] 마지막 페이지\r\n */\r\nprivate static void solve(int num)\r\n{\r\n\t// 시작 페이지\r\n\tint start = 1;\r\n\t\r\n\t// 자릿수\r\n\tint digit = 1;\r\n\t\r\n\twhile (start <= num)\r\n\t{\r\n\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\twhile (num % 10 != 9 && start <= num)\r\n\t\t{\r\n\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\tcount(num, digit);\r\n\t\t\t\r\n\t\t\tnum--;\r\n\t\t}\r\n\t\t\r\n\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\tif (num < start)\r\n\t\t{\r\n\t\t\t// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\twhile (start % 10 != 0 && start <= num)\r\n\t\t{\r\n\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\tcount(start, digit);\r\n\t\t\t\r\n\t\t\tstart++;\r\n\t\t}\r\n\t\t\r\n\t\tstart /= 10;\r\n\t\tnum /= 10;\r\n\t\t\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t}\r\n\t\t\r\n\t\t// 자릿수 증가\r\n\t\tdigit *= 10;\r\n\t}\r\n}\r\n```\r\n\r\n시작 페이지는 무조건 1로 고정이다. 시작 페이지가 마지막 페이지보다 커질 때까지 반복한다.\r\n\r\n첫 번째 `while`문에서 마지막 페이지를 1씩 감소시켜 9로 끝나는 구간으로 보정한다. 중간에 조건문이 있는데, 이 처리를 해주지 않으면 `num`이 9보다 작을 경우 연산 과정에서 `start`가 `num`을 초과하지 못해 무한루프를 타게 된다.\r\n\r\n두 번째 `while`문은 1페이지를 1씩 증가시켜 0으로 끝나는 구간으로 보정한다. 보정된 모든 값은 `count` 메소드를 통해 별도로 카운팅된다.\r\n\r\n위 과정을 통해 구간을 맞췄으니, 나머지는 위에 언급한 수식을 적용하고, 이를 반복한다.\r\n\r\n## 분류\r\n\r\n* 수학","url":["2021-06-28-a1019","2021","06","28","a1019"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1016번 제곱 ㄴㄴ수","excerpt":"어떤 수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-23T00:22:31","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I","에라토스 테네스의 체"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-23-a1016.md","content":"\r\n# 제곱 ㄴㄴ수\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/15.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1016번 문제](https://www.acmicpc.net/problem/1016)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n어떤 수 $X$가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.\r\n\r\n## 입력\r\n\r\n첫째 줄에 두 정수 min과 max가 주어진다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 [min,max]구간에 제곱ㄴㄴ수가 몇 개인지 출력한다.\r\n\r\n## 제한\r\n\r\n* $1 ≤ \\text{min} ≤ 1,000,000,000,000$\r\n* $\\text{min} ≤ \\text{max} ≤ \\text{min} + 1,000,000$\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n1 10\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n7\r\n```\r\n\r\n# 풀이\r\n\r\n주어진 구간에서 제곱수(4, 9, 16 등)으로 나누어지지 않는 수의 갯수를 구하면 되는 문제.\r\n\r\n개념은 생각보다 간단하다. <span class=\"primary\">에라토스 테네스의 체</span>에 대해 알고있다면 생각보다 쉽게 접근할 수 있기도 하고. 의외로 문제는 다른 쪽에 있다.\r\n\r\n1. min, max의 최대값이 1조 단위다.\r\n2. 구간이 반드시 1부터 시작하지 않는다.\r\n3. 배열의 인덱스는 반드시 `int` 데이터만 가능하다.\r\n\r\n보편적인 정수 데이터인 `int`의 최대값이 약 21억인걸 감안하면 턱없이 큰 수. 때문에 `long` 데이터의 사용이 강제된다. 반면 배열의 인덱스는 `int` 데이터만 사용 가능하므로, `int`와 `long`의 적절한 데이터 선언 및 변환이 필요하다.\r\n\r\n최소값 <span class=\"lightBlue-A400\">min</span>과 최대값 <span class=\"lightBlue-A400\">max</span>는 그 수가 매우 클 수는 있어도, 그 차이는 백만 이하로만 나오므로 배열로 다루는데 무리가 없다.\r\n\r\n만약, min = 1,000,000,000,000(1조)이고, max = 1,000,000,500,000(1조 50만)일 경우, 실제로 비교해야할 구간은 약 50만개밖에 되지 않는다. 이 구간을 배열 $A$로 표시하면 $A[0] = 1,000,000,000,000\\text{(min)}$가 된다. 즉, $A[i] = i + \\text{min}$으로 다뤄야한다.\r\n\r\n**제곱수의 배수를 제외**해야한다는 점에서 소수의 배수를 제외하여 소수를 판별하는 <span class=\"primary\">에라토스 테네스의 체</span>의 개념와 매우 흡사하다. 즉, <span class=\"primary\">에라토스 테네스의 체</span> 알고리즘에서 소수가 아닌 제곱수의 배수를 판별하게끔 살짝 변형시켜주면 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 백준 전체 1016 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/23/a1016\">1016 풀이</a>\r\n * @since 2021.06.23 Fri 00:22:31\r\n */\r\npublic class Main\r\n{\r\n\t// 최소값\r\n\tprivate static long min;\r\n\t\r\n\t// 최대값\r\n\tprivate static long max;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\tlong[] temp = Arrays.stream(reader.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\r\n\t\t\r\n\t\tmin = temp[0];\r\n\t\tmax = temp[1];\r\n\t\t\r\n\t\twriter.write(Integer.toString(solve()));\r\n\t\twriter.newLine();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @return [int] 제곱수로 나누어 떨어지지 않는 수의 갯수\r\n\t */\r\n\tprivate static int solve()\r\n\t{\r\n\t\tint size = 0;\r\n\t\t\r\n\t\tboolean[] isNotPow = eratosthenes();\r\n\t\t\r\n\t\tfor (boolean item : isNotPow)\r\n\t\t{\r\n\t\t\t// 제곱수로 나누어 떨어지지 않는 수일 경우\r\n\t\t\tif (!item)\r\n\t\t\t{\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn size;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 에라토스 테네스의 체 배열 반환 함수\r\n\t * true: 제곱ㄴㄴ수가 아닌 수\r\n\t * false: 제곱ㄴㄴ수\r\n\t *\r\n\t * @return [boolean[]] 에라토스 테네스의 체 배열\r\n\t */\r\n\tprivate static boolean[] eratosthenes()\r\n\t{\r\n\t\tint length = (int) (max - min + 1);\r\n\t\t\r\n\t\tboolean[] isNotPow = new boolean[length];\r\n\t\t\r\n\t\tfor (long i = 2; i * i <= max; i++)\r\n\t\t{\r\n\t\t\tlong pow = i * i;\r\n\t\t\t\r\n\t\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\t\r\n\t\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t\t{\r\n\t\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn isNotPow;\r\n\t}\r\n}\r\n```\r\n\r\n`solve()` 메소드는 단순히 갯수를 파악하는 로직이므로 그 의도만 알면 된다. 가장 핵심인 부분은 <span class=\"primary\">에라토스 테네스의 체</span>를 변형한 아래 코드다.\r\n\r\n``` java\r\n/**\r\n * 에라토스 테네스의 체 배열 반환 함수\r\n *\r\n * true: 제곱ㄴㄴ수가 아닌 수\r\n * false: 제곱ㄴㄴ수\r\n *\r\n * @return [boolean[]] 에라토스 테네스의 체 배열\r\n */\r\nprivate static boolean[] eratosthenes()\r\n{\r\n\tint length = (int) (max - min + 1);\r\n\t\r\n\tboolean[] isNotPow = new boolean[length];\r\n\t\r\n\tfor (long i = 2; i * i <= max; i++)\r\n\t{\r\n\t\tlong pow = i * i;\r\n\t\t\r\n\t\tlong start = min % pow == 0 ? min / pow : (min / pow) + 1;\r\n\t\t\r\n\t\tfor (long j = start; j * pow <= max; j++)\r\n\t\t{\r\n\t\t\t// 제곱수의 배수로 나누어 떨어지므로 제곱ㄴㄴ수가 아님\r\n\t\t\tisNotPow[(int) (j * pow - min)] = true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn isNotPow;\r\n}\r\n```\r\n\r\n총 2개의 반복문이 돌아간다. 인덱스는 각각 $i$, $j$다.\r\n\r\n* $i$: 제곱수의 제곱근\r\n* $j$: 제곱수의 배수를 구하기 위한 인덱스\r\n\r\n1보다 큰 제곱수는 4이므로, 인덱스 $i$의 시작값은 2이며, 제곱수인 $i^2$의 크기가 max 이하일때 까지 반복한다. 만약, 구간이 10부터 30까지라면, $i$는 2<span class=\"grey-500\">(4)</span>부터 5<span class=\"grey-500\">(25)</span>까지 증가할 것이다.\r\n\r\n인덱스 $j$는 약간 복잡한데, 이는 구간의 존재 때문이다. 기본적으로 <span class=\"primary\">에라토스 테네스의 체</span>는 1부터 시작하므로 상관없지만, 해당 문제는 <span class=\"red-500\">시작값이 1이 아닐 경우</span>가 존재한다.\r\n\r\n예를 들어, $i = 2$이고 구간이 10 ~ 20까지라고 가정하자. $i^2 = 4$이므로 제곱수 4의 배수를 제거해야한다. 만약 평상시처럼 곱셈의 인덱스를 1부터 시작해서 $4 \\times 1$, $4 \\times 2$, $\\dots$와 같이 시작한다면 문제가 생긴다. 구간은 10부터인데 비해, 10 이하인 4, 8을 제거하게되니 이를 걸러내야한다. 만약 구간이 1000부터 시작이라면 250개의 쓸모없는 연산이 발생한다. 구간이 최대 1조부터 시작할 수 있음을 생각한다면 구간의 시작에 따라 곱셈 인덱스 $j$를 적절히 계산해야한다.\r\n\r\n$i = 2$일 경우, $i^2 = 4$이다. 구간의 시작이 10일 경우, 10 이하인 수 $4 \\times 1$, $4 \\times 2$는 건너뛰므로 곱셈 인덱스 $j$는 3부터 시작해야한다.\r\n\r\n$$\r\nj_{\\text{min}} = \r\n\\begin{cases}\r\n\t\\text{min} \\div i^2 \\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 == 0)\\\\\r\n\t(\\text{min} \\div i^2) + 1 \\,\\,\\, (\\text{min} \\,\\,\\, \\% \\,\\,\\, i^2 \\,\\,\\, !=  0)\r\n\\end{cases}\r\n$$\r\n\r\n즉, 곱셈 인덱스 $j$의 시작값의 일반식은 위와 같다.\r\n\r\n$\\text{제곱수의 배수} = j \\times i^2 \\,\\,\\, (j = 1, 2, 3, \\dots)$이므로, 해당값을 모두 제외하면 된다. 단, $j \\times i^2$는 실제 값이므로, 배열의 인덱스는 $(j \\times i^2) - \\text{min}$이다.\r\n\r\n배열에 `true`를 할당하는 이유는 `boolean[]`의 초기값이 `false`이기 때문. `Arrays.fill()` 메소드를 활용하여 `true`로 초기화할 수도 있으나, 의미론적으론 좋지만 불필요한 연산이므로 `false`를 제곱ㄴㄴ수로, `true`를 제곱ㄴㄴ수가 아닌 수로 지칭한다. 배열 이름이 `isNotPow`인 이유도 이때문.\r\n\r\n이후 `isNotPow` 배열을 순회하며, 값이 `false`인 수만 카운팅하면 된다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 정수론\r\n* 소수 판정\r\n* 에라토스 테네스의 체","url":["2021-06-23-a1016","2021","06","23","a1016"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1013번 Contact","excerpt":"푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다. 이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-13T04:53:32","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","정규 표현식","GOLD","GOLD V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-13-a1013.md","content":"\r\n# Contact\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/11.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1013번 문제](https://www.acmicpc.net/problem/1013)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n> “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”\r\n\r\n푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다.\r\n\r\n이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.\r\n\r\n전파의 기본 단위는 $\\{ 0 , 1 \\}$ 두 가지로 구성되어있으며, $x+ (  )$ 는 임의의 개수(최소 1개) $x$의 반복으로 이루어진 전파의 집합을 나타낸다.\r\n\r\n$(xyx)+ (  )$ 는 괄호 내의 $xyx$의 반복으로 이루어진 전파의 집합을 뜻한다. 아래는 이해를 돕기 위한 예제이다.\r\n\r\n* 1+ = { 1, 11, 111, 1111, 11111, … }\r\n* 10+ = { 10, 100, 1000, 10000, 100000, … }\r\n* (01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }\r\n* (1001)+ = { 1001, 10011001, 100110011001, … }\r\n* 10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }\r\n* (10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }\r\n\r\n반복을 의미하는 + 외에도 or 를 의미하는 $|$ 기호가 있다. $\\{ x | y \\}$ 는 $x$ 혹은 $y$를 의미하는 것으로, $\\{ 0+ | 1+ \\}$ 는 $\\{ 0 , 1 , 00 , 11 , 000 , 111 , \\dotsm \\}$ 의 집합을 의미한다. 아래는 두 기호를 복합적으로 사용한 예이다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n최근 김동혁 박사는 아레시보 전파망원경에서 star Vega(직녀성) 으로부터 수신한 전파 기록의 일부를 조사하여 그 전파들의 패턴을 분석하여 아래와 같이 기록하였다.\r\n\r\n* (100+1+ | 01)+\r\n\r\n김동혁 박사는 다양한 전파 기록 중에서 위의 패턴을 지니는 전파를 가려내는 프로그램을 필요로 한다. 이를 수행할 수 있는 프로그램을 작성하라.\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 전파를 표현하는, $\\{ 0, 1 \\}$만으로 이루어진 문자열이 공백 없이 주어진다. 문자열 길이는 $(1 ≤ N ≤ 200)$의 범위를 갖는다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 전파가 문제에서 제시한 패턴이면 “YES”를 그렇지 않은 경우는 “NO”를 출력한다. 출력 문자열은 모두 대문자로 구성되어 있다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n10010111\r\n011000100110001\r\n0110001011001\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\nNO\r\nNO\r\nYES\r\n```\r\n\r\n# 풀이\r\n\r\n정규식을 대강 알고있다면 이게 왜 <span class=\"amber-A400\">GOLD V</span>인지 다소 이해되지 않는 수준의 문제다. 정규식이 어려운 이유는 원하는 패턴에 맞춰 정규식을 설계하는 건데, 그 정규식을 대놓고 준다. 사실상 정규식의 개념을 아냐 모르느냐를 물어보는 문제.\r\n\r\n나의 경우, 일하다가 간간히 쓸 일이 생겨서 몇 번 다뤄본적이 있어 그리 생소하지 않았다. [regexr](https://regexr.com/)에서 정규식을 설계하고 테스트를 할 수 있으니 참고하자. 정규식 관련해서는 유명한 사이트.\r\n\r\n문제에 대놓고 $(100+1+ | 01)+$라는 정규식 자체를 제공하기 때문에, 그냥 문자열 받아서 정규식과 일치하는지 보면 된다.\r\n\r\nJAVA에서는 `Pattern.matches({정규식 문자열}, {문자열});`과 같이 사용하며, 일치여부를 `boolean`으로 반환한다.\r\n\r\n아래 소스를 보면 알겠지만 진짜 간단하다. 정규식을 아는 사람에겐 <span class=\"brown-500\">BRONZE</span> 수준의 문제.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * 백준 전체 1013 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/13/a1013\">1013 풀이</a>\r\n * @since 2021.06.13 Sun 04:34:19\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString text = reader.readLine();\r\n\t\t\t\r\n\t\t\t// 정규식 일치 여부\r\n\t\t\tString result = Pattern.matches(\"(100+1+|01)+\", text) ? \"YES\" : \"NO\";\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 문자열\r\n* 정규 표현식\r\n\r\n## 여담\r\n\r\n문제가 생각보다 쉬워서, \"사실 이렇게 하면 안 되는게 아닐까?\"하고 찾아보니 역시나 다른 방식으로 접근하는 방법이 공유되어 있었다. 정규표현식이 아닌 DFA(오토마타 전이 그래프)를 활용하는 방식이다. 정규표현식을 공식적으로 지원해주지 않는 언어라면 대체제로 시도해봄직하다. 백준에선 외부 라이브러리를 사용할 수 없을테니.","url":["2021-06-13-a1013","2021","06","13","a1013"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1007번 벡터","excerpt":"평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다. V에 있는 벡터의 갯수는 P에 있는 점의 절반이다. 평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T00:50:26","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Brute Force(무차별 대입 공격)","Combination(조합)","GOLD","GOLD II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1007.md","content":"\r\n# 습격자 초라기\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/14.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1007번 문제](https://www.acmicpc.net/problem/1007)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n평면 상에 $N$개의 점이 찍혀있고, 그 점을 집합 $P$라고 하자. 집합 $P$의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 $P$의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, $P$에 속하는 모든 점은 한 번씩 쓰여야 한다.\r\n\r\n$V$에 있는 벡터의 갯수는 $P$에 있는 점의 절반이다.\r\n\r\n평면 상의 점이 주어졌을 때, 집합 $P$의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n테스트 케이스의 첫째 줄에 점의 갯수 $N$이 주어진다. $N$은 짝수이다. 둘째 줄부터 $N$개의 줄에 점의 좌표가 주어진다. $N$은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4\r\n5 5\r\n5 -5\r\n-5 5\r\n-5 -5\r\n2\r\n-100000 -100000\r\n100000 100000\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.000000000000\r\n282842.712474619038\r\n```\r\n\r\n# 풀이\r\n\r\n두 개의 점으로 하나의 벡터를 만들 수 있다. $N <= 20$이므로 주어지는 점의 최대 갯수는 20개다. $N = 20$이라고 가정하면, 만들 수 있는 벡터의 수는 그 절반인 10개다. 20개의 점을 어떻게 잇느냐에 따라서 벡터 10개를 만드는 수 많은 경우의 수가 발생한다. 이 경우의 수에서 <span class=\"red-A400\">벡터의 총합이 가장 작은 값을 계산</span>하는 게 이 알고리즘의 결과다.(10개의 벡터 중 가장 짧은 벡터를 계산하는 것이 아님에 유의하자.)\r\n\r\n이 알고리즘의 핵심은 <span class=\"green-A400\">$N$개의 원소에서 $N / 2$개의 벡터를 만들 수 있는 경우를 계산해서 최소값을 계산</span>하면 된다. $N$의 최대값이 20으로 매우 작으므로 하나하나 비교하는 것이 가능하다. 애초에 알고리즘 자체가 Brute Force(무차별 대입 공격)으로 분류돼있기도 하고.\r\n\r\n좌표 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$가 있으며, 이 좌표에서 두 벡터인 $v_1$, $v_2$를 만든다고 가정하자.(조건은 알고리즘 문제와 동일) $v_1$이 $(x_1, y_1), (x_2, y_2)$으로 이루어져 있으며, $v_2$는 $(x_3, y_3), (x_4, y_4)$로 이루어져있다고 가정하자. 각 벡터를 좌표를 통해 표현하면 아래와 같다.\r\n\r\n$$\r\nv_1 = (x_2 - x_1, y_2 - y_1)\r\n$$\r\n\r\n$$\r\nv_2 = (x_4 - x_3, y_4 - y_3)\r\n$$\r\n\r\n벡터의 합은 벡터 좌표의 단순합으로 이루어진다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121457485-b4520c80-c9e2-11eb-8de4-660f9a86a7a1.png)\r\n\r\n즉, 벡터의 총합 $v$는 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\nv = v_1 + v_2 = (x_2 + x_4 - x_1 - x_3, y_2 + y_4 - y_1 - y_3)\r\n$$\r\n\r\n$$\r\n||v|| = \\sqrt{(x_2 + x_4 - x_1 - x_3)^2 + (y_2 + y_4 - y_1 - y_3)^2}\r\n$$\r\n\r\n위 식으로 계산한 값의 최소값이 알고리즘의 해답이 된다. 즉, 우리는 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$을 조건에 맞게 조합해야한다. 각 조합의 $||v||$를 계산한 뒤, 이 중 최소값을 반환하면 될 것 같다.\r\n\r\n무턱대고 10개의 벡터를 for문 돌려가며 하나하나 만드는 방법은 안 된다. 좀 더 효율적으로 벡터를 계산하는 방법을 생각해보자.\r\n\r\n$v$식을 자세히 보면 쓸만한 특징일 하나 찾을 수 있는데, 각각의 좌표 $x$, $y$를 계산할 때 좌표의 절반은 더해지고, 절반은 빼진다. 좌표가 4개일 경우 2개는 더해지고, 나머지 2개는 빼진다. 만약 10개라면? 5개는 더해지고, 5개는 빼질 것이다.\r\n\r\n이를 활용하면 전체 좌표 $N$의 절반인 $N / 2$만큼의 좌표 조합을 구한다면 어떨까? 반은 더해지는 좌표, 나머지 반은 빼지는 좌표로 구분할 수 있다. 이후 각 좌표를 더하고 빼주면 손쉽게 $||v||$를 계산할 수 있을 것이다.\r\n\r\n따라서, 점을 반으로 나누어 <span class=\"green-A400\">양의 연산에 사용할 점과 음의 연산에 사용될 점의 경우의 수를 구하는 것이 이번 알고리즘의 핵심</span>이다. $_nC_r$(조합, Combination)을 사용하면 이를 쉽게 구할 수 있을 겻이다. $_nC_{(n / 2)}$를 계산하여, 선택된 좌표는 더하고, 선택되지 않은 좌표는 뺀다.\r\n\r\n예제 1의 $_4C_2$의 경우의 수는 아래와 같다.\r\n\r\n|     양의 좌표     |     음의 좌표     |   $v$    | $\\Vert v \\Vert$ |\r\n| :---------------: | :---------------: | :------: | :-------------: |\r\n|  (5, 5), (5, -5)  | (-5, 5), (-5, -5) | (20, 0)  |       20        |\r\n|  (5, 5), (-5, 5)  | (5, -5), (-5, -5) | (0, 20)  |       20        |\r\n| (5, 5), (-5, -5)  | (5, -5), (-5, 5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, 5)  | (5, 5), (-5, -5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, -5) |  (5, 5), (-5, 5)  | (0, -20) |       20        |\r\n| (-5, 5), (-5, -5) |  (5, 5), (5, -5)  | (-20, 0) |       20        |\r\n\r\n위와 같은 이유로 예제 1에서 벡터 총합의 최소값은 0이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1007 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/09/a1007\">1007 풀이</a>\r\n * @since 2021.06.09 Tue 00:50:26\r\n */\r\npublic class Main\r\n{\r\n\t// 결과\r\n\tprivate static double result;\r\n\t\r\n\t// 조합 선택 여부\r\n\tprivate static boolean[] isChecked;\r\n\t\r\n\t// 점의 배열\r\n\tprivate static int[][] P;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 점의 갯수\r\n\t\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\t\r\n\t\t\tresult = Double.MAX_VALUE;\r\n\t\t\t\r\n\t\t\tisChecked = new boolean[N];\r\n\t\t\t\r\n\t\t\tP = new int[N][2];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < N; j++)\r\n\t\t\t{\r\n\t\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tP[j][0] = Integer.parseInt(temp[0]);\r\n\t\t\t\tP[j][1] = Integer.parseInt(temp[1]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcombination(0, N / 2);\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t * @param count: [int] 조합할 원소 갯수\r\n\t */\r\n\tprivate static void combination(int index, int count)\r\n\t{\r\n\t\t// 조합할 원소 갯수가 더 이상 없을 경우\r\n\t\tif (count == 0)\r\n\t\t{\r\n\t\t\tresult = Math.min(result, getVector());\r\n\t\t}\r\n\t\t\r\n\t\t// 조합할 원소 갯수가 아직 남아있을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = index; i < P.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisChecked[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(i + 1, count - 1);\r\n\t\t\t\t\r\n\t\t\t\tisChecked[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 벡터 계산 함수\r\n\t *\r\n\t * @return [double] 벡터 크기\r\n\t */\r\n\tprivate static double getVector()\r\n\t{\r\n\t\tint x = 0;\r\n\t\tint y = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < P.length; i++)\r\n\t\t{\r\n\t\t\t// 양수로 선택된 점일 경우\r\n\t\t\tif (isChecked[i])\r\n\t\t\t{\r\n\t\t\t\tx += P[i][0];\r\n\t\t\t\ty += P[i][1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 음수로 선택된 점일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx -= P[i][0];\r\n\t\t\t\ty -= P[i][1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 브루트포스 알고리즘","url":["2021-06-09-a1007","2021","06","09","a1007"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1005번 ACM Craft","excerpt":"서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-01T01:27:56","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Dynamic Programming(동적 프로그래밍)","위상 정렬","GOLD","GOLD III"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-01-a1005.md","content":"\r\n# ACM Craft\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/13.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1005번 문제](https://www.acmicpc.net/problem/1005)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   1초    |    512MB    |\r\n\r\n## 문제\r\n\r\n서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다.\r\n\r\n이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219763-b1cf1480-c276-11eb-8131-a3471db1cfc4.png)\r\n\r\n위의 예시를 보자.\r\n\r\n이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할 수 있다. (동시에 진행이 가능하다.) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번 건물의 건설을 시작할 수 있다.\r\n\r\n따라서 4번 건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물와 3번 건물을 동시에 건설하기 시작하면 2번은 1초 뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을 수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.\r\n\r\n프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM Craft 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정 건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정 건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.\r\n\r\n## 입력\r\n\r\n첫째 줄에는 테스트케이스의 갯수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다, 첫째 줄에 건물의 갯수 $N$과 건물 간의 건설순서 규칙의 총 갯수 $K$가 주어진다.(전물의 번호는 1번 부터 $N$번 까지 존재한다.)\r\n\r\n둘째 줄에는 각 건물 당 건설에 걸리는 시간 $D$가 공백을 사이로 주어진다. 셋째 줄부터 $K + 2$줄 까지 건설순서 $X$ $Y$가 주어진다.(이는 건물 X를 지은 다음에 건물 $Y$를 짓는 것이 가능하다는 의미이다.)\r\n\r\n마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 $W$가 주어진다.\r\n\r\n## 출력\r\n\r\n건물 $W$를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.  \r\n건설순서는 모든 건물이 건설 가능하도록 주어진다.\r\n\r\n## 제한\r\n\r\n* $2 ≤ N ≤ 1,000$\r\n* $1 ≤ K ≤ 100,000$\r\n* $1 ≤ X, Y, W ≤ N$\r\n* $0 ≤ D ≤ 100,000)$ $D$는 정수\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4 4\r\n10 1 100 10\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4\r\n8 8\r\n10 20 1 5 8 7 1 43\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n5 7\r\n6 7\r\n7 8\r\n7\r\n```\r\n+ 출력\r\n\r\n``` tc\r\n120\r\n39\r\n```\r\n\r\n### 예제 2\r\n\r\n+ 입력\r\n\r\n``` tc\r\n5\r\n3 2\r\n1 2 3\r\n3 2\r\n2 1\r\n1\r\n4 3\r\n5 5 5 5\r\n1 2\r\n1 3\r\n2 3\r\n4\r\n5 10\r\n100000 99999 99997 99994 99990\r\n4 5\r\n3 5\r\n3 4\r\n2 5\r\n2 4\r\n2 3\r\n1 5\r\n1 4\r\n1 3\r\n1 2\r\n4\r\n4 3\r\n1 1 1 1\r\n1 2\r\n3 2\r\n1 4\r\n4\r\n7 8\r\n0 0 0 0 0 0 0\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n4 5\r\n4 6\r\n5 7\r\n6 7\r\n7\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n6\r\n5\r\n399990\r\n2\r\n0\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 이해가 되는데, 이를 코딩으로 풀어내기가 어려웠던 알고리즘. <span class=\"primary\">위상정렬</span> 알고리즘에 대한 이해가 있어야한다.  \r\n문제의 경우, 스타크래프트의 건물 테크트리랑 비슷한 개념으로 접근하면 된다. 군수공장을 짓기 위해선 병영을 지어야하는 것처럼, 요구 트리가 있는 건물의 경우 해당 건물을 반드시 완료해야 하며, 하나의 건물이 여러 요구 트리를 가질 경우도 존재한다. 물론 이 경우 요구하는 건물들을 **모두** 건설한 뒤에 건설 가능하다. 요구하는 건물들 중 하나만 건설하면 충족되는게 아니다.\r\n\r\n<span class=\"primary\">위상정렬</span>은 <span class=\"green-A400\">순서가 정해진 작업을 수행할 때, 이 순서를 결정하는 알고리즘</span>이다. <span class=\"primary\">위상정렬</span>은 반드시 DAG(Directed Acyclic Graph, 유향 비순환 그래프) 형태여야 한다. 즉, 순서를 도식화했을 때 반드시 <span class=\"red-A400\">시작/도착점이 존재</span>해야 한다. 시작/도착점이 구분되지 않는 순환 형태일 경우 위상정렬을 적용할 수 없다.\r\n\r\n위상정렬은 순서를 정하는 알고리즘이고, 순서도의 형태에 따라 여러가지의 답이 나올 수 있다. 이 문제는 최적의 답을 도출하기 위해 각 **건물을 건설하는데 필요한 요구 건물**과 **건설 시간**을 적용했다.\r\n\r\n다음 건물을 건설하기 위해선 요구 건물을 모두 건설해야하므로 요구 건물의 건설시간이 가장 많은 건물이 다음 순서가 된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219453-3b321700-c276-11eb-9029-ec105c694854.png)\r\n\r\n예시 1번의 두 번째 케이스를 예시로 하여 위상정렬을 도식화하면 위 사진과 같다.\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   0   |   1   |   1   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n위 표는 도식를 수치화하여 정리한 것이다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">1. 순서의 시작점(진입선이 없는 점)을 찾는다. 시작점이 여러개일 경우 시작점 중 무작위로 하나를 선택해도 무방하다. (위 예시는 시작점이 하나)</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219469-4127f800-c276-11eb-91c8-db36e543c217.png)\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">2. 시작점 1을 큐에 넣고, 시작점에 연결된 진출선을 전부 제거한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219471-438a5200-c276-11eb-9cd3-ca5f31dfb19b.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   0   |   0   |   1   |   1   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |\r\n| :---: | :---: |\r\n\r\n이 과정에서 2와 3이 새로운 시작점이 된 것을 확인할 수 있다.\r\n\r\n1을 건설하는데 걸리는 시간은 1초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">3. 2에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219484-45ecac00-c276-11eb-8114-a6c4c8b17036.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   0   |   0   |   0   |   1   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |\r\n| :---: | :---: | :---: |\r\n\r\n4와 5의 진입선이 0이 된다. 즉, 4와 5를 건설할 수 있게 된다.\r\n\r\n2를 건설하는데는 $10(1) + 20(2)$로 총 30초가 소요된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">4. 3에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219493-48e79c80-c276-11eb-8f48-cf132cab8f5c.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   0   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |\r\n| :---: | :---: | :---: | :---: |\r\n\r\n6의 진입선이 0이 된다. 6을 건설할 수 있게 된다.\r\n\r\n3의 건설시간은 $10(1) + 1(3)$으로 총 11초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">5. 4에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219504-4be28d00-c276-11eb-9b40-07c5ea51cbd9.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   0   |   0   |   2   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |\r\n| :---: | :---: | :---: | :---: | :---: |\r\n\r\n4는 진출선이 없으므로 큐에만 추가된다.\r\n\r\n4의 건설시간은 $10(1) + 20(2) + 5(4)$로 총 35초\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">6. 5에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219509-4edd7d80-c276-11eb-9c5f-fc17d373bf50.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   0   |   1   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7이 5와 6에 연결되어 있으므로, 7의 진입선은 1이 된다. 아직 7을 건설할 수 없다.\r\n\r\n5의 건설시간은 $10(1) + 20(2) + 8(5)$로 총 38초\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">7. 6에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219520-53099b00-c276-11eb-9c99-060dcd2039d8.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   0   |   1   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n7의 진입선이 0이 된다. 7을 건설할 수 있게 된다.\r\n\r\n6의 건설시간은 $10(1) + 1(3) + 7(6)$으로 총 18초.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">8. 7에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219527-56048b80-c276-11eb-866b-9b411445b22b.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   0   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n8의 진입선이 0이 된다.\r\n\r\n1 ~ 6까지는 요구 건물이 하나였지만, 7은 두개이다. 앞서 언급했듯이, 5와 6 중 건설시간이 더 긴 것을 기준으로 계산해야한다.\r\n\r\n즉, 7의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7)$로 총 39초\r\n\r\n5번을 기준으로 계산하므로, <span class=\"red-A400\">6번과 중간인 3번은 계산에서 제외</span>된다. 만약, 3의 건설시간을 1초에서 4초로 증가시켜도 결과에 영향을 미치지 않는다. 3의 건설시간을 무시하기 때문이다. 단, 3의 건설시간이 너무 커지게되면 5보다 6의 건설시간이 같이 커지게 되어 결과에 영향을 미치게 된다.\r\n\r\n<br />\r\n<br />\r\n\r\n<span class=\"large orange-A400\">9. 8에 대해 2번 과정을 적용한다.</span>\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/120219535-58ff7c00-c276-11eb-907c-2a90cc84c596.png)\r\n\r\n|  노드  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 진입선 |   -   |   -   |   -   |   -   |   -   |   -   |   -   |   -   |\r\n|  시간  |  10   |  20   |   1   |   5   |   8   |   7   |   1   |  43   |\r\n\r\n|  큐   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n\r\n문제는 7에 대한 건설시간을 요구하고 있으므로 8은 무시해도 무방하다. \r\n8의 건설시간은 $10(1) + 20(2) + 8(5) + 1(7) + 43(8)$로 총 82초\r\n\r\n## 전체 소스\r\n\r\n`time`, `matrix`, `link`의 배열 크기가 $N + 1$이다. 별다른 이유는 아니고, 건물은 1번부터 시작하는데 배열은 0번부터 시작한다. 이러한 차이에서 오는 혼란을 방지하기 위해 건물이 총 4개면 배열의 크기를 5로(0, 1, 2, 3, 4, 5)로 지정하여 0을 제외하고 1부터 사용한다.\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * 백준 전체 1005 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/01/a1005\">1005 풀이</a>\r\n * @since 2021.05.31 Mon 19:11:58\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\t// 케이스 갯수\r\n\t\tint T = scanner.nextInt();\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 건물 갯수\r\n\t\t\tint N = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 규칙(건설시간) 갯수\r\n\t\t\tint K = scanner.nextInt();\r\n\t\t\t\r\n\t\t\t// 건물별 건설시간 배열\r\n\t\t\tint[] time = new int[N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결여부 배열\r\n\t\t\tboolean[][] matrix = new boolean[N + 1][N + 1];\r\n\t\t\t\r\n\t\t\t// 건물별 연결 갯수 배열\r\n\t\t\tint[] link = new int[N + 1];\r\n\t\t\t\r\n\t\t\tfor (int j = 1; j < N + 1; j++)\r\n\t\t\t{\r\n\t\t\t\ttime[j] = scanner.nextInt();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < K; j++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물\r\n\t\t\t\tint X = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\t// 상위 건물\r\n\t\t\t\tint Y = scanner.nextInt();\r\n\t\t\t\t\r\n\t\t\t\tmatrix[X][Y] = true;\r\n\t\t\t\tlink[Y]++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표 건물\r\n\t\t\tint W = scanner.nextInt();\r\n\t\t\t\r\n\t\t\tbuilder.append(calcTopologicalSort(time, matrix, link)[W]).append(\"\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(builder.toString());\r\n\t\t\r\n\t\tscanner.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 위상정렬 결과 반환 함수\r\n\t *\r\n\t * @param time: [int[]] 건물별 건설시간\r\n\t * @param matrix: [boolean[][]] 건물별 연결여부\r\n\t * @param link: [int[]] 건물별 연결 갯수\r\n\t *\r\n\t * @return [int[]] 건물별 종 건설시간 배열\r\n\t */\r\n\tprivate static int[] calcTopologicalSort(int[] time, boolean[][] matrix, int[] link)\r\n\t{\r\n\t\tQueue<Integer> queue = new LinkedList<>();\r\n\t\t\r\n\t\tint[] result = new int[link.length];\r\n\t\t\r\n\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t{\r\n\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\tif (link[i] == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = time[i];\r\n\t\t\t\tqueue.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile (!queue.isEmpty())\r\n\t\t{\r\n\t\t\t// 하위 건물\r\n\t\t\tint prev = queue.poll();\r\n\t\t\t\r\n\t\t\tfor (int i = 1; i < link.length; i++)\r\n\t\t\t{\r\n\t\t\t\t// 하위 건물 건설을 요구 하는 건물일 경우\r\n\t\t\t\tif (matrix[prev][i])\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = Math.max(result[i], result[prev] + time[i]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 해당 건물의 요구 건물 갯수 1 감소\r\n\t\t\t\t\t--link[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// 요구 건물이 없는 건물일 경우\r\n\t\t\t\t\tif (link[i] == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tqueue.add(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 다이나믹 프로그래밍\r\n* 그래프 이론\r\n* 위상 정렬","url":["2021-06-01-a1005","2021","06","01","a1005"]}],"categories":{"All":{"count":68,"flag":true},"RaspberryPi":{"count":6,"flag":true},"Ubuntu":{"count":1,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"GOLD","page":1,"hash":"96e5598e3c3"},"__N_SSG":true}