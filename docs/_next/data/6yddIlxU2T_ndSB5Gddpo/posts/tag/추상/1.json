{"pageProps":{"posts":[{"header":{"title":"[OOP] 객체지향의 특징 - 상속(Inheritance)","excerpt":"나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다. 나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 상속이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.","coverImage":"https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png","date":"2021-08-11T20:32:33","type":"posts","category":"CS","tag":["CS","객체지향","상속","추상"],"group":"객체지향","comment":true,"publish":true},"name":"2021-08-11-inheritance.md","content":"\r\n# 상속 (Inheritance)\r\n\r\n나른한 주말, 느긋하게 영화를 보고 있는 A씨. 영화에선 천대받으며 살던 주인공 소녀가 어느날 누군가로부터 거액의 유산을 받았다. 알고보니 그는 어렸을 적 실종된 재벌집 가문의 손녀딸이였던 것! 이후 그녀는 받은 유산을 통해 고마웠던 주변인에게 은혜를 갚고, 무시하던 이들에게 통쾌한 복수를 돌려준다는 내용이였다.\r\n\r\n나름 통쾌했던 A씨지만, 어차피 현실에선 일어날 수 없는 일이라는 걸 이내 떠올린 A씨. 우리는 이걸 **상속**이라 부른다. 이처럼 상속이라는 개념은 영화나 드라마와 같은 창작물에서나 볼 수 있었다. 사전에서나 찾아볼 수 있었던 허구의 개념인 셈이다.\r\n\r\n<p align=\"center\"><i><del>평범하게 살던 내가 콤퓨타 이세카이에선 상속자???!!?!?!</del></i></p>\r\n\r\n하지만 객체지향 언어에서는 누구나 필요에 의해 쉽게 상속받을 수 있다!\r\n\r\n객체지향 역시 동일한 개념이 존재한다. 객체지향에서의 <span class=\"teal-400\">상속</span>이란 <span class=\"blue-400\">객체가 다른 객체를 상속받아 상속받은 객체의 요소를 사용</span>하는 것을 의미한다.\r\n\r\n이 때 객체를 상속받은 객체는 <span class=\"teal-400\">자식</span>, 상속된 객체는 <span class=\"teal-400\">부모</span>라 칭한다.\r\n\r\n자식 객체는 상속된 부모 객체의 은닉화 구성에 따라 정해진 변수, 메소드에 접근할 수 있다. 또한 부모 객체가 <span class=\"teal-400\">추상 객체</span>일 경우 <span class=\"teal-400\">추상 메소드</span>와 <span class=\"teal-400\">오버라이딩</span>(Overriding)을 통해 부모 객체의 메소드를 구현하거나 다룰 수 있다.\r\n\r\n## 추상 객체\r\n\r\n<span class=\"teal-400\">추상 객체</span>는 하나 이상의 추상 메소드를 포함하는 객체다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\t// 메소드\r\n}\r\n```\r\n\r\nJAVA로 표현한 추상 클래스는 위와 같으며, 클래스의 맨 앞에 `abstract` 키워드를 적어 해당 객체가 추상 객체임을 표현할 수 있다.\r\n\r\n## 추상 메소드\r\n\r\n<span class=\"teal-400\">추상 메소드</span>는 자식 객체에서 구현해야하는 메소드다.\r\n\r\n``` java\r\nabstract public class Main\r\n{\r\n\tpublic void normalMethod()\r\n\t{\r\n\t\tSystem.out.println(\"일반 메소드\");\r\n\t}\r\n\r\n\tabstract public void abstractMethod();\r\n}\r\n```\r\n\r\n위는 JAVA로 표현한 추상 객체다. `normalMethod()`은 일반적인 메소드고, `abstractMethod()`는 추상 메소드다. 추상 메소드는 일반적인 메소드와 큰 차이가 있는데, 메소드의 동작이 기술되어있지 않다.\r\n\r\n추상 메소드의 구현은 자식 객체가 담당하며, 아래 단계에서 이루어진다.\r\n\r\n* 추상 객체의 인스턴스 생성 시\r\n* 추상 객체를 상속받을 시\r\n\r\n일반적인 메소드는 자신의 객체에서 선언되어있다. 하지만 추상 메소드의 경우, 추상 객체를 할당받으려는 객체에서 선언이 이루어진다. 이 경우 어떤 메리트가 있을까?\r\n\r\n예를 들어, 부모 객체 `Main`과 이를 상속받은 자식 객체 `Sub`가 있다고 가정하자. 만약 동작 구조 상 `abstractMethod()`에서 자식 객체의 변수나 메소드를 사용해야만 한다면?\r\n\r\n`normalMethod()` 처럼 동작이 이미 부모 객체에 선언되는 경우 자식 객체의 요소를 반영하기가 매우 어렵다. 인스턴스를 생성하는 방법도 있겠지만 어떤 객체를 상속받을 지 알 수 없는 경우, 예상되는 객체의 인스턴스를 전부 할당받아놓는 게 아니라면 불가능에 가깝다. 그리고 이 방법의 경우 메모리 낭비가 너무 심해진다.\r\n\r\n반면 `abstractMethod()` 같은 추상 메소드의 경우 자식 객체에서 구현되기 때문에 자식 객체의 변수나 메소드에 직접적으로 접근할 수 있다. 때문에 자식 객체의 요소를 활용해서 동작을 구현해야 할 경우, 해당 메소드를 추상으로 정의하면 자식 객체의 특성에 맞게 구현하기 용이하다.\r\n\r\n### 추상 메소드 구현 - 인스턴스 생성 시\r\n\r\nJAVA를 통해 `Main`의 인스턴스를 `Sub`에서 생성해보자.\r\n\r\n``` java\r\npublic class Sub\r\n{\r\n\tpublic void run()\r\n\t{\r\n\t\tMain main = new Main()\r\n\t\t{\r\n\t\t\t@Override\r\n\t\t\tpublic void abstractMethod()\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(text());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"Sub 객체의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n원래대로라면 `abstractMethod()` 메소드는 `Sub` 객체의 `text()`에 접근할 수 없다. `text()`는 `private` 접근제어자를 가지기 때문이다.\r\n\r\n하지만 추상 메소드의 경우 구현이 `Sub`에서 이루어지기 때문에 `Sub`의 모든 요소에 직접적으로 접근할 수 있다. 즉, `private` 같은 내부 메소드까지 전부 접근 가능하다.\r\n\r\n### 추상 메소드 구현 - 상속 시\r\n\r\nJAVA를 통해 `Main`을 `Sub`에 상속시켜보자.\r\n\r\n``` java\r\npublic class Sub extends Main\r\n{\r\n\t@Override\r\n\tpublic void abstractMethod()\r\n\t{\r\n\t\tSystem.out.println(text());\r\n\t}\r\n\r\n\tprivate String text()\r\n\t{\r\n\t\treturn \"자식 객체 Sub의 요소\";\r\n\t}\r\n}\r\n```\r\n\r\n부모 객체에 추상 메소드가 있을 경우, 자식 객체는 이를 반드시 오버라이딩해야한다. 그러지 않을 경우 컴파일 오류를 일으킨다.\r\n\r\n마찬가지로 메소드의 구현이 자식 객체에서 이루어지므로, 자식 객체의 모든 요소에 접근할 수 있다.\r\n\r\n추상 메소드는 이처럼 구현의 주체를 자식 객체에게 전가함으로써, 자식 객체의 요소에 제한없이 접근할 수 있다. 원래라면 `public` 등으로 열어줬어야 함에도 자식 객체 내부에서 구현이 이루어지기 때문에 접근제어자를 변경할 필요가 없다.\r\n\r\n# 상속의 예제\r\n\r\nJAVA를 통해 객체의 상속이 어떤식으로 이루어지고, 어떤식으로 사용되는지 알아보자.\r\n\r\n``` java\r\nimport java.util.Date;\r\n\r\n/**\r\n * 컴퓨터 추상 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:19:19\r\n */\r\nabstract public class Computer\r\n{\r\n\tprivate final String OS;\r\n\t\r\n\t/**\r\n\t * Computer 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Computer(String os)\r\n\t{\r\n\t\tthis.OS = os;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\tpublic void startup()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - started at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(new StringBuilder().append(OS).append(\" - shutdown at \").append(new Date().toString()));\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 추상 함수\r\n\t */\r\n\tabstract public void run();\r\n}\r\n```\r\n\r\n여기 `Computer`라는 추상 객체가 존재한다. 이 객체는 `OS`라는 상태와 `startup`, `shutdown`, `run`이라는 동작을 가진다.\r\n\r\n이 중 `run`은 좀 특별한데, 동작은 적혀있으나, 어떤식으로 동작하는지에 대한 명세는 정해져있지 않다.\r\n\r\n이는 <span class=\"teal-400\">추상 객체</span>의 특징 중 하나로, 추상 객체는 하나 이상의 <span class=\"teal-400\">추상 메서드</span>를 포함할 수 있다. 추상 메서드는 구현되지 않은 메서드로, **동작의 개념** 정도로만 이해하면 된다. <span class=\"red-400\">추상 메서드의 구현은 해당 객체를 상속받은 자식 객체에서 이루어진다.</span> 즉, `run` 추상 메소드는 자식마다 제각각으로 구현된 동작을 수행한다.\r\n\r\n아래의 두 클래스 `Asus`와 `Dell`은 `Computer` 추상 클래스를 상속받은 자식 클래스다.\r\n\r\n``` java\r\n/**\r\n * ASUS 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:24:50\r\n */\r\npublic class Asus extends Computer\r\n{\r\n\t/**\r\n\t * Asus 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Asus(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"ASUS 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n``` java\r\n/**\r\n * DELL 컴퓨터 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.08.06 Fri 21:26:46\r\n */\r\npublic class Dell extends Computer\r\n{\r\n\t/**\r\n\t * Dell 생성자 함수\r\n\t *\r\n\t * @param os: [String] OS 이름\r\n\t */\r\n\tpublic Dell(String os)\r\n\t{\r\n\t\tsuper(os);\r\n\t}\r\n\t\r\n\t/**\r\n\t * 시작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void startup()\r\n\t{\r\n\t\tsuper.startup();\r\n\t\t\r\n\t\tSystem.out.println(\"시스템 안정화 수행\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 종료 함수\r\n\t */\r\n\t@Override\r\n\tpublic void shutdown()\r\n\t{\r\n\t\tSystem.out.println(\"시스템 프로세스 정리 수행\");\r\n\t\t\r\n\t\tsuper.shutdown();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 동작 함수\r\n\t */\r\n\t@Override\r\n\tpublic void run()\r\n\t{\r\n\t\tSystem.out.println(\"DELL 작업 수행\");\r\n\t}\r\n}\r\n```\r\n\r\n`Asus`와 `Dell` 모두 `Computer`를 상속받았음을 확인할 수 있다. 또한 모두 `run` 함수가 제각각 구현된 것 역시 확인할 수 있다.\r\n\r\n그런데 `Asus`와 달리 `Dell`은 부팅 시와 종료 시 각각 시스템의 안정성을 위한 사전/후 작업이 추가됐다.\r\n\r\n이러한 사전/후 작업을 구현하기 위해 `startup`, `shutdown`을 오버라이딩한다. 이 과정을 통해 시작과 종료 함수에 각각 원하는 동작을 추가한다.\r\n\r\n> **super?**  \r\n> 자식 클래스에서 부모 클래스를 호출할 때 `super` 키워드를 이용해 호출한다. `Dell`의 오버라이딩 메소드 동작에서 활용됨을 알 수 있다. `super.shutdown()`은 부모 클래스 `Computer`의 메소드인 `shutdown()`을 호출한다.\r\n\r\n``` java\r\n/**\r\n * 메인 클래스\r\n *\r\n * @author RWB\r\n * @since 2021.06.14 Mon 00:06:32\r\n */\r\npublic class Main\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t */\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\tDell dell = new Dell(\"Windows 10 Pro\");\r\n\t\tAsus asus = new Asus(\"Ubuntu 21.04\");\r\n\t\t\r\n\t\tdell.startup();\r\n\t\tdell.run();\r\n\t\tdell.shutdown();\r\n\t\t\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tasus.startup();\r\n\t\tasus.run();\r\n\t\tasus.shutdown();\r\n\t}\r\n}\r\n```\r\n\r\n``` output\r\nWindows 10 Pro - started at Fri Aug 06 22:54:39 KST 2021\r\n시스템 안정화 수행\r\nDELL 작업 수행\r\n시스템 프로세스 정리 수행\r\nWindows 10 Pro - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n\r\nUbuntu 21.04 - started at Fri Aug 06 22:54:39 KST 2021\r\nASUS 작업 수행\r\nUbuntu 21.04 - shutdown at Fri Aug 06 22:54:39 KST 2021\r\n```\r\n\r\n`Asus`와 `Dell`의 메소드를 순서대로 수행하면 위와 같은 결과가 나온다. `Dell`의 시작, 종료 간 시스템 동작이 수행됨을 확인할 수 있다.\r\n\r\n# 정리\r\n\r\n객체지향은 모든 객체의 모듈화를 추구한다. 좋은 모듈화는 <span class=\"amber-400\">캡슐화</span>, <span class=\"amber-400\">은닉화</span>가 적절히 구현되고 유지되는 것을 지향한다.\r\n\r\n하지만 포장이 견고하면 뜯기 어렵듯이, 탄탄한 모듈화는 모듈이 경직된다. 재사용의 범위가 제한되는 것 뿐만 아니라, 이를 이용한 확장 또한 어려울 것이다. 만약 객체지향에 이 두 개념만 있었다면 개발자는 재사용성과 모듈화를 적절히 타협하며 객체를 구현했을 것이다.\r\n\r\n하지만 상속이라는 개념의 존재로 인해 객체에 지정된 모듈화를 전혀 해치지 않으면서 재사용성, 확장성을 보장받을 수 있다. 객체지향의 모듈화로 인한 딜레마를 상쇄하는 키치한 개념이 아닐 수 없다. 개인적으로는 객체지향의 특징 중 가장 중요한 특징이라고 생각한다. 물론 객체지향 중에서도 매우 어려운 개념이지만, 이를 잘 이해하면 조금 더 객체지향다운 코드를 짤 수 있을 것이다.","url":["2021-08-11-inheritance","2021","08","11","inheritance"]}],"categories":{"All":{"count":68,"flag":true},"RaspberryPi":{"count":6,"flag":true},"Ubuntu":{"count":1,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.gif","celeb10.gif","celeb11.gif","celeb12.gif","celeb13.gif","celeb14.gif","celeb15.gif","celeb16.gif","celeb2.gif","celeb3.gif","celeb4.gif","celeb5.gif","celeb6.gif","celeb7.gif","celeb8.gif","celeb9.gif","city1.gif","city10.gif","city11.gif","city12.gif","city13.gif","city14.gif","city15.gif","city2.gif","city3.gif","city4.gif","city4.jpg","city5.gif","city6.gif","city7.gif","city8.gif","city9.gif","code1.gif","code2.gif","code3.gif","funk1.gif","funk2.gif","funk3.gif","funk4.gif","funk5.gif","funk6.gif","game1.gif","signal.gif"],"tag":"추상","page":1,"hash":"96e5598e3c3"},"__N_SSG":true}