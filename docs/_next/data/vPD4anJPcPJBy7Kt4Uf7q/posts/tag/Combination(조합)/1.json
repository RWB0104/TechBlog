{"pageProps":{"posts":[{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1010번 다리 놓기","excerpt":"재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T14:14:09","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Combination(조합)","SILVER","SILVER V"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1010.md","content":"\r\n# 다리 놓기\r\n\r\n|                            랭크                            |                                                      사용 언어                                                      |\r\n| :--------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/6.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1010번 문제](https://www.acmicpc.net/problem/1010)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|  0.5초   |    128MB    |\r\n\r\n## 문제\r\n\r\n재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 <span class=\"primary\">사이트</span>라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 $N$개의 사이트가 있고 동쪽에는 $M$개의 사이트가 있다는 것을 알았다. $(N ≤ M)$\r\n\r\n재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. <span class=\"red-600\">(이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.)</span> 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 ($N$개) 다리를 지으려고 한다. <span class=\"red-600\">다리끼리는 서로 겹쳐질 수 없다</span>고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.\r\n\r\n![image](https://www.acmicpc.net/upload/201003/pic1.JPG)\r\n\r\n## 입력\r\n\r\n입력의 첫 줄에는 테스트 케이스의 개수 $T$가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 $N$, $M$ $(0 < N ≤ M < 30)$이 주어진다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n3\r\n2 2\r\n1 5\r\n13 29\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1\r\n5\r\n67863915\r\n```\r\n\r\n# 풀이\r\n\r\n규칙을 정리하면 아래와 같다.\r\n\r\n1. $N$구역에서 $M$구역으로 다리를 건설한다.\r\n2. $N <= M$이다.\r\n3. 사이트 당 연결된 다리는 하나다.\r\n4. 다리끼리는 서로 겹쳐서 연결되면 안 된다.\r\n\r\n1000번 부터 문제 풀면서, [1007번 벡터](/posts/2021/06/09/a1007)로 인해 조합이라는 키워드를 쉽게 연상할 수 있었다. 문제에서 $N$구역에서 $M$구역으로 다리를 건설한다고 서술하므로 $N$을 기준으로 생각하기 쉽다. 반대로 $M$을 기준으로 생각하면 해결의 실마리가 보인다. $M$구역의 사이트에서 $N$구역의 사이트 갯수만큼 연결할 사이트에 대한 조합을 계산하면 되기 때문.\r\n\r\n예를 들어 $N$구역에 3개의 사이트가 있고, $M$구역에 5개의 사이트가 있다고 가정하자.\r\n\r\n| 구분  | $M_1$ | $M_2$ | $M_3$ | $M_4$ | $M_5$ |\r\n| :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   O   |   O   |   O   |       |       |\r\n|   2   |   O   |   O   |       |   O   |       |\r\n|   3   |   O   |   O   |       |       |   O   |\r\n|   4   |   O   |       |   O   |   O   |       |\r\n|   5   |   O   |       |   O   |       |   O   |\r\n|   6   |   O   |       |       |   O   |   O   |\r\n|   7   |       |   O   |   O   |   O   |       |\r\n|   8   |       |   O   |   O   |       |   O   |\r\n|   9   |       |   O   |       |   O   |   O   |\r\n|  10   |       |       |   O   |   O   |   O   |\r\n\r\n총 10개의 경우의 수가 존재한다. 이는 $_5C_3$의 계산 결과와 일치한다.\r\n\r\n$$\r\n_5C_3 = \\frac{5!}{3! \\times 2!} = \\frac{5 \\times 4 \\times 3 \\times 2 \\times 1}{(3 \\times 2 \\times 1) \\times (2 \\times 1)} = \\frac{5 \\times 4}{2 \\times 1} = 10\r\n$$\r\n\r\n> ❓ **숫자가 왜 감탄(!)을 하죠?**  \r\n> Factorial(팩토리얼) 연산자로 $n! = n \\times (n - 1) \\times (n - 2) \\times ... \\times 1$과 같은 형태로 연산한다.\r\n\r\n더도말고 덜도말고 조합 알고리즘을 설계하면 된다. 조합의 요소를 반환할 필요 없이, 조합의 갯수만 구하면 되므로 [1007번 벡터](/posts/2021/06/09/a1007)문제보다 더 간단하다.\r\n\r\n## Gotta Go FAST!\r\n\r\n무턱대로 위 식으로 조합 알고리즘을 짜면 <span class=\"red-A400\">시간 초과</span> 오류를 볼 수 있다. 그도 그럴 것이, 원리 자체는 쉽지만 시간제한이 0.5s로 매우 짧기 때문. $M$의 값이 최대 30이므로, 최대 $30!$에 대한 연산을 수행해야하기 때문이다. 그러므로 <span class=\"blue-A400\">Memoization(메모이제이션)</span>이라는 최적화를 적용해야 한다.\r\n\r\n> ❓ **Memoization(메모이제이션)이란?**  \r\n> 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장해놓고 필요 시 사용하여 반복적인 연산 작업을 제거하는 기술.\r\n\r\n조합을 재귀적으로 표현하면 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\n_nC_r = _{n-1}C_{r-1} + _{n-1}C_r\r\n$$\r\n\r\n아래의 그림을 보면 이해하기 쉽다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121479130-b036e680-ca04-11eb-96ed-620c4fc3086a.png)\r\n\r\n만약, $_5C_3$을 연산한다면 아래와 같이 진행된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121479160-b6c55e00-ca04-11eb-97da-a4708798a715.png)\r\n\r\n이 중, $_3C_2$의 경우 $_4C_2$, $_4C_3$을 계산할 때 필요하므로 여러번 호출된다. 만약, 메모이제이션이 적용되지 않았다면, $_3C_2$이 필요할 때마다 1에서부터 다시 연산해야한다. $_{30}C_{14}$와 같이 숫자가 커지면 위 그림의 깊이도 깊어지기 때문에 많은 오버헤드가 발생한다.\r\n\r\n만약 이렇게 연산된 값을 버리지 않고 메모리상에 저장한 뒤 쓸 수 있다면 연산에서 엄청난 이점이 발생한다. $_3C_2$을 이미 저장했다면 $_4C_2$, $_4C_3$을 계산할 때 저장된 $_3C_2$을 즉시 꺼내 사용할 수 있다. 복잡한 연산을 건너뛸 수 있으며, 동일한 값이 여러번 호출되도 상관없다.\r\n\r\n해당 문제의 조합 알고리즘의 연산에서 한 번 연산된 값을 임의의 배열에 저장하여 이를 활용하면 0.5초라는 짧은 시간을 충족할 수 있을 것이다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1010 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/09/a1010\">1010 풀이</a>\r\n * @since 2021.06.09 Tue 14:14:09\r\n */\r\npublic class Main\r\n{\r\n\t// 다리 건설 경우의 수\r\n\tprivate static final int[][] dp = new int[31][31];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\r\n\t\t\tint N = Integer.parseInt(temp[0]);\r\n\t\t\tint M = Integer.parseInt(temp[1]);\r\n\t\t\t\r\n\t\t\tSystem.out.println(combination(M, N));\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 결과 반환 함수\r\n\t *\r\n\t * @param n: [int] 원소 갯수\r\n\t * @param r: [int] 조합 갯수\r\n\t *\r\n\t * @return [int] 조합\r\n\t */\r\n\tprivate static int combination(int n, int r)\r\n\t{\r\n\t\t// 이미 계산된 값일 경우\r\n\t\tif (dp[n][r] > 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r];\r\n\t\t}\r\n\t\t\r\n\t\t// 원소의 갯수가 조합의 갯수와 동일하거나 0일 경우\r\n\t\telse if (n == r || r == 0)\r\n\t\t{\r\n\t\t\treturn dp[n][r] = 1;\r\n\t\t}\r\n\t\t\r\n\t\t// 일반적인 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn dp[n][r] = combination(n - 1, r - 1) + combination(n - 1, r);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$dp[n][r]$는 int형 배열이므로 기본값이 0이다. 즉, $dp[n][r] > 0$일 경우 $_nC_r$가 이미 계산되었다는 뜻이므로, 이미 저장된 값을 반환한다.\r\n\r\n$_5C_0$, $_5C_5$와 같이 $_nC_0$, $_nC_n$일 경우 그 값은 1이다. 해당 케이스의 경우 1을 반환한다. (전체를 선택하거나, 아무것도 선택하지 않는 방법은 하나뿐이다.)\r\n\r\n나머지 일반적인 경우 $_nC_r$의 재귀적 표현 방식인 $_{n-1}C_{r-1} + _{n-1}C_{r}$을 적용하면 된다.\r\n\r\n또한 $dp$ 이차원 배열은 31행렬로 초기화되는데, 그 이유는 $dp$의 행렬이 되는 $N$과 $M$의 최대값이 30이기 때문. 배열은 인덱스가 0부터 시작하므로 1을 더해야 한다.\r\n\r\n또한 케이스별로 $dp$를 초기화하지 않는데, 이는 <span class=\"green-A400\">조합이 범용적이므로 재사용이 가능하기 때문</span>이다. 1번 케이스나 100번 케이스나 $_5C_3$의 값은 10이다. 따라서 초기화를 하지 않으면 오히려 이전 케이스에서 계산했던 내용을 그대로 사용할 수 있어서 이득이다. 만약 첫 번째 케이스에서 $_{30}C_{12}$와 같이 큰 수를 계산했다면, 이후 케이스의 $_{12}C_{5}$와 같은 모든 하위 조합들은 연산을 통째로 건너뛸 수도 있을 것이다.\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 다이나믹 프로그래밍\r\n* 조합론","url":["2021-06-09-a1010","2021","06","09","a1010"]},{"header":{"title":"[백준 / JAVA] 백준 알고리즘 1007번 벡터","excerpt":"평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다. V에 있는 벡터의 갯수는 P에 있는 점의 절반이다. 평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-09T00:50:26","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","Brute Force(무차별 대입 공격)","Combination(조합)","GOLD","GOLD II"],"group":"백준 알고리즘","comment":true,"publish":true},"name":"2021-06-09-a1007.md","content":"\r\n# 습격자 초라기\r\n\r\n|                            랭크                             |                                                      사용 언어                                                      |\r\n| :---------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------: |\r\n| ![image](https://d2gd6pc034wcta.cloudfront.net/tier/14.svg) | ![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange) |\r\n\r\n🔗 [전체 1007번 문제](https://www.acmicpc.net/problem/1007)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    512MB    |\r\n\r\n## 문제\r\n\r\n평면 상에 $N$개의 점이 찍혀있고, 그 점을 집합 $P$라고 하자. 집합 $P$의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 $P$의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, $P$에 속하는 모든 점은 한 번씩 쓰여야 한다.\r\n\r\n$V$에 있는 벡터의 갯수는 $P$에 있는 점의 절반이다.\r\n\r\n평면 상의 점이 주어졌을 때, 집합 $P$의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.\r\n\r\n## 입력\r\n\r\n첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.\r\n\r\n테스트 케이스의 첫째 줄에 점의 갯수 $N$이 주어진다. $N$은 짝수이다. 둘째 줄부터 $N$개의 줄에 점의 좌표가 주어진다. $N$은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.\r\n\r\n## 출력\r\n\r\n각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n2\r\n4\r\n5 5\r\n5 -5\r\n-5 5\r\n-5 -5\r\n2\r\n-100000 -100000\r\n100000 100000\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n0.000000000000\r\n282842.712474619038\r\n```\r\n\r\n# 풀이\r\n\r\n두 개의 점으로 하나의 벡터를 만들 수 있다. $N <= 20$이므로 주어지는 점의 최대 갯수는 20개다. $N = 20$이라고 가정하면, 만들 수 있는 벡터의 수는 그 절반인 10개다. 20개의 점을 어떻게 잇느냐에 따라서 벡터 10개를 만드는 수 많은 경우의 수가 발생한다. 이 경우의 수에서 <span class=\"red-A400\">벡터의 총합이 가장 작은 값을 계산</span>하는 게 이 알고리즘의 결과다.(10개의 벡터 중 가장 짧은 벡터를 계산하는 것이 아님에 유의하자.)\r\n\r\n이 알고리즘의 핵심은 <span class=\"green-A400\">$N$개의 원소에서 $N / 2$개의 벡터를 만들 수 있는 경우를 계산해서 최소값을 계산</span>하면 된다. $N$의 최대값이 20으로 매우 작으므로 하나하나 비교하는 것이 가능하다. 애초에 알고리즘 자체가 Brute Force(무차별 대입 공격)으로 분류돼있기도 하고.\r\n\r\n좌표 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$가 있으며, 이 좌표에서 두 벡터인 $v_1$, $v_2$를 만든다고 가정하자.(조건은 알고리즘 문제와 동일) $v_1$이 $(x_1, y_1), (x_2, y_2)$으로 이루어져 있으며, $v_2$는 $(x_3, y_3), (x_4, y_4)$로 이루어져있다고 가정하자. 각 벡터를 좌표를 통해 표현하면 아래와 같다.\r\n\r\n$$\r\nv_1 = (x_2 - x_1, y_2 - y_1)\r\n$$\r\n\r\n$$\r\nv_2 = (x_4 - x_3, y_4 - y_3)\r\n$$\r\n\r\n벡터의 합은 벡터 좌표의 단순합으로 이루어진다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/121457485-b4520c80-c9e2-11eb-8de4-660f9a86a7a1.png)\r\n\r\n즉, 벡터의 총합 $v$는 아래와 같이 표현할 수 있다.\r\n\r\n$$\r\nv = v_1 + v_2 = (x_2 + x_4 - x_1 - x_3, y_2 + y_4 - y_1 - y_3)\r\n$$\r\n\r\n$$\r\n||v|| = \\sqrt{(x_2 + x_4 - x_1 - x_3)^2 + (y_2 + y_4 - y_1 - y_3)^2}\r\n$$\r\n\r\n위 식으로 계산한 값의 최소값이 알고리즘의 해답이 된다. 즉, 우리는 $(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)$을 조건에 맞게 조합해야한다. 각 조합의 $||v||$를 계산한 뒤, 이 중 최소값을 반환하면 될 것 같다.\r\n\r\n무턱대고 10개의 벡터를 for문 돌려가며 하나하나 만드는 방법은 안 된다. 좀 더 효율적으로 벡터를 계산하는 방법을 생각해보자.\r\n\r\n$v$식을 자세히 보면 쓸만한 특징일 하나 찾을 수 있는데, 각각의 좌표 $x$, $y$를 계산할 때 좌표의 절반은 더해지고, 절반은 빼진다. 좌표가 4개일 경우 2개는 더해지고, 나머지 2개는 빼진다. 만약 10개라면? 5개는 더해지고, 5개는 빼질 것이다.\r\n\r\n이를 활용하면 전체 좌표 $N$의 절반인 $N / 2$만큼의 좌표 조합을 구한다면 어떨까? 반은 더해지는 좌표, 나머지 반은 빼지는 좌표로 구분할 수 있다. 이후 각 좌표를 더하고 빼주면 손쉽게 $||v||$를 계산할 수 있을 것이다.\r\n\r\n따라서, 점을 반으로 나누어 <span class=\"green-A400\">양의 연산에 사용할 점과 음의 연산에 사용될 점의 경우의 수를 구하는 것이 이번 알고리즘의 핵심</span>이다. $_nC_r$(조합, Combination)을 사용하면 이를 쉽게 구할 수 있을 겻이다. $_nC_{(n / 2)}$를 계산하여, 선택된 좌표는 더하고, 선택되지 않은 좌표는 뺀다.\r\n\r\n예제 1의 $_4C_2$의 경우의 수는 아래와 같다.\r\n\r\n|     양의 좌표     |     음의 좌표     |   $v$    | $\\Vert v \\Vert$ |\r\n| :---------------: | :---------------: | :------: | :-------------: |\r\n|  (5, 5), (5, -5)  | (-5, 5), (-5, -5) | (20, 0)  |       20        |\r\n|  (5, 5), (-5, 5)  | (5, -5), (-5, -5) | (0, 20)  |       20        |\r\n| (5, 5), (-5, -5)  | (5, -5), (-5, 5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, 5)  | (5, 5), (-5, -5)  |  (0, 0)  |        0        |\r\n| (5, -5), (-5, -5) |  (5, 5), (-5, 5)  | (0, -20) |       20        |\r\n| (-5, 5), (-5, -5) |  (5, 5), (5, -5)  | (-20, 0) |       20        |\r\n\r\n위와 같은 이유로 예제 1에서 벡터 총합의 최소값은 0이 된다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\n/**\r\n * 백준 전체 1007 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see <a href=\"https://blog.itcode.dev/posts/2021/06/09/a1007\">1007 풀이</a>\r\n * @since 2021.06.09 Tue 00:50:26\r\n */\r\npublic class Main\r\n{\r\n\t// 결과\r\n\tprivate static double result;\r\n\t\r\n\t// 조합 선택 여부\r\n\tprivate static boolean[] isChecked;\r\n\t\r\n\t// 점의 배열\r\n\tprivate static int[][] P;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\t// 케이스 수\r\n\t\tint T = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tfor (int i = 0; i < T; i++)\r\n\t\t{\r\n\t\t\t// 점의 갯수\r\n\t\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\t\r\n\t\t\tresult = Double.MAX_VALUE;\r\n\t\t\t\r\n\t\t\tisChecked = new boolean[N];\r\n\t\t\t\r\n\t\t\tP = new int[N][2];\r\n\t\t\t\r\n\t\t\tfor (int j = 0; j < N; j++)\r\n\t\t\t{\r\n\t\t\t\tString[] temp = reader.readLine().split(\" \");\r\n\t\t\t\t\r\n\t\t\t\tP[j][0] = Integer.parseInt(temp[0]);\r\n\t\t\t\tP[j][1] = Integer.parseInt(temp[1]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcombination(0, N / 2);\r\n\t\t\t\r\n\t\t\tSystem.out.println(result);\r\n\t\t}\r\n\t\t\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 조합 함수\r\n\t *\r\n\t * @param index: [int] 인덱스\r\n\t * @param count: [int] 조합할 원소 갯수\r\n\t */\r\n\tprivate static void combination(int index, int count)\r\n\t{\r\n\t\t// 조합할 원소 갯수가 더 이상 없을 경우\r\n\t\tif (count == 0)\r\n\t\t{\r\n\t\t\tresult = Math.min(result, getVector());\r\n\t\t}\r\n\t\t\r\n\t\t// 조합할 원소 갯수가 아직 남아있을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = index; i < P.length; i++)\r\n\t\t\t{\r\n\t\t\t\tisChecked[i] = true;\r\n\t\t\t\t\r\n\t\t\t\tcombination(i + 1, count - 1);\r\n\t\t\t\t\r\n\t\t\t\tisChecked[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 벡터 계산 함수\r\n\t *\r\n\t * @return [double] 벡터 크기\r\n\t */\r\n\tprivate static double getVector()\r\n\t{\r\n\t\tint x = 0;\r\n\t\tint y = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i < P.length; i++)\r\n\t\t{\r\n\t\t\t// 양수로 선택된 점일 경우\r\n\t\t\tif (isChecked[i])\r\n\t\t\t{\r\n\t\t\t\tx += P[i][0];\r\n\t\t\t\ty += P[i][1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 음수로 선택된 점일 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tx -= P[i][0];\r\n\t\t\t\ty -= P[i][1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n\t}\r\n}\r\n```\r\n\r\n## 분류\r\n\r\n* 수학\r\n* 브루트포스 알고리즘","url":["2021-06-09-a1007","2021","06","09","a1007"]}],"categories":{"All":{"count":70,"flag":true},"Ubuntu":{"count":2,"flag":true},"RaspberryPi":{"count":7,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.webm","celeb10.webm","celeb11.webm","celeb12.webm","celeb13.webm","celeb14.webm","celeb15.webm","celeb16.webm","celeb2.webm","celeb3.webm","celeb4.webm","celeb5.webm","celeb6.webm","celeb7.webm","celeb8.webm","celeb9.webm","city1.webm","city10.webm","city11.webm","city12.webm","city13.webm","city14.webm","city15.webm","city2.webm","city3.webm","city4.webm","city5.webm","city6.webm","city7.webm","city8.webm","city9.webm","code1.webm","code2.webm","code3.webm","funk1.webm","funk2.webm","funk3.webm","funk4.webm","funk5.webm","funk6.webm","game1.webm","signal.webm"],"tag":"Combination(조합)","page":1,"hash":"f1814897788"},"__N_SSG":true}