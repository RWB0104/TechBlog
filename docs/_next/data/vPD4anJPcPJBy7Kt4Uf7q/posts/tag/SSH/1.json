{"pageProps":{"posts":[{"header":{"title":"[Ubuntu] Ubuntu 원격 프로토콜 보안 강화하기","excerpt":"SSH, SFTP와 같은 원격 프로토콜은 서버의 접근성을 향상시켜주지만, 서버의 보안성을 극도로 훼손한다. 공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다. 따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다. 외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/133300948-2ee9b77a-1589-4afc-8489-fb402a13520f.png","date":"2021-09-15T01:53:21","type":"posts","category":"Ubuntu","tag":["Ubuntu","SSH","SFTP"],"comment":true,"publish":true},"name":"2021-09-15-increase-ubuntu-remote-security.md","content":"\r\n# 개요\r\n\r\nSSH, SFTP와 같은 원격 프로토콜은 <span class=\"green-600\">서버의 접근성을 향상</span>시켜주지만, <span class=\"red-600\">서버의 보안성을 극도로 훼손</span>한다.\r\n\r\n공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다.\r\n\r\n따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다.\r\n\r\n외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.\r\n\r\n단순히 재미삼아 내가 접속한 도메인에 접속시도를 하는 어중이떠중이들도 있겠지만, 그 중 몇몇은 공격자로 취급할 수 있을 정도의 실력을 가지기도 하며, 그 중에서도 극소수의 몇몇은 내 서버의 보안을 우회할 수 있을 정도의 실력을 가지고 있을 수도 있다.\r\n\r\n서버의 특성 상 여러 내부 시스템 및 네트워크와 연결되어 있으므로, 서버가 뜷리는 것은 그 서버와 연관된 각종 정보들의 안전을 보장할 수 없음을 의미한다. 심지어 <span class=\"red-600\">항상 최상의 보안대책을 강구하는 기업에서조차 피해를 입기도 한다.</span> 우스갯소리로 이미 대다수의 자국민 주민등록번호는 인터넷에 나뒹굴고 있을거라고 얘기하기도 할 정도니.\r\n\r\n기업처럼 높은 수준의 보안과 수준에 맞는 지식을 가진 담당자가 있을 경우 피해 확인 및 보완이라도 할 수 있겠지만, 보안에 무감각하거나 관련 지식이 미흡한 <span class=\"orange-400\">소규모 사업장이나 개인의 경우 자신의 서버가 피해를 입었다는 사실조차 인지하지 못 하기도 한다.</span> 심할 경우 서버 관리조차 이루어지지 않아 공격자의 개인 서버로 사용되기까지 한다.\r\n\r\n그 어떤 보안대첵을 강구해도 보안은 언제나 부족하다. 하지만 간단한 조치만으로도 앞서 언급한 위협의 상당부분을 차단할 수 있다. 말했듯이 대부분은 공격자라고 부르기도 뭐한 장난섞인 시도이며, <span class=\"blue-400\">상대적으로 낮은 가치의 데이터가 대다수인 개인 서버가 일정 수준의 보안을 갖추고 있을 경우 이를 우회하는 것은 시간낭비</span>이기 때문이다.\r\n\r\n간단히 말해 여러분이 게임을 하는데 체력은 많고 패턴도 귀찮은데다, 보상은 잡몹 수준인 보스가 있다고 가정하자. 해당 구간에 도달할 때마다 한숨만 나올 것이며, 게임 커뮤니티엔 해당 보스를 삭제해달라는 요구가 빗발칠 것이다. 유튜브를 보다보면 인기 급상승 5위로 올라온 \"역대 최악의 게임 보스 TOP 10\" 영상에 당당히 이름이 올라가있다. 또한 DC의 해당 게임 갤러리나 인벤에선 그 보스의 이름을 비하의 의미로 사용하고 있을 것이며, 해당 보스를 스킵할 수 있는 각종 연구들이 활발하게 진행되고 있을 것이다.\r\n\r\n이 장에선 우리의 서버를 이런 \"<span class=\"pink-600\">보상은 없고 패턴은 귀찮은 체력돼지</span>\" 보스로 만들어 공격자들이 드러워서 피하도록 만들어 볼 것이다.\r\n\r\n# 서비스 포트 변경하기\r\n\r\n파일 시스템에 직접적으로 영향을 주는 통신은 <span class=\"primary\">SSH</span>, <span class=\"primary\">SFTP</span>가 존재한다. 각 프로토콜의 전신인 Telnet과 FTP는 SSL의 미적용으로 OS 설치 시 비활성화 되어있다. 굳이 해당 프로토콜을 쓸 이유조차 없으니, 여기서는 논외로 한다.\r\n\r\n각 서비스 포트는 동일하게 SSH 데몬에서 관리하므로 22다. 기본 프로토콜의 포트는 기본 포트가 고정적이므로, 대부분의 공격 시도는 이런 불변성을 악용하여 이루어진다. 반대로 말하자면, <span class=\"green-600\">서비스 포트를 변경하는 것만으로도 간단한 공격 시도를 손쉽게 차단</span>할 수 있다.\r\n\r\n기본으로 설정된 포트와 달리, 서버 담당자가 임의로 바꾼 포트는 추적할 방법이 없기 때문. 포트의 최대값은 65,535개이므로, 임의의 포트로 변경했다면 공격자는 모든 포트에 통신을 시도하여 SSH 포트를 찾아내야만 한다.\r\n\r\nSSH와 SFTP의 서비스 포트를 변경하거나, `iptables`이나 공유기 설정을 통해 포트포워딩을 시켜 임의의 외부 포트와 22번 포트를 매칭시켜줄 수도 있다.\r\n\r\n## 서비스 포트 변경을 통한 접근 제어\r\n\r\n``` bash\r\nsudo vi /etc/ssh/sshd_config\r\n```\r\n\r\n파일 내용을 보면 `#Port 22`로 주석처리된 구문을 확인할 수 있는데, 해당 주석을 제거하여 원하는 포트로 입력해준 뒤 저장하면 된다.\r\n\r\n``` bash\r\nsystemctl restart ssh\r\n```\r\n\r\nSSH 서비스를 재시작함을 잊지 말자.\r\n\r\n## 포트포워딩을 통한 접근 제어\r\n\r\nSSH의 포트 변경이 꺼려진다면, 포트포워딩을 통해 외부에서 접속하는 임의의 포트 하나와 매칭하자. `iptables`를 활용하여 구성할 수 있다.\r\n\r\n``` bash\r\n# 포트포워딩 추가\r\niptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port [PORT NUMBER]\r\n\r\n# 포트포워딩 삭제\r\niptables -t nat -D PREROUTING -p tcp --dport 22 -j REDIRECT --to-port [PORT NUMBER]\r\n\r\n# 포트포워딩 상태 확인\r\niptables -L\r\n```\r\n\r\n공유기를 사용하고 있다면 공유기에서 포트포워딩을 진행할 수도 있다.\r\n\r\n`iptables`를 활용하면 특정 IP만 해당 포트에 접근할 수 있도록 제한할 수도 있다. <span class=\"primary\">geoIP</span> 플러그인과 연동하면 국가별 IP 대역별로 관리할 수도 있으니, 관심이 있다면 찾아보길 바란다. 적용이 마냥 간단하지는 않으니 참고할 것.\r\n\r\n# RSA Key 파일로만 접근 허용하기\r\n\r\n공격자가 꽤나 근성이 있어서, 혹은 운이 좋아서 내가 임의로 변경한 SSH 서비스 포트를 알아내어 공격을 시도한다고 가정해보자.\r\n\r\n계정정보의 경우 보통 Brute Force 기법을 통해 가능한 모든 조합의 계정정보를 입력하여 로그인을 시도할 것이다. 이를 막기 위해 일정량의 <span class=\"blue-400\">로그인 실패가 감지되면 잠시 동안 접근을 제한</span>하거나, <span class=\"blue-400\">계정을 잠궈 관리자가 해제해야 다시 활성화</span>되게끔 시스템을 구성하기도 한다.\r\n\r\n위 방법도 충분히 좋은 방법이지만, 오로지 <span class=\"blue-600\">RSA Key로만 로그인할 수 있도록 서버 설정을 구성</span>하면 로그인의 보안을 대폭 강화할 수 있다.\r\n\r\n내가 사용자의 계정정보, 심지어 비밀번호까지 알고 있더라도 <span class=\"amber-600\">서버에 등록된 공개키와 매칭되는 개인키가 없을 경우 로그인을 시도할 수 없다.</span>\r\n\r\n<br />\r\n\r\n절차는 아래와 같다.\r\n\r\n1. RSA 키쌍 생성\r\n2. 서버에 공개키 등록\r\n3. SSH, SFTP 프로토콜 접속 시 개인키 파일을 제공하여 로그인 수행\r\n\r\nRSA 키 생성 시 키 파일에 암호를 설정할 수 있다. 이 경우, 로그인 시 해당 키 파일에 설정된 비밀번호를 요구한다. 키 파일의 비밀번호는 서버의 계정정보와 별개이므로, 키 파일이 유출되었다 하더라도 키 파일의 사용을 막아 실질적인 피해를 방지할 수 있다.\r\n\r\n## RSA 키쌍 생성하기\r\n\r\n``` bash\r\nssh-keygen -t rsa\r\n```\r\n\r\n위 명령어를 사용하여 <span class=\"indigo-400\">RSA 비대칭키를 생성</span>하자. 생성 과정에서 키 파일의 비밀번호를 요구하는데, 빈 칸인 채로 Enter를 누르면 비밀번호 없이 생성된다. 이 경우, 키 파일만 획득하면 키 파일을 사용할 수 있다. 반대로 비밀번호를 입력하면 해당 키 파일을 사용하기 위해 지정한 비밀번호를 입력하여 디코딩해야한다.\r\n\r\n* 개인키 `/home/username/.ssh/id_rsa`\r\n* 공개키 `/home/username/.ssh/id_rsa.pub`\r\n\r\n기본적으로 위 경로에 바로 생성된다.\r\n\r\n## RSA 키를 서버에 등록하기\r\n\r\n``` bash\r\nssh-copy-id username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n위 명령어를 입력하여 <span class=\"indigo-400\">키 파일을 서버에 등록</span>하자. `/home/username/.ssh/id_rsa.pub`를 자동으로 등록한다.\r\n\r\n## 키 파일로 SSH 접속하기\r\n\r\n``` bash\r\nssh -i [PRIVATE KEY] username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n위 명령어를 입력하여 SSH를 접속할 수 있다. `-i` 옵션으로 개인키 경로를 입력할 수 있다. 키 생성 시 비밀번호를 입력했다면 비밀번호 입력이 필요하며, 따로 생성하지 않았을 경우 즉시 로그인이 된다.\r\n\r\n### 저 Windows에서 쓰고있는데, 개인키 사용시 오류떠요!\r\n\r\n아마 대부분 Ubuntu에서 RSA 키를 생성하고, 생성한 개인키를 Windows로 전송하여 SSH 접근하는데 사용할 것이다.\r\n\r\n``` output\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\nPermissions for 'C:\\\\id_rsa' are too open.\r\nIt is required that your private key files are NOT accessible by others.\r\nThis private key will be ignored.\r\nLoad key \"C:\\\\id_rsa\": bad permissions\r\n```\r\n\r\n하지만 막상 Windows에서 키 파일 사용 시, 키 파일이 너무 많은 유저에게 허용되면 보안 상의 이유로 키 파일의 사용을 제한한다. 해결책은 하나다. 해당 키 파일을 사용할 유저에게만  권한을 부여해주면 된다.\r\n\r\n문제는 Windows의 편의성으로 인해, 파일 전송 완료 시 필요한 권한을 자동으로 부여해주기 때문에, 수동으로 제거해야한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/133301005-c4c5a2df-f878-4ff5-8dc0-63366e28b59b.png)\r\n\r\n키 파일의 [속성] - [보안] 탭에서 파일에 부여된 접근권한을 확인할 수 있다. 보다시피 현재는 너무 많은 사용자에게 접근이 허가되어 있으므로, 오직 나만 접근할 수 있도록 변경한다. 안타깝게도 파일에 상속이 적용되어있어서 그냥 삭제되지 않는다. 하단의 [고급] 탭을 누르자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/133299523-ec1af2cc-44e2-4b39-b5ae-d7e04425500f.png)\r\n\r\n하단의 [상속 사용 안 함] 버튼을 클릭하여 상속 관계를 제거한다. 메시지 하나가 뜰텐데, [명시적 사용 권한으로 변환]을 선택한다. 제거하면 사용자를 직접 지정해야해서 번거롭다.\r\n\r\n이후 내 계정을 제외한 모든 권한 항목은 제거한다. 이후 저장하고 다시 시도하면 정상적으로 로그인을 수행할 수 있다.\r\n\r\n\r\n# SSH 접근 시 키 파일 방식만 허용하기\r\n\r\n여기까지 왔다면 로그인은 잘 됐다는 뜻인데, 키 파일로 로그인할 수 있는 건 좋지만, <span class=\"red-400\">문제는 그냥 계정 정보를 입력해도 로그인이 된다.</span>\r\n\r\n이래서야 키 파일의 높은 보안성을 활용하기 어렵다. 로그인 시 반드시 <span class=\"blue-400\">키 파일 로그인만을 허용</span>하여, 내 서버의 개인키를 가진 인원만 접속할 수 있도록 제한해보자.\r\n\r\n<p class=\"red-600\">※ 무턱대고 설정했다간 본인조차 SSH에 접속하지 못하는 상황이 생기기도 하니 주의할 것</p>\r\n\r\n``` bash\r\nsudo vi /etc/ssh/sshd_config\r\n```\r\n\r\nSSH 설정 파일을 열어 아래의 값을 수정하자. <span class=\"green-400\">비밀번호 입력 로그인 방식을 사용하지 않도록 설정</span>하는 것이다.\r\n\r\n* `PasswordAuthentication yes` -> `PasswordAuthentication no`\r\n\r\n``` bash\r\nsystemctl restart ssh\r\n```\r\n\r\n재부팅 후 로그인을 수행해보자.\r\n\r\n``` bash\r\n# 일반 로그인 방식의 SSH\r\nssh username@xxx.xxx.xxx.xxx\r\n\r\n# 키 파일 방식의 SSH\r\nssh -i [PRIVATE KEY] username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n일반로그인은 계정 정보를 제대로 입력했다 하더라도 로그인에 실패할 것이다.\r\n\r\n# 정리\r\n\r\nSSH와 SFTP를 반드시 개인키로만 로그인할 수 있도록 구성을 변경했다.\r\n\r\n생각보다 간단한 수준의 보안 작업이라도, 실제로 이루어지는 공격의 대다수를 무력화시킬 수 있다.\r\n\r\n키를 통해 더욱 안전하게 서버의 보안을 지킬 수 있지만, 키 파일을 분실하지 않도록 주의하자.","url":["2021-09-15-increase-ubuntu-remote-security","2021","09","15","increase-ubuntu-remote-security"]},{"header":{"title":"[라즈베리파이 4] 원격 환경 구축하기 (SSH, RDP)","excerpt":"이제 얼추 라즈베리파이에 그럴듯한 웹서버 환경이 구축됐다. 하지만 라즈베리파이를 다루기 위해서 기기에 직접 모니터랑 키보드, 마우스를 연결해서 쓰긴 좀 번거롭다. 이 주제에서의 라즈베리파이는 어디까지나 서브로 운영되는 웹서버이므로, 메인 컴퓨터가 될 수 없다. 즉, 개발같은 대부분의 작업은 메인 컴퓨터에서 진행하고, 배포만 서버가 담당하는 방식이다. 이렇게 디바이스가 서로 나뉠 경우, 두 디바이스의 접근이 서로 원활해야한다. 한 마디로, 원격 환경이 필요하다. 이 장에서는 라즈베리파이에 원격 환경을 구축한다. SSH, RDP 통신을 구축함으로써 SSH 혹은 윈도우 PC 어디에서나 라즈베리파이에 접근할 수 있도록 구성한다.","coverImage":"https://user-images.githubusercontent.com/50317129/131238727-666f2aaa-d759-4f62-af73-3856086da73d.png","date":"2021-09-08T22:40:38","type":"posts","category":"RaspberryPi","tag":["라즈베리파이","Ubuntu","SSH","RDP"],"group":"라즈베리파이","comment":true,"publish":true},"name":"2021-09-08-raspberry-remote.md","content":"\r\n# 개요\r\n\r\n이제 얼추 라즈베리파이에 그럴듯한 웹서버 환경이 구축됐다. 하지만 라즈베리파이를 다루기 위해서 기기에 직접 모니터랑 키보드, 마우스를 연결해서 쓰긴 좀 번거롭다.\r\n\r\n이 주제에서의 라즈베리파이는 어디까지나 서브로 운영되는 웹서버이므로, 메인 컴퓨터가 될 수 없다. 즉, 개발같은 대부분의 작업은 메인 컴퓨터에서 진행하고, 배포만 서버가 담당하는 방식이다. 이렇게 디바이스가 서로 나뉠 경우, 두 디바이스의 접근이 서로 원활해야한다.\r\n\r\n한 마디로, 원격 환경이 필요하다. 이 장에서는 <span class=\"amber-600\">라즈베리파이에 원격 환경을 구축</span>한다. <span class=\"primary\">SSH</span>, <span class=\"primary\">RDP</span> 통신을 구축함으로써 SSH 혹은 윈도우 PC 어디에서나 라즈베리파이에 접근할 수 있도록 구성한다.\r\n\r\n# SSH 환경 구축하기\r\n\r\n<span class=\"primary\">SSH(Secure SHell)</span>는 네트워크에 연결된 PC에 로그인하여 원격 PC에서 해당 PC로 명령어를 실행하는 등의 Shell 통신을 수행하는 프로토콜이다.\r\n\r\nSSH 환경을 구축하여 원격으로 Ubuntu Shell에 접근할 수 있다. 이를 통해 원격으로 명령어를 입력하여 Ubuntu를 다룰 수 있다. Windows와 달리 Linux는 거의 모든 프로그램이 명령어 기반으로 동작하므로 어려움없이 Ubuntu를 다룰 수 있다.\r\n\r\n## 준비물\r\n\r\n* openssh-server 패키지\r\n* SSH(22) 서비스 포트 개방\r\n\r\n## OpenSSH Server 패키지 설치\r\n\r\nOpenSSH 패키지는 크게 두 가지가 있는데, 하나는 OpenSSH Client, 다른 하나는 OpenSSH Server다.\r\n\r\n* <span class=\"teal-500\">OpenSSH Server</span> - 해당 OS에 SSH 서비스 환경을 구축함\r\n* <span class=\"teal-500\">OpenSSH Client</span> - 타 PC의 SSH 접속 기능을 추가함\r\n\r\nOpenSSH Server를 설치하여 Ubuntu에 SSH에 접근할 수 있도록 환경을 구성하자.\r\n\r\n``` bash\r\nsudo apt-get install -y openssh-server\r\n```\r\n\r\n설치후 추가로 해야할 작업은 없다.\r\n\r\n## 포트 개방\r\n\r\nSSH가 서비스되는 포트를 개방한다. 기본적으로 22번 포트를 사용한다.\r\n\r\n``` bash\r\nsudo ufw allow 22\r\n```\r\n\r\nufw를 통해 22번 포트를 개방한다.\r\n\r\n## SSH 접속하기\r\n\r\n다른 PC에서 Ubuntu로 접속해보자. Windows 혹은 다른 Linux 기반 OS 등, SSH 프로토콜을 사용할 수 있는 모든 OS 및 프로그램이라면 가능하다.\r\n\r\n``` bash\r\nssh username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n위 명령어를 통해 입력한 IP와 계정명으로 접근을 시도할 수 있다. IP는 라즈베리파이의 IP를, 계정명은 라즈베리파이의 계정명을 입력하면 된다. IP 대신 도메인을 입력해도 된다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132518427-796d71c2-7331-4a99-8d7f-65eef29344bb.png)\r\n\r\n접속정보가 유효하다면 비밀번호를 입력하여 로그인을 수행해야한다. 로그인이 완료되면 Shell에 명령어를 입력할 수 있으며, 이를 통해 원격지에서도 Ubuntu를 다룰 수 있게된다.\r\n\r\n# RDP 환경 구축하기\r\n\r\n<p class=\"red-500\" align=\"center\">※ Ubuntu에 UI가 존재하는 Ubuntu Desktop 혹은 이에 준하는 UI 패키지가 설치된 OS에만 적용 가능합니다.</p>\r\n\r\n비록 Ubuntu가 대부분의 동작을 명령어로만 처리할 수 있긴 하지만, 간혹 몇몇 작업들은 반드시 UI가 필요하기도 하다. 이를테면 브라우저로 리눅스에서의 웹 페이지를 디버깅한다던가, 동영상을 본다던가. 혹시 Oracle DBMS를 설치하고자 한다면 반드시 UI를 사용할 수 있는 환경이 필요하다.\r\n\r\n심지어 우리가 설치한 Ubuntu도 UI가 있는데, 기껏 설치한 UI는 놀리고 SSH만 쓰기도 난감하다. 물론 라즈베리파이에 HDMI를 연결해서 쓰면 된다지만, 그 것도 번거롭긴 마찬가지다.\r\n\r\n내 경우 듀얼모니터를 사용하고 있어서 여건이 나쁘진 않다. 그러나 모니터가 하나라면 라즈베리파이를 연결한 순간 원래 PC는 사용이 제한되버린다.\r\n\r\n<br />\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132518566-fb8858ce-0b0c-4483-9a84-c3dc718f3e5f.png)\r\n\r\nWindows에는 <span class=\"primary\">원격 데스크톱 연결</span>이라는 기능이 존재한다. Windows 간 원격이 가능한 기능으로써, 팀뷰어나 AnyDesk를 생각하면 된다. 일종의 내장 원격 프로그램.\r\n\r\n말로만 들어보면 왠지 Windows 간 통신만 지원할 것 같다. 필자도 그렇게 생각했었다. 하지만 Ubuntu는 내 생각 이상으로 잡다한게 많았다. xrdp 패키지를 설치하면 Windows의 RDP와 통신이 가능하다.\r\n\r\n## 준비물\r\n\r\n* xrdp 패키지\r\n* RDP(3389) 서비스 포트 개방\r\n\r\n## xrdp 패키지 설치\r\n\r\n``` bash\r\nsudo apt-get install -y xrdp\r\n```\r\n\r\n위 명령어를 입력하여 설치한다.\r\n\r\n## 포트 개방\r\n\r\nRDP가 서비스되는 포트를 개방한다. 기본적으로 3389번 포트를 사용한다.\r\n\r\n``` bash\r\nsudo ufw allow 3389\r\n```\r\n\r\nufw를 통해 3389번 포트를 개방한다.\r\n\r\n## RDP 접속하기\r\n\r\n다른 Windows PC에서 Ubuntu로 접속해보자. 시작 프로그램에서 <span class=\"blue-400\">[원격 데스크톱 연결]</span>을 입력하여 프로그램을 실행하자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132518999-0293653c-ccef-4181-a084-71022f83fc47.png)\r\n\r\nUbuntu IP를 입력하여 연결한다. 정상적으로 연결되면 Ubuntu의 접속정보를 통해 로그인을 수행한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/132519253-e4ec536d-d6a4-4fea-8905-50451a892a5b.png)\r\n\r\n접속에 성공하면 원격으로 Ununtu UI를 다룰 수 있게 된다. 하지만 여러 기술적 한계와 효용성으로 인해 성능이 그리 좋지는 않은 것 같다. 끊김 현상이 좀 심한 것으로 보인다.\r\n\r\n## 검은 화면만 나와요!\r\n\r\n분명히 정상적으로 잘 접속했는데, <span class=\"red-500\">검은화면만 뜨는 경우가 발생</span>하기도 한다.\r\n\r\n꽤 유명한 이슈로, 설정 몇 개만 수정하면 해결된다.\r\n\r\n``` bash\r\nsudo vi /etc/xrdp/startwm.sh\r\n\r\n# 파일의 맨 아랫 줄에 아래 내용 추가\r\nunset DBUS_SESSION_BUS_ADDRESS\r\nunset XDG_RUNTIME_DIR\r\n\r\ntest -x /etc/X11/Xsession && exec /etc/X11/Xsession\r\nexec /bin/sh /etc/X11/Xsession\r\n\r\n# 파일 저장\r\n:wq\r\n```\r\n\r\n`/etc/xrdp/startwm.sh` 파일에 위 내용을 추가하고 저장하면 된다.\r\n\r\n``` bash\r\nservice xrdp restart\r\n```\r\n\r\n이후 서비스를 재시작하고 시도하면 정상적으로 접속될 것이다.\r\n\r\n# 목표\r\n\r\n* <del class=\"grey-400\">라즈베리파이에 Ubuntu 서버를 구축한다.</del>\r\n* <del class=\"grey-400\">Tomcat을 구동하여 페이지를 호스팅한다.</del>\r\n* <del class=\"grey-400\">도메인을 입힌다.</del>\r\n* <del class=\"grey-400\">SSL 인증서를 발급하여 HTTPS 통신을 제공한다.</del>\r\n* <del class=\"grey-400\">SSH, RDP 등의 원격 통신환경을 구축한다.</del>\r\n* MariaDB를 설치하여 DB 통신을 수행한다.\r\n\r\n이로써 어디에서나 라즈베리파이의 Ubuntu에 접속하여 조작할 수 있다. Shell과 UI 둘 다 조작이 가능하므로 필요에 따라 원하는 방식으로 접근하면 될 것이다.","url":["2021-09-08-raspberry-remote","2021","09","08","raspberry-remote"]}],"categories":{"All":{"count":70,"flag":true},"Ubuntu":{"count":2,"flag":true},"RaspberryPi":{"count":7,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.webm","celeb10.webm","celeb11.webm","celeb12.webm","celeb13.webm","celeb14.webm","celeb15.webm","celeb16.webm","celeb2.webm","celeb3.webm","celeb4.webm","celeb5.webm","celeb6.webm","celeb7.webm","celeb8.webm","celeb9.webm","city1.webm","city10.webm","city11.webm","city12.webm","city13.webm","city14.webm","city15.webm","city2.webm","city3.webm","city4.webm","city5.webm","city6.webm","city7.webm","city8.webm","city9.webm","code1.webm","code2.webm","code3.webm","funk1.webm","funk2.webm","funk3.webm","funk4.webm","funk5.webm","funk6.webm","game1.webm","signal.webm"],"tag":"SSH","page":1,"hash":"f1814897788"},"__N_SSG":true}