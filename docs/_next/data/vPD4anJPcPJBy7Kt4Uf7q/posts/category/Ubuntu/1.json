{"pageProps":{"posts":[{"header":{"title":"[Ubuntu] Ubuntu 원격 프로토콜 보안 강화하기","excerpt":"SSH, SFTP와 같은 원격 프로토콜은 서버의 접근성을 향상시켜주지만, 서버의 보안성을 극도로 훼손한다. 공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다. 따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다. 외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/133300948-2ee9b77a-1589-4afc-8489-fb402a13520f.png","date":"2021-09-15T01:53:21","type":"posts","category":"Ubuntu","tag":["Ubuntu","SSH","SFTP"],"comment":true,"publish":true},"name":"2021-09-15-increase-ubuntu-remote-security.md","content":"\r\n# 개요\r\n\r\nSSH, SFTP와 같은 원격 프로토콜은 <span class=\"green-600\">서버의 접근성을 향상</span>시켜주지만, <span class=\"red-600\">서버의 보안성을 극도로 훼손</span>한다.\r\n\r\n공격자가 특정 서버의 IP를 알아냈을 경우, 해당 IP로 SSH 접속 시도를 할 수 있다. 굳이 IP가 아니더라도 해당 IP와 연결된 도메인을 통해서도 얼마든지 가능하다. 특정 도메인의 정보를 DNS서버에 요청하여 IP는 물론 소유자 정보까지 쉽게 취득할 수 있기 때문이다.\r\n\r\n따라서 누군가가 내가 접속하려는 서버의 IP 혹은 도메인, SSH 서비스 포트, 계정정보를 알고 있다면 얼마든지 SSH 접속 시도를 하거나 서버에 피해를 줄 수 있다.\r\n\r\n외부에 도메인을 공개하는 순간 국내는 물론 외국에서 여러 접속 시도가 들어오기도 한다. 특히 중국에서의 공격이 많이 들어오며, 인터넷에서 이와 관련된 경험담이나 피해사례를 쉽게 찾아볼 수 있다.\r\n\r\n단순히 재미삼아 내가 접속한 도메인에 접속시도를 하는 어중이떠중이들도 있겠지만, 그 중 몇몇은 공격자로 취급할 수 있을 정도의 실력을 가지기도 하며, 그 중에서도 극소수의 몇몇은 내 서버의 보안을 우회할 수 있을 정도의 실력을 가지고 있을 수도 있다.\r\n\r\n서버의 특성 상 여러 내부 시스템 및 네트워크와 연결되어 있으므로, 서버가 뜷리는 것은 그 서버와 연관된 각종 정보들의 안전을 보장할 수 없음을 의미한다. 심지어 <span class=\"red-600\">항상 최상의 보안대책을 강구하는 기업에서조차 피해를 입기도 한다.</span> 우스갯소리로 이미 대다수의 자국민 주민등록번호는 인터넷에 나뒹굴고 있을거라고 얘기하기도 할 정도니.\r\n\r\n기업처럼 높은 수준의 보안과 수준에 맞는 지식을 가진 담당자가 있을 경우 피해 확인 및 보완이라도 할 수 있겠지만, 보안에 무감각하거나 관련 지식이 미흡한 <span class=\"orange-400\">소규모 사업장이나 개인의 경우 자신의 서버가 피해를 입었다는 사실조차 인지하지 못 하기도 한다.</span> 심할 경우 서버 관리조차 이루어지지 않아 공격자의 개인 서버로 사용되기까지 한다.\r\n\r\n그 어떤 보안대첵을 강구해도 보안은 언제나 부족하다. 하지만 간단한 조치만으로도 앞서 언급한 위협의 상당부분을 차단할 수 있다. 말했듯이 대부분은 공격자라고 부르기도 뭐한 장난섞인 시도이며, <span class=\"blue-400\">상대적으로 낮은 가치의 데이터가 대다수인 개인 서버가 일정 수준의 보안을 갖추고 있을 경우 이를 우회하는 것은 시간낭비</span>이기 때문이다.\r\n\r\n간단히 말해 여러분이 게임을 하는데 체력은 많고 패턴도 귀찮은데다, 보상은 잡몹 수준인 보스가 있다고 가정하자. 해당 구간에 도달할 때마다 한숨만 나올 것이며, 게임 커뮤니티엔 해당 보스를 삭제해달라는 요구가 빗발칠 것이다. 유튜브를 보다보면 인기 급상승 5위로 올라온 \"역대 최악의 게임 보스 TOP 10\" 영상에 당당히 이름이 올라가있다. 또한 DC의 해당 게임 갤러리나 인벤에선 그 보스의 이름을 비하의 의미로 사용하고 있을 것이며, 해당 보스를 스킵할 수 있는 각종 연구들이 활발하게 진행되고 있을 것이다.\r\n\r\n이 장에선 우리의 서버를 이런 \"<span class=\"pink-600\">보상은 없고 패턴은 귀찮은 체력돼지</span>\" 보스로 만들어 공격자들이 드러워서 피하도록 만들어 볼 것이다.\r\n\r\n# 서비스 포트 변경하기\r\n\r\n파일 시스템에 직접적으로 영향을 주는 통신은 <span class=\"primary\">SSH</span>, <span class=\"primary\">SFTP</span>가 존재한다. 각 프로토콜의 전신인 Telnet과 FTP는 SSL의 미적용으로 OS 설치 시 비활성화 되어있다. 굳이 해당 프로토콜을 쓸 이유조차 없으니, 여기서는 논외로 한다.\r\n\r\n각 서비스 포트는 동일하게 SSH 데몬에서 관리하므로 22다. 기본 프로토콜의 포트는 기본 포트가 고정적이므로, 대부분의 공격 시도는 이런 불변성을 악용하여 이루어진다. 반대로 말하자면, <span class=\"green-600\">서비스 포트를 변경하는 것만으로도 간단한 공격 시도를 손쉽게 차단</span>할 수 있다.\r\n\r\n기본으로 설정된 포트와 달리, 서버 담당자가 임의로 바꾼 포트는 추적할 방법이 없기 때문. 포트의 최대값은 65,535개이므로, 임의의 포트로 변경했다면 공격자는 모든 포트에 통신을 시도하여 SSH 포트를 찾아내야만 한다.\r\n\r\nSSH와 SFTP의 서비스 포트를 변경하거나, `iptables`이나 공유기 설정을 통해 포트포워딩을 시켜 임의의 외부 포트와 22번 포트를 매칭시켜줄 수도 있다.\r\n\r\n## 서비스 포트 변경을 통한 접근 제어\r\n\r\n``` bash\r\nsudo vi /etc/ssh/sshd_config\r\n```\r\n\r\n파일 내용을 보면 `#Port 22`로 주석처리된 구문을 확인할 수 있는데, 해당 주석을 제거하여 원하는 포트로 입력해준 뒤 저장하면 된다.\r\n\r\n``` bash\r\nsystemctl restart ssh\r\n```\r\n\r\nSSH 서비스를 재시작함을 잊지 말자.\r\n\r\n## 포트포워딩을 통한 접근 제어\r\n\r\nSSH의 포트 변경이 꺼려진다면, 포트포워딩을 통해 외부에서 접속하는 임의의 포트 하나와 매칭하자. `iptables`를 활용하여 구성할 수 있다.\r\n\r\n``` bash\r\n# 포트포워딩 추가\r\niptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port [PORT NUMBER]\r\n\r\n# 포트포워딩 삭제\r\niptables -t nat -D PREROUTING -p tcp --dport 22 -j REDIRECT --to-port [PORT NUMBER]\r\n\r\n# 포트포워딩 상태 확인\r\niptables -L\r\n```\r\n\r\n공유기를 사용하고 있다면 공유기에서 포트포워딩을 진행할 수도 있다.\r\n\r\n`iptables`를 활용하면 특정 IP만 해당 포트에 접근할 수 있도록 제한할 수도 있다. <span class=\"primary\">geoIP</span> 플러그인과 연동하면 국가별 IP 대역별로 관리할 수도 있으니, 관심이 있다면 찾아보길 바란다. 적용이 마냥 간단하지는 않으니 참고할 것.\r\n\r\n# RSA Key 파일로만 접근 허용하기\r\n\r\n공격자가 꽤나 근성이 있어서, 혹은 운이 좋아서 내가 임의로 변경한 SSH 서비스 포트를 알아내어 공격을 시도한다고 가정해보자.\r\n\r\n계정정보의 경우 보통 Brute Force 기법을 통해 가능한 모든 조합의 계정정보를 입력하여 로그인을 시도할 것이다. 이를 막기 위해 일정량의 <span class=\"blue-400\">로그인 실패가 감지되면 잠시 동안 접근을 제한</span>하거나, <span class=\"blue-400\">계정을 잠궈 관리자가 해제해야 다시 활성화</span>되게끔 시스템을 구성하기도 한다.\r\n\r\n위 방법도 충분히 좋은 방법이지만, 오로지 <span class=\"blue-600\">RSA Key로만 로그인할 수 있도록 서버 설정을 구성</span>하면 로그인의 보안을 대폭 강화할 수 있다.\r\n\r\n내가 사용자의 계정정보, 심지어 비밀번호까지 알고 있더라도 <span class=\"amber-600\">서버에 등록된 공개키와 매칭되는 개인키가 없을 경우 로그인을 시도할 수 없다.</span>\r\n\r\n<br />\r\n\r\n절차는 아래와 같다.\r\n\r\n1. RSA 키쌍 생성\r\n2. 서버에 공개키 등록\r\n3. SSH, SFTP 프로토콜 접속 시 개인키 파일을 제공하여 로그인 수행\r\n\r\nRSA 키 생성 시 키 파일에 암호를 설정할 수 있다. 이 경우, 로그인 시 해당 키 파일에 설정된 비밀번호를 요구한다. 키 파일의 비밀번호는 서버의 계정정보와 별개이므로, 키 파일이 유출되었다 하더라도 키 파일의 사용을 막아 실질적인 피해를 방지할 수 있다.\r\n\r\n## RSA 키쌍 생성하기\r\n\r\n``` bash\r\nssh-keygen -t rsa\r\n```\r\n\r\n위 명령어를 사용하여 <span class=\"indigo-400\">RSA 비대칭키를 생성</span>하자. 생성 과정에서 키 파일의 비밀번호를 요구하는데, 빈 칸인 채로 Enter를 누르면 비밀번호 없이 생성된다. 이 경우, 키 파일만 획득하면 키 파일을 사용할 수 있다. 반대로 비밀번호를 입력하면 해당 키 파일을 사용하기 위해 지정한 비밀번호를 입력하여 디코딩해야한다.\r\n\r\n* 개인키 `/home/username/.ssh/id_rsa`\r\n* 공개키 `/home/username/.ssh/id_rsa.pub`\r\n\r\n기본적으로 위 경로에 바로 생성된다.\r\n\r\n## RSA 키를 서버에 등록하기\r\n\r\n``` bash\r\nssh-copy-id username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n위 명령어를 입력하여 <span class=\"indigo-400\">키 파일을 서버에 등록</span>하자. `/home/username/.ssh/id_rsa.pub`를 자동으로 등록한다.\r\n\r\n## 키 파일로 SSH 접속하기\r\n\r\n``` bash\r\nssh -i [PRIVATE KEY] username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n위 명령어를 입력하여 SSH를 접속할 수 있다. `-i` 옵션으로 개인키 경로를 입력할 수 있다. 키 생성 시 비밀번호를 입력했다면 비밀번호 입력이 필요하며, 따로 생성하지 않았을 경우 즉시 로그인이 된다.\r\n\r\n### 저 Windows에서 쓰고있는데, 개인키 사용시 오류떠요!\r\n\r\n아마 대부분 Ubuntu에서 RSA 키를 생성하고, 생성한 개인키를 Windows로 전송하여 SSH 접근하는데 사용할 것이다.\r\n\r\n``` output\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\nPermissions for 'C:\\\\id_rsa' are too open.\r\nIt is required that your private key files are NOT accessible by others.\r\nThis private key will be ignored.\r\nLoad key \"C:\\\\id_rsa\": bad permissions\r\n```\r\n\r\n하지만 막상 Windows에서 키 파일 사용 시, 키 파일이 너무 많은 유저에게 허용되면 보안 상의 이유로 키 파일의 사용을 제한한다. 해결책은 하나다. 해당 키 파일을 사용할 유저에게만  권한을 부여해주면 된다.\r\n\r\n문제는 Windows의 편의성으로 인해, 파일 전송 완료 시 필요한 권한을 자동으로 부여해주기 때문에, 수동으로 제거해야한다.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/133301005-c4c5a2df-f878-4ff5-8dc0-63366e28b59b.png)\r\n\r\n키 파일의 [속성] - [보안] 탭에서 파일에 부여된 접근권한을 확인할 수 있다. 보다시피 현재는 너무 많은 사용자에게 접근이 허가되어 있으므로, 오직 나만 접근할 수 있도록 변경한다. 안타깝게도 파일에 상속이 적용되어있어서 그냥 삭제되지 않는다. 하단의 [고급] 탭을 누르자.\r\n\r\n![image](https://user-images.githubusercontent.com/50317129/133299523-ec1af2cc-44e2-4b39-b5ae-d7e04425500f.png)\r\n\r\n하단의 [상속 사용 안 함] 버튼을 클릭하여 상속 관계를 제거한다. 메시지 하나가 뜰텐데, [명시적 사용 권한으로 변환]을 선택한다. 제거하면 사용자를 직접 지정해야해서 번거롭다.\r\n\r\n이후 내 계정을 제외한 모든 권한 항목은 제거한다. 이후 저장하고 다시 시도하면 정상적으로 로그인을 수행할 수 있다.\r\n\r\n\r\n# SSH 접근 시 키 파일 방식만 허용하기\r\n\r\n여기까지 왔다면 로그인은 잘 됐다는 뜻인데, 키 파일로 로그인할 수 있는 건 좋지만, <span class=\"red-400\">문제는 그냥 계정 정보를 입력해도 로그인이 된다.</span>\r\n\r\n이래서야 키 파일의 높은 보안성을 활용하기 어렵다. 로그인 시 반드시 <span class=\"blue-400\">키 파일 로그인만을 허용</span>하여, 내 서버의 개인키를 가진 인원만 접속할 수 있도록 제한해보자.\r\n\r\n<p class=\"red-600\">※ 무턱대고 설정했다간 본인조차 SSH에 접속하지 못하는 상황이 생기기도 하니 주의할 것</p>\r\n\r\n``` bash\r\nsudo vi /etc/ssh/sshd_config\r\n```\r\n\r\nSSH 설정 파일을 열어 아래의 값을 수정하자. <span class=\"green-400\">비밀번호 입력 로그인 방식을 사용하지 않도록 설정</span>하는 것이다.\r\n\r\n* `PasswordAuthentication yes` -> `PasswordAuthentication no`\r\n\r\n``` bash\r\nsystemctl restart ssh\r\n```\r\n\r\n재부팅 후 로그인을 수행해보자.\r\n\r\n``` bash\r\n# 일반 로그인 방식의 SSH\r\nssh username@xxx.xxx.xxx.xxx\r\n\r\n# 키 파일 방식의 SSH\r\nssh -i [PRIVATE KEY] username@xxx.xxx.xxx.xxx\r\n```\r\n\r\n일반로그인은 계정 정보를 제대로 입력했다 하더라도 로그인에 실패할 것이다.\r\n\r\n# 정리\r\n\r\nSSH와 SFTP를 반드시 개인키로만 로그인할 수 있도록 구성을 변경했다.\r\n\r\n생각보다 간단한 수준의 보안 작업이라도, 실제로 이루어지는 공격의 대다수를 무력화시킬 수 있다.\r\n\r\n키를 통해 더욱 안전하게 서버의 보안을 지킬 수 있지만, 키 파일을 분실하지 않도록 주의하자.","url":["2021-09-15-increase-ubuntu-remote-security","2021","09","15","increase-ubuntu-remote-security"]},{"header":{"title":"[Ubuntu] ufw로 방화벽 포트 설정하기","excerpt":"모든 건물에는 입구가 존재한다. 일반적인 상황에서, 누구든지 해당 건물에 드나들기 위해선 좋든 싫든 입구를 통과해야한다. 이 입구라는 것이 또 마냥 열려있는 건 아니라서, 필요 시엔 개방되어있다가도 특정 시간에는 폐쇄되기도 한다. 심지어 어떤 곳은 까다롭기 그지없어서, 사람을 가려받기도 한다. 이를테면 보안구역이라던가, 금요일 밤의 클럽이라던가. PC통신도 이와 원리가 별반 다를 바 없다. 보기엔 그냥 막 통신하는 것 같아도, 저마다 할당받은 입구를 통해 PC에 드나든다. PC가 건물이라고 한다면, PC의 입구는 포트(PORT)라 할 수 있다.","coverImage":"https://user-images.githubusercontent.com/50317129/132039520-3efc64ec-28c2-499c-af29-dfe153f53852.png","date":"2021-09-04T01:26:20","type":"posts","category":"Ubuntu","tag":["Ubuntu","방화벽"],"comment":true,"publish":true},"name":"2021-09-04-firewall-with-ufw.md","content":"\r\n# 개요\r\n\r\n모든 건물에는 입구가 존재한다. 일반적인 상황에서, 누구든지 해당 건물에 드나들기 위해선 좋든 싫든 입구를 통과해야한다.\r\n\r\n이 입구라는 것이 또 마냥 열려있는 건 아니라서, 필요 시엔 개방되어있다가도 특정 시간에는 폐쇄되기도 한다.\r\n\r\n심지어 어떤 곳은 까다롭기 그지없어서, 사람을 가려받기도 한다. 이를테면 보안구역이라던가, 금요일 밤의 클럽이라던가.\r\n\r\n<br />\r\n\r\nPC통신도 이와 원리가 별반 다를 바 없다. 보기엔 그냥 막 통신하는 것 같아도, 저마다 할당받은 입구를 통해 PC에 드나든다.\r\n\r\nPC가 건물이라고 한다면, PC의 입구는 포트(PORT)라 할 수 있다.\r\n\r\n<br />\r\n\r\n모든 프로그램은 PC와의 통신 시 임의의 입구, 포트를 할당받는다. 프로그램은 해당 포트를 통해 들어오고, 나가며 정해진 동작을 수행한다.\r\n\r\n만약 해당 포트가 막혀있다면, 해당 컴퓨터를 대상으론 정상적으로 동작할 수 없을 것이다.\r\n\r\n이 프로그램이 내 PC에 필요하다면 포트를 열어주면 될 것이고, 아니라면 포트를 닫음으로써 접근하지 못하게 함이 바람직하다. 혹은 인증된 소수의 프로그램에게만 포트를 허용할 수도 있을 것이다.\r\n\r\n<br />\r\n\r\n말 그대로 보안과 매우 밀접한 개념으로써, <span class=\"red-600\">방화벽 설정을 통해 원하는 포트를 원하는 대상에게 개방/폐쇄</span>할 수 있다.\r\n\r\nUbuntu에서 ufw를 통해 방화벽 설정을 원하는대로 설정해보자.\r\n\r\n# 그냥 다 열면 안 돼?\r\n\r\n조선시대 제주도는 문을 잠근다는 개념이 매우 미약했다고 한다.\r\n\r\n옛 교통방식과 섬이라는 폐쇄적인 환경 덕분에 유동인구가 매우 적었고, 각 마을 주민에 대한 신원이 확실했을 것이다. 내륙에 비해 외지인이 방문/거주할 일도 매우 적었을 것이다.\r\n\r\n이처럼 주변 환경과 사람들 간의 신뢰성이 있다면 굳이 그렇게 폐쇄적일 필요는 없을지도 모른다.\r\n\r\n<br />\r\n\r\n하지만 인터넷이라는 환경은 이와 결이 매우 다르다. 인터넷에 연결만 되어있다면 누구나 내 PC에 접근할 수 있는 잠재적 가능성을 가진다. 누가, 왜, 무엇을 위해 오는지도 알 수 없다.\r\n\r\n이 경우 문을 아무렇게나 열어재껴놓는건 바람직한 상황이 아닐 것이다.\r\n\r\n<br />\r\n\r\n방화벽은 이러한 문제로부터 PC를 최대한 보호하기위해, <span class=\"green-600\">기본적으로 폐쇄적인 설정</span>을 가진다. 일단 안 된다고 질러놓고 보는 셈이다.\r\n\r\n보안을 위해서 방화벽은 가급적 폐쇄하되, 필요한 프로그램만 개방하는 화이트리스트 방식을 쓰는 습관을 들이도록 하자.\r\n\r\n# ufw\r\n\r\n기본적인 방화벽 명령어 `iptables`가 있지만, 명령어가 그리 직관적이지 않다는 단점이 있다. 이에 비해 `ufw`는 `iptables`에 비해 훨씬 쉽고 직관적인 명령어로 다룰 수 있다.\r\n\r\n`iptables`과 성능상의 차이가 거의 없다는 점을 감안하면 확실한 장점.\r\n\r\n## ufw 설치\r\n\r\nufw는 기본 명령어가 아니다. <span class=\"blue-400\">ufw를 설치</span>하자.\r\n\r\n``` bash\r\nsudo apt-get install ufw\r\n```\r\n\r\n위 명령어를 통해 설치할 수 있다.\r\n\r\n## ufw 상태 관리 명령어\r\n\r\nufw의 상태를 관리하는 명령어다.\r\n\r\n``` bash\r\n# ufw 활성화\r\nsudo ufw enable\r\n\r\n# ufw 비활성화\r\nsudo ufw disable\r\n\r\n# ufw 상태 확인\r\nsudo ufw status verbose\r\n```\r\n\r\nufw가 설치된 후 방화벽에 영향을 주는 걸 방지하기 위해 <span class=\"blue-400\">기본적으로 비활성화 상태</span>로 설치된다.\r\n\r\n`sudo ufw enable` 명령어를 입력하여 활성화하자.\r\n\r\n## ufw 정책 관리 명령어\r\n\r\nufw에 적용된 <span class=\"blue-400\">정책을 관리</span>한다.\r\n\r\n``` bash\r\n# 정책 조회\r\nsudo ufw show raw\r\n\r\n# 기본 정책 허용\r\nsudo ufw default allow\r\n\r\n# 기본 정책 차단\r\nsudo ufw default deny\r\n```\r\n\r\n모든 포트 통신에 대한 일괄 허용/차단이 가능하다.\r\n\r\n``` bash\r\n# 들어오는 통신 차단\r\nsudo ufw default deny incoming\r\n\r\n# 나가는 통신 허용\r\nsudo ufw default allow outgoing\r\n```\r\n\r\n오는사람 막고 가는사람 안 막는다라는 말을 들어본 적이 있을 것이다. 보안도 똑같다. 내게 들어오는 통신은 최대한 폐쇄적으로, 내게서 나가는 통신은 개방적으로 대한다.\r\n\r\n## ufw 정책 설정 명령어\r\n\r\n``` bash\r\n# 80포트(HTTP) 허용\r\nsudo ufw allow 80\r\n\r\n# 80포트(HTTP) TCP 허용\r\nsudo ufw allow 80/tcp\r\n\r\n# 80포트(HTTP) UDP 허용\r\nsudo ufw allow 80/udp\r\n\r\n# 80포트(HTTP) 허용\r\nsudo ufw allow http\r\n```\r\n\r\n위 명령어는 <span class=\"blue-400\">HTTP 포트 80을 허용하는 명령어</span>들의 모음이다.\r\n\r\nufw는 고유 서비스 이름을 사용해서 포트를 관리할 수 있다. HTTP(80), HTTPS(443), FTP(21), SSH(22) 등이 이에 해당한다.\r\n\r\n`allow` 이외에도 `deny`를 통해 통신을 거부하거나, `delete`를 통해 해당 정책을 아예 지워버릴 수도 있다.\r\n\r\n정책을 지우게 되면 ufw에 설정된 기본 정책을 따르게 된다.\r\n\r\n## ufw 정책 세부설정 명령어\r\n\r\n### IP 통신 정책\r\n\r\n``` bash\r\n# 192.168.0.100 IP의 통신 허용\r\nsudo ufw allow from 192.168.0.100\r\n\r\n# 192.168.0.100 ~ 200 대역의 IP의 통신 허용\r\nsudo ufw allow from 192.168.0.100/200\r\n```\r\n\r\n위 명령어를 통해서 <span class=\"blue-400\">특정 IP 혹은 IP 대역의 통신을 관리</span>할 수 있다.\r\n\r\n### IP 및 포트 통신 정책\r\n\r\n``` bash\r\n# 192.168.0.100 IP의 80포트 허용\r\nsudo ufw allow from 192.168.0.100 to any port 80\r\n\r\n# 192.168.0.100 IP의 80포트 TCP 허용\r\nsudo ufw allow from 192.168.0.100 to any port 80 proto tcp\r\n```\r\n\r\n<span class=\"blue-400\">특정 IP의 특정 포트만 허용/차단</span>할 수도 있다.\r\n\r\n## ufw 정책 수정 명령어\r\n\r\n``` bash\r\nsudo ufw status numbered\r\n```\r\n\r\n현재 적용된 정책을 인덱스 번호와 함께 보여준다.\r\n\r\n해당 번호를 통해 <span class=\"blue-400\">정책을 수정, 삭제</span>할 수 있다.\r\n\r\n``` bash\r\n# 1번 정책을 80포트 차단 정책으로 변경\r\nsudo ufw insert 1 deny 80\r\n\r\n# 2번 정책을 192.168.0.100 IP의 통신 허용 정책으로 변경\r\nsudo ufw insert 2 allow from 192.168.0.100\r\n```\r\n\r\n## ufw 정책 삭제 명령어\r\n\r\n``` bash\r\n# 1번 정책 삭제\r\nsudo ufw delete 1\r\n```\r\n\r\n# 정리\r\n\r\n서비스에서 서버가 갖는 역할과 비중을 생각해본다면, 서버의 보안은 서비스의 안정성과 직결되는 중요한 문제다.\r\n\r\n때문에 서버의 보안은 귀찮을정도로 견고하게 구성되는 것이 바람직하다.\r\n\r\n<br />\r\n\r\n프로그램, 웹 등 모든 서비스의 기초는 데이터의 통신이므로, 통신을 잘 제어하는 것이 중요하다.\r\n\r\n반드시 필요한 통신만을 허가하고 관리하여 서버가 항상 최상의 보안을 유지할 수 있도록 보안정책을 구성하자.","url":["2021-09-04-firewall-with-ufw","2021","09","04","firewall-with-ufw"]}],"categories":{"All":{"count":70,"flag":true},"Ubuntu":{"count":2,"flag":true},"RaspberryPi":{"count":7,"flag":true},"알고리즘":{"count":32,"flag":false},"잡담":{"count":2,"flag":false},"WEB":{"count":7,"flag":false},"CS":{"count":10,"flag":false},"React":{"count":1,"flag":false},"JAVA":{"count":3,"flag":false},"Jekyll":{"count":4,"flag":false},"WAS":{"count":2,"flag":false}},"images":["celeb1.webm","celeb10.webm","celeb11.webm","celeb12.webm","celeb13.webm","celeb14.webm","celeb15.webm","celeb16.webm","celeb2.webm","celeb3.webm","celeb4.webm","celeb5.webm","celeb6.webm","celeb7.webm","celeb8.webm","celeb9.webm","city1.webm","city10.webm","city11.webm","city12.webm","city13.webm","city14.webm","city15.webm","city2.webm","city3.webm","city4.webm","city5.webm","city6.webm","city7.webm","city8.webm","city9.webm","code1.webm","code2.webm","code3.webm","funk1.webm","funk2.webm","funk3.webm","funk4.webm","funk5.webm","funk6.webm","game1.webm","signal.webm"],"category":"Ubuntu","page":1,"hash":"f1814897788"},"__N_SSG":true}