<!DOCTYPE html><html lang="ko"><head><link rel="icon" href="/favicons/favicon.ico"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><meta name="google-site-verification" content="4NW8SDMGP89T6Sldqnv7ldyklb-kQkq0hq9tOdGgLsM"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-X2THE3XLX1"></script><title>자료구조가 중요한 까닭 - Kapoo</title><meta name="description" content="혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다."/><meta property="og:site_name" content="Kapoo"/><meta property="og:title" content="자료구조가 중요한 까닭"/><meta property="og:description" content="혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다."/><meta property="og:type" content="website"/><meta property="og:url" content="https://rwb0104.github.io/posts/2021/07/10/about-algorithm-chapter01/"/><meta property="og:image" content="https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png"/><meta property="og:locale" content="ko_KR"/><link rel="canonical" href="https://rwb0104.github.io/posts/2021/07/10/about-algorithm-chapter01/"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/6b02b2129d8e6ee22211.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6b02b2129d8e6ee22211.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" as="script"/><link rel="preload" href="/_next/static/chunks/6bbc0c86603d2feda1b6d9e3f0b0f690f2f4c9a4.62794267ce6b83fa1d13.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-a56a9833bc2424f9492b.js" as="script"/><link rel="preload" href="/_next/static/chunks/0a301732.10ced01e52dc82e99752.js" as="script"/><link rel="preload" href="/_next/static/chunks/a5190d9ce7329a37db61865e931a1a66806e37b1.e0bb27786170d93a4a8b.js" as="script"/><link rel="preload" href="/_next/static/chunks/39eb40a19e7e82f610f97d892c72a9a025d001d6.463482cc4895dad81b92.js" as="script"/><link rel="preload" href="/_next/static/chunks/d0cb84a5c8b749bd71f104256fde72bc846b2656.c889dd6a5a1e01ef484b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-2e0609bfb4d36bf9d207.js" as="script"/><link rel="preload" href="/_next/static/chunks/d6344e9a4d7f8e29af8741de220cdb9ff49f13dc.7896df7c38f14edd6e3e.js" as="script"/><link rel="preload" href="/_next/static/chunks/5631b5f5713ebfda782daea8f3e487334c496d05.137501440fe8249a994b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5B...slug%5D-96c89aa2af9f19796390.js" as="script"/><style id="jss-server-side">.MuiSvgIcon-root {
  fill: currentColor;
  width: 1em;
  height: 1em;
  display: inline-block;
  font-size: 1.5rem;
  transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
  flex-shrink: 0;
  user-select: none;
}
.MuiSvgIcon-colorPrimary {
  color: #2196f3;
}
.MuiSvgIcon-colorSecondary {
  color: #3d5afe;
}
.MuiSvgIcon-colorAction {
  color: #fff;
}
.MuiSvgIcon-colorError {
  color: #f44336;
}
.MuiSvgIcon-colorDisabled {
  color: rgba(255, 255, 255, 0.3);
}
.MuiSvgIcon-fontSizeInherit {
  font-size: inherit;
}
.MuiSvgIcon-fontSizeSmall {
  font-size: 1.25rem;
}
.MuiSvgIcon-fontSizeLarge {
  font-size: 2.1875rem;
}
.MuiPaper-root {
  color: #fff;
  transition: box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
  background-color: #424242;
}
.MuiPaper-rounded {
  border-radius: 4px;
}
.MuiPaper-outlined {
  border: 1px solid rgba(255, 255, 255, 0.12);
}
.MuiPaper-elevation0 {
  box-shadow: none;
}
.MuiPaper-elevation1 {
  box-shadow: 0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation2 {
  box-shadow: 0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation3 {
  box-shadow: 0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation4 {
  box-shadow: 0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation5 {
  box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2),0px 5px 8px 0px rgba(0,0,0,0.14),0px 1px 14px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation6 {
  box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation7 {
  box-shadow: 0px 4px 5px -2px rgba(0,0,0,0.2),0px 7px 10px 1px rgba(0,0,0,0.14),0px 2px 16px 1px rgba(0,0,0,0.12);
}
.MuiPaper-elevation8 {
  box-shadow: 0px 5px 5px -3px rgba(0,0,0,0.2),0px 8px 10px 1px rgba(0,0,0,0.14),0px 3px 14px 2px rgba(0,0,0,0.12);
}
.MuiPaper-elevation9 {
  box-shadow: 0px 5px 6px -3px rgba(0,0,0,0.2),0px 9px 12px 1px rgba(0,0,0,0.14),0px 3px 16px 2px rgba(0,0,0,0.12);
}
.MuiPaper-elevation10 {
  box-shadow: 0px 6px 6px -3px rgba(0,0,0,0.2),0px 10px 14px 1px rgba(0,0,0,0.14),0px 4px 18px 3px rgba(0,0,0,0.12);
}
.MuiPaper-elevation11 {
  box-shadow: 0px 6px 7px -4px rgba(0,0,0,0.2),0px 11px 15px 1px rgba(0,0,0,0.14),0px 4px 20px 3px rgba(0,0,0,0.12);
}
.MuiPaper-elevation12 {
  box-shadow: 0px 7px 8px -4px rgba(0,0,0,0.2),0px 12px 17px 2px rgba(0,0,0,0.14),0px 5px 22px 4px rgba(0,0,0,0.12);
}
.MuiPaper-elevation13 {
  box-shadow: 0px 7px 8px -4px rgba(0,0,0,0.2),0px 13px 19px 2px rgba(0,0,0,0.14),0px 5px 24px 4px rgba(0,0,0,0.12);
}
.MuiPaper-elevation14 {
  box-shadow: 0px 7px 9px -4px rgba(0,0,0,0.2),0px 14px 21px 2px rgba(0,0,0,0.14),0px 5px 26px 4px rgba(0,0,0,0.12);
}
.MuiPaper-elevation15 {
  box-shadow: 0px 8px 9px -5px rgba(0,0,0,0.2),0px 15px 22px 2px rgba(0,0,0,0.14),0px 6px 28px 5px rgba(0,0,0,0.12);
}
.MuiPaper-elevation16 {
  box-shadow: 0px 8px 10px -5px rgba(0,0,0,0.2),0px 16px 24px 2px rgba(0,0,0,0.14),0px 6px 30px 5px rgba(0,0,0,0.12);
}
.MuiPaper-elevation17 {
  box-shadow: 0px 8px 11px -5px rgba(0,0,0,0.2),0px 17px 26px 2px rgba(0,0,0,0.14),0px 6px 32px 5px rgba(0,0,0,0.12);
}
.MuiPaper-elevation18 {
  box-shadow: 0px 9px 11px -5px rgba(0,0,0,0.2),0px 18px 28px 2px rgba(0,0,0,0.14),0px 7px 34px 6px rgba(0,0,0,0.12);
}
.MuiPaper-elevation19 {
  box-shadow: 0px 9px 12px -6px rgba(0,0,0,0.2),0px 19px 29px 2px rgba(0,0,0,0.14),0px 7px 36px 6px rgba(0,0,0,0.12);
}
.MuiPaper-elevation20 {
  box-shadow: 0px 10px 13px -6px rgba(0,0,0,0.2),0px 20px 31px 3px rgba(0,0,0,0.14),0px 8px 38px 7px rgba(0,0,0,0.12);
}
.MuiPaper-elevation21 {
  box-shadow: 0px 10px 13px -6px rgba(0,0,0,0.2),0px 21px 33px 3px rgba(0,0,0,0.14),0px 8px 40px 7px rgba(0,0,0,0.12);
}
.MuiPaper-elevation22 {
  box-shadow: 0px 10px 14px -6px rgba(0,0,0,0.2),0px 22px 35px 3px rgba(0,0,0,0.14),0px 8px 42px 7px rgba(0,0,0,0.12);
}
.MuiPaper-elevation23 {
  box-shadow: 0px 11px 14px -7px rgba(0,0,0,0.2),0px 23px 36px 3px rgba(0,0,0,0.14),0px 9px 44px 8px rgba(0,0,0,0.12);
}
.MuiPaper-elevation24 {
  box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2),0px 24px 38px 3px rgba(0,0,0,0.14),0px 9px 46px 8px rgba(0,0,0,0.12);
}
.MuiButtonBase-root {
  color: inherit;
  border: 0;
  cursor: pointer;
  margin: 0;
  display: inline-flex;
  outline: 0;
  padding: 0;
  position: relative;
  align-items: center;
  user-select: none;
  border-radius: 0;
  vertical-align: middle;
  -moz-appearance: none;
  justify-content: center;
  text-decoration: none;
  background-color: transparent;
  -webkit-appearance: none;
  -webkit-tap-highlight-color: transparent;
}
.MuiButtonBase-root::-moz-focus-inner {
  border-style: none;
}
.MuiButtonBase-root.Mui-disabled {
  cursor: default;
  pointer-events: none;
}
@media print {
  .MuiButtonBase-root {
    color-adjust: exact;
  }
}
  .MuiIconButton-root {
    flex: 0 0 auto;
    color: #fff;
    padding: 12px;
    overflow: visible;
    font-size: 1.5rem;
    text-align: center;
    transition: background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    border-radius: 50%;
  }
  .MuiIconButton-root:hover {
    background-color: rgba(255, 255, 255, 0.08);
  }
  .MuiIconButton-root.Mui-disabled {
    color: rgba(255, 255, 255, 0.3);
    background-color: transparent;
  }
@media (hover: none) {
  .MuiIconButton-root:hover {
    background-color: transparent;
  }
}
  .MuiIconButton-edgeStart {
    margin-left: -12px;
  }
  .MuiIconButton-sizeSmall.MuiIconButton-edgeStart {
    margin-left: -3px;
  }
  .MuiIconButton-edgeEnd {
    margin-right: -12px;
  }
  .MuiIconButton-sizeSmall.MuiIconButton-edgeEnd {
    margin-right: -3px;
  }
  .MuiIconButton-colorInherit {
    color: inherit;
  }
  .MuiIconButton-colorPrimary {
    color: #2196f3;
  }
  .MuiIconButton-colorPrimary:hover {
    background-color: rgba(33, 150, 243, 0.08);
  }
@media (hover: none) {
  .MuiIconButton-colorPrimary:hover {
    background-color: transparent;
  }
}
  .MuiIconButton-colorSecondary {
    color: #3d5afe;
  }
  .MuiIconButton-colorSecondary:hover {
    background-color: rgba(61, 90, 254, 0.08);
  }
@media (hover: none) {
  .MuiIconButton-colorSecondary:hover {
    background-color: transparent;
  }
}
  .MuiIconButton-sizeSmall {
    padding: 3px;
    font-size: 1.125rem;
  }
  .MuiIconButton-label {
    width: 100%;
    display: flex;
    align-items: inherit;
    justify-content: inherit;
  }
  .MuiAppBar-root {
    width: 100%;
    display: flex;
    z-index: 1100;
    box-sizing: border-box;
    flex-shrink: 0;
    flex-direction: column;
  }
  .MuiAppBar-positionFixed {
    top: 0;
    left: auto;
    right: 0;
    position: fixed;
  }
@media print {
  .MuiAppBar-positionFixed {
    position: absolute;
  }
}
  .MuiAppBar-positionAbsolute {
    top: 0;
    left: auto;
    right: 0;
    position: absolute;
  }
  .MuiAppBar-positionSticky {
    top: 0;
    left: auto;
    right: 0;
    position: sticky;
  }
  .MuiAppBar-positionStatic {
    position: static;
  }
  .MuiAppBar-positionRelative {
    position: relative;
  }
  .MuiAppBar-colorDefault {
    color: #fff;
    background-color: #212121;
  }
  .MuiAppBar-colorPrimary {
    color: #fff;
    background-color: #2196f3;
  }
  .MuiAppBar-colorSecondary {
    color: #fff;
    background-color: #3d5afe;
  }
  .MuiAppBar-colorInherit {
    color: inherit;
  }
  .MuiAppBar-colorTransparent {
    color: inherit;
    background-color: transparent;
  }
  .MuiAvatar-root {
    width: 40px;
    height: 40px;
    display: flex;
    overflow: hidden;
    position: relative;
    font-size: 1.25rem;
    align-items: center;
    flex-shrink: 0;
    font-family: 나눔스퀘어라운드, sans-serif;
    line-height: 1;
    user-select: none;
    border-radius: 50%;
    justify-content: center;
  }
  .MuiAvatar-colorDefault {
    color: #020d1d;
    background-color: #757575;
  }
  .MuiAvatar-rounded {
    border-radius: 4px;
  }
  .MuiAvatar-square {
    border-radius: 0;
  }
  .MuiAvatar-img {
    color: transparent;
    width: 100%;
    height: 100%;
    object-fit: cover;
    text-align: center;
    text-indent: 10000px;
  }
  .MuiAvatar-fallback {
    width: 75%;
    height: 75%;
  }

  .jss4 {  }
  .jss17 {
    display: flex;
    position: relative;
    flex-direction: column;
  }
  .jss18 {
    position: absolute;
  }
  .jss19 {  }
  .jss20 {
    display: flex;
    align-self: center;
    flex-direction: column;
    justify-content: center;
  }
  .jss27 {  }
  .jss28 {  }
  .jss31 {  }
  .jss33 {
    display: flex;
    align-items: center;
  }
  .jss34 {
    flex-grow: 1;
  }
  .jss35 {  }
  .jss36 {
    flex-grow: 1;
  }
  .jss38 {  }
  .jss47 {  }
  .jss48 {
    display: flex;
    align-items: center;
  }
  .jss49 {
    flex-grow: 1;
  }
  .jss50 {  }
  .jss51 {
    flex-grow: 1;
  }
  .jss52 {
    display: flex;
    align-items: center;
    flex-direction: column;
  }
  .jss53 {
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .jss54 {
    display: flex;
    justify-content: center;
  }
  .jss55 {
    display: flex;
    align-items: center;
    flex-direction: column;
  }
  .jss56 {
    display: flex;
    align-items: center;
    flex-direction: column;
  }
  .jss57 {
    display: flex;
    justify-content: center;
  }
  .jss58 {
    display: flex;
    align-items: center;
    flex-direction: column;
  }
  .jss59 {
    display: flex;
    align-items: center;
    flex-direction: column;
  }
  .jss60 {
    display: flex;
    align-items: center;
    flex-direction: column;
  }
  .MuiTypography-root {
    margin: 0;
  }
  .MuiTypography-body2 {
    font-size: 0.875rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 1.43;
  }
  .MuiTypography-body1 {
    font-size: 1rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 1.5;
  }
  .MuiTypography-caption {
    font-size: 0.75rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 1.66;
  }
  .MuiTypography-button {
    font-size: 0.875rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 500;
    line-height: 1.75;
    text-transform: uppercase;
  }
  .MuiTypography-h1 {
    font-size: 6rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 300;
    line-height: 1.167;
  }
  .MuiTypography-h2 {
    font-size: 3.75rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 300;
    line-height: 1.2;
  }
  .MuiTypography-h3 {
    font-size: 3rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 1.167;
  }
  .MuiTypography-h4 {
    font-size: 2.125rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 1.235;
  }
  .MuiTypography-h5 {
    font-size: 1.5rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 1.334;
  }
  .MuiTypography-h6 {
    font-size: 1.25rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 500;
    line-height: 1.6;
  }
  .MuiTypography-subtitle1 {
    font-size: 1rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 1.75;
  }
  .MuiTypography-subtitle2 {
    font-size: 0.875rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 500;
    line-height: 1.57;
  }
  .MuiTypography-overline {
    font-size: 0.75rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 400;
    line-height: 2.66;
    text-transform: uppercase;
  }
  .MuiTypography-srOnly {
    width: 1px;
    height: 1px;
    overflow: hidden;
    position: absolute;
  }
  .MuiTypography-alignLeft {
    text-align: left;
  }
  .MuiTypography-alignCenter {
    text-align: center;
  }
  .MuiTypography-alignRight {
    text-align: right;
  }
  .MuiTypography-alignJustify {
    text-align: justify;
  }
  .MuiTypography-noWrap {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
  .MuiTypography-gutterBottom {
    margin-bottom: 0.35em;
  }
  .MuiTypography-paragraph {
    margin-bottom: 16px;
  }
  .MuiTypography-colorInherit {
    color: inherit;
  }
  .MuiTypography-colorPrimary {
    color: #2196f3;
  }
  .MuiTypography-colorSecondary {
    color: #3d5afe;
  }
  .MuiTypography-colorTextPrimary {
    color: #fff;
  }
  .MuiTypography-colorTextSecondary {
    color: rgba(255, 255, 255, 0.7);
  }
  .MuiTypography-colorError {
    color: #f44336;
  }
  .MuiTypography-displayInline {
    display: inline;
  }
  .MuiTypography-displayBlock {
    display: block;
  }
  .MuiButton-root {
    color: #fff;
    padding: 6px 16px;
    font-size: 0.875rem;
    min-width: 64px;
    box-sizing: border-box;
    transition: background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 500;
    line-height: 1.75;
    border-radius: 4px;
    text-transform: uppercase;
  }
  .MuiButton-root:hover {
    text-decoration: none;
    background-color: rgba(255, 255, 255, 0.08);
  }
  .MuiButton-root.Mui-disabled {
    color: rgba(255, 255, 255, 0.3);
  }
@media (hover: none) {
  .MuiButton-root:hover {
    background-color: transparent;
  }
}
  .MuiButton-root:hover.Mui-disabled {
    background-color: transparent;
  }
  .MuiButton-label {
    width: 100%;
    display: inherit;
    align-items: inherit;
    justify-content: inherit;
  }
  .MuiButton-text {
    padding: 6px 8px;
  }
  .MuiButton-textPrimary {
    color: #2196f3;
  }
  .MuiButton-textPrimary:hover {
    background-color: rgba(33, 150, 243, 0.08);
  }
@media (hover: none) {
  .MuiButton-textPrimary:hover {
    background-color: transparent;
  }
}
  .MuiButton-textSecondary {
    color: #3d5afe;
  }
  .MuiButton-textSecondary:hover {
    background-color: rgba(61, 90, 254, 0.08);
  }
@media (hover: none) {
  .MuiButton-textSecondary:hover {
    background-color: transparent;
  }
}
  .MuiButton-outlined {
    border: 1px solid rgba(255, 255, 255, 0.23);
    padding: 5px 15px;
  }
  .MuiButton-outlined.Mui-disabled {
    border: 1px solid rgba(255, 255, 255, 0.12);
  }
  .MuiButton-outlinedPrimary {
    color: #2196f3;
    border: 1px solid rgba(33, 150, 243, 0.5);
  }
  .MuiButton-outlinedPrimary:hover {
    border: 1px solid #2196f3;
    background-color: rgba(33, 150, 243, 0.08);
  }
@media (hover: none) {
  .MuiButton-outlinedPrimary:hover {
    background-color: transparent;
  }
}
  .MuiButton-outlinedSecondary {
    color: #3d5afe;
    border: 1px solid rgba(61, 90, 254, 0.5);
  }
  .MuiButton-outlinedSecondary:hover {
    border: 1px solid #3d5afe;
    background-color: rgba(61, 90, 254, 0.08);
  }
  .MuiButton-outlinedSecondary.Mui-disabled {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
@media (hover: none) {
  .MuiButton-outlinedSecondary:hover {
    background-color: transparent;
  }
}
  .MuiButton-contained {
    color: rgba(0, 0, 0, 0.87);
    box-shadow: 0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12);
    background-color: #e0e0e0;
  }
  .MuiButton-contained:hover {
    box-shadow: 0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);
    background-color: #d5d5d5;
  }
  .MuiButton-contained.Mui-focusVisible {
    box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12);
  }
  .MuiButton-contained:active {
    box-shadow: 0px 5px 5px -3px rgba(0,0,0,0.2),0px 8px 10px 1px rgba(0,0,0,0.14),0px 3px 14px 2px rgba(0,0,0,0.12);
  }
  .MuiButton-contained.Mui-disabled {
    color: rgba(255, 255, 255, 0.3);
    box-shadow: none;
    background-color: rgba(255, 255, 255, 0.12);
  }
@media (hover: none) {
  .MuiButton-contained:hover {
    box-shadow: 0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12);
    background-color: #e0e0e0;
  }
}
  .MuiButton-contained:hover.Mui-disabled {
    background-color: rgba(255, 255, 255, 0.12);
  }
  .MuiButton-containedPrimary {
    color: #fff;
    background-color: #2196f3;
  }
  .MuiButton-containedPrimary:hover {
    background-color: #1976d2;
  }
@media (hover: none) {
  .MuiButton-containedPrimary:hover {
    background-color: #2196f3;
  }
}
  .MuiButton-containedSecondary {
    color: #fff;
    background-color: #3d5afe;
  }
  .MuiButton-containedSecondary:hover {
    background-color: #304ffe;
  }
@media (hover: none) {
  .MuiButton-containedSecondary:hover {
    background-color: #3d5afe;
  }
}
  .MuiButton-disableElevation {
    box-shadow: none;
  }
  .MuiButton-disableElevation:hover {
    box-shadow: none;
  }
  .MuiButton-disableElevation.Mui-focusVisible {
    box-shadow: none;
  }
  .MuiButton-disableElevation:active {
    box-shadow: none;
  }
  .MuiButton-disableElevation.Mui-disabled {
    box-shadow: none;
  }
  .MuiButton-colorInherit {
    color: inherit;
    border-color: currentColor;
  }
  .MuiButton-textSizeSmall {
    padding: 4px 5px;
    font-size: 0.8125rem;
  }
  .MuiButton-textSizeLarge {
    padding: 8px 11px;
    font-size: 0.9375rem;
  }
  .MuiButton-outlinedSizeSmall {
    padding: 3px 9px;
    font-size: 0.8125rem;
  }
  .MuiButton-outlinedSizeLarge {
    padding: 7px 21px;
    font-size: 0.9375rem;
  }
  .MuiButton-containedSizeSmall {
    padding: 4px 10px;
    font-size: 0.8125rem;
  }
  .MuiButton-containedSizeLarge {
    padding: 8px 22px;
    font-size: 0.9375rem;
  }
  .MuiButton-fullWidth {
    width: 100%;
  }
  .MuiButton-startIcon {
    display: inherit;
    margin-left: -4px;
    margin-right: 8px;
  }
  .MuiButton-startIcon.MuiButton-iconSizeSmall {
    margin-left: -2px;
  }
  .MuiButton-endIcon {
    display: inherit;
    margin-left: 8px;
    margin-right: -4px;
  }
  .MuiButton-endIcon.MuiButton-iconSizeSmall {
    margin-right: -2px;
  }
  .MuiButton-iconSizeSmall > *:first-child {
    font-size: 18px;
  }
  .MuiButton-iconSizeMedium > *:first-child {
    font-size: 20px;
  }
  .MuiButton-iconSizeLarge > *:first-child {
    font-size: 22px;
  }
  .MuiContainer-root {
    width: 100%;
    display: block;
    box-sizing: border-box;
    margin-left: auto;
    margin-right: auto;
    padding-left: 16px;
    padding-right: 16px;
  }
@media (min-width:600px) {
  .MuiContainer-root {
    padding-left: 24px;
    padding-right: 24px;
  }
}
  .MuiContainer-disableGutters {
    padding-left: 0;
    padding-right: 0;
  }
@media (min-width:600px) {
  .MuiContainer-fixed {
    max-width: 600px;
  }
}
@media (min-width:960px) {
  .MuiContainer-fixed {
    max-width: 960px;
  }
}
@media (min-width:1280px) {
  .MuiContainer-fixed {
    max-width: 1280px;
  }
}
@media (min-width:1920px) {
  .MuiContainer-fixed {
    max-width: 1920px;
  }
}
@media (min-width:0px) {
  .MuiContainer-maxWidthXs {
    max-width: 444px;
  }
}
@media (min-width:600px) {
  .MuiContainer-maxWidthSm {
    max-width: 600px;
  }
}
@media (min-width:960px) {
  .MuiContainer-maxWidthMd {
    max-width: 960px;
  }
}
@media (min-width:1280px) {
  .MuiContainer-maxWidthLg {
    max-width: 1280px;
  }
}
@media (min-width:1920px) {
  .MuiContainer-maxWidthXl {
    max-width: 1920px;
  }
}
html {
  box-sizing: border-box;
  -webkit-font-smoothing: auto;
  -moz-osx-font-smoothing: grayscale;
}
*, *::before, *::after {
  box-sizing: inherit;
}
strong, b {
  font-weight: 700;
}
body {
  color: #fff;
  margin: 0;
  font-size: 0.875rem;
  font-family: 나눔스퀘어라운드, sans-serif;
  font-weight: 400;
  line-height: 1.43;
  background-color: #020d1d;
}
@media print {
  body {
    background-color: #fff;
  }
}
body::backdrop {
  background-color: #020d1d;
}
*::-webkit-scrollbar, *::-webkit-scrollbar-thumb {
  width: 6px;
  border: 1px solid transparent;
  border-radius: 6px;
  background-clip: padding-box;
}
*::-webkit-scrollbar-thumb {
  color: #404040;
  box-shadow: inset 0 0 0 10px;
}
  .MuiDivider-root {
    border: none;
    height: 1px;
    margin: 0;
    flex-shrink: 0;
    background-color: rgba(255, 255, 255, 0.12);
  }
  .MuiDivider-absolute {
    left: 0;
    width: 100%;
    bottom: 0;
    position: absolute;
  }
  .MuiDivider-inset {
    margin-left: 72px;
  }
  .MuiDivider-light {
    background-color: rgba(255, 255, 255, 0.08);
  }
  .MuiDivider-middle {
    margin-left: 16px;
    margin-right: 16px;
  }
  .MuiDivider-vertical {
    width: 1px;
    height: 100%;
  }
  .MuiDivider-flexItem {
    height: auto;
    align-self: stretch;
  }
  .MuiFab-root {
    color: rgba(0, 0, 0, 0.87);
    width: 56px;
    height: 56px;
    padding: 0;
    font-size: 0.875rem;
    min-width: 0;
    box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12);
    box-sizing: border-box;
    min-height: 36px;
    transition: background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: 500;
    line-height: 1.75;
    border-radius: 50%;
    text-transform: uppercase;
    background-color: #e0e0e0;
  }
  .MuiFab-root:active {
    box-shadow: 0px 7px 8px -4px rgba(0,0,0,0.2),0px 12px 17px 2px rgba(0,0,0,0.14),0px 5px 22px 4px rgba(0,0,0,0.12);
  }
  .MuiFab-root:hover {
    text-decoration: none;
    background-color: #d5d5d5;
  }
  .MuiFab-root.Mui-focusVisible {
    box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12);
  }
  .MuiFab-root.Mui-disabled {
    color: rgba(255, 255, 255, 0.3);
    box-shadow: none;
    background-color: rgba(255, 255, 255, 0.12);
  }
@media (hover: none) {
  .MuiFab-root:hover {
    background-color: #e0e0e0;
  }
}
  .MuiFab-root:hover.Mui-disabled {
    background-color: rgba(255, 255, 255, 0.12);
  }
  .MuiFab-label {
    width: 100%;
    display: inherit;
    align-items: inherit;
    justify-content: inherit;
  }
  .MuiFab-primary {
    color: #fff;
    background-color: #2196f3;
  }
  .MuiFab-primary:hover {
    background-color: #1976d2;
  }
@media (hover: none) {
  .MuiFab-primary:hover {
    background-color: #2196f3;
  }
}
  .MuiFab-secondary {
    color: #fff;
    background-color: #3d5afe;
  }
  .MuiFab-secondary:hover {
    background-color: #304ffe;
  }
@media (hover: none) {
  .MuiFab-secondary:hover {
    background-color: #3d5afe;
  }
}
  .MuiFab-extended {
    width: auto;
    height: 48px;
    padding: 0 16px;
    min-width: 48px;
    min-height: auto;
    border-radius: 24px;
  }
  .MuiFab-extended.MuiFab-sizeSmall {
    width: auto;
    height: 34px;
    padding: 0 8px;
    min-width: 34px;
    border-radius: 17px;
  }
  .MuiFab-extended.MuiFab-sizeMedium {
    width: auto;
    height: 40px;
    padding: 0 16px;
    min-width: 40px;
    border-radius: 20px;
  }
  .MuiFab-colorInherit {
    color: inherit;
  }
  .MuiFab-sizeSmall {
    width: 40px;
    height: 40px;
  }
  .MuiFab-sizeMedium {
    width: 48px;
    height: 48px;
  }
  .MuiGrid-container {
    width: 100%;
    display: flex;
    flex-wrap: wrap;
    box-sizing: border-box;
  }
  .MuiGrid-item {
    margin: 0;
    box-sizing: border-box;
  }
  .MuiGrid-zeroMinWidth {
    min-width: 0;
  }
  .MuiGrid-direction-xs-column {
    flex-direction: column;
  }
  .MuiGrid-direction-xs-column-reverse {
    flex-direction: column-reverse;
  }
  .MuiGrid-direction-xs-row-reverse {
    flex-direction: row-reverse;
  }
  .MuiGrid-wrap-xs-nowrap {
    flex-wrap: nowrap;
  }
  .MuiGrid-wrap-xs-wrap-reverse {
    flex-wrap: wrap-reverse;
  }
  .MuiGrid-align-items-xs-center {
    align-items: center;
  }
  .MuiGrid-align-items-xs-flex-start {
    align-items: flex-start;
  }
  .MuiGrid-align-items-xs-flex-end {
    align-items: flex-end;
  }
  .MuiGrid-align-items-xs-baseline {
    align-items: baseline;
  }
  .MuiGrid-align-content-xs-center {
    align-content: center;
  }
  .MuiGrid-align-content-xs-flex-start {
    align-content: flex-start;
  }
  .MuiGrid-align-content-xs-flex-end {
    align-content: flex-end;
  }
  .MuiGrid-align-content-xs-space-between {
    align-content: space-between;
  }
  .MuiGrid-align-content-xs-space-around {
    align-content: space-around;
  }
  .MuiGrid-justify-xs-center {
    justify-content: center;
  }
  .MuiGrid-justify-xs-flex-end {
    justify-content: flex-end;
  }
  .MuiGrid-justify-xs-space-between {
    justify-content: space-between;
  }
  .MuiGrid-justify-xs-space-around {
    justify-content: space-around;
  }
  .MuiGrid-justify-xs-space-evenly {
    justify-content: space-evenly;
  }
  .MuiGrid-spacing-xs-1 {
    width: calc(100% + 8px);
    margin: -4px;
  }
  .MuiGrid-spacing-xs-1 > .MuiGrid-item {
    padding: 4px;
  }
  .MuiGrid-spacing-xs-2 {
    width: calc(100% + 16px);
    margin: -8px;
  }
  .MuiGrid-spacing-xs-2 > .MuiGrid-item {
    padding: 8px;
  }
  .MuiGrid-spacing-xs-3 {
    width: calc(100% + 24px);
    margin: -12px;
  }
  .MuiGrid-spacing-xs-3 > .MuiGrid-item {
    padding: 12px;
  }
  .MuiGrid-spacing-xs-4 {
    width: calc(100% + 32px);
    margin: -16px;
  }
  .MuiGrid-spacing-xs-4 > .MuiGrid-item {
    padding: 16px;
  }
  .MuiGrid-spacing-xs-5 {
    width: calc(100% + 40px);
    margin: -20px;
  }
  .MuiGrid-spacing-xs-5 > .MuiGrid-item {
    padding: 20px;
  }
  .MuiGrid-spacing-xs-6 {
    width: calc(100% + 48px);
    margin: -24px;
  }
  .MuiGrid-spacing-xs-6 > .MuiGrid-item {
    padding: 24px;
  }
  .MuiGrid-spacing-xs-7 {
    width: calc(100% + 56px);
    margin: -28px;
  }
  .MuiGrid-spacing-xs-7 > .MuiGrid-item {
    padding: 28px;
  }
  .MuiGrid-spacing-xs-8 {
    width: calc(100% + 64px);
    margin: -32px;
  }
  .MuiGrid-spacing-xs-8 > .MuiGrid-item {
    padding: 32px;
  }
  .MuiGrid-spacing-xs-9 {
    width: calc(100% + 72px);
    margin: -36px;
  }
  .MuiGrid-spacing-xs-9 > .MuiGrid-item {
    padding: 36px;
  }
  .MuiGrid-spacing-xs-10 {
    width: calc(100% + 80px);
    margin: -40px;
  }
  .MuiGrid-spacing-xs-10 > .MuiGrid-item {
    padding: 40px;
  }
  .MuiGrid-grid-xs-auto {
    flex-grow: 0;
    max-width: none;
    flex-basis: auto;
  }
  .MuiGrid-grid-xs-true {
    flex-grow: 1;
    max-width: 100%;
    flex-basis: 0;
  }
  .MuiGrid-grid-xs-1 {
    flex-grow: 0;
    max-width: 8.333333%;
    flex-basis: 8.333333%;
  }
  .MuiGrid-grid-xs-2 {
    flex-grow: 0;
    max-width: 16.666667%;
    flex-basis: 16.666667%;
  }
  .MuiGrid-grid-xs-3 {
    flex-grow: 0;
    max-width: 25%;
    flex-basis: 25%;
  }
  .MuiGrid-grid-xs-4 {
    flex-grow: 0;
    max-width: 33.333333%;
    flex-basis: 33.333333%;
  }
  .MuiGrid-grid-xs-5 {
    flex-grow: 0;
    max-width: 41.666667%;
    flex-basis: 41.666667%;
  }
  .MuiGrid-grid-xs-6 {
    flex-grow: 0;
    max-width: 50%;
    flex-basis: 50%;
  }
  .MuiGrid-grid-xs-7 {
    flex-grow: 0;
    max-width: 58.333333%;
    flex-basis: 58.333333%;
  }
  .MuiGrid-grid-xs-8 {
    flex-grow: 0;
    max-width: 66.666667%;
    flex-basis: 66.666667%;
  }
  .MuiGrid-grid-xs-9 {
    flex-grow: 0;
    max-width: 75%;
    flex-basis: 75%;
  }
  .MuiGrid-grid-xs-10 {
    flex-grow: 0;
    max-width: 83.333333%;
    flex-basis: 83.333333%;
  }
  .MuiGrid-grid-xs-11 {
    flex-grow: 0;
    max-width: 91.666667%;
    flex-basis: 91.666667%;
  }
  .MuiGrid-grid-xs-12 {
    flex-grow: 0;
    max-width: 100%;
    flex-basis: 100%;
  }
@media (min-width:600px) {
  .MuiGrid-grid-sm-auto {
    flex-grow: 0;
    max-width: none;
    flex-basis: auto;
  }
  .MuiGrid-grid-sm-true {
    flex-grow: 1;
    max-width: 100%;
    flex-basis: 0;
  }
  .MuiGrid-grid-sm-1 {
    flex-grow: 0;
    max-width: 8.333333%;
    flex-basis: 8.333333%;
  }
  .MuiGrid-grid-sm-2 {
    flex-grow: 0;
    max-width: 16.666667%;
    flex-basis: 16.666667%;
  }
  .MuiGrid-grid-sm-3 {
    flex-grow: 0;
    max-width: 25%;
    flex-basis: 25%;
  }
  .MuiGrid-grid-sm-4 {
    flex-grow: 0;
    max-width: 33.333333%;
    flex-basis: 33.333333%;
  }
  .MuiGrid-grid-sm-5 {
    flex-grow: 0;
    max-width: 41.666667%;
    flex-basis: 41.666667%;
  }
  .MuiGrid-grid-sm-6 {
    flex-grow: 0;
    max-width: 50%;
    flex-basis: 50%;
  }
  .MuiGrid-grid-sm-7 {
    flex-grow: 0;
    max-width: 58.333333%;
    flex-basis: 58.333333%;
  }
  .MuiGrid-grid-sm-8 {
    flex-grow: 0;
    max-width: 66.666667%;
    flex-basis: 66.666667%;
  }
  .MuiGrid-grid-sm-9 {
    flex-grow: 0;
    max-width: 75%;
    flex-basis: 75%;
  }
  .MuiGrid-grid-sm-10 {
    flex-grow: 0;
    max-width: 83.333333%;
    flex-basis: 83.333333%;
  }
  .MuiGrid-grid-sm-11 {
    flex-grow: 0;
    max-width: 91.666667%;
    flex-basis: 91.666667%;
  }
  .MuiGrid-grid-sm-12 {
    flex-grow: 0;
    max-width: 100%;
    flex-basis: 100%;
  }
}
@media (min-width:960px) {
  .MuiGrid-grid-md-auto {
    flex-grow: 0;
    max-width: none;
    flex-basis: auto;
  }
  .MuiGrid-grid-md-true {
    flex-grow: 1;
    max-width: 100%;
    flex-basis: 0;
  }
  .MuiGrid-grid-md-1 {
    flex-grow: 0;
    max-width: 8.333333%;
    flex-basis: 8.333333%;
  }
  .MuiGrid-grid-md-2 {
    flex-grow: 0;
    max-width: 16.666667%;
    flex-basis: 16.666667%;
  }
  .MuiGrid-grid-md-3 {
    flex-grow: 0;
    max-width: 25%;
    flex-basis: 25%;
  }
  .MuiGrid-grid-md-4 {
    flex-grow: 0;
    max-width: 33.333333%;
    flex-basis: 33.333333%;
  }
  .MuiGrid-grid-md-5 {
    flex-grow: 0;
    max-width: 41.666667%;
    flex-basis: 41.666667%;
  }
  .MuiGrid-grid-md-6 {
    flex-grow: 0;
    max-width: 50%;
    flex-basis: 50%;
  }
  .MuiGrid-grid-md-7 {
    flex-grow: 0;
    max-width: 58.333333%;
    flex-basis: 58.333333%;
  }
  .MuiGrid-grid-md-8 {
    flex-grow: 0;
    max-width: 66.666667%;
    flex-basis: 66.666667%;
  }
  .MuiGrid-grid-md-9 {
    flex-grow: 0;
    max-width: 75%;
    flex-basis: 75%;
  }
  .MuiGrid-grid-md-10 {
    flex-grow: 0;
    max-width: 83.333333%;
    flex-basis: 83.333333%;
  }
  .MuiGrid-grid-md-11 {
    flex-grow: 0;
    max-width: 91.666667%;
    flex-basis: 91.666667%;
  }
  .MuiGrid-grid-md-12 {
    flex-grow: 0;
    max-width: 100%;
    flex-basis: 100%;
  }
}
@media (min-width:1280px) {
  .MuiGrid-grid-lg-auto {
    flex-grow: 0;
    max-width: none;
    flex-basis: auto;
  }
  .MuiGrid-grid-lg-true {
    flex-grow: 1;
    max-width: 100%;
    flex-basis: 0;
  }
  .MuiGrid-grid-lg-1 {
    flex-grow: 0;
    max-width: 8.333333%;
    flex-basis: 8.333333%;
  }
  .MuiGrid-grid-lg-2 {
    flex-grow: 0;
    max-width: 16.666667%;
    flex-basis: 16.666667%;
  }
  .MuiGrid-grid-lg-3 {
    flex-grow: 0;
    max-width: 25%;
    flex-basis: 25%;
  }
  .MuiGrid-grid-lg-4 {
    flex-grow: 0;
    max-width: 33.333333%;
    flex-basis: 33.333333%;
  }
  .MuiGrid-grid-lg-5 {
    flex-grow: 0;
    max-width: 41.666667%;
    flex-basis: 41.666667%;
  }
  .MuiGrid-grid-lg-6 {
    flex-grow: 0;
    max-width: 50%;
    flex-basis: 50%;
  }
  .MuiGrid-grid-lg-7 {
    flex-grow: 0;
    max-width: 58.333333%;
    flex-basis: 58.333333%;
  }
  .MuiGrid-grid-lg-8 {
    flex-grow: 0;
    max-width: 66.666667%;
    flex-basis: 66.666667%;
  }
  .MuiGrid-grid-lg-9 {
    flex-grow: 0;
    max-width: 75%;
    flex-basis: 75%;
  }
  .MuiGrid-grid-lg-10 {
    flex-grow: 0;
    max-width: 83.333333%;
    flex-basis: 83.333333%;
  }
  .MuiGrid-grid-lg-11 {
    flex-grow: 0;
    max-width: 91.666667%;
    flex-basis: 91.666667%;
  }
  .MuiGrid-grid-lg-12 {
    flex-grow: 0;
    max-width: 100%;
    flex-basis: 100%;
  }
}
@media (min-width:1920px) {
  .MuiGrid-grid-xl-auto {
    flex-grow: 0;
    max-width: none;
    flex-basis: auto;
  }
  .MuiGrid-grid-xl-true {
    flex-grow: 1;
    max-width: 100%;
    flex-basis: 0;
  }
  .MuiGrid-grid-xl-1 {
    flex-grow: 0;
    max-width: 8.333333%;
    flex-basis: 8.333333%;
  }
  .MuiGrid-grid-xl-2 {
    flex-grow: 0;
    max-width: 16.666667%;
    flex-basis: 16.666667%;
  }
  .MuiGrid-grid-xl-3 {
    flex-grow: 0;
    max-width: 25%;
    flex-basis: 25%;
  }
  .MuiGrid-grid-xl-4 {
    flex-grow: 0;
    max-width: 33.333333%;
    flex-basis: 33.333333%;
  }
  .MuiGrid-grid-xl-5 {
    flex-grow: 0;
    max-width: 41.666667%;
    flex-basis: 41.666667%;
  }
  .MuiGrid-grid-xl-6 {
    flex-grow: 0;
    max-width: 50%;
    flex-basis: 50%;
  }
  .MuiGrid-grid-xl-7 {
    flex-grow: 0;
    max-width: 58.333333%;
    flex-basis: 58.333333%;
  }
  .MuiGrid-grid-xl-8 {
    flex-grow: 0;
    max-width: 66.666667%;
    flex-basis: 66.666667%;
  }
  .MuiGrid-grid-xl-9 {
    flex-grow: 0;
    max-width: 75%;
    flex-basis: 75%;
  }
  .MuiGrid-grid-xl-10 {
    flex-grow: 0;
    max-width: 83.333333%;
    flex-basis: 83.333333%;
  }
  .MuiGrid-grid-xl-11 {
    flex-grow: 0;
    max-width: 91.666667%;
    flex-basis: 91.666667%;
  }
  .MuiGrid-grid-xl-12 {
    flex-grow: 0;
    max-width: 100%;
    flex-basis: 100%;
  }
}
  .MuiGridList-root {
    display: flex;
    padding: 0;
    flex-wrap: wrap;
    list-style: none;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  .MuiGridListTile-root {
    box-sizing: border-box;
    flex-shrink: 0;
  }
  .MuiGridListTile-tile {
    height: 100%;
    display: block;
    overflow: hidden;
    position: relative;
  }
  .MuiGridListTile-imgFullHeight {
    left: 50%;
    height: 100%;
    position: relative;
    transform: translateX(-50%);
  }
  .MuiGridListTile-imgFullWidth {
    top: 50%;
    width: 100%;
    position: relative;
    transform: translateY(-50%);
  }
  .MuiGridListTileBar-root {
    left: 0;
    right: 0;
    height: 48px;
    display: flex;
    position: absolute;
    background: rgba(0, 0, 0, 0.5);
    align-items: center;
    font-family: 나눔스퀘어라운드, sans-serif;
  }
  .MuiGridListTileBar-titlePositionBottom {
    bottom: 0;
  }
  .MuiGridListTileBar-titlePositionTop {
    top: 0;
  }
  .MuiGridListTileBar-rootSubtitle {
    height: 68px;
  }
  .MuiGridListTileBar-titleWrap {
    color: #fff;
    overflow: hidden;
    flex-grow: 1;
    margin-left: 16px;
    margin-right: 16px;
  }
  .MuiGridListTileBar-titleWrapActionPosLeft {
    margin-left: 0;
  }
  .MuiGridListTileBar-titleWrapActionPosRight {
    margin-right: 0;
  }
  .MuiGridListTileBar-title {
    overflow: hidden;
    font-size: 1rem;
    line-height: 24px;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
  .MuiGridListTileBar-subtitle {
    overflow: hidden;
    font-size: 0.75rem;
    line-height: 1;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
  .MuiGridListTileBar-actionIconActionPosLeft {
    order: -1;
  }
  .MuiLink-underlineNone {
    text-decoration: none;
  }
  .MuiLink-underlineHover {
    text-decoration: none;
  }
  .MuiLink-underlineHover:hover {
    text-decoration: underline;
  }
  .MuiLink-underlineAlways {
    text-decoration: underline;
  }
  .MuiLink-button {
    border: 0;
    cursor: pointer;
    margin: 0;
    outline: 0;
    padding: 0;
    position: relative;
    user-select: none;
    border-radius: 0;
    vertical-align: middle;
    -moz-appearance: none;
    background-color: transparent;
    -webkit-appearance: none;
    -webkit-tap-highlight-color: transparent;
  }
  .MuiLink-button::-moz-focus-inner {
    border-style: none;
  }
  .MuiLink-button.Mui-focusVisible {
    outline: auto;
  }
  .MuiToolbar-root {
    display: flex;
    position: relative;
    align-items: center;
  }
  .MuiToolbar-gutters {
    padding-left: 16px;
    padding-right: 16px;
  }
@media (min-width:600px) {
  .MuiToolbar-gutters {
    padding-left: 24px;
    padding-right: 24px;
  }
}
  .MuiToolbar-regular {
    min-height: 56px;
  }
@media (min-width:0px) and (orientation: landscape) {
  .MuiToolbar-regular {
    min-height: 48px;
  }
}
@media (min-width:600px) {
  .MuiToolbar-regular {
    min-height: 64px;
  }
}
  .MuiToolbar-dense {
    min-height: 48px;
  }
  .jss1 {
    z-index: 1201;
    flex-grow: 1;
    background: linear-gradient(to right, #000000CC, #434343CC);;
    backdrop-filter: blur(5px) saturate(180%);
    -webkit-backdrop-filter: blur(5px) saturate(180%);
  }
  .jss2 {
    min-height: 64px;
  }
  .jss3 {
    display: flex;
  }
  .jss5 {
    margin-top: 24px;
    margin-bottom: 24px;
  }
  .jss6 {
    margin-left: 24px;
    margin-right: 24px;
  }
  .jss7 {
    padding-left: 16px;
    padding-right: 16px;
  }
  .jss8 {
    width: 100%;
    height: calc(100vh - 64px);
  }
@media (max-width:959.95px) {
  .jss8 {
    height: calc(100vh - 136px);
  }
}
  .jss9 {
    top: 0;
    clip: rect(0, auto, auto, 0);
    left: 0;
    width: 100%;
    height: 100%;
  }
  .jss10 {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    position: fixed;
    background-size: cover;
    background-color: rgba(0, 0, 0, 0.6);
    background-image: url(https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png);
    background-repeat: no-repeat;
    -o-background-size: cover;
    background-position: center;
    -moz-background-size: cover;
    background-attachment: fixed;
    background-blend-mode: multiply;
    -webkit-background-size: cover;
  }
  .jss11 {
    width: 100%;
    height: 100%;
    padding: 50px;
  }
  .jss12 {
    color: white;
    font-weight: bolder;
    margin-bottom: 60px;
  }
  .jss13 {
    color: white;
    font-family: Blacksword, sans-serif;
    font-weight: bold;
    margin-bottom: 60px;
  }
  .jss13 span {
    display: inline-block;
  }
  .jss14 {
    color: white;
  }
  .jss15 {
    color: white;
    width: 100%;
    padding: 20px;
  }
  .jss15 svg {
    width: 50px;
    height: 50px;
  }
@media (max-width:959.95px) {
  .jss15 svg {
    width: 30px;
    height: 30px;
  }
}
  .jss16 {
    opacity: 0;
  }
  .jss21 {
    font-size: 1.25rem;
    font-family: 나눔스퀘어라운드, sans-serif;
    line-height: 1.75;
    margin-bottom: 160px;
  }
  .jss21 .center {
    text-align: center;
  }
  .jss21 .small {
    font-size: 1rem;
  }
  .jss21 .large {
    font-size: 1.5rem;
  }
  .jss21 .primary {
    color: #1976d2;
  }
  .jss21 .secondary {
    color: #304ffe;
  }
  .jss21 .error {
    color: #d32f2f;
  }
  .jss21 .warning {
    color: #f57c00;
  }
  .jss21 .info {
    color: #f57c00;
  }
  .jss21 .success {
    color: #f57c00;
  }
  .jss21 .red-50 {
    color: #ffebee;
  }
  .jss21 .red-100 {
    color: #ffcdd2;
  }
  .jss21 .red-200 {
    color: #ef9a9a;
  }
  .jss21 .red-300 {
    color: #e57373;
  }
  .jss21 .red-400 {
    color: #ef5350;
  }
  .jss21 .red-500 {
    color: #f44336;
  }
  .jss21 .red-600 {
    color: #e53935;
  }
  .jss21 .red-700 {
    color: #d32f2f;
  }
  .jss21 .red-800 {
    color: #c62828;
  }
  .jss21 .red-900 {
    color: #b71c1c;
  }
  .jss21 .red-A100 {
    color: #ff8a80;
  }
  .jss21 .red-A200 {
    color: #ff5252;
  }
  .jss21 .red-A400 {
    color: #ff1744;
  }
  .jss21 .red-A700 {
    color: #d50000;
  }
  .jss21 .pink-50 {
    color: #fce4ec;
  }
  .jss21 .pink-100 {
    color: #f8bbd0;
  }
  .jss21 .pink-200 {
    color: #f48fb1;
  }
  .jss21 .pink-300 {
    color: #f06292;
  }
  .jss21 .pink-400 {
    color: #ec407a;
  }
  .jss21 .pink-500 {
    color: #e91e63;
  }
  .jss21 .pink-600 {
    color: #d81b60;
  }
  .jss21 .pink-700 {
    color: #c2185b;
  }
  .jss21 .pink-800 {
    color: #ad1457;
  }
  .jss21 .pink-900 {
    color: #880e4f;
  }
  .jss21 .pink-A100 {
    color: #ff80ab;
  }
  .jss21 .pink-A200 {
    color: #ff4081;
  }
  .jss21 .pink-A400 {
    color: #f50057;
  }
  .jss21 .pink-A700 {
    color: #c51162;
  }
  .jss21 .purple-50 {
    color: #f3e5f5;
  }
  .jss21 .purple-100 {
    color: #e1bee7;
  }
  .jss21 .purple-200 {
    color: #ce93d8;
  }
  .jss21 .purple-300 {
    color: #ba68c8;
  }
  .jss21 .purple-400 {
    color: #ab47bc;
  }
  .jss21 .purple-500 {
    color: #9c27b0;
  }
  .jss21 .purple-600 {
    color: #8e24aa;
  }
  .jss21 .purple-700 {
    color: #7b1fa2;
  }
  .jss21 .purple-800 {
    color: #6a1b9a;
  }
  .jss21 .purple-900 {
    color: #4a148c;
  }
  .jss21 .purple-A100 {
    color: #ea80fc;
  }
  .jss21 .purple-A200 {
    color: #e040fb;
  }
  .jss21 .purple-A400 {
    color: #d500f9;
  }
  .jss21 .purple-A700 {
    color: #aa00ff;
  }
  .jss21 .deepPurple-50 {
    color: #ede7f6;
  }
  .jss21 .deepPurple-100 {
    color: #d1c4e9;
  }
  .jss21 .deepPurple-200 {
    color: #b39ddb;
  }
  .jss21 .deepPurple-300 {
    color: #9575cd;
  }
  .jss21 .deepPurple-400 {
    color: #7e57c2;
  }
  .jss21 .deepPurple-500 {
    color: #673ab7;
  }
  .jss21 .deepPurple-600 {
    color: #5e35b1;
  }
  .jss21 .deepPurple-700 {
    color: #512da8;
  }
  .jss21 .deepPurple-800 {
    color: #4527a0;
  }
  .jss21 .deepPurple-900 {
    color: #311b92;
  }
  .jss21 .deepPurple-A100 {
    color: #b388ff;
  }
  .jss21 .deepPurple-A200 {
    color: #7c4dff;
  }
  .jss21 .deepPurple-A400 {
    color: #651fff;
  }
  .jss21 .deepPurple-A700 {
    color: #6200ea;
  }
  .jss21 .indigo-50 {
    color: #e8eaf6;
  }
  .jss21 .indigo-100 {
    color: #c5cae9;
  }
  .jss21 .indigo-200 {
    color: #9fa8da;
  }
  .jss21 .indigo-300 {
    color: #7986cb;
  }
  .jss21 .indigo-400 {
    color: #5c6bc0;
  }
  .jss21 .indigo-500 {
    color: #3f51b5;
  }
  .jss21 .indigo-600 {
    color: #3949ab;
  }
  .jss21 .indigo-700 {
    color: #303f9f;
  }
  .jss21 .indigo-800 {
    color: #283593;
  }
  .jss21 .indigo-900 {
    color: #1a237e;
  }
  .jss21 .indigo-A100 {
    color: #8c9eff;
  }
  .jss21 .indigo-A200 {
    color: #536dfe;
  }
  .jss21 .indigo-A400 {
    color: #3d5afe;
  }
  .jss21 .indigo-A700 {
    color: #304ffe;
  }
  .jss21 .blue-50 {
    color: #e3f2fd;
  }
  .jss21 .blue-100 {
    color: #bbdefb;
  }
  .jss21 .blue-200 {
    color: #90caf9;
  }
  .jss21 .blue-300 {
    color: #64b5f6;
  }
  .jss21 .blue-400 {
    color: #42a5f5;
  }
  .jss21 .blue-500 {
    color: #2196f3;
  }
  .jss21 .blue-600 {
    color: #1e88e5;
  }
  .jss21 .blue-700 {
    color: #1976d2;
  }
  .jss21 .blue-800 {
    color: #1565c0;
  }
  .jss21 .blue-900 {
    color: #0d47a1;
  }
  .jss21 .blue-A100 {
    color: #82b1ff;
  }
  .jss21 .blue-A200 {
    color: #448aff;
  }
  .jss21 .blue-A400 {
    color: #2979ff;
  }
  .jss21 .blue-A700 {
    color: #2962ff;
  }
  .jss21 .lightBlue-50 {
    color: #e1f5fe;
  }
  .jss21 .lightBlue-100 {
    color: #b3e5fc;
  }
  .jss21 .lightBlue-200 {
    color: #81d4fa;
  }
  .jss21 .lightBlue-300 {
    color: #4fc3f7;
  }
  .jss21 .lightBlue-400 {
    color: #29b6f6;
  }
  .jss21 .lightBlue-500 {
    color: #03a9f4;
  }
  .jss21 .lightBlue-600 {
    color: #039be5;
  }
  .jss21 .lightBlue-700 {
    color: #0288d1;
  }
  .jss21 .lightBlue-800 {
    color: #0277bd;
  }
  .jss21 .lightBlue-900 {
    color: #01579b;
  }
  .jss21 .lightBlue-A100 {
    color: #80d8ff;
  }
  .jss21 .lightBlue-A200 {
    color: #40c4ff;
  }
  .jss21 .lightBlue-A400 {
    color: #00b0ff;
  }
  .jss21 .lightBlue-A700 {
    color: #0091ea;
  }
  .jss21 .cyan-50 {
    color: #e0f7fa;
  }
  .jss21 .cyan-100 {
    color: #b2ebf2;
  }
  .jss21 .cyan-200 {
    color: #80deea;
  }
  .jss21 .cyan-300 {
    color: #4dd0e1;
  }
  .jss21 .cyan-400 {
    color: #26c6da;
  }
  .jss21 .cyan-500 {
    color: #00bcd4;
  }
  .jss21 .cyan-600 {
    color: #00acc1;
  }
  .jss21 .cyan-700 {
    color: #0097a7;
  }
  .jss21 .cyan-800 {
    color: #00838f;
  }
  .jss21 .cyan-900 {
    color: #006064;
  }
  .jss21 .cyan-A100 {
    color: #84ffff;
  }
  .jss21 .cyan-A200 {
    color: #18ffff;
  }
  .jss21 .cyan-A400 {
    color: #00e5ff;
  }
  .jss21 .cyan-A700 {
    color: #00b8d4;
  }
  .jss21 .teal-50 {
    color: #e0f2f1;
  }
  .jss21 .teal-100 {
    color: #b2dfdb;
  }
  .jss21 .teal-200 {
    color: #80cbc4;
  }
  .jss21 .teal-300 {
    color: #4db6ac;
  }
  .jss21 .teal-400 {
    color: #26a69a;
  }
  .jss21 .teal-500 {
    color: #009688;
  }
  .jss21 .teal-600 {
    color: #00897b;
  }
  .jss21 .teal-700 {
    color: #00796b;
  }
  .jss21 .teal-800 {
    color: #00695c;
  }
  .jss21 .teal-900 {
    color: #004d40;
  }
  .jss21 .teal-A100 {
    color: #a7ffeb;
  }
  .jss21 .teal-A200 {
    color: #64ffda;
  }
  .jss21 .teal-A400 {
    color: #1de9b6;
  }
  .jss21 .teal-A700 {
    color: #00bfa5;
  }
  .jss21 .green-50 {
    color: #e8f5e9;
  }
  .jss21 .green-100 {
    color: #c8e6c9;
  }
  .jss21 .green-200 {
    color: #a5d6a7;
  }
  .jss21 .green-300 {
    color: #81c784;
  }
  .jss21 .green-400 {
    color: #66bb6a;
  }
  .jss21 .green-500 {
    color: #4caf50;
  }
  .jss21 .green-600 {
    color: #43a047;
  }
  .jss21 .green-700 {
    color: #388e3c;
  }
  .jss21 .green-800 {
    color: #2e7d32;
  }
  .jss21 .green-900 {
    color: #1b5e20;
  }
  .jss21 .green-A100 {
    color: #b9f6ca;
  }
  .jss21 .green-A200 {
    color: #69f0ae;
  }
  .jss21 .green-A400 {
    color: #00e676;
  }
  .jss21 .green-A700 {
    color: #00c853;
  }
  .jss21 .lightGreen-50 {
    color: #f1f8e9;
  }
  .jss21 .lightGreen-100 {
    color: #dcedc8;
  }
  .jss21 .lightGreen-200 {
    color: #c5e1a5;
  }
  .jss21 .lightGreen-300 {
    color: #aed581;
  }
  .jss21 .lightGreen-400 {
    color: #9ccc65;
  }
  .jss21 .lightGreen-500 {
    color: #8bc34a;
  }
  .jss21 .lightGreen-600 {
    color: #7cb342;
  }
  .jss21 .lightGreen-700 {
    color: #689f38;
  }
  .jss21 .lightGreen-800 {
    color: #558b2f;
  }
  .jss21 .lightGreen-900 {
    color: #33691e;
  }
  .jss21 .lightGreen-A100 {
    color: #ccff90;
  }
  .jss21 .lightGreen-A200 {
    color: #b2ff59;
  }
  .jss21 .lightGreen-A400 {
    color: #76ff03;
  }
  .jss21 .lightGreen-A700 {
    color: #64dd17;
  }
  .jss21 .lime-50 {
    color: #f9fbe7;
  }
  .jss21 .lime-100 {
    color: #f0f4c3;
  }
  .jss21 .lime-200 {
    color: #e6ee9c;
  }
  .jss21 .lime-300 {
    color: #dce775;
  }
  .jss21 .lime-400 {
    color: #d4e157;
  }
  .jss21 .lime-500 {
    color: #cddc39;
  }
  .jss21 .lime-600 {
    color: #c0ca33;
  }
  .jss21 .lime-700 {
    color: #afb42b;
  }
  .jss21 .lime-800 {
    color: #9e9d24;
  }
  .jss21 .lime-900 {
    color: #827717;
  }
  .jss21 .lime-A100 {
    color: #f4ff81;
  }
  .jss21 .lime-A200 {
    color: #eeff41;
  }
  .jss21 .lime-A400 {
    color: #c6ff00;
  }
  .jss21 .lime-A700 {
    color: #aeea00;
  }
  .jss21 .yellow-50 {
    color: #fffde7;
  }
  .jss21 .yellow-100 {
    color: #fff9c4;
  }
  .jss21 .yellow-200 {
    color: #fff59d;
  }
  .jss21 .yellow-300 {
    color: #fff176;
  }
  .jss21 .yellow-400 {
    color: #ffee58;
  }
  .jss21 .yellow-500 {
    color: #ffeb3b;
  }
  .jss21 .yellow-600 {
    color: #fdd835;
  }
  .jss21 .yellow-700 {
    color: #fbc02d;
  }
  .jss21 .yellow-800 {
    color: #f9a825;
  }
  .jss21 .yellow-900 {
    color: #f57f17;
  }
  .jss21 .yellow-A100 {
    color: #ffff8d;
  }
  .jss21 .yellow-A200 {
    color: #ffff00;
  }
  .jss21 .yellow-A400 {
    color: #ffea00;
  }
  .jss21 .yellow-A700 {
    color: #ffd600;
  }
  .jss21 .amber-50 {
    color: #fff8e1;
  }
  .jss21 .amber-100 {
    color: #ffecb3;
  }
  .jss21 .amber-200 {
    color: #ffe082;
  }
  .jss21 .amber-300 {
    color: #ffd54f;
  }
  .jss21 .amber-400 {
    color: #ffca28;
  }
  .jss21 .amber-500 {
    color: #ffc107;
  }
  .jss21 .amber-600 {
    color: #ffb300;
  }
  .jss21 .amber-700 {
    color: #ffa000;
  }
  .jss21 .amber-800 {
    color: #ff8f00;
  }
  .jss21 .amber-900 {
    color: #ff6f00;
  }
  .jss21 .amber-A100 {
    color: #ffe57f;
  }
  .jss21 .amber-A200 {
    color: #ffd740;
  }
  .jss21 .amber-A400 {
    color: #ffc400;
  }
  .jss21 .amber-A700 {
    color: #ffab00;
  }
  .jss21 .orange-50 {
    color: #fff3e0;
  }
  .jss21 .orange-100 {
    color: #ffe0b2;
  }
  .jss21 .orange-200 {
    color: #ffcc80;
  }
  .jss21 .orange-300 {
    color: #ffb74d;
  }
  .jss21 .orange-400 {
    color: #ffa726;
  }
  .jss21 .orange-500 {
    color: #ff9800;
  }
  .jss21 .orange-600 {
    color: #fb8c00;
  }
  .jss21 .orange-700 {
    color: #f57c00;
  }
  .jss21 .orange-800 {
    color: #ef6c00;
  }
  .jss21 .orange-900 {
    color: #e65100;
  }
  .jss21 .orange-A100 {
    color: #ffd180;
  }
  .jss21 .orange-A200 {
    color: #ffab40;
  }
  .jss21 .orange-A400 {
    color: #ff9100;
  }
  .jss21 .orange-A700 {
    color: #ff6d00;
  }
  .jss21 .deepOrange-50 {
    color: #fbe9e7;
  }
  .jss21 .deepOrange-100 {
    color: #ffccbc;
  }
  .jss21 .deepOrange-200 {
    color: #ffab91;
  }
  .jss21 .deepOrange-300 {
    color: #ff8a65;
  }
  .jss21 .deepOrange-400 {
    color: #ff7043;
  }
  .jss21 .deepOrange-500 {
    color: #ff5722;
  }
  .jss21 .deepOrange-600 {
    color: #f4511e;
  }
  .jss21 .deepOrange-700 {
    color: #e64a19;
  }
  .jss21 .deepOrange-800 {
    color: #d84315;
  }
  .jss21 .deepOrange-900 {
    color: #bf360c;
  }
  .jss21 .deepOrange-A100 {
    color: #ff9e80;
  }
  .jss21 .deepOrange-A200 {
    color: #ff6e40;
  }
  .jss21 .deepOrange-A400 {
    color: #ff3d00;
  }
  .jss21 .deepOrange-A700 {
    color: #dd2c00;
  }
  .jss21 .brown-50 {
    color: #efebe9;
  }
  .jss21 .brown-100 {
    color: #d7ccc8;
  }
  .jss21 .brown-200 {
    color: #bcaaa4;
  }
  .jss21 .brown-300 {
    color: #a1887f;
  }
  .jss21 .brown-400 {
    color: #8d6e63;
  }
  .jss21 .brown-500 {
    color: #795548;
  }
  .jss21 .brown-600 {
    color: #6d4c41;
  }
  .jss21 .brown-700 {
    color: #5d4037;
  }
  .jss21 .brown-800 {
    color: #4e342e;
  }
  .jss21 .brown-900 {
    color: #3e2723;
  }
  .jss21 .brown-A100 {
    color: #d7ccc8;
  }
  .jss21 .brown-A200 {
    color: #bcaaa4;
  }
  .jss21 .brown-A400 {
    color: #8d6e63;
  }
  .jss21 .brown-A700 {
    color: #5d4037;
  }
  .jss21 .grey-50 {
    color: #fafafa;
  }
  .jss21 .grey-100 {
    color: #f5f5f5;
  }
  .jss21 .grey-200 {
    color: #eeeeee;
  }
  .jss21 .grey-300 {
    color: #e0e0e0;
  }
  .jss21 .grey-400 {
    color: #bdbdbd;
  }
  .jss21 .grey-500 {
    color: #9e9e9e;
  }
  .jss21 .grey-600 {
    color: #757575;
  }
  .jss21 .grey-700 {
    color: #616161;
  }
  .jss21 .grey-800 {
    color: #424242;
  }
  .jss21 .grey-900 {
    color: #212121;
  }
  .jss21 .grey-A100 {
    color: #d5d5d5;
  }
  .jss21 .grey-A200 {
    color: #aaaaaa;
  }
  .jss21 .grey-A400 {
    color: #303030;
  }
  .jss21 .grey-A700 {
    color: #616161;
  }
  .jss21 .blueGrey-50 {
    color: #eceff1;
  }
  .jss21 .blueGrey-100 {
    color: #cfd8dc;
  }
  .jss21 .blueGrey-200 {
    color: #b0bec5;
  }
  .jss21 .blueGrey-300 {
    color: #90a4ae;
  }
  .jss21 .blueGrey-400 {
    color: #78909c;
  }
  .jss21 .blueGrey-500 {
    color: #607d8b;
  }
  .jss21 .blueGrey-600 {
    color: #546e7a;
  }
  .jss21 .blueGrey-700 {
    color: #455a64;
  }
  .jss21 .blueGrey-800 {
    color: #37474f;
  }
  .jss21 .blueGrey-900 {
    color: #263238;
  }
  .jss21 .blueGrey-A100 {
    color: #cfd8dc;
  }
  .jss21 .blueGrey-A200 {
    color: #b0bec5;
  }
  .jss21 .blueGrey-A400 {
    color: #78909c;
  }
  .jss21 .blueGrey-A700 {
    color: #455a64;
  }
  .jss21 .MuiDivider-root {
    border: none;
    height: 1px;
    margin: 0;
    flex-shrink: 0;
    background-color: rgba(255, 255, 255, 0.12);
  }
  .jss21 h1, .jss21 h2, .jss21 h3, .jss21 h4, .jss21 h5, .jss21 h6 {
    margin-top: 80px;
  }
  .jss21 h1, .jss21 h2, .jss21 h3 {
    border-bottom: 1px solid rgba(255, 255, 255, 0.12);
  }
  .jss21 a {
    color: #29b6f6;
  }
  .jss21 blockquote {
    color: #AAA;
    padding: 15px 25px;
    font-style: italic;
    margin-top: 64px;
    border-left: 4px solid #ff9800;
    margin-bottom: 64px;
    background-color: #222;
  }
  .jss21 img {
    margin: 0 auto;
    display: block;
    max-width: 100%;
    margin-top: 80px;
    margin-bottom: 80px;
  }
  .jss21 p span {
    word-break: break-word;
  }
  .jss21 strong {
    word-break: break-word;
  }
  .jss21 table {
    margin: auto;
    display: block;
    padding: 0;
    overflow: auto;
    font-size: 1rem;
    margin-top: 56px;
    margin-bottom: 56px;
    border-collapse: collapse;
  }
  .jss21 iframe {
    max-width: 100%;
  }
  .jss21 code:not([class*='language-']) {
    color: white;
    padding: 5px;
    font-size: 0.75em;
    word-break: break-word;
    font-family: Hack, 나눔스퀘어라운드, monospace;
    margin-left: 8px;
    user-select: text;
    margin-right: 8px;
    border-radius: 5px;
    -ms-user-select: text;
    -moz-user-select: text;
    background-color: #303f9f;
    -webkit-user-select: text;
  }
  .jss21 code[class*='language-'], .jss21 pre[class*='language-'] {
    color: #ccc;
    hyphens: none;
    tab-size: 4;
    font-size: 16px;
    word-wrap: normal;
    background: none;
    text-align: left;
    word-break: normal;
    -ms-hyphens: none;
    font-family: Hack, 나눔스퀘어라운드, monospace;
    line-height: 1.5;
    white-space: pre;
    -moz-hyphens: none;
    word-spacing: normal;
    -moz-tab-size: 4;
    -webkit-hyphens: none;
  }
  .jss21 pre[class*='language-'] {
    margin: .5em 0;
    padding: 2em;
    overflow: auto;
  }
  .jss21 :not(pre) > code[class*='language-'], .jss21 pre[class*='language-'] {
    background: #020213;
    border-radius: 10px;
  }
  .jss21 :not(pre) > code[class*='language-'] {
    padding: .1em;
    white-space: normal;
    border-radius: .3em;
  }
  .jss21 pre.language-tc {
    overflow: auto;
    max-height: 300px;
  }
  .jss21 .token.comment, .jss21 .token.block-comment, .jss21 .token.prolog, .jss21 .token.doctype, .jss21 .token.cdata {
    color: #00c800;
  }
  .jss21 .token.punctuation {
    color: #ccc;
  }
  .jss21 .token.tag, .jss21 .token.attr-name, .jss21 .token.namespace, .jss21 .token.deleted {
    color: #e2777a;
  }
  .jss21 .token.function-name {
    color: #6196cc;
  }
  .jss21 .token.boolean, .jss21 .token.number, .jss21 .token.function {
    color: #f08d49;
  }
  .jss21 .token.property, .jss21 .token.class-name, .jss21 .token.constant, .jss21 .token.symbol {
    color: #f8c555;
  }
  .jss21 .token.selector, .jss21 .token.important, .jss21 .token.atrule, .jss21 .token.keyword, .jss21 .token.builtin {
    color: #cc99cd;
  }
  .jss21 .token.string, .jss21 .token.char, .jss21 .token.attr-value, .jss21 .token.regex, .jss21 .token.variable {
    color: #7ec699;
  }
  .jss21 .token.operator, .jss21 .token.entity, .jss21 .token.url {
    color: #67cdcc;
  }
  .jss21 .token.important, .jss21 .token.bold {
    font-weight: bold;
  }
  .jss21 .token.italic {
    font-style: italic;
  }
  .jss21 .token.entity {
    cursor: help;
  }
  .jss21 .token.inserted {
    color: green;
  }
  .jss21 a.head-link {
    margin-right: 8px;
    text-decoration: none;
  }
  .jss21 .toc-wrap {
    padding: 24px;
    margin-top: 80px;
    background-color: #222;
  }
  .jss21 .math-display {
    overflow: auto;
  }
  .jss21 .toc-wrap .toc-link {
    color: #fff;
    transition: 500ms;
    text-decoration: none;
  }
  .jss21 .toc-wrap .toc-item-h1 {
    margin-top: 24px;
    margin-bottom: 24px;
  }
  .jss21 .toc-wrap .toc-link:hover {
    color: #2196f3;
    transition: 500ms;
  }
  .jss21 table tr {
    margin: 0;
    padding: 0;
    border-top: 1px solid #333333;
    background-color: transparent;
  }
  .jss21 table tr:nth-child(2n) {
    background-color: #041733;
  }
  .jss21 table tr th {
    border: 1px solid #333333;
    margin: 0;
    padding: 6px 13px;
    word-break: keep-all;
    font-weight: bold;
  }
  .jss21 table tr td {
    border: 1px solid #333333;
    margin: 0;
    padding: 6px 13px;
    word-break: keep-all;
  }
  .jss21 table tr th :first-child, .jss21 table tr td :first-child {
    margin-top: 0;
  }
  .jss21 table tr th :last-child, .jss21 table tr td :last-child {
    margin-bottom: 0;
  }
  .jss21 blockquote > :first-child {
    margin-top: 0;
  }
  .jss21 blockquote > :last-child {
    margin-bottom: 0;
  }
  .jss21 .remark-highlight * {
    user-select: text;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
  }
  .jss22 {
    font-size: 2em;
    font-weight: bold;
  }
  .jss23 {
    margin-top: 24px;
    margin-bottom: 24px;
  }
  .jss24 {
    cursor: pointer;
    flex-wrap: nowrap;
    transform: translateZ(0);
  }
  .jss25:hover img {
    transform: translateY(-50%) scale(1.2);
    transition: 0.5s;
  }
  .jss25 .MuiGridListTileBar-title {
    transition: 0.5s;
  }
  .jss25:hover .MuiGridListTileBar-title {
    color: #1976d2;
    transition: 0.5s;
  }
  .jss26 {
    transition: 0.5s;
  }
  .jss29 {
    margin-bottom: 40px;
  }
  .jss30 {
    margin-right: 24px;
  }
  .jss32 {
    height: 100%;
  }
  .jss37 {
    margin-top: 80px;
  }
  .jss39 {
    margin-top: 160px;
    padding-bottom: 80px;
  }
  .jss40 {
    margin-top: 80px;
  }
  .jss40 > div {
    margin-bottom: 40px;
  }
  .jss41 {
    animation: rotate 5s linear infinite;
    transform-origin: 50% 50%;
  }
  .jss42 {
    color: #CCCCCC;
    font-family: 나눔스퀘어라운드, sans-serif;
    font-weight: bold;
    margin-bottom: 24px;
  }
  .jss43 {
    color: #CCCCCC;
  }
  .jss45 {
    border: 3px solid white;
    margin-left: 16px;
    margin-right: 16px;
  }
  .jss46 {
    color: #CCCCCC;
    margin: 8px;
  }
  .jss61 {
    color: #eeeeee;
    right: 50px;
    bottom: 50px;
    position: fixed;
    background-color: #424242;
  }
  .jss61:hover {
    background-color: #616161;
  }
  .jss61 svg {
    color: #fb8c00;
  }
@media (min-width:960px) {
  .jss61 span {
    margin-left: 8px;
  }
}
@media (max-width:959.95px) {
  .jss61 {
    right: 20px;
    bottom: 70px;
  }
}
  .jss62 {
    color: #212121;
    right: 50px;
    bottom: 50px;
    position: fixed;
    background-color: #eeeeee;
  }
  .jss62:hover {
    background-color: #e0e0e0;
  }
  .jss62 svg {
    color: #1e88e5;
  }
@media (min-width:960px) {
  .jss62 span {
    margin-left: 8px;
  }
}
@media (max-width:959.95px) {
  .jss62 {
    right: 20px;
    bottom: 70px;
  }
}
  .jss63 {
    height: 24px;
  }</style></head><body><div id="__next"><header class="MuiBox-root jss4"><header class="MuiPaper-root MuiAppBar-root MuiAppBar-positionFixed MuiAppBar-colorPrimary jss1 mui-fixed MuiPaper-elevation4"><div class="MuiToolbar-root MuiToolbar-regular jss2 MuiToolbar-gutters"><div class="MuiContainer-root jss3 MuiContainer-maxWidthLg"></div></div></header></header><div class="react-reveal"><div class="MuiBox-root jss17 jss8" id="top"><div class="MuiBox-root jss18 jss9"><div class="MuiBox-root jss19 jss10"></div></div><div class="MuiBox-root jss20 jss11"><h3 class="MuiTypography-root jss14 MuiTypography-h3 MuiTypography-alignCenter" up="h3" down="h5"><div class="react-reveal">[알고리즘]</div></h3><h2 class="MuiTypography-root jss12 MuiTypography-h2 MuiTypography-alignCenter" up="h2" down="h4"><div class="react-reveal">자료구조가 중요한 까닭</div></h2><h4 class="MuiTypography-root jss14 MuiTypography-h4 MuiTypography-alignCenter" up="h4" down="h6"><div class="react-reveal">2021-07-10 Sat 01:30:56</div></h4></div><button class="MuiButtonBase-root jss15" tabindex="0" type="button"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"></path></svg></button><hr class="MuiDivider-root jss16"/></div></div><div class="MuiContainer-root MuiContainer-maxWidthMd"><div class="jss21"><nav class="toc-wrap"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#개요">개요</a></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#1장-자료-구조가-중요한-까닭">1장 자료 구조가 중요한 까닭</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#1-1-배열-기초-자료-구조">1-1. 배열: 기초 자료 구조</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#1-2-읽기">1-2 읽기</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#1-3-검색">1-3. 검색</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#1-4-삽입">1-4. 삽입</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#1-5-삭제">1-5. 삭제</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#1-6-집합-단-하나의-규칙이-효율성을-바꾼다">1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다</a></li></ol></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#마무리">마무리</a></li></ol></nav><p class="orange-A400" align="center">본 포스팅은 개인 스터디 모임 활동의 일환으로, "누구나 자료구조와 알고리즘" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>
<h1 id="개요"><a class="head-link" href="#개요"><span>🔗</span></a>개요</h1>
<p>혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다.</p>
<p>마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.</p>
<p>비전공자가 자료구조같은 기초지식이 항상 아킬레스건이였다. 특히 백준 풀 때 뼈저리게 느끼지만. 이 스터디가 끝나면 자료구조에 대해 기초정도는 알 수 있었음 한다.</p>
<p>언어는 가급적 <span class="orange-400">JAVA</span>로 진행한다.</p>
<h1 id="1장-자료-구조가-중요한-까닭"><a class="head-link" href="#1장-자료-구조가-중요한-까닭"><span>🔗</span></a>1장 자료 구조가 중요한 까닭</h1>
<p>이 장에서는 배열의 기초와 그에 해당하는 연산들에 대한 내용을 소개하면서 사용자에게 배열에 관한 러프한 개념을 설명해준다.</p>
<p>배열과 <span class="primary">집합</span>이라는 개념에 대한 내용을 기술한다. 저자에 의하면 챕터가 진행될 수록 연산 성능에 대한 점진적인 비교를 한다고 하니, 알고리즘 적용에 따른 성능 향상의 차이를 확인해 볼 수 있을 것이다.</p>
<h2 id="1-1-배열-기초-자료-구조"><a class="head-link" href="#1-1-배열-기초-자료-구조"><span>🔗</span></a>1-1. 배열: 기초 자료 구조</h2>
<p><span class="primary">배열</span>은 거의 모든 언어에 존재하는 매우 기초적인 자료구조다.</p>
<p>JAVA에는 <code>int</code>, <code>boolean</code>과 같은 <span class="green-A400">기본형 타입(Primitive Type)</span>과 <code>String</code>, <code>HashMap</code>과 같은 <span class="green-A400">참조형 타입(Reference Type)</span>으로 구분된다.</p>
<p>이와 같은 데이터들은 각각 단일로 사용할 수도 있지만, 다수의 데이터를 동시에 다뤄야하는 경우가 심심치않게 발생한다. 이러한 데이터들이 모여 하나의 배열이 될 수 있다.</p>
<p><code>String</code> 데이터가 모여 <code>String[]</code>이라는 <span class="primary">문자열 배열</span>이 되며, <code>int</code> 데이터가 모여 <code>int[]</code>라는 <span class="primary">정수 배열</span>이 된다.</p>
<p>JAVA에서의 배열은 이처럼 특정한 데이터가 여러개 모인 자료 구조이며, 반드시 <span class="red-A400">지정된 데이터만을 요소로 받아들일 수 있다.</span></p>
<p>예를 들어, <code>boolean</code>은 <code>true</code>, <code>false</code>로 이루어진 데이터 형식이다. <code>boolean[]</code>은 <code>boolean</code> 데이터가 여러개 모인 배열이며, 이렇게 선언된 배열은 <code>boolean</code>에 해당하는 <code>true</code>, <code>false</code>만 받아들일 수 있다. 즉, 1이나 "A"와 같은 문자열은 배열에 삽입할 수 없다.</p>
<p>또한 <span class="red-A400">배열은 고정 길이를 가진다.</span> 한 번 할당된 배열의 길이는 재할당되지 않는 이상 절대로 길이가 변경되지 않는다.</p>
<blockquote>
<p><strong>⚠잠깐! 이건 어디까지나 JAVA 얘기에요!</strong><br>
지금 설명하는 배열의 특징은 JAVA에 국한되는 예시다. 당장 JavaScript만 봐도, 배열에 별다른 제약이 존재하지 않는다. 길이는 필요에 따라 증축할 수 있으며, 요소에 아무 데이터 타입이나 할당 가능하다.</p>
</blockquote>
<p>JAVA에서 배열은 <span class="green-A400">참조형 타입(Reference Type)</span>에 해당한다.</p>
<p>배열에서 수행 가능한 연산에는 4가지가 존재한다.</p>
<ul>
<li>읽기</li>
<li>검색</li>
<li>삽입</li>
<li>삭제</li>
</ul>
<p>위 4가지 연산은 배열의 가장 기초적인 연산이다. 이 4가지 연산을 JAVA로 직접 구현하며 어떤 단계를 거치는지 확인해보자.</p>
<h2 id="1-2-읽기"><a class="head-link" href="#1-2-읽기"><span>🔗</span></a>1-2 읽기</h2>
<p><span class="primary">읽기</span>연산은 배열의 특정 인덱스에 어떠한 값이 있는지 읽는 연산이다.</p>
<p>대부분 모든 언어의 런타임에서 할당되는 데이터들은 메모리에 기록된다. 많은 양의 데이터가 할당될수록 프로그램이 요구하는 메모리, 즉 RAM의 요구사항이 높아진다. 배틀그라운드나, 스타크래프트2와 같은 게임들은 많은 양의 메모리를 요구한다. 그 만큼 기록되고 처리되는 데이터의 양이 매우 방대하기 때문이다.</p>
<p>데이터가 메모리에 할당될 때, 가용한 임의의 메모리 주소에 저장된다. 해당 메모리 주소에 원하는 값이 존재할 것이므로, 값을 호출하기 위해선 해당 값이 저장된 메모리 주소에 접근하여 값을 조회한다. JAVA를 포함한 대부분의 언어들은 이러한 과정이 개발자에게까지 노출되지 않는 내부의 영역에 존재한다. 이걸 직접 다루는 것이 C언어의 그 악명높은 포인터다.</p>
<p>JAVA의 메모리는 JVM(Java Virtual Machine, 자바 가상머신)이 관리한다. JVM의 메모리 구조부터 시작하면 한도끝도 없이 브랜치가 뻗어나가니, 핵심만 찝어보자.</p>
<p>위에서 언급했듯이, 배열은 참조형 타입이며, 이 참조형 타입은 JVM의 Heap 영역에서 관리한다. 메모리를 간략하게 도식화하면 아래와 같이 표현할 수 있다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111131-7dc1fb80-e120-11eb-8a75-0cf615c9c020.png" width="600px">
</p>
<p>네모 한 칸에 하나의 데이터를 할당할 수 있다고 해보자. 만약 6, 43, 14, 9, 94 5개의 정수로 이루어진 정수형 배열을 메모리에 할당한다고 가정하자. JVM이 해당 배열의 크기를 메모리에 기록할 수 있는지 확인하고, 가능하다면 기록한다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111294-b2ce4e00-e120-11eb-8a6e-d5fc241db0ee.png" width="600px">
</p>
<p>위 처럼 메모리 상의 적절한 위치에 배열이 기록될 것이다. 여기서 배열의 4번째 데이터를 읽어보자.</p>
<p>프로그램은 해당 배열의 주소를 알고있다. 자기가 직접 할당했으니 당연하다. 배열의 주소를 0x0404라고 가정하면 아래와 같이 도식할 수 있다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png" width="600px">
</p>
<p>0x0404에서 4번째 데이터를 호출하므로 0x0407의 데이터를 조회하면 된다.</p>
<blockquote>
<p><strong>😒아니 4번째 데이터라면서요...</strong><br>
거의 대부분의 컴퓨터 언어는 시작 인덱스를 0으로 지정한다. 그 이유는 메모리에 있는데, 메모리를 기준으로 배열의 첫 번째 데이터는 주소의 이동이 없다.<br>
만약 주소가 0x0101이라면, 첫 번째 데이터는 0x0101이 되기 때문에 주소의 이동이 없으므로 0번째 데이터라고 정의하는 것이다. 이는 관점의 차이로, 초대 프로그램의 언어가 이와 같은 방식을 차용했다. 이후 이를 기반으로 생겨난 수 많은 언어들이 이 영향을 받았다.</p>
</blockquote>
<p>이처럼 배열의 주소에서 해당 인덱스만큼 주소에 더해 데이터를 읽는 것이므로, 동작은 아래와 같다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111156-887c9080-e120-11eb-94db-46545b8a5e9c.png" width="600px">
</p>
<p>주소 0x0404를 시작으로 4번째 데이터인 0x0407인 주소에 접근한다. 배열의 주소와 배열의 인덱스를 알고 있으므로 별도의 연산 없이 바로 접근 가능하다. 이로써 0x0407의 값 9에 접근할 수 있다.</p>
<div class="remark-highlight"><pre class="language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedWriter</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStreamWriter</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 누구나 자료 구조와 알고리즘 배열 읽기 클래스
 *
 * <span class="token keyword">@author</span> RWB
 * <span class="token keyword">@see</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>자료구조가 중요한 까닭<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>a</span><span class="token punctuation">></span></span>
 * <span class="token keyword">@since</span> 2021.07.09 Fri 22:53:39
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayRead</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 배열</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">94</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	<span class="token doc-comment comment">/**
	 * 메인 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">args</span>: [String[]] 매개변수
	 *
	 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IOException</span></span> 데이터 입출력 예외
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
	<span class="token punctuation">{</span>
		<span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 읽을 인덱스</span>
		<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
		
		<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"4번 째 아이템: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token doc-comment comment">/**
	 * 배열 읽기 결과 반환 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">index</span>: [int] 인덱스
	 *
	 * <span class="token keyword">@return</span> [int] 인덱스에 해당하는 값
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> ARRAY<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="remark-highlight"><pre class="language-tc"><code class="language-tc">4번 째 아이템: 9</code></pre></div>
<p>JAVA 소스는 위와 같다. 배열 <code>array</code>을 선언하고, <code>array[3]</code>을 호출하면 배열의 4번째 값인 94가 변수 <code>four</code>에 할당된다. 목표에 바로 접근하므로 작업에 필요한 단계는 단 하나다.</p>
<h2 id="1-3-검색"><a class="head-link" href="#1-3-검색"><span>🔗</span></a>1-3. 검색</h2>
<p>이처럼 주소의 값이나 인덱스를 정확히 알고 있다면, 별도의 연산 없이 바로 해당하는 값을 갖고올 수 있다. 하지만 실제로 배열을 다루다보면 꼭 이렇게 간단한 케이스만 있지는 않다.</p>
<p>우리가 구조를 알지 못하는 배열이 있다고 가정할 때, 해당 배열에서 우리가 원하는 값을 찾아야할 경우가 적지않게 발생한다. 이 경우 원하는 값의 인덱스를 가지고 있지도 않으며, 심지어 배열 내부에 원하는 값이 존재하는지조차 알 수 없다. 이 경우 <span class="primary">검색</span>연산을 통해 배열의 값을 찾아야 한다.</p>
<p>위에서 선언했던 배열을 다시 가져와보자.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png" width="600px">
</p>
<p>이번엔 우리가 이 배열에 대한 정확한 정보를 가지고있지 않다고 가정해보자. 현재 우리는 이 배열의 어떤 인덱스에 어떤 값이 있는지 전혀 모르는 상태다.</p>
<p>이 상황에서 14라는 값을 검색해보자.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111164-8a465400-e120-11eb-9432-8c127bfed9b2.png" width="600px">
</p>
<p>검색은 읽기 작업의 반복이라고 봐도 무방하다. 위 그림은 이러한 검색의 특성을 여실히 보여준다. 목표값인 14를 찾기 위해 <code>array[0]</code> 부터 순차적으로 읽음으로써 14를 찾는다.</p>
<p>만약 어떠한 방법으로든 읽기과정을 줄이면서도 정상적인 검색이 가능하다면 소요시간이 효과적으로 감소할 것이다.</p>
<div class="remark-highlight"><pre class="language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedWriter</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStreamWriter</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 누구나 자료 구조와 알고리즘 배열 검색 클래스
 *
 * <span class="token keyword">@author</span> RWB
 * <span class="token keyword">@see</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>자료구조가 중요한 까닭<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>a</span><span class="token punctuation">></span></span>
 * <span class="token keyword">@since</span> 2021.07.09 Fri 23:47:03
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayFind</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">94</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	<span class="token doc-comment comment">/**
	 * 메인 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">args</span>: [String[]] 매개변수
	 *
	 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IOException</span></span> 데이터 입출력 예외
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
	<span class="token punctuation">{</span>
		<span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 목표 숫자</span>
		<span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">;</span>
		
		<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"이 포함된 인덱스: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token doc-comment comment">/**
	 * 요소 검색 및 인덱스 반환 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">target</span>: [int] 목표 숫자
	 *
	 * <span class="token keyword">@return</span> [int] 인덱스
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// 인덱스</span>
		<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> ARRAY<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token comment">// 목표 숫자와 배열의 값이 일치할 경우</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> ARRAY<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				result <span class="token operator">=</span> i<span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="remark-highlight"><pre class="language-tc"><code class="language-tc">14이 포함된 인덱스: 2</code></pre></div>
<p>하지만 위는 가장 기초적인 검색 알고리즘을 적용한 것이다. 3번째 요소를 찾기 위해선 3개 과정이 필요하고, 5484번째 요소를 찾기 위해선 5484개 과정이 필요하다.</p>
<p>그러나, 요소가 맨 끝에 있거나, 불행히도 배열 내에 존재하지 않을 경우 배열 전체를 검색해야할 수도 있다. 즉 배열에 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개의 요소가 있다면, 검색의 최대 작업 갯수는 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개가 된다.</p>
<h2 id="1-4-삽입"><a class="head-link" href="#1-4-삽입"><span>🔗</span></a>1-4. 삽입</h2>
<p>배열에 새로운 요소를 넣는 작업을 <span class="primary">삽입</span> 연산이라 한다. 배열에서 55를 삽입하는 과정을 통해 삽입 연산에 대해 알아보자.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111179-8d414480-e120-11eb-9c36-965d4506fd8c.png" width="600px">
</p>
<p>런타임 시 배열을 할당했다면 우리는 배열의 주소를 알고 있을 것이다. 배열의 맨 끝에 요소를 추가한다면 그냥 이어붙이면 된다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111188-8fa39e80-e120-11eb-8576-aee6d30ae3a7.png" width="600px">
</p>
<p>하지만 배열의 중간에 삽입한다면 이야기가 조금 달라진다. 삽입하려는 위치 이후의 요소를 한 칸씩 뒤로 미루고, 해당 위치에 값을 삽입하게 된다.</p>
<p>최악의 경우, 배열의 가장 첫 인덱스인 0의 위치에 요소를 삽입한다면 모든 배열의 요소를 한 칸씩 뒤로 미룬뒤 55를 삽입해야한다. 즉, 배열에 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개의 요소가 있을 경우 삽입에 필요한 작업량은 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개의 요소를 하나씩 이동하는 작업 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>의 작업량이 발생할 수 있다.</p>
<div class="remark-highlight"><pre class="language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedWriter</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStreamWriter</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 누구나 자료 구조와 알고리즘 배열 삽입 클래스
 *
 * <span class="token keyword">@author</span> RWB
 * <span class="token keyword">@see</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>자료구조가 중요한 까닭<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>a</span><span class="token punctuation">></span></span>
 * <span class="token keyword">@since</span> 2021.07.09 Sat 00:27:47
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayInsert</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 배열</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">94</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	<span class="token doc-comment comment">/**
	 * 메인 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">args</span>: [String[]] 매개변수
	 *
	 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IOException</span></span> 데이터 입출력 예외
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
	<span class="token punctuation">{</span>
		<span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 삽입할 인덱스</span>
		<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 삽입할 요소</span>
		<span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>
		
		<span class="token function">insert</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"번 째 요소에 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" 삽입: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>ARRAY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token doc-comment comment">/**
	 * 배열 삽입 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">index</span>: [int] 삽입 위치
	 * <span class="token keyword">@param</span> <span class="token parameter">item</span>: [int] 삽입할 요소
	 */</span>
	<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"ManualArrayCopy"</span><span class="token punctuation">)</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// 배열의 값이 -1(빈 요소)가 아닐 경우</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ARRAY<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> ARRAY<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				ARRAY<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ARRAY<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
		ARRAY<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="remark-highlight"><pre class="language-tc"><code class="language-tc">2번 째 요소에 55 삽입: [6, 43, 55, 14, 9, 94, -1, -1, -1, -1]</code></pre></div>
<p>삽입 소스는 위와 같다.</p>
<blockquote>
<p><strong>@SuppressWarnings는 뭔가요?</strong><br>
Eclipse, IntelliJ와 같은 IDE는 코드를 분석하는 과정에서 오류 또는 경고를 개발자에게 알려줌으로써 잠재적 위험을 제거할 수 있도록 유도한다. 간혹 의도된 동작임에도, IDE의 최적화 설정과 맞지 않아 경고를 띄우기도 한다. 이 경우 @SuppressWarnings 애노테이션을 쓰면 해당 경고를 무시할 수 있다. @@SuppressWarnings를 지워도 소스 동작엔 아무런 문제가 없다.</p>
</blockquote>
<p>위에서도 언급했지만, JAVA의 배열은 고정길이를 가진다. 삽입 연산을 하기 위해선 필연적으로 현재 배열의 크기보다 하나 이상 커야하므로, 이전과 달이 총 길이가 10인 배열을 선언했다. 배열의 요소가 -1일 경우, 해당 요소는 아직 할당되지 않은 빈 요소로 간주한다.</p>
<blockquote>
<p><strong>가변 길이를 가지는 List</strong><br>
JAVA에서도 얼마든지 가변길이 배열이 필요한 경우가 생긴다. 이 경우 <code>ArrayList</code>와 같은 <code>List</code> 데이터를 활용하면 된다. <code>List</code>는 가변길이를 가짐으로써 비정형화된 배열 데이터를 다루는데 유리하다.</p>
</blockquote>
<p>배열의 가장 끝 요소부터 삽입하려는 인덱스 이전까지 순차적으로 내려오며 현재 요소의 값을 이전 요소의 값으로 할당하여 요소를 이동시킨다. 이후 삽입하려는 인덱스에 요소를 할당함으로써 삽입이 완료된다.</p>
<h2 id="1-5-삭제"><a class="head-link" href="#1-5-삭제"><span>🔗</span></a>1-5. 삭제</h2>
<p>삽입을 했으니, 반대로 <span class="primary">삭제</span>도 필요할 수 있다. 삭제 연산은 원하는 인덱스의 요소를 삭제하는 것이다. 간단히 말하자면, 삽입과 정 반대의 프로세스를 가진다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111198-93372580-e120-11eb-9949-aa21aef11dfa.png" width="600px">
</p>
<p>마찬가지로, 배열의 맨 끝에 요소를 삭제한다면 그냥 끝의 요소를 삭제하면 그만이다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111204-9500e900-e120-11eb-8c44-c45faeb459fd.png" width="600px">
</p>
<p>하지만 배열의 중간을 삭제한다면 동일한 작업이 필요하다. 삭제하려는 위치의 요소를 삭제하고, 요소를 한 칸씩 당겨야 한다.</p>
<p>최악의 경우, 배열의 가장 첫 인덱스인 0의 위치의 요소를 삭제한다면 해당 요소를 삭제한 뒤 모든 배열의 요소를 한 칸씩 앞으로 당길 것이다. 즉, 배열에 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개의 요소가 있을 경우 삭제에 필요한 작업량은 해당 인덱스의 요소를 삭제하는 작업 1개, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>개의 요소를 하나씩 이동하는 작업 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>개로 최대 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>의 작업량이 발생할 수 있다.</p>
<div class="remark-highlight"><pre class="language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedWriter</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStreamWriter</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 누구나 자료 구조와 알고리즘 배열 삭제 클래스
 *
 * <span class="token keyword">@author</span> RWB
 * <span class="token keyword">@see</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>자료구조가 중요한 까닭<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>a</span><span class="token punctuation">></span></span>
 * <span class="token keyword">@since</span> 2021.07.09 Sat 00:59:02
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayDelete</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 배열</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">94</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	<span class="token doc-comment comment">/**
	 * 메인 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">args</span>: [String[]] 매개변수
	 *
	 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IOException</span></span> 데이터 입출력 예외
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
	<span class="token punctuation">{</span>
		<span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 삭제할 인덱스</span>
		<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		
		<span class="token function">remove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"번째 요소 삭제 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>ARRAY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token doc-comment comment">/**
	 * 배열 삭제 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">index</span>: [int] 삭제 위치
	 */</span>
	<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"ManualArrayCopy"</span><span class="token punctuation">)</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// 배열의 값이 -1(빈 요소)가 아닐 경우</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ARRAY<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> ARRAY<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				ARRAY<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ARRAY<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
			ARRAY<span class="token punctuation">[</span>ARRAY<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="remark-highlight"><pre class="language-tc"><code class="language-tc">2번째 요소 삭제 [6, 43, 9, 94, -1, -1, -1, -1, -1, -1]</code></pre></div>
<p>삭제 소스는 위와 같다.</p>
<p>삭제는 삽입과 달리 배열의 크기가 증가할 필요가 없다. 마찬가지로 배열의 요소가 -1일 경우, 해당 요소는 삭제된 빈 요소로 간주한다.</p>
<p>삽입과는 반대로, 삭제하려는 인덱스부터 배열의 끝까지 순차적으로 올라가며 현재 요소의 값을 이후 요소의 값으로 할당하여 요소를 이동시킨다. 이후 배열의 끝 요소를 제거함으로써 삭제가 완료된다.</p>
<h2 id="1-6-집합-단-하나의-규칙이-효율성을-바꾼다"><a class="head-link" href="#1-6-집합-단-하나의-규칙이-효율성을-바꾼다"><span>🔗</span></a>1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다</h2>
<p>배열의 경우 요소의 타입만 맞다면 별다른 신경을 쓰지 않는다. 이말인즉슨, 중복되는 요소에 대한 처리도 이루어지지 않는다. 하지만 종종 중복되는 값을 허용하지 않는 배열의 필요성이 생기기도 한다. 책에서는 이를 <span class="primary">집합</span>이라는 개념으로 설명한다.</p>
<p>배열에 요소를 삽입할 때, 중복여부를 확인하기 위해선 검색 작업이 선행되어야 한다. 검색을 통해 집합에 해당 요소가 없는 것이 확인될 경우에만 삽입이 이루어지는 방식이다.</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111212-97634300-e120-11eb-8d2e-c024761e23ff.png" width="600px">
</p>
<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/125111220-992d0680-e120-11eb-97a2-3e1e8eda7518.png" width="600px">
</p>
<p>위의 두 그림은 집합 개념이 적용된 배열에서 존재하지 않는 값 55와, 존재하는 값 14를 삽입했을 때 나타나는 결과를 도식화한 것이다.</p>
<p>55의 경우 기존에 존재하지 않았으므로 삽입이 가능하지만, 14의 경우 이미 2번 째 인덱스에 동일한 값이 있으므로 삽입이 불가능하다.</p>
<p>검증이 완료된 이후의 삽입 과정은 기존의 삽입 과정과 동일하다. 단, 작업량은 달라진다. 기존의 삽입 작업량에서 검색의 작업량이 추가되기 때문이다.</p>
<p>가장 최악의 케이스는 중복되지 않는 임의의 값을 배열의 0번 째 인덱스에 삽입하는 것이다. <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개의 요소를 가진 배열에서 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개 요소를 검색하는 작업량 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개의 요소를 하나씩 이동하는 작업 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2N + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>개의 작업량이 발생한다.</p>
<div class="remark-highlight"><pre class="language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedWriter</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStreamWriter</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 누구나 자료 구조와 알고리즘 집합 배열 클래스
 *
 * <span class="token keyword">@author</span> RWB
 * <span class="token keyword">@see</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>자료구조가 중요한 까닭<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>a</span><span class="token punctuation">></span></span>
 * <span class="token keyword">@since</span> 2021.07.10 Sat 01:30:56
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UniqueArray</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 배열</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">94</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	<span class="token doc-comment comment">/**
	 * 메인 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">args</span>: [String[]] 매개변수
	 *
	 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IOException</span></span> 데이터 입출력 예외
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span>
	<span class="token punctuation">{</span>
		<span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 삽입할 인덱스</span>
		<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 삽입할 요소</span>
		<span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>
		
		<span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token function">hasInserted</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"번 째 인덱스에 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" 삽입 결과: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token doc-comment comment">/**
	 * 집합 배열 삽입 결과 반환 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">index</span>: [int] 삽입 위치
	 * <span class="token keyword">@param</span> <span class="token parameter">item</span>: [int] 삽입할 요소
	 *
	 * <span class="token keyword">@return</span> [boolean] 삽입 결과
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasInserted</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 중복되지 않을 경우</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token function">insert</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">// 중복될 경우</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token doc-comment comment">/**
	 * 요소 검색 및 인덱스 반환 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">target</span>: [int] 목표 숫자
	 *
	 * <span class="token keyword">@return</span> [int] 인덱스
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// 인덱스</span>
		<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> ARRAY<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token comment">// 목표 숫자와 배열의 값이 일치할 경우</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> ARRAY<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				result <span class="token operator">=</span> i<span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token doc-comment comment">/**
	 * 배열 삽입 함수
	 *
	 * <span class="token keyword">@param</span> <span class="token parameter">index</span>: [int] 삽입 위치
	 * <span class="token keyword">@param</span> <span class="token parameter">item</span>: [int] 삽입할 요소
	 */</span>
	<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"ManualArrayCopy"</span><span class="token punctuation">)</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// 배열의 값이 -1(빈 요소)가 아닐 경우</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ARRAY<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> ARRAY<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				ARRAY<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ARRAY<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
		ARRAY<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="remark-highlight"><pre class="language-tc"><code class="language-tc">2번 째 인덱스에 55 삽입 결과: true</code></pre></div>
<p>집합 배열의 삽입 소스는 위와 같다.</p>
<p><code>find</code>와 <code>insert</code> 함수는 검색과 삽입 파트에서 사용한 로직과 동일한 로직이다. 집합 배열은 반드시 고유한 요소만을 삽입해야 하므로, <code>hasInserted</code> 함수를 구성하여 중복 여부를 검증한 뒤 삽입을 진행한다.</p>
<p><code>find</code> 함수는 검색되는 요소가 없을 경우 -1을 반환한다. 즉, -1을 반환하는 숫자는 고유한 숫자다. <code>find</code>가 -1을 반환할 경우 <code>insert</code> 함수로 삽입을 진행한다.</p>
<blockquote>
<p><strong>Set 객체는 중복을 허용하지 않아요</strong><br>
JAVA의 배열은 기본적으로 요소의 중복같은건 신경쓰지 않는다. 때문에, 요소의 중복을 감지하기 위해선 별도의 검증 로직을 구성해야한다.<br>
하지만 <code>HashSet</code>과 같은 <code>Set</code> 객체를 활용하면 항상 고유한 값만 삽입할 수 있다.</p>
</blockquote>
<h1 id="마무리"><a class="head-link" href="#마무리"><span>🔗</span></a>마무리</h1>
<p>이 장에서는 최대한 개념 위주로 설명하며, 설명에 어떠한 알고리즘 지식이 들어가지 않은 것으로 보인다. 이러한 저자의 의도를 최대한 반영하여, 내 로직 역시 가능한 기본 데이터 타입을 사용했으며, 복잡한 로직을 최대한 지양했다. 철저히 연산이 동작하는 기본 원리에 입각하도록 소스를 구성했다.</p>
<p>다음 장에서는 알고리즘에 대한 본격적인 내용이 기술될 것이다.</p></div><article class="MuiBox-root jss27"><h1 class="MuiTypography-root jss22 MuiTypography-body1">◎ 연관 게시물</h1><div class="MuiBox-root jss28 jss23"><ul class="MuiGridList-root jss24" style="margin:-2px"><li class="MuiGridListTile-root jss25" style="width:40%;height:184px;padding:2px"><div class="MuiGridListTile-tile"><img src="https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png" class="jss26"/><div class="MuiGridListTileBar-root MuiGridListTileBar-titlePositionBottom"><div class="MuiGridListTileBar-titleWrap"><div class="MuiGridListTileBar-title">긍정적인 시나리오 최적화</div></div></div></div></li><li class="MuiGridListTile-root jss25" style="width:40%;height:184px;padding:2px"><div class="MuiGridListTile-tile"><img src="https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png" class="jss26"/><div class="MuiGridListTileBar-root MuiGridListTileBar-titlePositionBottom"><div class="MuiGridListTileBar-titleWrap"><div class="MuiGridListTileBar-title">빅 오를 사용하거나 사용하지 않는 코드 최적화</div></div></div></div></li><li class="MuiGridListTile-root jss25" style="width:40%;height:184px;padding:2px"><div class="MuiGridListTile-tile"><img src="https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png" class="jss26"/><div class="MuiGridListTileBar-root MuiGridListTileBar-titlePositionBottom"><div class="MuiGridListTileBar-titleWrap"><div class="MuiGridListTileBar-title">빅 오로 코드 속도 올리기</div></div></div></div></li><li class="MuiGridListTile-root jss25" style="width:40%;height:184px;padding:2px"><div class="MuiGridListTile-tile"><img src="https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png" class="jss26"/><div class="MuiGridListTileBar-root MuiGridListTileBar-titlePositionBottom"><div class="MuiGridListTileBar-titleWrap"><div class="MuiGridListTileBar-title">빅 오 표기법</div></div></div></div></li><li class="MuiGridListTile-root jss25" style="width:40%;height:184px;padding:2px"><div class="MuiGridListTile-tile"><img src="https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png" class="jss26"/><div class="MuiGridListTileBar-root MuiGridListTileBar-titlePositionBottom"><div class="MuiGridListTileBar-titleWrap"><div class="MuiGridListTileBar-title">알고리즘이 중요한 까닭</div></div></div></div></li></ul></div></article><article class="MuiBox-root jss31 jss29"><sub class="MuiTypography-root jss30 MuiTypography-body1 MuiTypography-colorPrimary">#<!-- -->자료구조</sub><sub class="MuiTypography-root jss30 MuiTypography-body1 MuiTypography-colorPrimary">#<!-- -->알고리즘</sub><sub class="MuiTypography-root jss30 MuiTypography-body1 MuiTypography-colorPrimary">#<!-- -->누구나 자료 구조와 알고리즘</sub><sub class="MuiTypography-root jss30 MuiTypography-body1 MuiTypography-colorPrimary">#<!-- -->배열</sub></article><div class="MuiGrid-root MuiGrid-container MuiGrid-spacing-xs-4 MuiGrid-justify-xs-space-between"><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-4"><button class="MuiButtonBase-root MuiButton-root MuiButton-outlined jss32 MuiButton-outlinedPrimary MuiButton-fullWidth" tabindex="0" type="button"><span class="MuiButton-label"><span class="MuiButton-startIcon MuiButton-iconSizeMedium"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></svg></span>[백준 / JAVA] 백준 알고리즘 1019번 책 페이지</span></button></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-4"><button class="MuiButtonBase-root MuiButton-root MuiButton-outlined jss32 MuiButton-outlinedPrimary MuiButton-fullWidth" tabindex="0" type="button"><span class="MuiButton-label">알고리즘이 중요한 까닭<span class="MuiButton-endIcon MuiButton-iconSizeMedium"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></svg></span></span></button></div></div><div class="MuiBox-root jss33 jss5"><div class="MuiBox-root jss34"><hr class="MuiDivider-root"/></div><div class="MuiBox-root jss35"><div class="MuiAvatar-root MuiAvatar-circle jss6"><img alt="RWB" src="/assets/images/profile.jpg" class="MuiAvatar-img"/></div></div><div class="MuiBox-root jss36"><hr class="MuiDivider-root"/></div></div><div class="MuiGrid-root MuiGrid-container MuiGrid-justify-xs-flex-end"><div class="MuiGrid-root MuiGrid-item"><button class="MuiButtonBase-root MuiButton-root MuiButton-outlined jss7 MuiButton-fullWidth" tabindex="0" type="button"><span class="MuiButton-label"><span class="MuiButton-startIcon MuiButton-iconSizeMedium"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></span>목록</span></button></div></div><article class="MuiBox-root jss38 jss37" id="utterances"></article></div><footer class="MuiBox-root jss47 jss39"><div class="MuiBox-root jss48"><div class="MuiBox-root jss49"><hr class="MuiDivider-root"/></div><div class="MuiBox-root jss50"><img src="/assets/images/logo.png" width="84" class="jss41"/></div><div class="MuiBox-root jss51"><hr class="MuiDivider-root"/></div></div><div class="MuiContainer-root MuiContainer-maxWidthMd"><div class="MuiGrid-root jss40 MuiGrid-container MuiGrid-spacing-xs-3"><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12"><div class="MuiBox-root jss52"><h4 class="MuiTypography-root jss42 MuiTypography-h4" up="h4" down="h5">Developed by RWB at 2021.</h4></div></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-4"><h4 class="MuiTypography-root jss42 MuiTypography-h4 MuiTypography-alignCenter" up="h4" down="h5">Kapoo</h4><div class="MuiBox-root jss53"><h6 class="MuiTypography-root MuiTypography-subtitle2 MuiTypography-alignLeft" up="subtitle2" down="caption">🔗 <a class="MuiTypography-root MuiLink-root MuiLink-underlineHover jss44 MuiTypography-colorPrimary" href="https://rwb0104.github.io/">https://rwb0104.github.io/</a></h6><h6 class="MuiTypography-root jss43 MuiTypography-subtitle2 MuiTypography-alignLeft" up="subtitle2" down="caption">314159265359번째 알파카의 개발 낙서장</h6></div></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-4"><h4 class="MuiTypography-root jss42 MuiTypography-h4 MuiTypography-alignCenter" up="h4" down="h5">Contact Me</h4><div class="MuiBox-root jss54"><div class="MuiBox-root jss55"><button class="MuiButtonBase-root MuiIconButton-root jss45" tabindex="0" type="button" style="background-color:#EA4335;color:white"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeLarge" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M24 5.457v13.909c0 .904-.732 1.636-1.636 1.636h-3.819V11.73L12 16.64l-6.545-4.91v9.273H1.636A1.636 1.636 0 0 1 0 19.366V5.457c0-2.023 2.309-3.178 3.927-1.964L5.455 4.64 12 9.548l6.545-4.91 1.528-1.145C21.69 2.28 24 3.434 24 5.457z"></path></svg></svg></span></button><h6 class="MuiTypography-root jss46 MuiTypography-subtitle2 MuiTypography-alignCenter" up="subtitle2" down="caption">Mail</h6></div><div class="MuiBox-root jss56"><button class="MuiButtonBase-root MuiIconButton-root jss45" tabindex="0" type="button" style="background-color:#181717;color:white"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeLarge" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 .3a12 12 0 0 0-3.8 23.4c.6.1.8-.3.8-.6v-2c-3.3.7-4-1.6-4-1.6-.6-1.4-1.4-1.8-1.4-1.8-1-.7.1-.7.1-.7 1.2 0 1.9 1.2 1.9 1.2 1 1.8 2.8 1.3 3.5 1 0-.8.4-1.3.7-1.6-2.7-.3-5.5-1.3-5.5-6 0-1.2.5-2.3 1.3-3.1-.2-.4-.6-1.6 0-3.2 0 0 1-.3 3.4 1.2a11.5 11.5 0 0 1 6 0c2.3-1.5 3.3-1.2 3.3-1.2.6 1.6.2 2.8 0 3.2.9.8 1.3 1.9 1.3 3.2 0 4.6-2.8 5.6-5.5 5.9.5.4.9 1 .9 2.2v3.3c0 .3.1.7.8.6A12 12 0 0 0 12 .3"></path></svg></span></button><h6 class="MuiTypography-root jss46 MuiTypography-subtitle2 MuiTypography-alignCenter" up="subtitle2" down="caption">Github</h6></div></div></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-4"><h4 class="MuiTypography-root jss42 MuiTypography-h4 MuiTypography-alignCenter" up="h4" down="h5">Associated</h4><div class="MuiBox-root jss57"><div class="MuiBox-root jss58"><button class="MuiButtonBase-root MuiIconButton-root jss45" tabindex="0" type="button" style="background-color:#181717;color:#61DAFB"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeLarge" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z"></path></svg></svg></span></button><h6 class="MuiTypography-root jss46 MuiTypography-subtitle2 MuiTypography-alignCenter" up="subtitle2" down="caption">with Develop</h6></div><div class="MuiBox-root jss59"><button class="MuiButtonBase-root MuiIconButton-root jss45" tabindex="0" type="button" style="background-color:#0081CB;color:white"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeLarge" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 2.475v10.39l3 1.733V7.67l6 3.465 6-3.465v3.465l-6 3.463v3.464l6 3.463 9-5.195V9.402l-3 1.733v3.463l-6 3.464-3-1.732 6-3.465V2.475L9 7.67 0 2.475zm24 0l-3 1.73V7.67l3-1.732V2.474Z"></path></svg></svg></span></button><h6 class="MuiTypography-root jss46 MuiTypography-subtitle2 MuiTypography-alignCenter" up="subtitle2" down="caption">with Design</h6></div><div class="MuiBox-root jss60"><button class="MuiButtonBase-root MuiIconButton-root jss45" tabindex="0" type="button" style="background-color:#181717;color:white"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeLarge" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 .3a12 12 0 0 0-3.8 23.4c.6.1.8-.3.8-.6v-2c-3.3.7-4-1.6-4-1.6-.6-1.4-1.4-1.8-1.4-1.8-1-.7.1-.7.1-.7 1.2 0 1.9 1.2 1.9 1.2 1 1.8 2.8 1.3 3.5 1 0-.8.4-1.3.7-1.6-2.7-.3-5.5-1.3-5.5-6 0-1.2.5-2.3 1.3-3.1-.2-.4-.6-1.6 0-3.2 0 0 1-.3 3.4 1.2a11.5 11.5 0 0 1 6 0c2.3-1.5 3.3-1.2 3.3-1.2.6 1.6.2 2.8 0 3.2.9.8 1.3 1.9 1.3 3.2 0 4.6-2.8 5.6-5.5 5.9.5.4.9 1 .9 2.2v3.3c0 .3.1.7.8.6A12 12 0 0 0 12 .3"></path></svg></span></button><h6 class="MuiTypography-root jss46 MuiTypography-subtitle2 MuiTypography-alignCenter" up="subtitle2" down="caption">with Publish</h6></div></div></div></div></div></footer><button class="MuiButtonBase-root MuiFab-root jss61 MuiFab-extended" tabindex="0" type="button" style="opacity:0"><span class="MuiFab-label"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path></svg><span class="MuiTypography-root MuiTypography-button">라이트 모드 활성화</span></span></button></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"page":{"type":"posts","prev":{"title":"[백준 / JAVA] 백준 알고리즘 1019번 책 페이지","excerpt":"지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1페이지이고, 마지막 페이지는 N페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.","coverImage":"https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png","date":"2021-06-28T12:28:50","type":"posts","category":"알고리즘","tag":["백준","알고리즘","JAVA(자바)","GOLD","GOLD I"],"group":"백준 알고리즘","comment":true,"publish":true,"slug":"2021-06-28-A1019","content":"\r\n# 책 페이지\r\n\r\n![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java\u0026style=plastic\u0026logoColor=white\u0026labelColor=orange)\r\n\r\n🔗 [전체 1019번 문제](https://www.acmicpc.net/problem/1019)\r\n\r\n## 조건\r\n\r\n| 시간제한 | 메모리 제한 |\r\n| :------: | :---------: |\r\n|   2초    |    128MB    |\r\n\r\n## 문제\r\n\r\n지민이는 전체 페이지의 수가 $N$인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 $N$페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.\r\n\r\n## 입력\r\n\r\n첫째 줄에 $N$이 주어진다. $N$은 $1,000,000,000$보다 작거나 같은 자연수이다.\r\n\r\n## 출력\r\n\r\n첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.\r\n\r\n## 케이스\r\n\r\n### 예제 1\r\n\r\n+ 입력\r\n\r\n``` tc\r\n11\r\n```\r\n\r\n+ 출력\r\n\r\n``` tc\r\n1 4 1 1 1 1 1 1 1 1\r\n```\r\n\r\n# 풀이\r\n\r\n문제는 명확하고 직관적이다. 1페이지부터 $N$페이지까지 나열할 때, \u003cspan class=\"green-400\"\u003e숫자가 사용된 수를 각 숫자별로 나타내는 문제\u003c/span\u003e.\r\n\r\n165라는 숫자를 표기하기 위해선 $[ 1, 5, 6 ]$이 사용된다. 이렇게 \u003cspan class=\"green-400\"\u003e1부터 해당 숫자까지의 모든 숫자를 표현하기 위해 사용한 숫자의 수를 0부터 오름차순으로 출력\u003c/span\u003e하면 된다. \r\n\r\n즉, $N = 5$라고 가정하면, 페이지 배열은 $[ 1, 2, 3, 4, 5 ]$까지 나열된다. 각 숫자가 사용된 수를 표로 나타내면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n1부터 5까지 나열하는데, 각각 숫자 하나씩 사용했으니 위 처럼 표시할 수 있다. 그렇다면 예제의 11은 어떨까?\r\n\r\n$[ 1, 2, 3, \\dots, 10, 11 ]$까지 나열된다. \r\n\r\n1부터 9까지는 각각 숫자가 하나씩 사용되며, 10은 1과 0이 사용되고, 11은 1이 두 개 사용된다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n위의 표만큼 숫자가 사용됐다. 이해를 위해 $N = 13$일 경우를 하나 더 해보자.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n$12 = [ 1, 2 ]$, $13 = [ 1, 3 ]$이 된다. 1 ~ 13에는 11도 포함되기 때문에, 11의 결과에 12, 13의 값을 각각 더해줘도 상관없다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n이 정도면 알고리즘이 원하는 게 무엇인지 이해했으리라 생각한다.\r\n\r\n## 🔎규칙 찾아보기\r\n\r\n사실 무식하게 접근하면, 그리 어려운 문제는 아니다. 하나하나 반복문 돌려가며 숫자 분해해서 해당하는 숫자의 배열에 집어넣으면 그만이니. 하지만 안타깝게도, 변수 $N$의 최대값은 10억 ~~(다행히 int의 최대값은 넘지 않는다.)~~ 에 육박한다. 그 말인즉는 무식하게 접근하면 안 된다는 의미.\r\n\r\n그렇다면 어딘가에 존재하는 규칙성을 발견해서 일반식을 설계해야한다는 뜻인데, 이럴땐 하나하나 나열해보면 알 수 있을 것이다.\r\n\r\n|   N   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   0   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   2   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   3   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   4   |   0   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |\r\n|   5   |   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   6   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |\r\n|   7   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |\r\n|   8   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |\r\n|   9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  10   |   1   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  11   |   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  12   |   1   |   5   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  13   |   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|  14   |   1   |   7   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |\r\n|  15   |   1   |   8   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |\r\n|  16   |   1   |   9   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |\r\n|  17   |   1   |  10   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |\r\n|  18   |   1   |  11   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |\r\n|  19   |   1   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  20   |   2   |  12   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  21   |   2   |  13   |   4   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  22   |   2   |  13   |   6   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n|  23   |   2   |  13   |   7   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |\r\n\r\n규칙성을 찾아보기 위해 20 받고 살짝 더 얹어서 사용된 숫자를 나열해보았다. 어떤 패턴이 보이는 것 같긴 하다.\r\n\r\n1. 0은 10의 배수마다 1씩 증가한다.\r\n2. 각 1의 자리마다 해당하는 숫자가 1씩 증가하며, 값은 10의 자릿수 + 1이다.\r\n3. 10의 자릿수는 해당하는 숫자를 1씩 증가시킨다.\r\n\r\n그냥 쳐다보면 규칙성을 찾기 좀 어려울 수 있다. 해답은 \u003cspan class=\"red-400\"\u003e*0 ~ *9\u003c/span\u003e 구간에 있다. 예를 들어, 10 ~ 29까지 나열해보자. 1부터 시작하는 것이 아니라, 임의의 구간 $A ~ B$를 기준으로 알고리즘을 계산한다고 가정하는 것이다.\r\n\r\n\u003ctable\u003e\r\n\t\u003ctbody\u003e\r\n\t\t\u003ctr\u003e\r\n\t\t\t\u003ctd\u003e10\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e11\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e12\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e13\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e14\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e15\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e16\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e17\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e18\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e19\u003c/td\u003e\r\n\t\t\u003c/tr\u003e\r\n\t\t\u003ctr\u003e\r\n\t\t\t\u003ctd\u003e20\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e21\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e22\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e23\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e24\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e25\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e26\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e27\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e28\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e29\u003c/td\u003e\r\n\t\t\u003c/tr\u003e\r\n\t\u003c/tbody\u003e\r\n\u003c/table\u003e\r\n\r\n위 표의 숫자들을 잘 보면, 1의 자리 숫자는 각각 하나씩 사용하는 것을 확인할 수 있다.\r\n\r\n## 1의 자리에서의 규칙\r\n\r\n\u003ctable\u003e\r\n\t\u003ctbody\u003e\r\n\t\t\u003ctr\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e0\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e3\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e4\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e5\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e6\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e7\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e8\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e1\u003cspan class=\"red-A400\"\u003e9\u003c/span\u003e\u003c/td\u003e\r\n\t\t\u003c/tr\u003e\r\n\t\t\u003ctr\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e0\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e3\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e4\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e5\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e6\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e7\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e8\u003c/span\u003e\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e2\u003cspan class=\"red-A400\"\u003e9\u003c/span\u003e\u003c/td\u003e\r\n\t\t\u003c/tr\u003e\r\n\t\u003c/tbody\u003e\r\n\u003c/table\u003e\r\n\r\n이제 좀 규칙성이 눈에 띄기 시작한다. 20 ~ 39와 같은 \u003cspan class=\"red-400\"\u003e*0 ~ *9\u003c/span\u003e 형태의 범위에선 1의 자리에 해당하는 모든 숫자가 동일하게 사용된다. 10 ~ 19, 20 ~ 29 두 구간이 있으므로 각 구간별로 1씩 모든 숫자가 두 번 사용됐다.\r\n\r\n시작 페이지를 $n$, 마지막 페이지를 $N$이라고 가정할 때, 위 규칙을 일반식으로 표현하면 아래와 같다.\r\n\r\n$$\r\n(N \\div 10) - (n \\div 10) + 1 = \\text{1의 자리에 사용된 각각의 숫자 갯수}\r\n$$\r\n\r\n따라서 10 ~ 29 범위에서 모든 숫자는 두 번 사용된 것임을 알 수 있다.\r\n\r\n## p의 자리에서의 규칙\r\n\r\n문제는 위 식은 \u003cspan class=\"orange-400\"\u003e1의 자리에서만 적용되는 수식\u003c/span\u003e이다. 페이지는 최대 10의 자리까지 존재할 수 있다. 즉, 통용되는 일반식을 구해야한다.\r\n\r\n\u003ctable\u003e\r\n\t\u003ctbody\u003e\r\n\t\t\u003ctr\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e0\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e1\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e2\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e3\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e4\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e5\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e6\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e7\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e8\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e1\u003c/span\u003e9\u003c/td\u003e\r\n\t\t\u003c/tr\u003e\r\n\t\t\u003ctr\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e0\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e1\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e2\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e3\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e4\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e5\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e6\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e7\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e8\u003c/td\u003e\r\n\t\t\t\u003ctd\u003e\u003cspan class=\"red-A400\"\u003e2\u003c/span\u003e9\u003c/td\u003e\r\n\t\t\u003c/tr\u003e\r\n\t\u003c/tbody\u003e\r\n\u003c/table\u003e\r\n\r\n반대로 10의 자리수를 자세히 보자. 1이 10번 사용된다. 만약 100 ~ 199 구간이라면 1은 100개가 사용될 것이고, 1000 ~ 1999 구간이라면 1은 1000개가 사용될 것이다.\r\n\r\n쉽게 설명하기 위해 10 ~ 19, 100 ~ 199, 1000 ~ 1999 등 $n0* ~ n9*$ 같은 형태의 구간을 단위 구간이라고 정의하자. 이 때, 해당 구간에서 $n$이 사용되는 갯수는 아래와 같이 정의할 수 있다.\r\n\r\n$$\r\n((N \\div 10) - (n \\div 10) + 1) \\times \\text{p} = \\text{각각의 숫자 갯수}\r\n$$\r\n\r\n* $n$: 구간 시작 값\r\n* $N$: 구간 끝 값\r\n* $p$: 자릿수\r\n\r\n## 구간 보정하기\r\n\r\n이제 구간만 맞으면 호출되는 숫자를 구할 수는 있지만, 아직 제한적이다.\r\n\r\n우선, 본 알고리즘에서 시작 값은 1로 고정이다. 끝 값인 $N$ 역시 반드시 199와 같은 단위 구간의 형태로 들어오지도 않는다. 만약 $N = 35$라면 우리는 1 ~ 35 구간에 알고리즘을 적용해야 한다. 구간이 10 ~ 39라면 모를까, 형태가 전혀 다른 구간에는 위 일반식이 적용되지 않는다.\r\n\r\n해결 방법은 간단하다. 가늠좌 클리크 조정하듯이 구간에 맞게 값을 더하고 빼서 조정해주면 된다.\r\n\r\n1 ~ 35 구간에서, 1의 경우, 1보다 크며 0을 포함한 수 중 가장 가까운 값은 10이다. 따라서, 시작 값은 10까지 증가시키며, 증가시킨 숫자를 카운팅한다. 1부터 9까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n35의 경우 35보다 작으며 9를 포함한 수 중 가장 가까운 수는 29다. 마찬가지로 마지막 값은 29까지 감소시키며, 감소한 숫자를 카운팅한다. 35부터 30까지 카운팅되므로, 이를 표로 표현하면 아래와 같다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n즉, 초기값은 위 보정값을 더한 배열이며, 이후 계산은 계산된 초기값에 누적한다.\r\n\r\n|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   1   |   1   |   1   |   7   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| **1** | **2** | **2** | **8** | **2** | **2** | **1** | **1** | **1** | **1** |\r\n\r\n## 자릿수 보정하기\r\n\r\n$N = 1999$, $n = 1000$일 때, 1의 자리에 사용된 숫자의 갯수를 구하면 아래와 같다.\r\n\r\n$$\r\n((1999 / 10) - (1000 / 10) + 1) \\times 1 = 100\r\n$$\r\n\r\n1의 자리에서 각 숫자는 100개씩 사용됐다. 10의 자리에서는 어떨까?\r\n\r\n$N$, $n$을 각각 10으로 나누면 10의 자리에 대한 구간을 얻을 수 있다. 나눠진 숫자를 위의 일반식에 적용하면 된다.\r\n\r\n$$\r\n((199 / 10) - (100 / 10) + 1) \\times 10 = 100\r\n$$\r\n\r\n100의 자리는 $N$, $n$을 각각 100으로 나누어 계산하면 된다.\r\n\r\n$$\r\n((19 / 10) - (10 / 10) + 1) \\times 100 = 100\r\n$$\r\n\r\n1000의 자리는 $N$, $n$을 각각 1000으로 나누어 계산하면 된다. 그러나 $N = n = 1$이므로, 1에만 1000개가 사용된다.\r\n\r\n|  $p$  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  10   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n| 1000  |   0   | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|       |  300  | 1300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n따라서 1000 ~ 1999 구간은 위와 같이 계산된다.\r\n\r\n## 📃일반식 적용하기\r\n\r\n완벽한 이해를 위해, 위 개념을 토대로 $N = 4153$일 경우의 알고리즘을 계산해보자.\r\n\r\n$N = 4153$이므로, 구간은 1 ~ 4153이다.\r\n\r\n### 시작 페이지 구간 보정하기\r\n\r\n1보다 큰 수 중 1의 자리가 0인 가장 가까운 수 10까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n1부터 9까지 이동하여 10에 도착하므로, 1 ~ 9를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n\r\n### 마지막 페이지 구간 보정하기\r\n\r\n4153보다 작은 수 중 1의 자리가 9인 가장 가까운 수 4149까지 이동하며, 이동한 수를 별도로 카운팅한다.\r\n\r\n4153부터 4150까지 이동하여 4149까지 도착하므로, 이를 별도로 카운팅해준다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 4153  |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4152  |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4151  |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 4150  |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n\r\n### 1의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 4149을 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((4149 / 10) - (10 / 10) + 1) \\times 1 = 414 - 1 + 1 = 414\r\n$$\r\n\r\n|   구분   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1의 자리 |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n\r\n### 10의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 1의 자리 일반식 구간 4149, 10을 각각 10으로 나눈다.\r\n\r\n10의 자리에 대한 구간은 $1 ~ 414$가 된다. 마찬가지로 일반식 적용을 위해 구간을 보정한다. 10의 자리이므로, \u003cspan class=\"red-400\"\u003e1 -\u003e 2로의 이동은 실제로 10 -\u003e 20으로의 이동임에 주의\u003c/span\u003e하자.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  414  |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|  413  |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  412  |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  411  |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|  410  |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 10의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 409를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((409 / 10) - (10 / 10) + 1) \\times 10 = (40 - 1 + 1) \\times 10 = 400\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n\r\n### 100의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 10의 자리 일반식 구간 409, 10을 각각 10으로 나눈다.\r\n\r\n100의 자리에 대한 구간은 $1 ~ 40$이 된다. 나머지는 10의 자리 프로세스와 동일하다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 9 |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|  40   |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 100의 자리 일반식 적용\r\n\r\n일반식을 적용할 수 있는 구간 10 ~ 39를 구했으니, 일반식을 적용한다.\r\n\r\n$$\r\n((39 / 10) - (10 / 10) + 1) \\times 100 = (3 - 1 + 1) \\times 100 = 300\r\n$$\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n\r\n### 1000의 자리 구간 계산 및 보정하기\r\n\r\n상위 자릿수 계산을 위해 100의 자리 일반식 구간 39, 10을 각각 10으로 나눈다.\r\n\r\n1000의 자리에 대한 구간은 $1 ~ 3$이 된다.\r\n\r\n여기서 문제가 하나 있는데, 마지막 구간에서 일의 자리가 9인 가장 작은 수는 -9다. 음수가 올 수 없으므로, 더 이상의 일반식 연산은 불가능하며, 개별적으로 더해주면 된다.\r\n\r\n| 구분  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n| 1 ~ 3 |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n\r\n### 총합 계산하기\r\n\r\n단계별로 구한 숫자를 정리하여 총합을 표로 나타낸다.\r\n\r\n|   구분    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |\r\n| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\r\n|   1 ~ 9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |\r\n|   4153    |   0   |   1   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4152    |   0   |   1   |   1   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4151    |   0   |   2   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n|   4150    |   1   |   1   |   0   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |\r\n| 1의 자리  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |  414  |\r\n|   1 ~ 9   |   0   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |  10   |\r\n|    414    |   0   |  10   |   0   |   0   |  20   |   0   |   0   |   0   |   0   |   0   |\r\n|    413    |   0   |  10   |   0   |  10   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    412    |   0   |  10   |  10   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    411    |   0   |  20   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n|    410    |  10   |  10   |   0   |   0   |  10   |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |  400  |\r\n|   1 ~ 9   |   0   |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |  100  |\r\n|    40     |  100  |   0   |   0   |   0   |  100  |   0   |   0   |   0   |   0   |   0   |\r\n| 10의 자리 |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |  300  |\r\n|   1 ~ 3   |   0   | 1000  | 1000  | 1000  |   0   |   0   |   0   |   0   |   0   |   0   |\r\n|   총합    | 1225  | 2290  | 2236  | 2236  | 1389  | 1229  | 1225  | 1225  | 1225  | 1225  |\r\n\r\n구간 1 ~ 4153에 대한 알고리즘 결과는 위와 같다.\r\n\r\n## 전체 소스\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 백준 전체 1019 문제 알고리즘 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/06/28/A1019/\"\u003e1019 풀이\u003c/a\u003e\r\n * @since 2021.06.28 Mon 12:28:50\r\n */\r\npublic class Main\r\n{\r\n\t// 숫자 카운트 배열\r\n\tprivate static final int[] counter = new int[10];\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 마지막 페이지\r\n\t\tint N = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\tsolve(N);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\r\n\t\tfor (int item : counter)\r\n\t\t{\r\n\t\t\tbuilder.append(item).append(\" \");\r\n\t\t}\r\n\t\t\r\n\t\twriter.write(builder.toString().trim());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\treader.close();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 동작 함수\r\n\t *\r\n\t * @param num: [int] 마지막 페이지\r\n\t */\r\n\tprivate static void solve(int num)\r\n\t{\r\n\t\t// 시작 페이지\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 자릿수\r\n\t\tint digit = 1;\r\n\t\t\r\n\t\twhile (start \u003c= num)\r\n\t\t{\r\n\t\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\t\twhile (num % 10 != 9 \u0026\u0026 start \u003c= num)\r\n\t\t\t{\r\n\t\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\t\tcount(num, digit);\r\n\t\t\t\t\r\n\t\t\t\tnum--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\t\tif (num \u003c start)\r\n\t\t\t{\r\n\t\t\t\t// 이를 처리하지 않으면 num \u003c 9일 경우 무한루프를 탐\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\t\twhile (start % 10 != 0 \u0026\u0026 start \u003c= num)\r\n\t\t\t{\r\n\t\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\t\tcount(start, digit);\r\n\t\t\t\t\r\n\t\t\t\tstart++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstart /= 10;\r\n\t\t\tnum /= 10;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i \u003c 10; i++)\r\n\t\t\t{\r\n\t\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 자릿수 증가\r\n\t\t\tdigit *= 10;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * 카운트 함수\r\n\t *\r\n\t * @param num: [int] 대상 숫자\r\n\t * @param digit: [int] 자릿수\r\n\t */\r\n\tprivate static void count(int num, int digit)\r\n\t{\r\n\t\twhile (num \u003e 0)\r\n\t\t{\r\n\t\t\tcounter[num % 10] += digit;\r\n\t\t\tnum /= 10;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n$N = 4153$일 때, 구간을 보정하는 과정에서 4153, 4152와 같은 수를 별도로 카운팅해야한다.\r\n\r\n``` java\r\n/**\r\n * 카운트 함수\r\n *\r\n * @param num: [int] 대상 숫자\r\n * @param digit: [int] 자릿수\r\n */\r\nprivate static void count(int num, int digit)\r\n{\r\n\twhile (num \u003e 0)\r\n\t{\r\n\t\tcounter[num % 10] += digit;\r\n\t\tnum /= 10;\r\n\t}\r\n}\r\n```\r\n\r\n로직은 어렵지 않다. 4152의 경우 $[ 4, 1, 5, 2 ]$로 이루어져있으므로, 해당하는 숫자에 자릿수만큼 카운팅(1이면 1개, 10이면 10개)하면 된다.\r\n\r\n1의 자리는 $4152 \\,\\,\\, \\% \\,\\,\\, 10 = 2$와 같이 구할 수 있다. 10의 자리는 4152를 10으로 한 번 나누고 방금의 연산을 다시 진행하면 된다.  \r\n100, 1000 등 자릿수만큼 반복하여 계산하면 된다.\r\n\r\n``` java\r\n/**\r\n * 알고리즘 동작 함수\r\n *\r\n * @param num: [int] 마지막 페이지\r\n */\r\nprivate static void solve(int num)\r\n{\r\n\t// 시작 페이지\r\n\tint start = 1;\r\n\t\r\n\t// 자릿수\r\n\tint digit = 1;\r\n\t\r\n\twhile (start \u003c= num)\r\n\t{\r\n\t\t// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함\r\n\t\twhile (num % 10 != 9 \u0026\u0026 start \u003c= num)\r\n\t\t{\r\n\t\t\t// 감소한 페이지 별도 카운팅\r\n\t\t\tcount(num, digit);\r\n\t\t\t\r\n\t\t\tnum--;\r\n\t\t}\r\n\t\t\r\n\t\t// 마지막 페이지가 시작 페이지보다 작을 경우\r\n\t\tif (num \u003c start)\r\n\t\t{\r\n\t\t\t// 이를 처리하지 않으면 num \u003c 9일 경우 무한루프를 탐\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\t// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함\r\n\t\twhile (start % 10 != 0 \u0026\u0026 start \u003c= num)\r\n\t\t{\r\n\t\t\t// 증가한 페이지 별도 카운팅\r\n\t\t\tcount(start, digit);\r\n\t\t\t\r\n\t\t\tstart++;\r\n\t\t}\r\n\t\t\r\n\t\tstart /= 10;\r\n\t\tnum /= 10;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c 10; i++)\r\n\t\t{\r\n\t\t\tcounter[i] += (num - start + 1) * digit;\r\n\t\t}\r\n\t\t\r\n\t\t// 자릿수 증가\r\n\t\tdigit *= 10;\r\n\t}\r\n}\r\n```\r\n\r\n시작 페이지는 무조건 1로 고정이다. 시작 페이지가 마지막 페이지보다 커질 때까지 반복한다.\r\n\r\n첫 번째 `while`문에서 마지막 페이지를 1씩 감소시켜 9로 끝나는 구간으로 보정한다. 중간에 조건문이 있는데, 이 처리를 해주지 않으면 `num`이 9보다 작을 경우 연산 과정에서 `start`가 `num`을 초과하지 못해 무한루프를 타게 된다.\r\n\r\n두 번째 `while`문은 1페이지를 1씩 증가시켜 0으로 끝나는 구간으로 보정한다. 보정된 모든 값은 `count` 메소드를 통해 별도로 카운팅된다.\r\n\r\n위 과정을 통해 구간을 맞췄으니, 나머지는 위에 언급한 수식을 적용하고, 이를 반복한다.\r\n\r\n## 분류\r\n\r\n* 수학"},"next":{"title":"알고리즘이 중요한 까닭","excerpt":"IT영역에서의 알고리즘이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. 개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구된다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열","정렬","이진 검색"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-10-about-algorithm-chapter02","content":"\r\n\u003cp class=\"orange-A400\" align=\"center\"\u003e본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.\u003c/p\u003e\r\n\r\n# 2장 알고리즘이 중요한 까닭\r\n\r\nIT영역에서의 \u003cspan class=\"primary\"\u003e알고리즘\u003c/span\u003e이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. \u003cspan class=\"teal-400\"\u003e개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구\u003c/span\u003e된다.\r\n\r\n이러한 특징으로 알고리즘은 뛰어난 문제 해결력과 수학적 사고 능력을 요한다. 때문에 많은 사람들이 어려워하는 분야 중 하나지만, 그 강력함과 효율로 인해 개발 역량의 척도를 확인하는데 사용하기도 한다. 흔히 기업에서 보는 \u003cspan class=\"teal-400\"\u003e코딩 테스트\u003c/span\u003e가 좋은 예시다.\r\n\r\n이 장에서는 \u003cspan class=\"primary\"\u003e알고리즘\u003c/span\u003e을 통해 검색 연산을 더욱 효과적으로 개선하는 방법에 대해 설명한다. 이전 장에서 언급했듯이, 검색 연산은 무수히 많은 읽기 연산의 모음이나 다름없다. 알고리즘이 어떻게 읽기 연산을 최적화시키는지 알아보자.\r\n\r\n## 2-1. 정렬된 배열\r\n\r\n\u003cspan class=\"primary\"\u003e정렬된 배열\u003c/span\u003e이란, 기존의 배열에서 요소들이 특정 조건으로 정렬된 배열을 의미한다. 정렬된 배열은 그 요소들이 항상 정해진 조건에 따라 순서대로 배치된다. 이는 삽입을 할 때도 동일하다. 정렬된 배열이 항상 정렬된 상태를 유지하기 위해선 \u003cspan class=\"red-A400\"\u003e삽입 시에도 요소의 정렬에 따라 정렬을 훼손하지 않는 올바른 자리에 삽입\u003c/span\u003e되어야 한다.\r\n\r\n기존의 배열이라면 배열의 크기가 허락하는 한, 원하는 위치 어디에서나 삽입이 가능하다. 배열에 55를 삽입할 때, 일반적인 배열은 아래처럼 삽입에 제한이 없다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144062-a3b6c280-e157-11eb-88d6-20689d8f05b1.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n하지만 정렬된 배열이라면 어떨까? 이번엔 배열이 오름차순으로 정렬된 배열이라고 가정해보자.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144070-aa453a00-e157-11eb-9390-1550623a57bd.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n정렬된 위 배열에서 55를 삽입한다면 어떨까?\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144072-aca79400-e157-11eb-8939-cc0beb583b9b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n반드시 44와 94의 사이에 삽입되어야 오름차순 정렬을 유지할 수 있다. 그렇다면 우리는 여기서 정렬된 배열의 삽입은 기존의 삽입 연산에 비해 로직이 추가됨을 유추할 수 있다. 원리는 간단하다. 요소를 순차적으로 읽어서 55보다 큰 수가 나올 때까지 반복한다. 배열이 정렬되어 있으므로, 55보다 큰 수를 만나게 되면 이전의 요소는 모두 55보다 작을 것이다. 이 위치를 기준으로 삽입을 진행하면 된다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144075-ae715780-e157-11eb-92ed-71ee06140c5f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n위 그림과 같이 순차적으로 요소를 검색하여 55보다 큰 요소를 찾는다. 94는 배열에서 55보다 큰 가장 작은 수다.\r\n\r\n94의 인덱스인 4번째 요소에 55를 삽입하고, 94를 한 칸 뒤로 미룬다. 이 과정을 통해 정렬된 배열의 연산을 수행할 수 있다.\r\n\r\n그렇다면 이 고생을 뭐하러 사서하는 것일까? 그 이유는 검색의 최적화에 있다. \u003cspan class=\"orange-A400\"\u003e정렬된 배열은 그 자체로 순서라는 규칙성을 지니기 때문에 이를 활용한 알고리즘 적용이 가능\u003c/span\u003e하기 때문이다. 이를 통해 검색의 작업량을 효과적으로 줄여 더욱 빠른 검색이 가능하다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 정렬된 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 02:41:14\r\n */\r\npublic class SortedArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 9, 14, 43, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tint result = run(item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(result);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 및 삽입된 인덱스 반환 함수\r\n\t *\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [int] 삽입된 인덱스\r\n\t */\r\n\tprivate static int run(int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\tinsert(result, item);\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자보다 배열의 값이 클 경우\r\n\t\t\tif (target \u003c ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i \u003e index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 인덱스에 55 삽입: [6, 9, 14, 43, 55, 94, -1, -1, -1, -1]\r\n```\r\n\r\n`insert` 함수는 이전 장에 나왔던 함수와 동일하지만, `find`의 경우 조금 달라졌다. `target == ARRAY[i]`로 동일한 값을 찾는 것이 아니라, `target \u003c ARRAY[i]`로 삽입할 요소보다 큰 값을 찾도록 변경됐다. `run` 함수는 이를 적절히 구동하여 삽입된 인덱스를 반환한다.\r\n\r\n\u003e **JAVA의 정렬 함수**  \r\n\u003e 자바는 `Arrays.sort()`라는 함수가 제공되며, 인수로 정렬할 배열을 전달한다. 기본적으로 오름차순으로 정렬되며, 본인이 직접 정렬 함수를 오버라이딩함으로써 자신만의 조건으로 정렬되도록 설계할 수도 있다.\r\n\r\n## 2-3. 이진 검색\r\n\r\n우리가 앞에서 배열을 정렬한 이유가 바로 이 것이다. \u003cspan class=\"primary\"\u003e이진 검색\u003c/span\u003e이라는 알고리즘을 적용하면 검색의 속도를 상당부분 개선할 수 있다. 심지어 이진 검색은 알고리즘 축에서는 매우 쉬운 편에 속한다. 심지어 우리는 이미 다른 형태로 이진 검색이라는 알고리즘을 접한 적이 있다.\r\n\r\n어렸을 때나, 혹은 술자리에서 Up \u0026 Down이라는 게임을 해본적이 있을 것이다. 진행자가 임의의 구간에 해당하는 임의의 수 하나를 머릿속으로 생각하면, 참가자들이 이 수를 맞추는 것이다. 참가자가 수를 말하면 진행자는 그 수가 자신의 수보다 큰 지, 작은 지 알려준다. 이걸 누군가 맞출 때까지 반복한다. 이진 검색의 원리는 이와 정확히 일치한다.\r\n\r\n\u003cspan class=\"red-A400\"\u003e이진 검색은 그 특성 상 정렬된 배열에서만 가능\u003c/span\u003e하다. 1 ~ 100의 구간으로 순차적으로 정렬된 배열이 있다고 가정해보자. 찾아야 할 수가 68일 때, 이진 검색은 아래와 같이 이루어진다.\r\n\r\n1. 1과 100의 중간인 50과 비교한다. (작업 +1)\r\n2. 50은 68보다 작으로 51 ~ 100의 구간을 검색한다.\r\n3. 51과 100의 중간인 75와 비교한다. (작업 +1)\r\n4. 75는 68보다 크므로 51 ~ 74의 구간을 검색한다.\r\n5. 51과 74의 중간인 62와 비교한다. (작업 +1)\r\n6. 62는 68보다 작으므로 63 ~ 74의 구간을 검색한다.\r\n7. 63과 74의 중간인 68과 비교한다. (작업 +1)\r\n8. 검색이 종료된다.\r\n\r\n만약 순차적으로 검색했다면 1 부터 68까지 총 68번의 작업이 발생할 것을 단 4번의 작업으로 검색을 완료했다. 간단한 알고리즘을 적용하는 것으로도 작업량이 17배 줄어든 것이다. 지금은 구간이 작지만, 구간의 끝이 만 단위가 넘어간다면 검색하려는 숫자의 위치에 따라 작업량이 기하급수적으로 감소한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target \u003e mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색을 구현한 소스는 위와 같다. 눈여겨 볼 부분은 `binarySearch` 함수다. 시작값 `start`는 1로 초기화되고, 끝값 `max`는 배열의 크기와 동일하다.\r\n\r\n`mid`를 계산하여 `target`과 크기비교를 한다. `target`이 더 클 경우, 중간값을 기준으로 윗 구간이므로 `start`를 `mid + 1`로 보정한다. 반대로 `target`이 더 작을 경우, 중간값을 기준으로 아랫 구간이므로 `end`를 `mid - 1`로 보정한다. 검색 대상값인 `target`과 중간값 `mid`가 동일할 때까지 알고리즘을 반복한다.\r\n\r\n1 ~ 100까지 차례대로 배치되어 있으므로, 1은 `ARRAY[0]`, 43은 `ARRAY[42]`로 값 자체로 인덱스나 다름없기 때문에 인덱스는 따로 구하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target \u003e mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색의 단점이 있는데, 1 ~ 100의 구간이 있다고 가정하면, 1이나 100과 같은 \u003cspan class=\"orange-A400\"\u003e구간의 시작과 끝을 검색하는데 시간이 매우 오래 걸린다.\u003c/span\u003e 이는 이진 검색이 중간값을 기준으로 검색한다는 특징으로 인한 단점이다. 위의 소스는 구간의 시작과 끝도 비교함으로써 이진 검색을 강화한 소스다.\r\n\r\n``` java\r\n// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\nif (target == start || target == end)\r\n{\r\n\tbreak;\r\n}\r\n```\r\n\r\n눈여겨 볼 부분은 `binarySearch` 함수의 해당 부분이다. 기존에 없던 `start`와 `end`의 비교 로직이 추가되어, \u003cspan class=\"orange-A400\"\u003e구간의 시작과 끝이 목표일 경우 더욱 빠르게 검색\u003c/span\u003e할 수 있도록 보정한 것이다.\r\n\r\n| 구분  | 보정 전 | 보정 후 |\r\n| :---: | :-----: | :-----: |\r\n|   1   |    6    |    1    |\r\n|  51   |    6    |    2    |\r\n|  100  |    7    |    1    |\r\n\r\n## 2-4. 이진 검색 대 선형 검색\r\n\r\n1부터 순차적으로 하나하나 검색하는 알고리즘을 \u003cspan class=\"primary\"\u003e선형 검색\u003c/span\u003e, 구간의 중간값을 기준으로 검색하는 알고리즘을 \u003cspan class=\"primary\"\u003e이진 검색\u003c/span\u003e이라 한다. 우리가 2장까지 진행하면서, 배열의 일반적인 검색과 이진 검색에 대해 설계하고 차이점을 비교했다.\r\n\r\n선형 검색의 경우 요소의 갯수 $N$이 늘어나면 늘어날수록 예상되는 최대 작업량도 $N$개로 비례하여 늘어난다. 이에 비해 이진 검색의 경우 $N = 10,000$일 때, 책에 의하면 최대 작업량이 13이라고 한다. $N = 1,000,000$이면 작업량은 20으로, 선형 검색의 작업량이 1,000,000임을 감안하면 \u003cspan class=\"green-A400\"\u003e데이터가 많아질 수록 이진 검색으로 절약할 수 있는 기대 비용이 더욱 큼\u003c/span\u003e을 알 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 검색 퍼포먼스 비교 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 04:21:37\r\n */\r\npublic class SearchCompare\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100000000;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 86421478;\r\n\t\t\r\n\t\tlong tic = System.nanoTime();\r\n\t\t\r\n\t\tint linearResult = find(target);\r\n\t\t\r\n\t\tlong toc1 = System.nanoTime() - tic;\r\n\t\t\r\n\t\ttic = System.nanoTime();\r\n\t\t\r\n\t\tint binaryResult = binarySearch(target);\r\n\t\t\r\n\t\tlong toc2 = System.nanoTime() - tic;\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 선형 검색 프로세스: \");\r\n\t\tbuilder.append(linearResult);\r\n\t\tbuilder.append(\"(\").append(toc1).append(\"ns)\\n\");\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 이진 검색 프로세스: \");\r\n\t\tbuilder.append(binaryResult);\r\n\t\tbuilder.append(\"(\").append(toc2).append(\"ns)\\n\\n\");\r\n\t\tbuilder.append(\"이진 검색이 약 \").append(toc1 / toc2).append(\"배 더 빠릅니다.\");\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target \u003e mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n86421478을 탐색하는데 소요된 선형 검색 프로세스: 86421477(26936600ns)\r\n86421478을 탐색하는데 소요된 이진 검색 프로세스: 26(5100ns)\r\n\r\n이진 검색이 약 5281배 더 빠릅니다.\r\n```\r\n\r\n위 소스는 선형 검색과 이진 검색을 통합해 퍼포먼스를 비교할 수 있는 소스다. 100,000,000(1억)의 구간에서 임의의 수 `target`을 검색한다. 해당 소스에서는 86,421,478으로 지정했다.\r\n\r\n|    구분     | 선형 검색  | 이진 검색 |    차이    |\r\n| :---------: | :--------: | :-------: | :--------: |\r\n| 프로세스 수 | 86,421,477 |    26     |     -      |\r\n|  테스트 1   | $2.442ms$  |  $5.2us$  | 약 4,699배 |\r\n|  테스트 2   | $2.463ms$  |  $5.3us$  | 약 4,648배 |\r\n|  테스트 3   | $2.434ms$  |  $5.5us$  | 약 4,424배 |\r\n|  테스트 4   | $2.536ms$  |  $5.3us$  | 약 4,785배 |\r\n|  테스트 5   | $2.383ms$  |   $5us$   | 약 4,766배 |\r\n|  테스트 6   | $2.509ms$  |  $5.1us$  | 약 4,919배 |\r\n|  테스트 7   | $2.487ms$  |  $5.4us$  | 약 4,605배 |\r\n|  테스트 8   | $2.394ms$  |  $4.5us$  | 약 5,320배 |\r\n|  테스트 9   | $2.666ms$  |  $5.3us$  | 약 5,030배 |\r\n|  테스트 10  | $2.352ms$  |  $5.3us$  | 약 4,438배 |\r\n\r\n\u003csmall class=\"red-400\"\u003e※ 위 테스트는 CPU i7-10700K, RAM 32GB에서 테스트한 결과물로, 구동 환경에 따라 연산 결과가 달라질 수 있음\u003c/small\u003e\r\n\r\n이진검색이 선형검색에 비해 약 5000배 까지도 차이가 남을 확인할 수 있다. 단위가 $ms$, $us$니까 사람 입장에선 그게 그거지만, 기계 입장에선 이진 검색으로 5000번 수행할 동안 선형 검색은 한 번 수행하는 셈이니 실로 어마어마한 차이다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 알고리즘을 적용한 이진 검색을 구현하고 이를 기존의 선형 검색과 비교함으로써 알고리즘의 강력함을 체감할 수 있었다.\r\n\r\n현업에서 일하면서 알고리즘이 강력하다는 건 알고있었지만, 이렇게 간단하게 구현해서 직접 비교해보니 역시나 알고리즘이 중요한 이유를 알 것 같다.\r\n\r\n원래 오늘같이 내일 쉬는 날이면 새벽 네 다섯시까지 공부하긴 하는데, 포스팅 때문에 풀타임으로 집중하다 보니 유난히 더 피곤하다...."}},"group":[{"title":"긍정적인 시나리오 최적화","excerpt":"지금까지는 항상 알고리즘을 비관적인 관점으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다. 이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-24T04:54:40","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","삽입 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-24-about-algorithm-chapter06","content":"\r\n\u003cp class=\"orange-A400\" align=\"center\"\u003e본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.\u003c/p\u003e\r\n\r\n# 6장 긍정적인 시나리오 최적화\r\n\r\n지금까지는 항상 알고리즘을 \u003cspan class=\"orange-400\"\u003e비관적인 관점\u003c/span\u003e으로 바라봤다. 이 경우의 장점은 명확하다. 어떠한 경우에도 최악을 대비하면 문제가 없다. 하지만 모든 데이터가 항상 최악의 경우는 아닐 뿐더러, 대부분의 케이스는 평범한 영역에 위치할 것이다.\r\n\r\n이 장에서는 모든 시나리오를 고려하여 상황에 따른 적절한 알고리즘을 판단한다.\r\n\r\n## 6-1. 삽입 정렬\r\n\r\n이 장에서는 \u003cspan class=\"primary\"\u003e삽입 정렬\u003c/span\u003e 알고리즘을 토대로 전개한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834021-dcb0625e-80fb-4567-bd8d-982ae60a04c0.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n정렬할 배열은 위와 같으며, 원리는 아래와 같다.\r\n\r\n1. 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n3. 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n## 6-2. 삽입 정렬해보기\r\n\r\n이전 문단의 원리를 토대로 삽입 정렬을 수행한다.\r\n\r\n1. 패스스루 1: 요소의 두 번째 값을 임시 변수에 저장하고 배열에서 제거한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834029-9a32e551-f1ef-4751-b0b1-46942455e737.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n삽입 정렬은 배열의 두 번째 인덱스를 기준으로 시작한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: -\r\n\r\n첫 동작이므로, 임시 변수에 3을 할당한다.\r\n\r\n2. 패스스루 1: 기준 인덱스 왼쪽의 요소를 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834036-d0c0cc1b-a968-4e79-a1b6-4957440c9a1b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n현재 기준 인덱스의 왼쪽에 위치한 요소들을 비교하고, 임시 변수의 값보다 클 경우 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n* 임시 변수: 3\r\n* 비교값: 7\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834043-3cee3312-ff41-475d-93e3-482ac2849577.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n임시 변수보다 비교값이 크므로, 해당 값을 오른쪽으로 한 칸 시프트한다.\r\n\r\n이 비교는 임시 변수보다 작은 값을 만나거나, 배열의 처음으로 갈때 까지 반복한다.\r\n\r\n1. 패스스루 1: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834049-06874e63-e166-4d43-a40f-bb9e59c0a4cf.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n요소의 맨 처음에 도달했으므로 비교를 종료하고, 현재 공백에 임시 변수의 값 3을 삽입한다. 3은 아직 완전히 정렬된 것이 아니며, 다음 패스스루의 작업에 제외되지 않는다.\r\n\r\n4. 패스스루 2: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834064-d8e10cd3-d825-47d4-9a29-ee3a95b9cb60.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 9\r\n* 비교값: -\r\n\r\n세 번째 요소의 값인 9를 임시 변수로 할당한다.\r\n\r\n5. 패스스루 2: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834073-83c7f417-d7ac-43ce-8421-0119ef5d4712.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 9\r\n* 비교값: 7\r\n\r\n임시 변수보다 비교값이 작을 경우, 비교를 종료하고 현재 공백에 임시 변수를 삽입한다. 이 케이스의 경우 바로 왼쪽에 위치한 요소가 7로 9보다 작으므로, 그 즉시 비교가 종료되며 삽입을 진행한다.\r\n\r\n5. 패스스루 2: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834078-3e4fda60-79af-4f58-9915-aca42d5babfd.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n공교롭게도, 원래의 위치에 임시 변수 9가 삽입된다.\r\n\r\n6. 패스스루 3: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834085-ce09440c-11a9-418c-ac7e-07c307bb16b5.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 2\r\n* 비교값: -\r\n\r\n네 번째 요소의 값인 2를 임시 변수로 할당한다.\r\n\r\n7. 패스스루 3: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834098-f4dbef5a-0a59-4668-aa73-0e98b431895a.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 2\r\n* 비교값: 9\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834107-74cc6e75-3a59-4fa3-8c66-56160cdb6913.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n비교값 9가 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834113-25e6eac5-d5eb-4380-918f-249eaf9de4d1.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 2\r\n* 비교값: 7\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834120-2df440ae-cad4-4f7b-a3fd-708b2ec0b6d3.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n비교값 7이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834129-5ee81114-faf3-43cd-ba96-4e3f46a705a8.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 2\r\n* 비교값: 3\r\n\r\n비교값 3이 임시 변수 2보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834134-09db5b58-6c7a-49af-a1e9-b3125e85dd6b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n8. 패스스루 3: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834141-cc23a70b-f809-4783-affb-cefae7faa2cf.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n가장 맨 첫 요소에 임시 변수 2가 삽입된다.\r\n\r\n9. 패스스루 4: 기준 인덱스를 한 칸 오른쪽으로 이동하여 과정 1을 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834150-6cd89c4c-6f2a-4360-b4cc-677d073ccd85.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 5\r\n* 비교값: -\r\n\r\n다섯 번째 요소의 값인 5를 임시 변수로 할당한다.\r\n\r\n10. 패스스루 4: 기준 인덱스 왼쪽의 요소들을 비교하고, 조건에 따라 시프트를 수행한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834157-416ea349-6684-496b-bb98-cbd456232e54.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 임시 변수: 5\r\n* 비교값: 9\r\n\r\n비교값 9가 임시 변수 5보다 크므로, 오른쪽으로 시프트한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834166-f03e3731-66b8-4b66-95e8-51d176a92bee.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n11. 패스스루 4: 현재 공백에 임시 변수의 값을 삽입한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834174-6b6b0444-fc8a-4983-814f-e54e93914765.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n네 번째 요소에 임시 변수 5가 삽입된다.\r\n\r\n가장 마지막 요소까지 기준 인덱스가 이동했으므로, 해당 패스스루를 마지막으로 종료한다.\r\n\r\n## 6-3. 삽입 정렬 구현\r\n\r\n삽입 정렬의 과정을 토대로 이를 \u003cspan class=\"orange-400\"\u003eJAVA\u003c/span\u003e로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 삽입 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\"\u003e긍정적인 시나리오 최적화\u003c/a\u003e\r\n * @since 2021.07.24 Sat 02:40:19\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int shiftCount = 0;\r\n\tprivate static int deleteCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tselectionSort(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 시프트 작업량: \");\r\n\t\twriter.write(String.valueOf(shiftCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삭제 작업량: \");\r\n\t\twriter.write(String.valueOf(deleteCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + shiftCount + deleteCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 삽입 정렬 알고리즘\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t */\r\n\tprivate static void selectionSort(int[] array)\r\n\t{\r\n\t\tfor (int i = 1; i \u003c array.length; i++)\r\n\t\t{\r\n\t\t\t// 임시 변수\r\n\t\t\tint temp = array[i];\r\n\t\t\t\r\n\t\t\t// 빈 공간\r\n\t\t\tint blank = i;\r\n\t\t\t\r\n\t\t\t// 삭제 작업 추가\r\n\t\t\tdeleteCount++;\r\n\t\t\t\r\n\t\t\t// 공백 표시\r\n\t\t\tarray[i] = Integer.MIN_VALUE;\r\n\t\t\t\r\n\t\t\tfor (int j = i - 1; j \u003e -1; j--)\r\n\t\t\t{\r\n\t\t\t\t// 비교 작업 추가\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소가 임시 변수보다 클 경우\r\n\t\t\t\tif (array[j] \u003e temp)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 시프트 작업 추가\r\n\t\t\t\t\tshiftCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = array[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tblank--;\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// 아닐 경우\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 삽입 작업 추가\r\n\t\t\tinsertCount++;\r\n\t\t\t\r\n\t\t\tarray[blank] = temp;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n10 9 8 7 6 5 4 3 2 1\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n - 비교 작업량: 45\r\n - 시프트 작업량: 45\r\n - 삭제 작업량: 9\r\n - 삽입 작업량: 9\r\n - 총 작업량: 108\r\n```\r\n\r\n소스와 입력, 출력값은 위와 같다. 사용자로부터 임의의 배열을 입력받아 삽입 정렬을 수행하고, 졍렬 결과와 각 작업량을 구분하여 표시한다.\r\n\r\n실제 핵심 동작은 `selectionSort` 메소드에서 이루어진다. 공백은 `Integer.MIN_VALUE`를 삽입하여 표시하며, 삭제됨을 표현하기 위한 것으로 작업량에 포함되지 않는다.\r\n\r\n``` java\r\nfor (int i = 1; i \u003c array.length; i++)\r\n{\r\n\t// 임시 변수\r\n\tint temp = array[i];\r\n\t\r\n\t// 빈 공간\r\n\tint blank = i;\r\n\t\r\n\t// 삭제 작업 추가\r\n\tdeleteCount++;\r\n\t\r\n\t// 공백 표시\r\n\tarray[i] = Integer.MIN_VALUE;\r\n\t\r\n\t// ...\r\n}\r\n```\r\n\r\n첫 번째 `for`문은 각 패스스루를 의미한다. 각 패스스루마다 기준 인덱스 `i`, 임시 변수 `temp`, 삭제된 요소의 인덱스 `blank`가 새로 정의된다. 이 과정에서 삭제 연산이 고정으로 한 번 수행된다.\r\n\r\n``` java\r\nfor (int j = i - 1; j \u003e -1; j--)\r\n{\r\n\t// 비교 작업 추가\r\n\tcompareCount++;\r\n\t\r\n\t// 현재 요소가 임시 변수보다 클 경우\r\n\tif (array[j] \u003e temp)\r\n\t{\r\n\t\t// 시프트 작업 추가\r\n\t\tshiftCount++;\r\n\t\t\r\n\t\tarray[blank] = array[j];\r\n\t\t\r\n\t\tblank--;\r\n\t\t\r\n\t\tarray[blank] = Integer.MIN_VALUE;\r\n\t}\r\n\t\r\n\t// 아닐 경우\r\n\telse\r\n\t{\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n두 번째 `for`문은 각 기준 인덱스 `i`의 왼쪽 요소부터 0까지 비교 및 시프트 작업을 의미한다. 각 사이클마다 비교 작업 한 번이 반드시 발생하며, 임시 변수와 현재 요소 간의 크기에 따라 시프트 작업이 발생할 수 있다.\r\n\r\n``` java\r\nfor (int i = 1; i \u003c array.length; i++)\r\n{\r\n\t// ...\r\n\t\r\n\t// 삽입 작업 추가\r\n\tinsertCount++;\r\n\t\r\n\tarray[blank] = temp;\r\n}\r\n```\r\n\r\n모든 비교가 끝나면 현재 공백인 요소에 임시 변수를 삽입한다. 이 과정에서 삽입 작업 한 번이 반드시 발생한다.\r\n\r\n## 6-4. 삽입 정렬의 효율성\r\n\r\n삽입 정렬 시 발생하는 작업을 분석하여 그 효율성에 대해 알아보자. 삽입 정렬은 \u003cspan class=\"orange-400\"\u003e삭제\u003c/span\u003e, \u003cspan class=\"orange-400\"\u003e비교\u003c/span\u003e, \u003cspan class=\"orange-400\"\u003e시프트\u003c/span\u003e, \u003cspan class=\"orange-400\"\u003e삽입\u003c/span\u003e의 4개 작업으로 이루어져있다.\r\n\r\n삽입 정렬에서 가장 최악의 케이스는 요소가 역순으로 정렬된 배열이다. 모든 요소가 역순으로 정렬될 경우, 발생할 수 있는 모든 작업이 발생한다. 최악의 경우에 발생하는 각 작업량을 일반식으로 정의하면 아래와 같다.\r\n\r\n* 삭제: $N - 1$\r\n* 비교: $N^2 \\div 2$ (대략적인 값)\r\n* 시프트: $N^2 \\div 2$ (대략적인 값)\r\n* 삽입: $N - 1$\r\n\r\n이를 토대로 삽입 정렬의 시간 복잡도는 $O(N^2 + 2N - 2)$임을 알 수 있다. 빅 오 표기법은 \u003cspan class=\"blue-400\"\u003e상수를 무시\u003c/span\u003e하므로 $O(N^2 + N)$으로 간략하게 표기할 수 있다. 하지만 빅 오 표기법은 상수만 무시하는 게 아니다. \u003cspan class=\"blue-400\"\u003e가장 높은 차수를 제외한 나머지 차수 또한 무시\u003c/span\u003e한다. 그말인 즉슨, $N^2 + N$에서 가장 높은 차수는 $N^2$이므로, $N$은 무시한다. 따라서 최종적으로 삽입 정렬의 시간 복잡도는 $O(N^2)$이 된다.\r\n\r\n|  $N$  |   $N^2$   |     $N^3$     |       $N^4$       |\r\n| :---: | :-------: | :-----------: | :---------------: |\r\n|   2   |     4     |       8       |        16         |\r\n|   5   |    25     |      125      |        625        |\r\n|  10   |    100    |     1,000     |      10,000       |\r\n|  100  |  10,000   |   1,000,000   |    100,000,000    |\r\n| 1,000 | 1,000,000 | 1,000,000,000 | 1,000,000,000,000 |\r\n\r\n요소 $N$의 갯수가 100일 때, $N^4$와 $N^3$은 $N$의 값인 100배 차이가 난다. $N^4$ 입장에서는 $N^3$ 작업 한 사이클이 발생해도, 자신의 작업량의 1%밖에 되지 않는다. 차수가 높아질 수록 작업량의 차이가 기하급수적으로 벌어지기 때문에 무시하는 것이다.\r\n\r\n지금까지 버블, 선택, 삽입 정렬 세 가지를 다뤄봤다. 각 알고리즘의 시간 복잡도를 정리하면 아래와 같다.\r\n\r\n|       구분        | 버블 정렬 |    선택 정렬    |     삽입 정렬     |\r\n| :---------------: | :-------: | :-------------: | :---------------: |\r\n|   빅 오 표기법    | $O(N^2)$  |    $O(N^2)$     |     $O(N^2)$      |\r\n| 실제 빅 오 표기법 | $O(N^2)$  | $O(N^2 \\div 2)$ | $O(N^2 + 2N - 2)$ |\r\n\r\n4장 부터 6장까지 오면서, 우리는 각 정렬의 빅 오 표기법과 실제 나타나는 빅 오 표기법에 대해 알고있다. 위 표를 토대로 본다면, 세 정렬 기법 중 선택 정렬이 가장 빠르다고 할 수 있을 것이다. 단, 누누히 말했듯이 최악의 경우에 가깝다는 전제가 수반된다.\r\n\r\n그렇다면 평균적인 경우는 어떨까?\r\n\r\n## 6-5. 평균적인 경우\r\n\r\n데이터가 1억, 1조가 넘어간다면 모를까, 대부분의 일반적인 환경에선 그리 많은 데이터를 처리하지 않는다. 즉, 대부분의 경우 최악의 케이스에 도달하지 않는다는 뜻이기도 하다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834185-4dfa70f6-0a15-4069-a7a4-7f3ed43809f4.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n대부분의 케이스는 위와 같은 정규 분포도를 따른다. 좌측으로 수렴할 수록 최악의 케이스, 우측으로 수렴할 수록 최선의 케이스, 정 가운데로 수렴할 수록 평균적인 케이스다. \u003cspan class=\"green-400\"\u003e대다수는 평균적인 영역에 포함\u003c/span\u003e되며, 양 옆의 극단적인 케이스는 상대적으로 양이 적다.\r\n\r\n지금까지 다룬 정렬 알고리즘의 대부분은 역순으로 정렬될 경우가 최악의 케이스였다. 완전 무작위의 배열이 입력된다고 가정할 때, 정확히 역순으로 나열된 배열이 나올 확률이 얼마나 될지 생각해보자. 대부분의 배열은 어떠한 규칙도 없이 무작위로 나열됐을 것이다. 굳이 위 같은 정규 분포도가 아니더라도 일상 생활에서 비슷한 사례는 많이 있다. 여러 케이스 중 발생하는 특이 케이스는 다른 대다수의 케이스와는 어떠한 방향으로든 다르다는 뜻이다. 최선, 최악의 케이스는 어찌 보면 이러한 특이 케이스의 범주에 속한다.\r\n\r\n우리가 이번 장에서 다룬 삽입 정렬을 토대로 확인해보자.\r\n\r\n* 최악의 경우, $O(N^2 + 2N - 2)$. 즉, $O(N^2)$를 가진다.\r\n* 최선의 경우, $O(3(N - 1))$. 즉, $O(N)$를 가진다.\r\n* 일반적인 경우, $O(N^2 \\div 2)$. 즉, $O(N^2)$를 가진다.\r\n\r\n이를 표로 나타내면 아래와 같다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126834196-63471f0e-41df-4715-ac15-8c79fd606fae.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n삽입 정렬은 케이스에 따라 유의미한 성능의 차이가 존재한다. 반대로 선택 정렬의 경우 꽤 난감한데, 선택 정렬은 어떠한 케이스에서든 $O(N^2)$의 시간 복잡도를 가진다.\r\n\r\n``` java\r\n/**\r\n * 선택 정렬 함수\r\n *\r\n * @param array : [int[]] 대상 배열\r\n *\r\n * @return [int[]] 작업 갯수 배열\r\n */\r\nprivate static int[] selectionSort(int[] array)\r\n{\r\n\tint compareCount = 0;\r\n\tint swapCount = 0;\r\n\t\r\n\tfor (int i = 0; i \u003c array.length; i++)\r\n\t{\r\n\t\t// 패스스루의 최소값 인덱스\r\n\t\tint min = i;\r\n\t\t\r\n\t\tfor (int j = i + 1; j \u003c array.length; j++)\r\n\t\t{\r\n\t\t\tcompareCount++;\r\n\t\t\t\r\n\t\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\t\tif (array[j] \u003c array[min])\r\n\t\t\t{\r\n\t\t\t\tmin = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// 최소 인덱스에 변화가 있었을 경우\r\n\t\tif (min != i)\r\n\t\t{\r\n\t\t\tint temp = array[min];\r\n\t\t\t\r\n\t\t\tarray[min] = array[i];\r\n\t\t\tarray[i] = temp;\r\n\t\t\t\r\n\t\t\tswapCount++;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn new int[] { compareCount, swapCount };\r\n}\r\n```\r\n\r\n위 소스는 5장에서 다룬 선택 정렬 소스다. 보시다시피 `for`문이 2개나 존재함으로 $O(N^2)$의 시간 복잡도를 가진다는 것을 어렵지 않게 유추할 수 있다. 더군다나 소스를 자세히 보자. 중간에 반복문을 종료할 수 있는 `break` 또한 존재하지 않는다. 좋든 싫든 항상 $N^2$의 작업을 수행한다는 뜻이다. 실제로 5장의 소스를 구동하면 케이스별로 작업량의 차이가 그리 크지 않다.\r\n\r\n만약 사용할 데이터의 대부분이 어느정도 정렬되어있을 경우, 삽입 정렬이 훨씬 유리하다고 판단할 수 있다. 만약 데이터가 완전히 무작위라면 선택 정렬이나 삽입 정렬이나 크게 차이가 없다고 볼 수 있다.\r\n\r\n## 6-6. 실제 예제\r\n\r\n두 배열이 존재하며, 각 배열에 공통으로 존재하는 요소를 추출하여 반환하는 교집합 알고리즘을 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\"\u003e긍정적인 시나리오 최적화\u003c/a\u003e\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class InsertionSort\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n* \r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 25\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n이중 `for` 구조이므로 시간 복잡도는 당연히 $O(N^2)$일 것이다. 두 배열의 요소의 크기가 완전히 동일할 때, 나타날 수 있는 최악의 케이스는 $O(N^2 + N)$이다. 간략히 $O(N^2)$라고 할 수 있다.\r\n\r\n위 알고리즘의 경우 불필요한 연산을 수행하기도 한다. 이를 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 교집합 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/24/about-algorithm-chapter06/\"\u003e긍정적인 시나리오 최적화\u003c/a\u003e\r\n * @since 2021.07.24 Sat 04:21:40\r\n */\r\npublic class ImproveIntersection\r\n{\r\n\tprivate static int compareCount = 0;\r\n\tprivate static int insertCount = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"첫 번째 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array1 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\twriter.write(\"두 번째 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tint[] array2 = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = intersection(array1, array2);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 삽입 작업량: \");\r\n\t\twriter.write(String.valueOf(insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(compareCount + insertCount));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 교집합 배열 반환 함수\r\n\t *\r\n\t * @param array1: [int[]] 첫 번째 배열\r\n\t * @param array2: [int[]] 두 번째 배열\r\n\t *\r\n\t * @return [int[]] 교집합 배열\r\n\t */\r\n\tprivate static int[] intersection(int[] array1, int[] array2)\r\n\t{\r\n\t\tArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e();\r\n\t\t\r\n\t\tfor (int item1 : array1)\r\n\t\t{\r\n\t\t\tfor (int item2 : array2)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 두 배열의 요소가 같을 경우\r\n\t\t\t\tif (item1 == item2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinsertCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.add(item1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn list.stream().mapToInt(Integer::intValue).toArray();\r\n\t}\r\n}\r\n```\r\n\r\n\r\n* 입력\r\n\r\n``` tc\r\n3 1 9 8 5\r\n2 4 7 5 1\r\n```\r\n\r\n* 출력\r\n* \r\n``` tc\r\n[1, 5]\r\n - 비교 작업량: 24\r\n - 삽입 작업량: 2\r\n - 총 작업량: 27\r\n```\r\n\r\n차이점은 `for`문 안의 `if` 구문에 있다.\r\n\r\n``` java\r\n// 두 배열의 요소가 같을 경우\r\nif (item1 == item2)\r\n{\r\n\tinsertCount++;\r\n\t\r\n\tlist.add(item1);\r\n\t\r\n\tbreak;\r\n}\r\n```\r\n\r\n이처럼 동일한 요소가 탐색되었을 경우, `break`를 통해 패스스루 강제 종료 기능을 추가했다. 최악의 시나리오에선 $O(N^2)$로 동일하지만, 최선의 시나리오에선 $O(N)$으로 동작할 것이다. 이전의 알고리즘이 항상 $O(N^2)$임을 감안한다면 적절한 최적화라 할 수 있다.\r\n\r\n# 마무리\r\n\r\n이 장에서 주로 얘기한 내용은 아래와 같다.\r\n\r\n* 알고리즘을 꼭 비관적으로만 바라보는 것은 아니다.\r\n* 오히려 대부분의 케이스는 평균의 범주에 속한다.\r\n* 알고리즘의 로직에 따라 케이스의 양에 따라시간 복잡도가 유의미하게 달라지기도 한다.\r\n\r\n이 장에서는 알고리즘의 또 다른 관점에 대해 알아봤다. 대부분의 케이스가 평균의 범주에 속하므로, 평균 시간 복잡도 역시 성능을 측정함에 있어서 중요한 요소 중 하나일 것이다.\r\n\r\n다음 장에서는 새로운 개념인 해시 테이블에 대해 알아본다."},{"title":"빅 오를 사용하거나 사용하지 않는 코드 최적화","excerpt":"지금까지 알고리즘의 퍼포먼스를 비교하면서 빅 오 표기법을 통해 수치화했다. 하지만 빅 오 표기법도 알고리즘의 퍼포먼스를 측정함에 있어서 완벽함을 보여주진 않는다. 이전 장에서 N(O^2)이나 N(N^2 - N) 모두 빅 오 표기법에선 N(O^2)로 간주한다고 설명했다. 이러한 특성으로 인해, 실제로는 명백한 차이를 보이는 알고리즘임에도 불구하고 빅 오 표기법으론 성능이 거의 동일하게 측정되기도 한다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-23T23:42:33","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","선택 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-23-about-algorithm-chapter05","content":"\r\n\u003cp class=\"orange-A400\" align=\"center\"\u003e본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.\u003c/p\u003e\r\n\r\n# 5장 빅 오를 사용하거나 사용하지 않는 코드 최적화\r\n\r\n지금까지 알고리즘의 퍼포먼스를 비교하면서 \u003cspan class=\"primary\"\u003e빅 오 표기법\u003c/span\u003e을 통해 수치화했다. 하지만 빅 오 표기법도 알고리즘의 퍼포먼스를 측정함에 있어서 완벽함을 보여주진 않는다.\r\n\r\n이전 장에서 $N(O^2)$이나 $N(N^2 - N)$ 모두 빅 오 표기법에선 $N(O^2)$로 간주한다고 설명했다. 이러한 특성으로 인해, 실제로는 명백한 차이를 보이는 알고리즘임에도 불구하고 빅 오 표기법으론 성능이 거의 동일하게 측정되기도 한다.\r\n\r\n알고리즘의 속도는 알고리즘을 선택하는 데 있어서 매우 중요한 척도이므로, 이를 정확비 측정하는 것은 매우 중요하다. 이 장에서는 앞서 설명한 것과 같이 대체로 성능이 \u003cspan class=\"pink-400\"\u003e비슷해\u003c/span\u003e보이는 알고리즘을 구별하여 더욱 빠른 알고리즘을 판별해본다.\r\n\r\n## 5-1. 선택 정렬\r\n\r\n이전 장에서는 \u003cspan class=\"orange-400\"\u003e버블 정렬\u003c/span\u003e 알고리즘을 통해 내용을 서술했다. 이번 장에서는 다른 정렬 알고리즘인 \u003cspan class=\"orange-400\"\u003e선택 정렬\u003c/span\u003e 알고리즘을 통해 서술해본다.\r\n\r\n선택 정렬 알고리즘은 패스스루마다 요소를 탐색하여 최소값을 탐지하고, 이를 앞으로 보내어 정렬하는 방식이다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793171-d9677021-0ff9-414c-b83b-165dc037222f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n정렬에 사용할 배열은 위와 같으며, 과정은 아래의 순서대로 진행된다.\r\n\r\n1. 맨 첫 번째 값을 탐색한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793179-854c05e3-04cc-420a-8a42-22fe0145c4cb.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n한 패스스루에서 가장 작은 요소를 찾는 것이 핵심이다. 아직 첫 단계이므로, 첫 요소는 그 자체로 최소값이 된다.\r\n\r\n2. 탐색 포인터를 한 칸 이동하여 패스스루 최소값과 비교한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793193-d865b162-9c02-44a0-a59c-d2e1674f4e5f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 5\r\n* 탐색값: 3\r\n\r\n패스스루 최소값을 3으로 갱신한다.\r\n\r\n3. 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793202-90a4dfc3-d40c-4073-9127-763781156693.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n4. 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793209-88b076db-fe26-4cee-9a0c-1f0540beb0c8.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 3\r\n* 탐색값: 2\r\n\r\n패스스루 최소값을 2로 갱신한다.\r\n\r\n5. 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793215-a5a7dde7-8fbf-42a4-b585-5b5778297cc3.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 2\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다. 마지막 요소이므로, 탐색이 종료되고 요소 하나를 정렬한다.\r\n\r\n6. 패스스루 최소값의 요소를 맨 앞으로 정렬한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793223-3580ae05-867b-464d-9d58-831e93b6142b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n맨 앞의 요소 5와 최소값 2의 자리를 서로 교환한다. 2는 완전히 매칭되었으므로, 앞으로의 패스스루에서 제외된다.\r\n\r\n## 5-2. 선택 정렬 실제로 해보기\r\n\r\n이전 문단에서 선택 정렬의 원리에 대해 알았으니, 전체 배열에 대한 선택 정렬을 수행해보자.\r\n\r\n\u003csmall class=\"red-A400\"\u003e패스스루 1은 이전 문단의 과정과 동일하다.\u003c/small\u003e\r\n\r\n1. 패스스루 1: 맨 첫 번째 요소를 탐색한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793179-854c05e3-04cc-420a-8a42-22fe0145c4cb.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: -\r\n* 탐색값: 5\r\n\r\n한 패스스루에서 가장 작은 요소를 찾는 것이 핵심이다. 아직 첫 단계이므로, 첫 요소는 그 자체로 최소값이 된다.\r\n\r\n2. 패스스루 1: 탐색 포인터를 한 칸 이동하여 패스스루 최소값과 비교한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793193-d865b162-9c02-44a0-a59c-d2e1674f4e5f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 5\r\n* 탐색값: 3\r\n\r\n패스스루 최소값을 3으로 갱신한다.\r\n\r\n3. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793202-90a4dfc3-d40c-4073-9127-763781156693.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n4. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793209-88b076db-fe26-4cee-9a0c-1f0540beb0c8.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 3\r\n* 탐색값: 2\r\n\r\n패스스루 최소값을 2로 갱신한다.\r\n\r\n5. 패스스루 1: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793215-a5a7dde7-8fbf-42a4-b585-5b5778297cc3.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 2\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다. 마지막 요소이므로, 탐색이 종료되고 요소 하나를 정렬한다.\r\n\r\n6. 패스스루 1: 패스스루 최소값의 요소를 맨 앞으로 정렬한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793223-3580ae05-867b-464d-9d58-831e93b6142b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n맨 앞의 요소 5와 최소값 2의 자리를 서로 교환한다. 2는 완전히 매칭되었으므로, **앞으로의 패스스루에서 제외**된다.\r\n\r\n7. 패스스루 2: 두 번째 요소를 탐색한다.\r\n\r\n* 최소값: -\r\n* 탐색값: 3\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793231-7c8448af-29e1-4d65-9c37-630dcec47e24.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n8. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793239-cefccd38-954e-4c49-85be-a007698d072b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 3\r\n* 탐색값: 9\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n9. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793255-354bc82f-0c65-4a75-bfde-c192f97344dc.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 3\r\n* 탐색값: 5\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n10. 패스스루 2: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793276-bd4020c4-fcda-4b45-b993-2575ff7c1b69.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 3\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n11. 패스스루 2: 패스스루 최소값의 요소를 두 번째 위치로 정렬한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793282-277dc152-91d4-47a8-bdcb-3f5280593040.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n최소값 3이 우연히도 올바른 자리에 위치하고 있어서 자리 교환이 일어나지 않는다. 두 번째 요소까지 정렬되었으므로, 마찬가지로 다음 패스스루부터 제외된다.\r\n\r\n12. 패스스루 3: 세 번째 요소를 탐색한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793296-8e9c6a9b-8aff-4634-86cc-684338c990dc.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n13. 패스스루 3: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793310-19358a00-e527-405d-8033-1eef2c11060b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 9\r\n* 탐색값: 5\r\n\r\n패스스루 최소값을 5로 갱신한다.\r\n\r\n14. 패스스루 3: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793315-ca00a872-d867-40e5-95c3-c9de2b7c7851.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 5\r\n* 탐색값: 6\r\n\r\n패스스루 최소값이 더 작으므로 갱신되지 않는다.\r\n\r\n15. 패스스루 3: 패스스루 최소값의 요소를 세 번째 위치로 정렬한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793330-af0a7836-5bfd-477c-b614-c8c2fc8f108f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n세 번째 요소 9와 최소값 5와의 자리를 서로 교환한다.\r\n\r\n16. 패스스루 4: 네 번째 요소를 탐색한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793337-f90959c9-c798-46f5-b64a-68807621edad.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n해당 요소를 최소값으로 지정한다.\r\n\r\n17. 패스스루 4: 2번 과정을 반복한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793345-4f6a2819-4dac-4c81-b9c6-4ca7fd4c8749.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: 9\r\n* 탐색값: 6\r\n\r\n패스스루 최소값을 6으로 갱신한다.\r\n\r\n18. 패스스루 4: 패스스루 최소값의 요소를 네 번째 위치로 정렬한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793357-e0e62399-9d03-48a8-8f23-721e43022a65.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n네 번째 요소 9와 최소값 6와의 자리를 서로 교환한다.\r\n\r\n19. 패스스루 5: 마지막 요소를 탐색한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793365-b658adfc-df4b-4e56-b130-e78e81826d54.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n* 최소값: -\r\n* 탐색값: 9\r\n\r\n패스스루 최소값을 9로 갱신한다.\r\n\r\n마지막 요소이므로 그 자체로 정렬된 위치에 있으며, 패스스루가 종료된다.\r\n\r\n이로써 선택 정렬을 통해 최종적으로 정렬된 배열의 형태는 아래와 같다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793370-a6ec0819-47c7-49c6-8f30-b953d9311336.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n## 5-3. 선택 정렬 구현\r\n\r\n선택 정렬의 과정을 토대로 이를 \u003cspan class=\"orange-400\"\u003eJAVA\u003c/span\u003e로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 선택 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/23/about-algorithm-chapter05/\"\u003e빅 오를 사용하거나 사용하지 않는 코드 최적화\u003c/a\u003e\r\n * @since 2021.07.23 Fri 01:12:20\r\n */\r\npublic class SelectionSort\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] processes = selectionSort(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[0]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 스왑 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(processes[0] + processes[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 선택 정렬 함수\r\n\t *\r\n\t * @param array : [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 작업 갯수 배열\r\n\t */\r\n\tprivate static int[] selectionSort(int[] array)\r\n\t{\r\n\t\tint compareCount = 0;\r\n\t\tint swapCount = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c array.length; i++)\r\n\t\t{\r\n\t\t\t// 패스스루의 최소값 인덱스\r\n\t\t\tint min = i;\r\n\t\t\t\r\n\t\t\tfor (int j = i + 1; j \u003c array.length; j++)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\t\t\tif (array[j] \u003c array[min])\r\n\t\t\t\t{\r\n\t\t\t\t\tmin = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 최소 인덱스에 변화가 있었을 경우\r\n\t\t\tif (min != i)\r\n\t\t\t{\r\n\t\t\t\tint temp = array[min];\r\n\t\t\t\t\r\n\t\t\t\tarray[min] = array[i];\r\n\t\t\t\tarray[i] = temp;\r\n\t\t\t\t\r\n\t\t\t\tswapCount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { compareCount, swapCount };\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n5 3 4 1 2\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 2, 3, 4, 5]\r\n - 비교 작업량: 10\r\n - 스왑 작업량: 4\r\n - 총 작업량: 14\r\n```\r\n\r\n사용자로부터 공백으로 구분된 숫자 배열을 입력받아 선택 정렬을 수행하고, 작업량을 구분에 따라 표시한다. 핵심 동작은 `selectionSort` 메소드에서 수행한다.\r\n\r\n* 첫 번째 `for`: 패스스루\r\n* 두 번째 `for`: 비교 작업\r\n* `if`문: 스왑 작업\r\n\r\n``` java\r\nfor (int i = 0; i \u003c array.length; i++)\r\n{\r\n\t// 패스스루의 최소값 인덱스\r\n\tint min = i;\r\n\t\r\n\tfor (int j = i + 1; j \u003c array.length; j++)\r\n\t{\r\n\t\tcompareCount++;\r\n\t\t\r\n\t\t// 현재 요소의 값이 패스스루의 최소값보다 작을 경우\r\n\t\tif (array[j] \u003c array[min])\r\n\t\t{\r\n\t\t\tmin = j;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 최소 인덱스에 변화가 있었을 경우\r\n\tif (min != i)\r\n\t{\r\n\t\tint temp = array[min];\r\n\t\t\r\n\t\tarray[min] = array[i];\r\n\t\tarray[i] = temp;\r\n\t\t\r\n\t\tswapCount++;\r\n\t}\r\n}\r\n```\r\n\r\n패스스루마다 첫 요소를 최소값 `min`에 할당한다. 이후 다음 요소부터 마지막 요소까지 순차적으로 `min`과 비교한다.\r\n\r\n`min`보다 더 작은 요소가 탐색될 경우 이를 교체한다. 최종적으로 `min`에는 검색한 요소들 중 가장 최소값이 할당된다.\r\n\r\n`if`문에서 `min`에 변화가 있었는지를 확인한다. 패스스루의 첫 요소의 인덱스가 아닐 경우, `min`이 변경된 것이므로 스왑을 진행한다.\r\n\r\n\r\n## 5-4. 선택 정렬의 효율성\r\n\r\n선택 정렬의 효율성을 따져보자. 위에서 언급했듯이, 선택 정렬은 \u003cspan class=\"blue-400\"\u003e비교\u003c/span\u003e, \u003cspan class=\"blue-400\"\u003e교환\u003c/span\u003e 작업으로 이루어진다. 비교는 항상 일어나고, 교환의 경우 조건부로 일어난다.\r\n\r\n요소가 5개인 배열을 선택 정렬할 경우 발생하는 비교 작업량은 아래와 같다.\r\n\r\n| 패스스루 | 작업량 |\r\n| :------: | :----: |\r\n|    1     |   4    |\r\n|    2     |   3    |\r\n|    3     |   2    |\r\n|    4     |   1    |\r\n\r\n$4 + 3 + 2 + 1 = 10$으로 총 10번의 비교 작업이 수행된다. 일반화하면 $(N - 1) + (N - 2) + \\dots + 1$와 같이 정의할 수 있다.\r\n\r\n교환의 경우, 비교와 달리 패스스루 당 최대 한 번만 발생하며, 이 또한 조건에 따라 아예 일어나지 않기도 한다.\r\n\r\n가장 최악의 경우, 각 패스스루마다 교환이 발생하므로 요소가 5개 일 때, 최대 4번의 교환 작업을 예상할 수 있다.\r\n\r\n예시로, $[ 5, 3, 4, 1, 2 ]$의 경우 모든 패스스루에서 스왑이 일어난다.\r\n\r\n\u003e **책에서는 역순일 때가 최악의 경우라는데요??**  \r\n\u003e 역순 배열일 경우 오히려 교환이 두 번 밖에 일어나지 않는다. 반만 정렬하면 나머지 뒤쪽은 알아서 정렬하기 때문.\r\n\r\n버블 정렬과 선택 정렬을 비교하면 아래와 같다.\r\n\r\n|  $N$  | 버블 정렬 | 선택 정렬 | 차이  |\r\n| :---: | :-------: | :-------: | :---: |\r\n|   5   |    20     |    14     |  30%  |\r\n|  10   |    90     |    54     |  40%  |\r\n|  20   |    380    |    199    | 52.4% |\r\n|  40   |   1560    |    819    | 52.5% |\r\n|  80   |   6320    |   3229    | 51.1% |\r\n|  100  |   9900    |   5049    |  51%  |\r\n\r\n버블 정렬 대비 선택 정렬의 속도가 50%로 수렴한다. 즉, 최악의 경우에도 선택 정렬이 두 배 가량 빠르다는 걸 알 수 있다.\r\n\r\n## 5-5. 상수 무시하기\r\n\r\n이전 문단에서의 디테일한 비교로 버블 정렬과 선택 정렬 간의 유의미한 차이가 있음을 확인했다. 선택 정렬을 빅 오 표기법으로 나타내면 $O(N^2 / 2)$가 된다.\r\n\r\n|  $N$  | $N^2 / 2$ | 선택 정렬의 작업량 |\r\n| :---: | :-------: | :----------------: |\r\n|   5   |   12.5    |         14         |\r\n|  10   |    50     |         54         |\r\n|  20   |    200    |        199         |\r\n|  40   |    800    |        819         |\r\n|  80   |   3200    |        3229        |\r\n|  100  |   5000    |        5049        |\r\n\r\n위 표가 이를 뒷받침해준다. 하지만 실제 버블 정렬과 선택 정렬의 빅 오 표기법은 둘 다 동일하게 $O(N^2)$이다. 실제로 선택 정렬 또한 \u003cspan class=\"red-400\"\u003e반복문이 두 번 중첩\u003c/span\u003e되어있다. $O(N^2)$의 특징이 그대로 나타나있는 것이다. 이는 빅 오 표기법이 처음 소개된 3장부터 꾸준히 언급되었던 특징으로, \u003cspan class=\"teal-400\"\u003e빅 오 표기법은 상수를 무시\u003c/span\u003e한다.\r\n\r\n분명히 상수도 유의미한 수인데, 명색이 **성능**을 측정한다는 기법이 왜 이렇게 느슨한 형태를 가지는 걸까?\r\n\r\n## 5-6. 빅 오의 역할\r\n\r\n빅 오 표기법은 왜 상수를 무시할까? 이는 빅 오 표기법이 가지는 관점 때문이라고 설명할 수 있다. $O(N)$과 $O(N^2)$, $O(100N)$과 $O(N^2)$의 작업량을 비교하면서 빅 오 표기법이 알고리즘을 어떤 관점으로 바라보는지 확인해보자.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/126793374-db4248af-daf1-4e02-8622-c16d2a2c9f69.png\" width=\"800px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n$O(N^2)$의 경우, 어떠한 경우에든 $O(N)$보다 같거나 느리다. 하지만 $O(100N)$의 경우는 살짝 다르다. 데이터가 적은 앞 구간에선 오히려 $O(N^2)$이 더 빠르지만, 충분히 데이터가 많아진 이후로는 $O(100N)$이 더 빠르다.\r\n\r\n빅 오 표기법이 상수에 크게 미련을 갖지 않는 이유다. $O(N)$, $O(N^2)$과 같이 구간이 완전히 다를 경우 항상 빠르거나, 반대로 느리다.\r\n\r\n그러나 $O(100N)$, $O(N^2)$의 경우 데이터의 양에 따라 상대적으로 빠르기도 하고, 느리기도 하다. 이런 경우의 알고리즘을 서로 구분하기 위해 빅 오 표기법은 상수를 무시한다. 어차피 $O(N)$이나 $O(100N)$이나 장기적으론 $O(N^2)$보다는 빨라지기 때문이다.\r\n\r\n빅 오 표기법은 여전히 구간이 전혀 다른 알고리즘을 상대로는 유효한 성능 판단의 척도다. 시간 복잡도가 동일하더라도, 실제로 보여주는 알고리즘의 성능은 차이가 있을 수 있다는 점을 감안하자.\r\n\r\n## 5-7. 실제 예제\r\n\r\n요소 $N$개를 가진 배열에서 두 요소 중 하나만 선택하여 $N \\div 2$의 요소를 가지는 새로운 배열을 만드는 알고리즘을 설계해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 배열 선택 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/23/about-algorithm-chapter05/\"\u003e빅 오를 사용하거나 사용하지 않는 코드 최적화\u003c/a\u003e\r\n * @since 2021.07.23 Fri 22:32:54\r\n */\r\npublic class HalfArray\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = solve(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 결과 배열\r\n\t */\r\n\tprivate static int[] solve(int[] array)\r\n\t{\r\n\t\tint length = (int) Math.ceil(array.length / 2D);\r\n\t\t\r\n\t\tint[] result = new int[length];\r\n\t\t\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c array.length; i++)\r\n\t\t{\r\n\t\t\t// 인덱스가 짝수일 경우\r\n\t\t\tif (i % 2 == 0)\r\n\t\t\t{\r\n\t\t\t\tresult[count] = array[i];\r\n\t\t\t\t\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[0, 2, 4, 6, 8]\r\n```\r\n\r\n위 알고리즘은 배열의 모든 원소를 순회하며, 인덱스가 짝수일 경우 해당 값을 추출하여 새로운 배열로 만들어 반환한다.\r\n\r\n해당 알고리즘은 \u003cspan class=\"orange-400\"\u003e탐색\u003c/span\u003e과 \u003cspan class=\"orange-400\"\u003e삽입\u003c/span\u003e으로 이루어져있다.\r\n\r\n* 탐색: $N$개\r\n* 삽입: $N / 2$개\r\n\r\n즉, 위 알고리즘의 정확한 시간 복잡도는 $O(1.5N)$이며, 위에서 언급했듯이 상수를 무시하므로 $O(N)$으로 표기한다.\r\n\r\n위 알고리즘을 조금 더 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 배열 선택 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/23/about-algorithm-chapter05/\"\u003e빅 오를 사용하거나 사용하지 않는 코드 최적화\u003c/a\u003e\r\n * @since 2021.07.23 Fri 22:51:52\r\n */\r\npublic class ImproveHalfArray\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"요소의 갯수가 짝수개인 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] result = solve(array);\r\n\t\t\r\n\t\twriter.write(Arrays.toString(result));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 알고리즘 결과 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 대상 배열\r\n\t *\r\n\t * @return [int[]] 결과 배열\r\n\t */\r\n\tprivate static int[] solve(int[] array)\r\n\t{\r\n\t\tint length = (int) Math.ceil(array.length / 2D);\r\n\t\t\r\n\t\tint[] result = new int[length];\r\n\t\t\r\n\t\tint count = 0;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c array.length; i += 2)\r\n\t\t{\r\n\t\t\tresult[count] = array[i];\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n* 입력\r\n\r\n``` tc\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[0, 2, 4, 6, 8]\r\n```\r\n\r\n위 알고리즘은 `solve` 메소드의 `for`부분을 향상시킨 알고리즘이다.\r\n\r\n``` java\r\nfor (int i = 0; i \u003c array.length; i += 2)\r\n{\r\n\tresult[count] = array[i];\r\n\t\r\n\tcount++;\r\n}\r\n```\r\n\r\n요소를 하나한 탐색하여 그 중 짝수인 인덱스를 판별하는 것이 아니라, 애초에 짝수 인덱스만을 탐색하여 삽입한다. 즉, 탐색의 작업이 50% 감소했다.\r\n\r\n* 탐색: $N / 2$개\r\n* 삽입: $N / 2$개\r\n\r\n이 알고리즘은 정직하게 $O(N)$의 시간 복잡도를 가진다. 엄밀히 따지면 아래의 알고리즘이 더 우수한 성능을 가지지만, 시간 복잡도의 관점에서는 둘 다 동일하다.\r\n\r\n같은 시간 복잡도를 가진다고 해도, 데이터의 양이 무수히 많을 경우 아래의 알고리즘이 더 적합할 것이다.\r\n\r\n# 마무리\r\n\r\n이 장에서 주로 얘기한 내용은 아래와 같다.\r\n\r\n* 빅 오 표기법은 비관적인 관점을 가지므로 시간 복잡도의 상수를 무시한다.\r\n* 시간 복잡도가 같아도, 실제 성능은 유의미하게 차이날 수 있다.\r\n\r\n간혹 여러 사람을 만나다보면 인생을 항상 부정적인 관점으로 바라보는 사람이 더러 있다. 아마 빅 오 표기법이 의인화된다면 이런 사람이 되지 않을까 싶다.\r\n\r\n부정적으로 보는 것이 좋을 때도 있겠지만, **언제나**라는 말이 통용되진 않는다. 세상엔 수 많은 관점이 존재하고, 이는 알고리즘도 예외는 아니다. 다행히, 현실에서 대부분의 일은 평범의 범주 안에서 일어난다.\r\n\r\n다음 장에서는 부정적인 관점에서 벗어나, 평균적인 관점으로 바라보는 시간을 가져보자."},{"title":"빅 오로 코드 속도 올리기","excerpt":"이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-16T21:39:54","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","버블 정렬"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-16-about-algorithm-chapter04","content":"\r\n\u003cp class=\"orange-A400\" align=\"center\"\u003e본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.\u003c/p\u003e\r\n\r\n# 4장 빅 오로 코드 속도 올리기\r\n\r\n이전 장에서 빅 오 코드 표기법을 배웠으니, 이를 통해 시간 복잡도를 비교함으로써 알고리즘을 서로 비교할 수 있음을 확인했다. 이 장에서는 버블 정렬 알고리즘을 설계하고, 이를 빅 오 표기법을 통해 어떻게 개선할 수 있는지 확인해본다.\r\n\r\n## 4-1 버블 정렬\r\n\r\n배열을 효과적으로 다루기 위해 \u003cspan class=\"primary\"\u003e정렬\u003c/span\u003e 기법이 폭넓게 이용된다. \u003cspan class=\"orange-A400\"\u003e이진 검색\u003c/span\u003e에서도 겪었듯이, 정렬된 배열은 배열의 요소를 어느정도 **예측**할 수 있도록 규칙성을 부여한다. 이러한 이유로 배열을 정렬하는 다양한 기법이 고안되었으며, 이 문단에서는 정렬 중 가장 기본적이면서 상대적으로 비효율적인 \u003cspan class=\"orange-A400\"\u003e버블 정렬\u003c/span\u003e에 대해 알아본다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947608-e434441d-f735-44d6-8634-32431c152333.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n위와 같은 배열이 존재할 때, 버블 정렬은 이를 어떻게 오름차순으로 정렬하는 지 알아보자.\r\n\r\n1. 우선 맨 첫 요소와 그 다음 요소를 비교한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n2. 앞의 요소가 뒤의 요소보다 클 경우 서로 교환(swap)한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n3. 각각 한 칸씩 이동하여 다음 요소를 비교한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n4. 1 ~ 3의 과정을 반복한다.\r\n\r\n더 이상 교환이 이루어지지 않을 때까지 1 ~ 3의 과정을 반복한다. 이러한 반복을 \u003cspan class=\"primary\"\u003e패스스루(passthrough)\u003c/span\u003e라 명칭한다.\r\n\r\n## 4-2. 버블 정렬 실제로 해보기\r\n\r\n이전 문단에서 \u003cspan class=\"orange-A400\"\u003e버블 정렬\u003c/span\u003e의 원리를 알았으니 실제로 적용하여 배열을 완전히 정렬해보자.\r\n\r\n대상 배열은 이전 문단에서 사용된 배열과 동일하다.\r\n\r\n1. 패스스루 1: 8과 4 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947619-042289cc-2740-445f-9b53-40f35bda9ba9.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n8과 4를 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947623-68067599-90d6-458d-b8ec-6590f88e7b81.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n2. 패스스루 1: 8과 6 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947629-459f452d-713d-443d-bf1d-d4d2a28db97f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n8과 6을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947635-b30df0e3-2b2b-4bee-b727-8bf070c82c73.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n3. 패스스루 1: 8과 7 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947646-ce35e2d1-0428-4e84-b8da-c2b17a13485c.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n8과 7을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947652-f53b26ef-f291-4c64-9719-e4886aff91b6.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n4. 패스스루 1: 8과 3 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947657-a374227c-855e-4b88-aba0-a8eb9ee881ca.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n8과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947666-5574d74d-9d9a-4ff3-b145-9e9b341df0c3.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n가장 마지막 배열의 요소까지 도달했으므로, 가장 마지막 요소인 8은 올바른 위치에 정렬되어 있다. 오름차순에서 배열의 가장 마지막 요소에는 가장 큰 값이 와야하므로, 배열의 요소 중 가장 큰 값인 8이 오는 것이 적절하다.\r\n\r\n이미 정렬되어있으므로, 다음 패스스루에선 마지막 요소는 비교하지 않아도 된다. 즉, \u003cspan class=\"teal-400\"\u003e패스스루가 진행될 수록 비교할 요소의 범위가 작아진다.\u003c/span\u003e\r\n\r\n정렬이 완료된 요소는 \u003cspan class=\"yellow-400\"\u003e노란색\u003c/span\u003e으로 표시한다.\r\n\r\n5. 패스스루 2: 4와 6 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947681-5b8ec91b-9da1-41da-9906-6d9e99c4fdd8.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n6. 패스스루 2: 6과 7 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947698-af6eae59-b9e5-4075-a7e5-e433c8888a6b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n6과 7을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n7. 패스스루 2: 7과 3 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947709-19eefa54-e834-41cc-9ba2-f57d23424e9c.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n7과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947720-2fca7b88-3f84-422b-af78-77e57779270f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n요소 7이 완전히 정렬됐다. 다음 패스스루를 시작한다.\r\n\r\n8. 패스스루 3: 4와 6 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947722-d73f88f3-3c12-4c19-9c85-0feb6bd4b3a9.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n4와 6을 비교한다. 뒤의 요소가 더 크므로, 스왑하지 않는다.\r\n\r\n9. 패스스루 3: 6과 3 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947729-b420b29e-3c9b-42c2-8fe2-88d509da6b91.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n6과 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947744-2d71db3b-e35b-457f-ba35-84d05e2a6088.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n요소 6이 완전히 정렬됐다. 다음 패스스루를 시작한다.\r\n\r\n10. 패스스루 4: 4와 3 비교\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947755-4833cd65-a86e-48c7-8413-d5e8df9c624c.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n4와 3을 비교한다. 앞의 요소가 더 크므로, 스왑한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947767-d8163c94-8fbc-43ec-9b17-5567b9714eb5.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n가장 마지막 패스스루이므로, 모든 요소가 정렬됐다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947774-a376dc47-0102-4ff1-8b08-d65cb8175cf0.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n정렬된 배열은 위와 같으며, 총 10번의 작업이 이루어졌다.\r\n\r\n## 4-3. 버블 정렬 구현\r\n\r\n\u003cspan class=\"orange-A400\"\u003e버블 정렬\u003c/span\u003e을 직접 코드로 구현해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 버블 정렬 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/\"\u003e빅 오로 코드 속도 올리기\u003c/a\u003e\r\n * @since 2021.07.16 Fri 19:11:19\r\n */\r\npublic class BubbleSort\r\n{\r\n\t// 배열\r\n\tprivate static int[] array;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"버블 정렬할 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\tarray = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tint[] count = bubbleSort();\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.write(Arrays.toString(array));\r\n\t\twriter.newLine();\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 비교 작업량: \");\r\n\t\twriter.write(String.valueOf(count[0]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 스왑 작업량: \");\r\n\t\twriter.write(String.valueOf(count[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\" - 총 작업량: \");\r\n\t\twriter.write(String.valueOf(count[0] + count[1]));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 버블 정렬 및 작업량 반환 함수\r\n\t *\r\n\t * @return [int[]] 비교 작업량과 스왑 작업량\r\n\t */\r\n\tprivate static int[] bubbleSort()\r\n\t{\r\n\t\t// 비교 작업량\r\n\t\tint compareCount = 0;\r\n\t\t\r\n\t\t// 스왑 작업량\r\n\t\tint swapCount = 0;\r\n\t\t\r\n\t\t// 스왑 여부\r\n\t\tboolean isSwaped = true;\r\n\t\t\r\n\t\t// 비교 인덱스\r\n\t\tint index = array.length - 1;\r\n\t\t\r\n\t\t// 스왑이 일어나지 않을 때까지\r\n\t\twhile (isSwaped)\r\n\t\t{\r\n\t\t\tisSwaped = false;\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i \u003c index; i++)\r\n\t\t\t{\r\n\t\t\t\tcompareCount++;\r\n\t\t\t\t\r\n\t\t\t\t// 현재 요소가 다음 요소보다 클 경우\r\n\t\t\t\tif (array[i] \u003e array[i + 1])\r\n\t\t\t\t{\r\n\t\t\t\t\t// 스왑 발생\r\n\t\t\t\t\tisSwaped = true;\r\n\t\t\t\t\tswapCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint temp = array[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\tarray[i] = array[i + 1];\r\n\t\t\t\t\tarray[i + 1] = temp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tindex--;\r\n\t\t}\r\n\t\t\r\n\t\treturn new int[] { compareCount, swapCount };\r\n\t}\r\n}\r\n```\r\n\r\n위 소스는 사용자로부터 공백으로 구분된 숫자를 입력받아 버블 정렬을 수행하는 알고리즘이다.\r\n\r\n* 입력\r\n\r\n``` tc\r\n5 4 12 6 77 32 1 9 11 59\r\n```\r\n\r\n* 출력\r\n\r\n``` tc\r\n[1, 4, 5, 6, 9, 11, 12, 32, 59, 77]\r\n\r\n - 읽기 작업량: 42\r\n - 스왑 작업량: 16\r\n - 총 작업량: 58\r\n```\r\n\r\n실제 버블 정렬이 수행되는 알고리즘은 아래와 같다.\r\n\r\n``` java\r\n/**\r\n * 버블 정렬 및 작업량 반환 함수\r\n *\r\n * @return [int[]] 비교 작업량과 스왑 작업량\r\n */\r\nprivate static int[] bubbleSort()\r\n{\r\n\t// 비교 작업량\r\n\tint compareCount = 0;\r\n\t\r\n\t// 스왑 작업량\r\n\tint swapCount = 0;\r\n\t\r\n\t// 스왑 여부\r\n\tboolean isSwaped = true;\r\n\t\r\n\t// 비교 인덱스\r\n\tint index = array.length - 1;\r\n\t\r\n\t// 스왑이 일어나지 않을 때까지\r\n\twhile (isSwaped)\r\n\t{\r\n\t\tisSwaped = false;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c index; i++)\r\n\t\t{\r\n\t\t\tcompareCount++;\r\n\t\t\t\r\n\t\t\t// 현재 요소가 다음 요소보다 클 경우\r\n\t\t\tif (array[i] \u003e array[i + 1])\r\n\t\t\t{\r\n\t\t\t\t// 스왑 발생\r\n\t\t\t\tisSwaped = true;\r\n\t\t\t\tswapCount++;\r\n\t\t\t\t\r\n\t\t\t\tint temp = array[i];\r\n\t\t\t\t\r\n\t\t\t\tarray[i] = array[i + 1];\r\n\t\t\t\tarray[i + 1] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tindex--;\r\n\t}\r\n\t\r\n\treturn new int[] { compareCount, swapCount };\r\n}\r\n```\r\n\r\n* `compareCount`: 비겨 작업량 카운트\r\n* `swapCount`: 스왑 작업량 카운트\r\n* `isSwaped`: 스왑 여부\r\n* `index`: 정렬 인덱스\r\n\r\n`index`는 정렬을 하기위한 배열의 최대 인덱스다. 1을 빼주는 이유는 버블 정렬의 특성 때문이다. $[0, 1, 2]$와 같은 배열의 최대 인덱스는 3이다. 배열의 최대 인덱스가 3일 때 첫 패스스루의 작업 갯수는 0과 1, 1과 2로 2번 일어난다. 최대 인덱스를 하나 빼주지 않으면 0과 1, 1과 2, 2와 무엇인가를 비교하려 하기 때문에 배열 초과 예외인 `ArrayIndexOutOfBoundsException`가 발생한다.\r\n\r\n`while`문을 통해 스왑이 일어나지 않을 때까지 반복한다. \u003cspan class=\"pink-A400\"\u003e패스스루 내에서 스왑이 한 번도 일어나지 않으면 정렬이 완료\u003c/span\u003e된 것으로 간주하여 종료한다.\r\n\r\n`for`문을 통해 인덱스 크기까지 비교하여 현재 배열보다 다음 배열이 더 클 경우 스왑한다. 이 과정에서 `isSwaped`이 `true`로 할당된다. `isSwaped`가 `true`이므로 다음 프로세스가 패스스루가 진행될 것이다.\r\n\r\n해당하는 각 과정은 카운팅된다.\r\n\r\n## 4-4. 버블 정렬의 효율성\r\n\r\n버블 정렬은 두 가지 작업으로 이루어진다.\r\n\r\n* **비교**: 더 큰 수를 찾기위해 비교한다.\r\n* **교환**: 정렬하기 위해 스왑한다.\r\n\r\n요소 5개가 있을 때, 아래와 같은 \u003cspan class=\"blue-400\"\u003e비교\u003c/span\u003e작업이 이루어진다.\r\n\r\n* 패스스루 1: 총 4번의 비교\r\n* 패스스루 2: 총 3번의 비교\r\n* 패스스루 3: 총 2번의 비교\r\n* 패스스루 4: 총 1번의 비교\r\n* 패스스루 5: 비교 없음 (정렬 완료)\r\n\r\n즉, 4 + 3 + 2 + 1로 총 10번의 비교가 일어난다.\r\n\r\n그렇다면 \u003cspan class=\"blue-400\"\u003e스왑\u003c/span\u003e작업은 어떨까? 스왑은 상황에 따라 일어날 수도, 일어나지 않을 수도 있다.\r\n\r\n이전 장에서 \u003cspan class=\"red-400\"\u003e알고리즘은 언제나 비관적인 관점\u003c/span\u003e으로 접근한다고 했으니, 스왑이 언제나 일어날 경우를 가정하자.\r\n\r\n\u003e 가장 최악의 버블 정렬 케이스  \r\n\u003e 버블 정렬은 하나의 요소와 다음 요소를 비교하여 정렬하는 알고리즘이다. 만약 오름차순으로 정렬할 경우, 내림차순으로 정렬된 배열을 입력할 때 가장 최악의 케이스가 된다. 이 경우 모든 요소에 비교와 스왑이 일어난다.\r\n\r\n최악의 케이스인 내림차순으로 정렬된 요소 5개가 있을 때, 아래와 같은 \u003cspan class=\"blue-400\"\u003e스왑\u003c/span\u003e작업이 이루어진다.\r\n\r\n* 패스스루 1: 총 4번의 스왑\r\n* 패스스루 2: 총 3번의 스왑\r\n* 패스스루 3: 총 2번의 스왑\r\n* 패스스루 4: 총 1번의 스왑\r\n* 패스스루 5: 스왑 없음 (정렬 완료)\r\n\r\n비교와 동일한 작업량이 발생한다. 이를 표로 정리하면 아래와 같다.\r\n\r\n|  $N$  | 작업 수 | $N^2$ |\r\n| :---: | :-----: | :---: |\r\n|   5   |   20    |  25   |\r\n|  10   |   90    |  100  |\r\n|  20   |   380   |  400  |\r\n|  40   |  1560   | 1600  |\r\n|  80   |  6320   | 6400  |\r\n|  100  |  9900   | 10000 |\r\n\r\n요소 $N$개 배열에서 버블 정렬의 최대 작업량은 $N(N - 1)$이다. 이전 장에서도 언급했 듯이, 알고리즘은 $O(N^2)$와 $O(N^2 - N)$과 크게 차이를 두지 않는다. 즉, 버블 정렬의 시간 복잡도는 $O(N^2)$가 된다.\r\n\r\n$O(N^2)$은 $O(N)$ 보다도 작업량이 급격히 증가한다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125947786-fb410c06-799f-4041-8827-9a946a8d076e.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n이를 비교하면 더욱 한눈에 알 수 있다. 이 $O(N^2)$을 \u003cspan class=\"orange-A400\"\u003e이차 시간\u003c/span\u003e이라고 명칭한다.\r\n\r\n## 4-5. 이차 문제\r\n\r\n위에서 버블 정렬에 대한 알고리즘을 설계했다. 시간 복잡도는 무려 $O(N^2)$을 가진다. 이전 장에서 선형 검색과 이진 검색을 비교하며 최대한 시간 복잡도를 줄이는게 좋다고 손아프게 적은게 무색할 정도로, 이 알고리즘의 효율은 지면을 뜷고 추락하고있다.\r\n\r\n여기 비슷한 이차 시간 알고리즘이 있다. 입력한 요소의 중복 여부를 판별하는 알고리즘이다.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 중복 확인 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/\"\u003e빅 오로 코드 속도 올리기\u003c/a\u003e\r\n * @since 2021.07.16 Fri 20:46:15\r\n */\r\npublic class DuplicateCheck\r\n{\r\n\tprivate static int count = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tboolean result = isDuplicated(array);\r\n\t\t\r\n\t\t// 중복된 요소가 있을 경우\r\n\t\tif (result)\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재합니다.\");\r\n\t\t}\r\n\t\t\r\n\t\t// 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재하지 않습니다.\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\"작업량: \");\r\n\t\twriter.write(String.valueOf(count));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소의 중복 여부 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t *\r\n\t * @return [boolean] 중복 여부\r\n\t */\r\n\tprivate static boolean isDuplicated(int[] array)\r\n\t{\r\n\t\tfor (int i = 0; i \u003c array.length; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j \u003c array.length; j++)\r\n\t\t\t{\r\n\t\t\t\tcount++;\r\n\t\t\t\t\r\n\t\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\t\tif (i != j \u0026\u0026 array[i] == array[j])\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력\r\n\r\n``` java\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` java\r\n중복된 요소가 존재하지 않습니다.\r\n작업량: 100\r\n```\r\n\r\n위 알고리즘도 마찬가지로 $N = 10$일 때 최악의 경우 $O(N^2)$의 시간 복잡도를 가진다.\r\n\r\n중복을 판별하는 핵심 동작을 보자.\r\n\r\n``` java\r\n/**\r\n * 요소의 중복 여부 반환 함수\r\n *\r\n * @param array: [int[]] 배열\r\n *\r\n * @return [boolean] 중복 여부\r\n */\r\nprivate static boolean isDuplicated(int[] array)\r\n{\r\n\tfor (int i = 0; i \u003c array.length; i++)\r\n\t{\r\n\t\tfor (int j = 0; j \u003c array.length; j++)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 서로 다른 요소가 동일한 값을 가질 경우\r\n\t\t\tif (i != j \u0026\u0026 array[i] == array[j])\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n}\r\n```\r\n\r\n버블 정렬과 마찬가지로 중첩 반복문이 존재한다. 중첩 반복문이 있을 경우, 반복문의 갯수만큼 시간 복잡도가 급격히 올라간다.\r\n\r\n중첩 반복문은 $N$개의 요소를 $N$번 만큼 작업한다. 반복문의 중첩이 심해지면 심해질 수록 $N$번의 $N$번의 $N$번의... 와 같은 작업을 반복할 것이다. 물론 시간 복잡도의 크기가 하늘 높은줄 모르고 치솟는 것도 포함된다.\r\n\r\n즉, 어디가서 중첩 반복문을 사용하는 알고리즘을 봤다면 그 알고리즘의 시간 복잡도는 최소 $O(N^2)$임을 바로 유추할 수 있다.\r\n\r\n## 4-6. 선형 해결법\r\n\r\n이전 장에서, 선형 검색과 이진 검색의 시간복잡도를 비교하며 $O(N)$이 $O(\\log N)$보다 얼마나 비효율적인지 손가락이 아플 정도로 설명했던 걸로 기억한다. 그런데 방금의 두 알고리즘은 아픈 손가락이 무색해질 정도로 미칠듯한 비효율을 선사하고 있다.\r\n\r\n\u003ci align=\"center\"\u003e아니, 니가 알고리즘을 많이 안 짜봐서 그런가본데, 그렇게 설계할 수 밖에 없는 알고리즘도 있거든??\u003c/i\u003e\r\n\r\n물론 맞는 말이다. 백준만 해도 로직이 복잡해서 중첩 반복문을 사용하기도 한다. 실무에서도 마찬가지다. 로직이 복잡하거나, 소스 최적화의 비용이 너무 높거나 혹은 효율이 극악이거나. 아니면 컴퓨터 성능이 충분히 좋아서 굳이 그렇게 머리 아픈일에 투자할 필요를 못 느낄 수도 있다.\r\n\r\n여담으로, 실제로 큰 기업은 이런 최적화 보다도 컴퓨팅 성능을 극대화시키는 방법을 많이 선택한다고 한다. 로직이야 어차피 한정적으로 적용되고, 차라리 컴퓨터 성능을 올리는게 오히려 싸게 먹히기도 한다. 로직과 달리 컴퓨팅 자원은 다른 곳에 써먹을 수도 있으니 이쪽이 더 범용적이다.\r\n\r\n필자의 컴퓨터도 작성일 기준으로 그리 못난 편은 아니지만, 안타깝게도 위에 작성한 중복 판별 알고리즘은 최적화의 비용이 매우 저렴한 편이다. 우리는 공부를 목적으로 하니 한 번 최적화해보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 향상된 중복 확인 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/16/about-algorithm-chapter04/\"\u003e빅 오로 코드 속도 올리기\u003c/a\u003e\r\n * @since 2021.07.16 Fri 21:18:05\r\n */\r\npublic class ImproveDuplicateCheck\r\n{\r\n\tprivate static int count = 0;\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"중복 확인할 정수 배열을 띄어쓰기로 구분하여 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 배열\r\n\t\tint[] array = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\r\n\t\t\r\n\t\tboolean result = isDuplicated(array);\r\n\t\t\r\n\t\t// 중복된 요소가 있을 경우\r\n\t\tif (result)\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재합니다.\");\r\n\t\t}\r\n\t\t\r\n\t\t// 없을 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"중복된 요소가 존재하지 않습니다.\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.write(\"작업량: \");\r\n\t\twriter.write(String.valueOf(count));\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소의 중복 여부 반환 함수\r\n\t *\r\n\t * @param array: [int[]] 배열\r\n\t *\r\n\t * @return [boolean] 중복 여부\r\n\t */\r\n\tprivate static boolean isDuplicated(int[] array)\r\n\t{\r\n\t\tArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e();\r\n\t\t\r\n\t\tfor (int item : array)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 중복되지 않았을 경우\r\n\t\t\tif (!list.contains(item))\r\n\t\t\t{\r\n\t\t\t\tlist.add(item);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 중복된 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력\r\n\r\n``` java\r\n0 1 2 3 4 5 6 7 8 9\r\n```\r\n\r\n* 출력\r\n\r\n``` java\r\n중복된 요소가 존재하지 않습니다.\r\n작업량: 10\r\n```\r\n\r\nJAVA의 가변 배열 `ArrayList` 클래스를 활용하여 구현했다. 요소가 한 번도 나오지 않았을 경우, `list`에 존재하지 않을 것이므로 넣어준다. 이후 동작 중에 이미 `list`에 존재하는 숫자가 발견될 경우, 중복된 요소이므로 종료하고 결과를 반환한다.\r\n\r\n$N = 10$일 때 $O(N)$의 시간 복잡도로 대폭 개선됨을 확인할 수 있다. 이전의 결과와 비교하면 무려 \u003cspan class=\"lightBlue-A400\"\u003e10배의 차이\u003c/span\u003e로, 산술적으로 이전 알고리즘이 1번 동작할 동안 개선된 알고리즘은 10번 동작할 수 있다.\r\n\r\n지금은 $N = 10$으로 요소 자체가 작아서 체감이 되지 않을 수도 있지만, $N = 10,000$일 경우 무려 \u003cspan class=\"lightBlue-A400\"\u003e10,000배의 차이\u003c/span\u003e가 발생한다.\r\n\r\n알고리즘의 최적화가 중요한 이유가 여기에 있다. 처리하는 데이터가 빅데이터에 가까워질수록 그 효율이 미친듯이 상승하기 때문.\r\n\r\n# 마무리\r\n\r\n이 장에서 배운 점을 정리하면 아래와 같다.\r\n\r\n* 반복문의 중첩 여부, 갯수를 통해 시간 복잡도를 유추할 수 있다.\r\n* 시간 복잡도를 통해 알고리즘의 성능 향상을 수치상으로 비교, 표시할 수 있다.\r\n\r\n사실 정리해놓고 보니 뭐 별 거 아닌, 당연한 얘기를 가지고 광활하게 설명했나 싶기도 하다. 난 이 당연한 걸 제대로 몰랐던 거고.\r\n\r\n이런 알고리즘도 있다. 속도가 비슷해서 빅 오 표기로는 그 차이가 보이지 않을 경우. 하지만 그럼에도 확실히 어떠한 요인으로든 차이가 발생할 것이다. 다음 장에서는 이러한 알고리즘에 대한 최적화에 대해 알아본다."},{"title":"빅 오 표기법","excerpt":"하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 문제를 해결하는 효율성의 차이 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-14T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","빅 오 표기법"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-14-about-algorithm-chapter03","content":"\r\n\u003cp class=\"orange-A400\" align=\"center\"\u003e본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.\u003c/p\u003e\r\n\r\n# 3장 빅 오 표기법\r\n\r\n하나의 문제가 있어도, 이를 해결하는 수 많은 알고리즘이 존재할 수 있다. 어떠한 방법으로든 문제를 해결할 수 있다면 그 자체로 알고리즘이라 불러도 손색이 없지만, 알고리즘이라고 해서 다 같진 않다. 바로 \u003cspan class=\"orange-A400\"\u003e문제를 해결하는 효율성의 차이\u003c/span\u003e 때문. 결과적으로 문제를 해결한다고 해도 그냥 무식하게 해결하는 알고리즘이 있는가 하면, 정말 효율적으로 문제를 해결하는 알고리즘도 있다. 그리고 우리는 통상 후자를 알고리즘이라는 명칭에 더 어울린다고 생각할 것이다.\r\n\r\n이러한 알고리즘의 성능을 하나의 규칙으로 표기한 것이 \u003cspan class=\"primary\"\u003e빅 오 표기법\u003c/span\u003e이다. 이 장에서는 알고리즘의 빅 오 표기법에 대해 설명한다.\r\n\r\n## 3-1. 빅 오: 단계 수 계산\r\n\r\n보통 알고리즘의 성능을 측정한다고 하면 소요시간을 생각하겠지만, 의외로 소요시간은 객관적인 성능 지표가 되지 못 한다. 그 이유는 컴퓨터마다 성능이 제각각이기 때문. 똑같은 게임을 구동해도 어떤 컴퓨터는 울트라옵으로 165 프레임을 뽑는다고 하면, 다른 컴퓨터는 최하옵으로도 버벅일 수 있다. \u003cspan class=\"teal-400\"\u003e동일한 작업을 수행해도 컴퓨터의 성능에 따라 그 소요시간이 천차만별\u003c/span\u003e로 달라진다.\r\n\r\n때문에 \u003cspan class=\"green-A400\"\u003e알고리즘의 성능을 측정하는 적절한 지표는 처리 단계\u003c/span\u003e라 할 수 있다. 이전 장의 \u003cspan class=\"primary\"\u003e읽기 연산\u003c/span\u003e과 \u003cspan class=\"primary\"\u003e선형 검색\u003c/span\u003e을 통해 예를 들어보자.\r\n\r\n읽기 연산의 경우, 배열이 10개가 있던 1억개가 있던 관계없이 인덱스 i의 요소를 읽는데 필요한 단계는 하나다. 반대로 선형 검색의 경우, 요소가 많아지면 많아질 수록 연산에 요구되는 단계가 늘어난다. 배열 $N$개가 있을 때, 찾는 요소가 배열 맨 끝에 있는 최악의 경우 $N$개의 단계가 필요하다.\r\n\r\n즉, 읽기 연산의 경우 언제나 한 단계만 필요하므로 $O(1)$로 표기할 수 있으머, 선형 검색의 경우 $O(N)$으로 표기할 수 있다. 이러한 표기를 \u003cspan class=\"amber-400\"\u003e시간 복잡도\u003c/span\u003e라 한다.\r\n\r\n## 3-2. 상수 시간과 선형 시간\r\n\r\n읽기 연산처럼 요소의 갯수에 상관없이 일정한 단계만을 필요로하는 연산이 있는가 하면, 선형 검색처럼 요소의 크기에 따라 단계가 가변하는 연산도 존재한다. 이전 문단에서 언급했듯이 읽기 연산의 시간 복잡도는 $O(1)$, 선형 검색의 시간 복잡도는 $O(N)$으로 표기할 수 있다. 이를 그래프로 비교하면 아래와 같다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125599099-db099ea5-e3e9-4b79-ad19-700870b07891.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n$O(N)$의 경우 우리가 흔히 접한 1차원 그래프 $y = x$와 패턴이 동일하다. 요소의 수가 1씩 증가할 수록 단계 또한 1씩 정직하게 증가한다. 이러한 패턴을 \u003cspan class=\"primary\"\u003e선형 시간\u003c/span\u003e이라고 표현한다. 그러나 $O(1)$의 경우 단계에 관계없이 일정한 상수 그래프 $y = 1$와 패턴이 동일하다. 이러한 패턴을 \u003cspan class=\"primary\"\u003e상수 시간\u003c/span\u003e이라고 표현한다.\r\n\r\n$O(1)$의 경우 조금 특이한데, 아래의 모든 그래프는 $O(1)$의 시간 복잡도를 가진다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125599889-72b5cbb9-ca20-4b19-9f49-6d363b8ebec5.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n요소의 수에 관계 없이 두 단계를 요구하면 $O(2)$, 100 단계를 요구하면 $O(100)$일 것 같지만, 빅 오 표기법은 단계가 일정할 경우 이를 크게 신경쓰지 않는다. 즉, 설령 단계가 1억개가 된다 하더라도 시간 복잡도는 $O(1)$이 된다.\r\n\r\n\u003cspan class=\"red-400\"\u003e상수 시간의 경우 기본적으로 선형 시간보다 효율적\u003c/span\u003e이라고 판단한다. 그 이유는 아래 그래프와 같다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125599827-0f58c448-9ab5-44dc-9bca-80d3ffd49d64.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n\u003csmall class=\"red-400\"\u003e※ $O(1)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.\u003c/small\u003e\r\n\r\n깊게 생각하지 않더라도, 선형적으로 증가하는 그래프는 언젠가 상수 그래프를 넘어서게 된다. 즉, 요소가 무수히 많아지는 거시적 관점으로 보면 \u003cspan class=\"red-400\"\u003e언젠가 선형 시간의 효율이 상수 시간보다 떨어지는 시점에 도달\u003c/span\u003e한다. 예제를 보면 요소가 10개 이상일 경우 선형 시간의 효율성이 점점 떨어진다.\r\n\r\n그런데 선형 시간의 경우를 생각해보자. 분명히 단계가 최대 $N$개가 소요될 수 있다는 뜻이지, 항상 $N$개가 소요된다는 것은 아니다. 예를 들어, 1부터 오름차순으로 정렬된 1억개의 배열에서 5를 검색한다고 가정하면, 필요한 단계는 5밖에 안 된다. 그럼에도 책에서는 선형 시간보다 상수 시간이 비교적 효율적이라고 설명하고 있다. 그 이유는 뭘까? 다음 문단에서 그 해답을 찾을 수 있다.\r\n\r\n## 3-3. 같은 알고리즘, 다른 시나리오\r\n\r\n선형 검색은 검색하려는 요소의 위치에 따라서 생각보다 많은 시간이 소요되지 않을 수도 있다. 최선의 경우 요소가 맨 앞에 있으므로 단계가 하나만 필요하여 $O(1)$과 동일한 시간 복잡도를 가질 수도 있다. 그러나 최악의 경우 요소가 맨 끝에 있으므로 온전히 $N$개의 단계가 필요하여 $O(N)$의 시간 복잡도를 가진다.\r\n\r\n통상 알고리즘이 어떤 데이터를 얼마나 많이 처리할지 미리 알 수 없다. $O(N)$의 시간 복잡도를 가지는 임의의 알고리즘에 최선의 케이스를 적용하여 처리하면 $O(1)$에 가깝게 동작할 것이고, 최악의 케이스를 적용하여 처리하면 $O(N)$에 가깝게 동작할 것이다. \u003cspan class=\"orange-A400\"\u003e알고리즘은 기본적으로 가장 비관적인 접근\u003c/span\u003e으로 바라본다.\r\n\r\n우리가 어떤 물건을 온라인으로 주문한다고 생각해보자. 내가 원하는 물건을 여러 업체에서 동일한 가격에 팔고 있지만, 택배 도착에 걸리는 시간이 다르다. 이는 업체의 페이지에 각각 아래와 같이 써있으며, 택배 도착은 이 시간을 절대로 벗어나지 않는다고 가정하자.\r\n\r\n* A업체: 빠르면 오늘, 늦으면 일주일 뒤\r\n* B업체: 빠르면 내일, 늦으면 3일 뒤\r\n* C업체: 빠르면 3일, 늦으면 5일 뒤\r\n\r\n우리가 3일 안으로 물건을 반드시 받아야 한다면 B업체가 가장 안전할 것이다. 물론 A업체에 주문하면 오늘 당장이라도 올 가능성이 있지만, 최악의 경우 일주일을 꼬박 기다려야 받게 될 수도 있기 때문에 3일을 넘어버릴 가능성 또한 무시할 수 없다. 빠르게 오면 단순히 좋은 정도지만, 3일을 넘어서면 안 되므로 A업체 또한 적절하지 않은 것이다. C업체는 말할 필요도 없고.\r\n\r\n알고리즘도 이러한 관점과 동일하다. $N$이 최대 100인 $O(N)$ 알고리즘이 있을 때, 성능 상의 이유로 단계가 50이 넘어가면 크래쉬를 유발할 경우 이 알고리즘은 적절하지 않다. 이와 같이 최악의 상황을 알아야 장애를 대비할 수 있다. 이러한 이유로 알고리즘의 성능은 항상 최악을 기준으로 표시한다.\r\n\r\n## 3-4 세 번째 유형의 알고리즘\r\n\r\n물론 시간 복잡도가 $O(1)$, $O(N)$만 있는 것은 아니다. 우리가 2장에서 다뤘던 이진 검색의 경우, 요소에 따라 단계가 증가하긴 하지만 $O(N)$과 같이 선형적으로 증가하지는 않는다. 즉, $O(1)$도 아니고, $O(N)$도 아닌 그 사이의 시간 복잡도를 가진다.\r\n\r\n이진 검색의 시간 복잡도는 기본적으로 $O(\\log_2N)$을 가진다. $O(1)$, $O(\\log_2N)$, $O(N)$가 요구하는 단계를 표로 표현하면 아래와 같다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125602081-0cc6075b-ba14-43c5-8aa6-52d8561559a3.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n\u003csmall class=\"red-400\"\u003e※ $O(1)$, $O(\\log N)$의 경우 값이 너무 작아 표시가 잘 안 되므로 우측의 보조축을 기준으로 표시한다.\u003c/small\u003e\r\n\r\n## 로가리즘\r\n\r\n우리가 흔히 부르는 $\\log$. 즉, 로그는 로가리즘(Logarithm)의 줄임말이다. $x^n = y$가 성립할 경우, 이를 로그로 표현하면 $\\log_xy = n$과 같다.\r\n\r\n예를 들어, $3^2 = 9$가 성립한다. 이를 로그로 표현하면 $\\log_39 =  2$가 된다. 이렇게 로그를 통해 수의 제곱수를 구할 수 있다.\r\n\r\n## $O(\\log N)$의 해석\r\n\r\n위 문단에서 로그에 대해 어느정도 이해를 했으니, $O(\\log N)$에 대해 논의해보자. 통상 수학에선 $\\log_{10}x$을 간략화하여 $\\log$로 표현했지만, 빅 오 표기법에서는 $\\log_2x$의 간략화다. \u003cspan class=\"orange-A400\"\u003e현실에선 십진법이 통용\u003c/span\u003e되지만, \u003cspan class=\"orange-A400\"\u003e컴퓨터는 이진법을 사용\u003c/span\u003e하기 때문.\r\n\r\n$O(N)$과 $O(\\log N)$를 비교하면 아래와 같다.\r\n\r\n|    $N$    |  $O(N)$   | $O(\\log N)$ |\r\n| :-------: | :-------: | :---------: |\r\n|     2     |     2     |      1      |\r\n|     4     |     4     |      2      |\r\n|     8     |     8     |      3      |\r\n|    16     |    16     |      4      |\r\n|    32     |    32     |      5      |\r\n|    64     |    64     |      6      |\r\n|    128    |    128    |      7      |\r\n|    256    |    256    |      8      |\r\n|    512    |    512    |      9      |\r\n|   1024    |   1024    |     10      |\r\n| $2^{100}$ | $2^{100}$ |     100     |\r\n\r\n$O(N)$는 $N$이 증가함에 따라 정직하게 같이 증가하지만, $O(\\log N)$은 $N$이 정확히 두 배가 될 때 1씩 증가한다.\r\n\r\n여담으로, 천문학같은 거시세계에서 로그가 중요한 이유가 위 표만으로도 쉽게 확인할 수 있다. $2^{100}$은 126,7650,6002,2822,9401,4967,0320,5376이다. 약 100양에 육박하는 수치로, 양은 수의 단위인 조를 아득히 뛰어넘는 단위다.\r\n\r\n\u003e 거시적 수의 단위  \r\n\u003e 일반적으로 사람이 접할 수 있는 의미 있는 단위는 조 단위로, 1억씩 천 번을 모아야 만들어지는 수치다.  \r\n\u003e 조 단위 뒤로는 경, 해, 자, 양 순으로 나열되며, 현실에서 경 이후로는 그 수의 크기를 논하는게 의미가 없는 정도\r\n\r\n현실세계와 달리 수학이나 천문학과 같은 경우 우리에게 의미가 없을 정도로 큰 수를 다루기도 하는데, 이를 로그로 표현하면 이를 효과적으로 다룰 수 있다.\r\n\r\n## 3-7. 실제 예제\r\n\r\n지금까지 기술한 내용을 토대로 실제 코드에 적용해보자. 4개의 요소를 가진 배열이 있고, 배열의 값을 하나씩 출력하는 알고리즘이 있다고 가정해보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\"\u003e빅 오 표기법\u003c/a\u003e\r\n * @since 2021.07.14 Wed 17:40:00\r\n */\r\npublic class BigO\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 배열\r\n\t\tString[] things = { \"apples\", \"baboons\", \"cribs\", \"delcimers\" };\r\n\t\t\r\n\t\t// 배열마다 하나씩 순회\r\n\t\tfor (String thing : things)\r\n\t\t{\r\n\t\t\tStringBuilder builder = new StringBuilder();\r\n\t\t\tbuilder.append(\"Here's a thing: \");\r\n\t\t\tbuilder.append(thing);\r\n\t\t\t\r\n\t\t\twriter.write(builder.toString());\r\n\t\t\twriter.newLine();\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHere's a thing: apples\r\nHere's a thing: baboons\r\nHere's a thing: cribs\r\nHere's a thing: delcimers\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n요소마다 하나씩 읽어 요소의 내용을 출력한다. 즉, \u003cspan class=\"blue-400\"\u003e요소가 많아지면 많아질 수록 같이 선형적으로 증가\u003c/span\u003e하므로, 이 알고리즘의 시간 복잡도는 $O(N)$으로 표현할 수 있다.\r\n\r\n반대로 가장 기본적인 문자열 하나를 출력하는 알고리즘을 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 빅 오 표기 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\"\u003e빅 오 표기법\u003c/a\u003e\r\n * @since 2021.07.14 Wed 17:56:49\r\n */\r\npublic class BigO2\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"Hello world!\");\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n``` tc\r\nHello world!\r\n```\r\n\r\n결과는 위와 같다.\r\n\r\n알고리즘이라 부르기는 조금 뭐하지만, 어쨌든 이 알고리즘을 수행하는 데 \u003cspan class=\"blue-400\"\u003e필요한 단계는 무조건 하나\u003c/span\u003e다. 즉 시간 복잡도는 $O(1)$이다.\r\n\r\n좀 더 실속있는 예제를 살펴보자.\r\n\r\n``` java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 소수 판별 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter03/\"\u003e빅 오 표기법\u003c/a\u003e\r\n * @since 2021.07.14 Wed 18:01:20\r\n */\r\npublic class CheckPrime\r\n{\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\twriter.write(\"소수를 판별할 값 입력 \u003e\u003e \");\r\n\t\twriter.flush();\r\n\t\t\r\n\t\t// 입력값\r\n\t\tint target = Integer.parseInt(reader.readLine());\r\n\t\t\r\n\t\t// 소수일 경우\r\n\t\tif (isPrime(target))\r\n\t\t{\r\n\t\t\twriter.write(\"소수로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\t// 아닐 경우\r\n\t\telse\r\n\t\t{\r\n\t\t\twriter.write(\"소수가 아닌 것으로 판별됨\");\r\n\t\t}\r\n\t\t\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\t\r\n\t\twriter.close();\r\n\t\treader.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 소수 여부 반환 함수\r\n\t *\r\n\t * @param num: [int] 대상 값\r\n\t *\r\n\t * @return [boolean] 소수 여부\r\n\t */\r\n\tprivate static boolean isPrime(int num)\r\n\t{\r\n\t\tfor (int i = 2; i \u003c num; i++)\r\n\t\t{\r\n\t\t\t// 나누어 떨어지는 수가 있을 경우\r\n\t\t\tif (num % i == 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\n소스는 위와 같다.\r\n\r\n* 입력값\r\n\r\n``` tc\r\n156842101\r\n```\r\n\r\n* 출력값\r\n\r\n``` tc\r\n소수가 아닌 것으로 판별됨\r\n```\r\n\r\n이 소스는 임의의 값을 입력받아 소수인지 아닌지를 판별하는 알고리즘이다. 이 알고리즘을 통해 156842101은 소수가 아님을 쉽게 알 수 있다.\r\n\r\n해당 알고리즘은 가장 작은 소수인 2부터 입력값 `target`까지 하나씩 증가시킨 값을 `target`과 나눠서 정확히 나눠떨어지는지 아닌지를 통해 소수를 판별하는 매우 기초적인 알고리즘이다.\r\n\r\n최악의 케이스는 판별값이 소수일 경우로,  2부터 `target - 1`까지의 작업 전체를 요구하므로 총 `target - 2`의 작업이 발생한다. $N = target$일 때, -2는 그렇게 의미있는 값이 아니므로 위 알고리즘의 시간 복잡도는 $O(N)$으로 봐도 무방하다.\r\n\r\n# 마무리\r\n\r\n알고리즘을 정석적으로 공부하지 않아서, 빅 오 표기법과 같은 시간 복잡도를 제대로 이해하지 않았었다. 시간 복잡도의 개념과 그 계산 방식을 알 수 있었던 매우 의미있는 장이였다.\r\n\r\n다음 장에선 이 빅 오 표기법을 활용하여 알고리즘을 개선하는 방법에 대해 설명한다."},{"title":"알고리즘이 중요한 까닭","excerpt":"IT영역에서의 알고리즘이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. 개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구된다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T04:21:37","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열","정렬","이진 검색"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-10-about-algorithm-chapter02","content":"\r\n\u003cp class=\"orange-A400\" align=\"center\"\u003e본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.\u003c/p\u003e\r\n\r\n# 2장 알고리즘이 중요한 까닭\r\n\r\nIT영역에서의 \u003cspan class=\"primary\"\u003e알고리즘\u003c/span\u003e이란, 어떤 문제를 해결하는 방법을 형상화한 코드를 의미한다. 알고리즘을 잘 설계한다면, 단순한 로직으로 접근할 때보다 훨씬 빠르게 문제를 처리할 수 있다. \u003cspan class=\"teal-400\"\u003e개발에는 정말 다양한 문제와 그보다 더욱 다양한 해결방법이 존재하기 때문에, 복잡한 문제일수록 정교한 알고리즘의 설계가 요구\u003c/span\u003e된다.\r\n\r\n이러한 특징으로 알고리즘은 뛰어난 문제 해결력과 수학적 사고 능력을 요한다. 때문에 많은 사람들이 어려워하는 분야 중 하나지만, 그 강력함과 효율로 인해 개발 역량의 척도를 확인하는데 사용하기도 한다. 흔히 기업에서 보는 \u003cspan class=\"teal-400\"\u003e코딩 테스트\u003c/span\u003e가 좋은 예시다.\r\n\r\n이 장에서는 \u003cspan class=\"primary\"\u003e알고리즘\u003c/span\u003e을 통해 검색 연산을 더욱 효과적으로 개선하는 방법에 대해 설명한다. 이전 장에서 언급했듯이, 검색 연산은 무수히 많은 읽기 연산의 모음이나 다름없다. 알고리즘이 어떻게 읽기 연산을 최적화시키는지 알아보자.\r\n\r\n## 2-1. 정렬된 배열\r\n\r\n\u003cspan class=\"primary\"\u003e정렬된 배열\u003c/span\u003e이란, 기존의 배열에서 요소들이 특정 조건으로 정렬된 배열을 의미한다. 정렬된 배열은 그 요소들이 항상 정해진 조건에 따라 순서대로 배치된다. 이는 삽입을 할 때도 동일하다. 정렬된 배열이 항상 정렬된 상태를 유지하기 위해선 \u003cspan class=\"red-A400\"\u003e삽입 시에도 요소의 정렬에 따라 정렬을 훼손하지 않는 올바른 자리에 삽입\u003c/span\u003e되어야 한다.\r\n\r\n기존의 배열이라면 배열의 크기가 허락하는 한, 원하는 위치 어디에서나 삽입이 가능하다. 배열에 55를 삽입할 때, 일반적인 배열은 아래처럼 삽입에 제한이 없다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144062-a3b6c280-e157-11eb-88d6-20689d8f05b1.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n하지만 정렬된 배열이라면 어떨까? 이번엔 배열이 오름차순으로 정렬된 배열이라고 가정해보자.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144070-aa453a00-e157-11eb-9390-1550623a57bd.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n정렬된 위 배열에서 55를 삽입한다면 어떨까?\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144072-aca79400-e157-11eb-8939-cc0beb583b9b.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n반드시 44와 94의 사이에 삽입되어야 오름차순 정렬을 유지할 수 있다. 그렇다면 우리는 여기서 정렬된 배열의 삽입은 기존의 삽입 연산에 비해 로직이 추가됨을 유추할 수 있다. 원리는 간단하다. 요소를 순차적으로 읽어서 55보다 큰 수가 나올 때까지 반복한다. 배열이 정렬되어 있으므로, 55보다 큰 수를 만나게 되면 이전의 요소는 모두 55보다 작을 것이다. 이 위치를 기준으로 삽입을 진행하면 된다.\r\n\r\n\u003cp align=\"center\"\u003e\r\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125144075-ae715780-e157-11eb-92ed-71ee06140c5f.png\" width=\"600px\" /\u003e\r\n\u003c/p\u003e\r\n\r\n위 그림과 같이 순차적으로 요소를 검색하여 55보다 큰 요소를 찾는다. 94는 배열에서 55보다 큰 가장 작은 수다.\r\n\r\n94의 인덱스인 4번째 요소에 55를 삽입하고, 94를 한 칸 뒤로 미룬다. 이 과정을 통해 정렬된 배열의 연산을 수행할 수 있다.\r\n\r\n그렇다면 이 고생을 뭐하러 사서하는 것일까? 그 이유는 검색의 최적화에 있다. \u003cspan class=\"orange-A400\"\u003e정렬된 배열은 그 자체로 순서라는 규칙성을 지니기 때문에 이를 활용한 알고리즘 적용이 가능\u003c/span\u003e하기 때문이다. 이를 통해 검색의 작업량을 효과적으로 줄여 더욱 빠른 검색이 가능하다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 정렬된 배열 삽입 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 02:41:14\r\n */\r\npublic class SortedArrayInsert\r\n{\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = { 6, 9, 14, 43, 94, -1, -1, -1, -1, -1 };\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 삽입할 요소\r\n\t\tint item = 55;\r\n\t\t\r\n\t\tint result = run(item);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(result);\r\n\t\tbuilder.append(\"번 째 인덱스에 \");\r\n\t\tbuilder.append(item);\r\n\t\tbuilder.append(\" 삽입: \");\r\n\t\tbuilder.append(Arrays.toString(ARRAY));\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 집합 배열 삽입 및 삽입된 인덱스 반환 함수\r\n\t *\r\n\t * @param item: [int] 삽입할 요소\r\n\t *\r\n\t * @return [int] 삽입된 인덱스\r\n\t */\r\n\tprivate static int run(int item)\r\n\t{\r\n\t\tint result = find(item);\r\n\t\t\r\n\t\tinsert(result, item);\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자보다 배열의 값이 클 경우\r\n\t\t\tif (target \u003c ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 삽입 함수\r\n\t *\r\n\t * @param index: [int] 삽입 위치\r\n\t * @param item: [int] 삽입할 요소\r\n\t */\r\n\t@SuppressWarnings(\"ManualArrayCopy\")\r\n\tprivate static void insert(int index, int item)\r\n\t{\r\n\t\t// 배열의 값이 -1(빈 요소)가 아닐 경우\r\n\t\tif (ARRAY[index] != -1)\r\n\t\t{\r\n\t\t\tfor (int i = ARRAY.length - 1; i \u003e index; i--)\r\n\t\t\t{\r\n\t\t\t\tARRAY[i] = ARRAY[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tARRAY[index] = item;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n4번 째 인덱스에 55 삽입: [6, 9, 14, 43, 55, 94, -1, -1, -1, -1]\r\n```\r\n\r\n`insert` 함수는 이전 장에 나왔던 함수와 동일하지만, `find`의 경우 조금 달라졌다. `target == ARRAY[i]`로 동일한 값을 찾는 것이 아니라, `target \u003c ARRAY[i]`로 삽입할 요소보다 큰 값을 찾도록 변경됐다. `run` 함수는 이를 적절히 구동하여 삽입된 인덱스를 반환한다.\r\n\r\n\u003e **JAVA의 정렬 함수**  \r\n\u003e 자바는 `Arrays.sort()`라는 함수가 제공되며, 인수로 정렬할 배열을 전달한다. 기본적으로 오름차순으로 정렬되며, 본인이 직접 정렬 함수를 오버라이딩함으로써 자신만의 조건으로 정렬되도록 설계할 수도 있다.\r\n\r\n## 2-3. 이진 검색\r\n\r\n우리가 앞에서 배열을 정렬한 이유가 바로 이 것이다. \u003cspan class=\"primary\"\u003e이진 검색\u003c/span\u003e이라는 알고리즘을 적용하면 검색의 속도를 상당부분 개선할 수 있다. 심지어 이진 검색은 알고리즘 축에서는 매우 쉬운 편에 속한다. 심지어 우리는 이미 다른 형태로 이진 검색이라는 알고리즘을 접한 적이 있다.\r\n\r\n어렸을 때나, 혹은 술자리에서 Up \u0026 Down이라는 게임을 해본적이 있을 것이다. 진행자가 임의의 구간에 해당하는 임의의 수 하나를 머릿속으로 생각하면, 참가자들이 이 수를 맞추는 것이다. 참가자가 수를 말하면 진행자는 그 수가 자신의 수보다 큰 지, 작은 지 알려준다. 이걸 누군가 맞출 때까지 반복한다. 이진 검색의 원리는 이와 정확히 일치한다.\r\n\r\n\u003cspan class=\"red-A400\"\u003e이진 검색은 그 특성 상 정렬된 배열에서만 가능\u003c/span\u003e하다. 1 ~ 100의 구간으로 순차적으로 정렬된 배열이 있다고 가정해보자. 찾아야 할 수가 68일 때, 이진 검색은 아래와 같이 이루어진다.\r\n\r\n1. 1과 100의 중간인 50과 비교한다. (작업 +1)\r\n2. 50은 68보다 작으로 51 ~ 100의 구간을 검색한다.\r\n3. 51과 100의 중간인 75와 비교한다. (작업 +1)\r\n4. 75는 68보다 크므로 51 ~ 74의 구간을 검색한다.\r\n5. 51과 74의 중간인 62와 비교한다. (작업 +1)\r\n6. 62는 68보다 작으므로 63 ~ 74의 구간을 검색한다.\r\n7. 63과 74의 중간인 68과 비교한다. (작업 +1)\r\n8. 검색이 종료된다.\r\n\r\n만약 순차적으로 검색했다면 1 부터 68까지 총 68번의 작업이 발생할 것을 단 4번의 작업으로 검색을 완료했다. 간단한 알고리즘을 적용하는 것으로도 작업량이 17배 줄어든 것이다. 지금은 구간이 작지만, 구간의 끝이 만 단위가 넘어간다면 검색하려는 숫자의 위치에 따라 작업량이 기하급수적으로 감소한다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target \u003e mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색을 구현한 소스는 위와 같다. 눈여겨 볼 부분은 `binarySearch` 함수다. 시작값 `start`는 1로 초기화되고, 끝값 `max`는 배열의 크기와 동일하다.\r\n\r\n`mid`를 계산하여 `target`과 크기비교를 한다. `target`이 더 클 경우, 중간값을 기준으로 윗 구간이므로 `start`를 `mid + 1`로 보정한다. 반대로 `target`이 더 작을 경우, 중간값을 기준으로 아랫 구간이므로 `end`를 `mid - 1`로 보정한다. 검색 대상값인 `target`과 중간값 `mid`가 동일할 때까지 알고리즘을 반복한다.\r\n\r\n1 ~ 100까지 차례대로 배치되어 있으므로, 1은 `ARRAY[0]`, 43은 `ARRAY[42]`로 값 자체로 인덱스나 다름없기 때문에 인덱스는 따로 구하지 않는다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 이진 검색 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 03:24:26\r\n */\r\npublic class BinarySearch\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 68;\r\n\t\t\r\n\t\tint result = binarySearch(target);\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 필요한 프로세스: \");\r\n\t\tbuilder.append(result);\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target \u003e mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n}\r\n```\r\n\r\n이진 검색의 단점이 있는데, 1 ~ 100의 구간이 있다고 가정하면, 1이나 100과 같은 \u003cspan class=\"orange-A400\"\u003e구간의 시작과 끝을 검색하는데 시간이 매우 오래 걸린다.\u003c/span\u003e 이는 이진 검색이 중간값을 기준으로 검색한다는 특징으로 인한 단점이다. 위의 소스는 구간의 시작과 끝도 비교함으로써 이진 검색을 강화한 소스다.\r\n\r\n``` java\r\n// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\nif (target == start || target == end)\r\n{\r\n\tbreak;\r\n}\r\n```\r\n\r\n눈여겨 볼 부분은 `binarySearch` 함수의 해당 부분이다. 기존에 없던 `start`와 `end`의 비교 로직이 추가되어, \u003cspan class=\"orange-A400\"\u003e구간의 시작과 끝이 목표일 경우 더욱 빠르게 검색\u003c/span\u003e할 수 있도록 보정한 것이다.\r\n\r\n| 구분  | 보정 전 | 보정 후 |\r\n| :---: | :-----: | :-----: |\r\n|   1   |    6    |    1    |\r\n|  51   |    6    |    2    |\r\n|  100  |    7    |    1    |\r\n\r\n## 2-4. 이진 검색 대 선형 검색\r\n\r\n1부터 순차적으로 하나하나 검색하는 알고리즘을 \u003cspan class=\"primary\"\u003e선형 검색\u003c/span\u003e, 구간의 중간값을 기준으로 검색하는 알고리즘을 \u003cspan class=\"primary\"\u003e이진 검색\u003c/span\u003e이라 한다. 우리가 2장까지 진행하면서, 배열의 일반적인 검색과 이진 검색에 대해 설계하고 차이점을 비교했다.\r\n\r\n선형 검색의 경우 요소의 갯수 $N$이 늘어나면 늘어날수록 예상되는 최대 작업량도 $N$개로 비례하여 늘어난다. 이에 비해 이진 검색의 경우 $N = 10,000$일 때, 책에 의하면 최대 작업량이 13이라고 한다. $N = 1,000,000$이면 작업량은 20으로, 선형 검색의 작업량이 1,000,000임을 감안하면 \u003cspan class=\"green-A400\"\u003e데이터가 많아질 수록 이진 검색으로 절약할 수 있는 기대 비용이 더욱 큼\u003c/span\u003e을 알 수 있다.\r\n\r\n``` java\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\n\r\n/**\r\n * 누구나 자료 구조와 알고리즘 검색 퍼포먼스 비교 클래스\r\n *\r\n * @author RWB\r\n * @see \u003ca href=\"https://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter02/\"\u003e알고리즘이 중요한 까닭\u003c/a\u003e\r\n * @since 2021.07.10 Sat 04:21:37\r\n */\r\npublic class SearchCompare\r\n{\r\n\t// 배열 최대 크기\r\n\tprivate static final int MAX = 100000000;\r\n\t\r\n\t// 배열\r\n\tprivate static final int[] ARRAY = initArray(MAX);\r\n\t\r\n\t/**\r\n\t * 메인 함수\r\n\t *\r\n\t * @param args: [String[]] 매개변수\r\n\t *\r\n\t * @throws IOException 데이터 입출력 예외\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException\r\n\t{\r\n\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\r\n\t\t\r\n\t\t// 검색 대상\r\n\t\tint target = 86421478;\r\n\t\t\r\n\t\tlong tic = System.nanoTime();\r\n\t\t\r\n\t\tint linearResult = find(target);\r\n\t\t\r\n\t\tlong toc1 = System.nanoTime() - tic;\r\n\t\t\r\n\t\ttic = System.nanoTime();\r\n\t\t\r\n\t\tint binaryResult = binarySearch(target);\r\n\t\t\r\n\t\tlong toc2 = System.nanoTime() - tic;\r\n\t\t\r\n\t\tStringBuilder builder = new StringBuilder();\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 선형 검색 프로세스: \");\r\n\t\tbuilder.append(linearResult);\r\n\t\tbuilder.append(\"(\").append(toc1).append(\"ns)\\n\");\r\n\t\tbuilder.append(target);\r\n\t\tbuilder.append(\"을 탐색하는데 소요된 이진 검색 프로세스: \");\r\n\t\tbuilder.append(binaryResult);\r\n\t\tbuilder.append(\"(\").append(toc2).append(\"ns)\\n\\n\");\r\n\t\tbuilder.append(\"이진 검색이 약 \").append(toc1 / toc2).append(\"배 더 빠릅니다.\");\r\n\t\t\r\n\t\twriter.write(builder.toString());\r\n\t\twriter.newLine();\r\n\t\twriter.flush();\r\n\t\twriter.close();\r\n\t}\r\n\t\r\n\t/**\r\n\t * 배열 초기화 함수\r\n\t *\r\n\t * @param max: [int] 배열 최대 크기\r\n\t *\r\n\t * @return [int[]] 1 ~ max가 할당된 정수 배열\r\n\t */\r\n\tprivate static int[] initArray(int max)\r\n\t{\r\n\t\tint[] temp = new int[max];\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c max; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = i + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn temp;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 이진 검색 및 프로세스 소요량 반환 함수\r\n\t *\r\n\t * @param target: [int] 검색 대상\r\n\t *\r\n\t * @return [int] 프로세스 소요량\r\n\t */\r\n\tprivate static int binarySearch(int target)\r\n\t{\r\n\t\t// 프로세스 소요량\r\n\t\tint count = 0;\r\n\t\t\r\n\t\t// 중간값\r\n\t\tint mid = -1;\r\n\t\t\r\n\t\t// 구간 시작값\r\n\t\tint start = 1;\r\n\t\t\r\n\t\t// 구간 끝값\r\n\t\tint end = ARRAY.length;\r\n\t\t\r\n\t\twhile (target != mid)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\t\r\n\t\t\t// 목표가 시간 구간 혹은 끝 구간과 일치할 경우\r\n\t\t\tif (target == start || target == end)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmid = (end + start) / 2;\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 클 경우\r\n\t\t\tif (target \u003e mid)\r\n\t\t\t{\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 목표가 중간값보다 작거나 같을 경우\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 요소 검색 및 인덱스 반환 함수\r\n\t *\r\n\t * @param target: [int] 목표 숫자\r\n\t *\r\n\t * @return [int] 인덱스\r\n\t */\r\n\tprivate static int find(int target)\r\n\t{\r\n\t\t// 인덱스\r\n\t\tint result = -1;\r\n\t\t\r\n\t\tfor (int i = 0; i \u003c ARRAY.length; i++)\r\n\t\t{\r\n\t\t\t// 목표 숫자와 배열의 값이 일치할 경우\r\n\t\t\tif (target == ARRAY[i])\r\n\t\t\t{\r\n\t\t\t\tresult = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n``` tc\r\n86421478을 탐색하는데 소요된 선형 검색 프로세스: 86421477(26936600ns)\r\n86421478을 탐색하는데 소요된 이진 검색 프로세스: 26(5100ns)\r\n\r\n이진 검색이 약 5281배 더 빠릅니다.\r\n```\r\n\r\n위 소스는 선형 검색과 이진 검색을 통합해 퍼포먼스를 비교할 수 있는 소스다. 100,000,000(1억)의 구간에서 임의의 수 `target`을 검색한다. 해당 소스에서는 86,421,478으로 지정했다.\r\n\r\n|    구분     | 선형 검색  | 이진 검색 |    차이    |\r\n| :---------: | :--------: | :-------: | :--------: |\r\n| 프로세스 수 | 86,421,477 |    26     |     -      |\r\n|  테스트 1   | $2.442ms$  |  $5.2us$  | 약 4,699배 |\r\n|  테스트 2   | $2.463ms$  |  $5.3us$  | 약 4,648배 |\r\n|  테스트 3   | $2.434ms$  |  $5.5us$  | 약 4,424배 |\r\n|  테스트 4   | $2.536ms$  |  $5.3us$  | 약 4,785배 |\r\n|  테스트 5   | $2.383ms$  |   $5us$   | 약 4,766배 |\r\n|  테스트 6   | $2.509ms$  |  $5.1us$  | 약 4,919배 |\r\n|  테스트 7   | $2.487ms$  |  $5.4us$  | 약 4,605배 |\r\n|  테스트 8   | $2.394ms$  |  $4.5us$  | 약 5,320배 |\r\n|  테스트 9   | $2.666ms$  |  $5.3us$  | 약 5,030배 |\r\n|  테스트 10  | $2.352ms$  |  $5.3us$  | 약 4,438배 |\r\n\r\n\u003csmall class=\"red-400\"\u003e※ 위 테스트는 CPU i7-10700K, RAM 32GB에서 테스트한 결과물로, 구동 환경에 따라 연산 결과가 달라질 수 있음\u003c/small\u003e\r\n\r\n이진검색이 선형검색에 비해 약 5000배 까지도 차이가 남을 확인할 수 있다. 단위가 $ms$, $us$니까 사람 입장에선 그게 그거지만, 기계 입장에선 이진 검색으로 5000번 수행할 동안 선형 검색은 한 번 수행하는 셈이니 실로 어마어마한 차이다.\r\n\r\n# 마무리\r\n\r\n이 장에서는 알고리즘을 적용한 이진 검색을 구현하고 이를 기존의 선형 검색과 비교함으로써 알고리즘의 강력함을 체감할 수 있었다.\r\n\r\n현업에서 일하면서 알고리즘이 강력하다는 건 알고있었지만, 이렇게 간단하게 구현해서 직접 비교해보니 역시나 알고리즘이 중요한 이유를 알 것 같다.\r\n\r\n원래 오늘같이 내일 쉬는 날이면 새벽 네 다섯시까지 공부하긴 하는데, 포스팅 때문에 풀타임으로 집중하다 보니 유난히 더 피곤하다...."}],"post":{"title":"자료구조가 중요한 까닭","excerpt":"혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다. 마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.","coverImage":"https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png","date":"2021-07-10T01:30:56","type":"posts","category":"알고리즘","tag":["자료구조","알고리즘","누구나 자료 구조와 알고리즘","배열"],"group":"누구나 자료 구조와 알고리즘","comment":true,"publish":true,"slug":"2021-07-10-about-algorithm-chapter01","content":"\u003cnav class=\"toc-wrap\"\u003e\u003col class=\"toc-level toc-level-1\"\u003e\u003cli class=\"toc-item toc-item-h1\"\u003e\u003ca class=\"toc-link toc-link-h1\" href=\"#개요\"\u003e개요\u003c/a\u003e\u003c/li\u003e\u003cli class=\"toc-item toc-item-h1\"\u003e\u003ca class=\"toc-link toc-link-h1\" href=\"#1장-자료-구조가-중요한-까닭\"\u003e1장 자료 구조가 중요한 까닭\u003c/a\u003e\u003col class=\"toc-level toc-level-2\"\u003e\u003cli class=\"toc-item toc-item-h2\"\u003e\u003ca class=\"toc-link toc-link-h2\" href=\"#1-1-배열-기초-자료-구조\"\u003e1-1. 배열: 기초 자료 구조\u003c/a\u003e\u003c/li\u003e\u003cli class=\"toc-item toc-item-h2\"\u003e\u003ca class=\"toc-link toc-link-h2\" href=\"#1-2-읽기\"\u003e1-2 읽기\u003c/a\u003e\u003c/li\u003e\u003cli class=\"toc-item toc-item-h2\"\u003e\u003ca class=\"toc-link toc-link-h2\" href=\"#1-3-검색\"\u003e1-3. 검색\u003c/a\u003e\u003c/li\u003e\u003cli class=\"toc-item toc-item-h2\"\u003e\u003ca class=\"toc-link toc-link-h2\" href=\"#1-4-삽입\"\u003e1-4. 삽입\u003c/a\u003e\u003c/li\u003e\u003cli class=\"toc-item toc-item-h2\"\u003e\u003ca class=\"toc-link toc-link-h2\" href=\"#1-5-삭제\"\u003e1-5. 삭제\u003c/a\u003e\u003c/li\u003e\u003cli class=\"toc-item toc-item-h2\"\u003e\u003ca class=\"toc-link toc-link-h2\" href=\"#1-6-집합-단-하나의-규칙이-효율성을-바꾼다\"\u003e1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli class=\"toc-item toc-item-h1\"\u003e\u003ca class=\"toc-link toc-link-h1\" href=\"#마무리\"\u003e마무리\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/nav\u003e\u003cp class=\"orange-A400\" align=\"center\"\u003e본 포스팅은 개인 스터디 모임 활동의 일환으로, \"누구나 자료구조와 알고리즘\" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.\u003c/p\u003e\n\u003ch1 id=\"개요\"\u003e\u003ca class=\"head-link\" href=\"#개요\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e개요\u003c/h1\u003e\n\u003cp\u003e혼자 공부하는건 다 좋은데 효율이 떨어진다. 컴퓨터 앞에 앉아있는 시간은 거의 대부분이라 할 수 있지만, 순수하게 공부하는 시간이 얼마나 되냐고 물어보면 눈치보기 바쁘다.\u003c/p\u003e\n\u003cp\u003e마침 블로그도 새로 개발해서 쓰고 있고, 공부도 할 겸 적절한 스터디에 하나 참가했다. 노트북 팔아버린 뒤로 스터디에 가입하고 싶어도 할 수가 없었던 차에, 노트북 없이도 할 수 있다는 말에 바로 들어갔다.\u003c/p\u003e\n\u003cp\u003e비전공자가 자료구조같은 기초지식이 항상 아킬레스건이였다. 특히 백준 풀 때 뼈저리게 느끼지만. 이 스터디가 끝나면 자료구조에 대해 기초정도는 알 수 있었음 한다.\u003c/p\u003e\n\u003cp\u003e언어는 가급적 \u003cspan class=\"orange-400\"\u003eJAVA\u003c/span\u003e로 진행한다.\u003c/p\u003e\n\u003ch1 id=\"1장-자료-구조가-중요한-까닭\"\u003e\u003ca class=\"head-link\" href=\"#1장-자료-구조가-중요한-까닭\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e1장 자료 구조가 중요한 까닭\u003c/h1\u003e\n\u003cp\u003e이 장에서는 배열의 기초와 그에 해당하는 연산들에 대한 내용을 소개하면서 사용자에게 배열에 관한 러프한 개념을 설명해준다.\u003c/p\u003e\n\u003cp\u003e배열과 \u003cspan class=\"primary\"\u003e집합\u003c/span\u003e이라는 개념에 대한 내용을 기술한다. 저자에 의하면 챕터가 진행될 수록 연산 성능에 대한 점진적인 비교를 한다고 하니, 알고리즘 적용에 따른 성능 향상의 차이를 확인해 볼 수 있을 것이다.\u003c/p\u003e\n\u003ch2 id=\"1-1-배열-기초-자료-구조\"\u003e\u003ca class=\"head-link\" href=\"#1-1-배열-기초-자료-구조\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e1-1. 배열: 기초 자료 구조\u003c/h2\u003e\n\u003cp\u003e\u003cspan class=\"primary\"\u003e배열\u003c/span\u003e은 거의 모든 언어에 존재하는 매우 기초적인 자료구조다.\u003c/p\u003e\n\u003cp\u003eJAVA에는 \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eboolean\u003c/code\u003e과 같은 \u003cspan class=\"green-A400\"\u003e기본형 타입(Primitive Type)\u003c/span\u003e과 \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eHashMap\u003c/code\u003e과 같은 \u003cspan class=\"green-A400\"\u003e참조형 타입(Reference Type)\u003c/span\u003e으로 구분된다.\u003c/p\u003e\n\u003cp\u003e이와 같은 데이터들은 각각 단일로 사용할 수도 있지만, 다수의 데이터를 동시에 다뤄야하는 경우가 심심치않게 발생한다. 이러한 데이터들이 모여 하나의 배열이 될 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e 데이터가 모여 \u003ccode\u003eString[]\u003c/code\u003e이라는 \u003cspan class=\"primary\"\u003e문자열 배열\u003c/span\u003e이 되며, \u003ccode\u003eint\u003c/code\u003e 데이터가 모여 \u003ccode\u003eint[]\u003c/code\u003e라는 \u003cspan class=\"primary\"\u003e정수 배열\u003c/span\u003e이 된다.\u003c/p\u003e\n\u003cp\u003eJAVA에서의 배열은 이처럼 특정한 데이터가 여러개 모인 자료 구조이며, 반드시 \u003cspan class=\"red-A400\"\u003e지정된 데이터만을 요소로 받아들일 수 있다.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eboolean\u003c/code\u003e은 \u003ccode\u003etrue\u003c/code\u003e, \u003ccode\u003efalse\u003c/code\u003e로 이루어진 데이터 형식이다. \u003ccode\u003eboolean[]\u003c/code\u003e은 \u003ccode\u003eboolean\u003c/code\u003e 데이터가 여러개 모인 배열이며, 이렇게 선언된 배열은 \u003ccode\u003eboolean\u003c/code\u003e에 해당하는 \u003ccode\u003etrue\u003c/code\u003e, \u003ccode\u003efalse\u003c/code\u003e만 받아들일 수 있다. 즉, 1이나 \"A\"와 같은 문자열은 배열에 삽입할 수 없다.\u003c/p\u003e\n\u003cp\u003e또한 \u003cspan class=\"red-A400\"\u003e배열은 고정 길이를 가진다.\u003c/span\u003e 한 번 할당된 배열의 길이는 재할당되지 않는 이상 절대로 길이가 변경되지 않는다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e⚠잠깐! 이건 어디까지나 JAVA 얘기에요!\u003c/strong\u003e\u003cbr\u003e\n지금 설명하는 배열의 특징은 JAVA에 국한되는 예시다. 당장 JavaScript만 봐도, 배열에 별다른 제약이 존재하지 않는다. 길이는 필요에 따라 증축할 수 있으며, 요소에 아무 데이터 타입이나 할당 가능하다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eJAVA에서 배열은 \u003cspan class=\"green-A400\"\u003e참조형 타입(Reference Type)\u003c/span\u003e에 해당한다.\u003c/p\u003e\n\u003cp\u003e배열에서 수행 가능한 연산에는 4가지가 존재한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e읽기\u003c/li\u003e\n\u003cli\u003e검색\u003c/li\u003e\n\u003cli\u003e삽입\u003c/li\u003e\n\u003cli\u003e삭제\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 4가지 연산은 배열의 가장 기초적인 연산이다. 이 4가지 연산을 JAVA로 직접 구현하며 어떤 단계를 거치는지 확인해보자.\u003c/p\u003e\n\u003ch2 id=\"1-2-읽기\"\u003e\u003ca class=\"head-link\" href=\"#1-2-읽기\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e1-2 읽기\u003c/h2\u003e\n\u003cp\u003e\u003cspan class=\"primary\"\u003e읽기\u003c/span\u003e연산은 배열의 특정 인덱스에 어떠한 값이 있는지 읽는 연산이다.\u003c/p\u003e\n\u003cp\u003e대부분 모든 언어의 런타임에서 할당되는 데이터들은 메모리에 기록된다. 많은 양의 데이터가 할당될수록 프로그램이 요구하는 메모리, 즉 RAM의 요구사항이 높아진다. 배틀그라운드나, 스타크래프트2와 같은 게임들은 많은 양의 메모리를 요구한다. 그 만큼 기록되고 처리되는 데이터의 양이 매우 방대하기 때문이다.\u003c/p\u003e\n\u003cp\u003e데이터가 메모리에 할당될 때, 가용한 임의의 메모리 주소에 저장된다. 해당 메모리 주소에 원하는 값이 존재할 것이므로, 값을 호출하기 위해선 해당 값이 저장된 메모리 주소에 접근하여 값을 조회한다. JAVA를 포함한 대부분의 언어들은 이러한 과정이 개발자에게까지 노출되지 않는 내부의 영역에 존재한다. 이걸 직접 다루는 것이 C언어의 그 악명높은 포인터다.\u003c/p\u003e\n\u003cp\u003eJAVA의 메모리는 JVM(Java Virtual Machine, 자바 가상머신)이 관리한다. JVM의 메모리 구조부터 시작하면 한도끝도 없이 브랜치가 뻗어나가니, 핵심만 찝어보자.\u003c/p\u003e\n\u003cp\u003e위에서 언급했듯이, 배열은 참조형 타입이며, 이 참조형 타입은 JVM의 Heap 영역에서 관리한다. 메모리를 간략하게 도식화하면 아래와 같이 표현할 수 있다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111131-7dc1fb80-e120-11eb-8a75-0cf615c9c020.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e네모 한 칸에 하나의 데이터를 할당할 수 있다고 해보자. 만약 6, 43, 14, 9, 94 5개의 정수로 이루어진 정수형 배열을 메모리에 할당한다고 가정하자. JVM이 해당 배열의 크기를 메모리에 기록할 수 있는지 확인하고, 가능하다면 기록한다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111294-b2ce4e00-e120-11eb-8a6e-d5fc241db0ee.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e위 처럼 메모리 상의 적절한 위치에 배열이 기록될 것이다. 여기서 배열의 4번째 데이터를 읽어보자.\u003c/p\u003e\n\u003cp\u003e프로그램은 해당 배열의 주소를 알고있다. 자기가 직접 할당했으니 당연하다. 배열의 주소를 0x0404라고 가정하면 아래와 같이 도식할 수 있다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e0x0404에서 4번째 데이터를 호출하므로 0x0407의 데이터를 조회하면 된다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e😒아니 4번째 데이터라면서요...\u003c/strong\u003e\u003cbr\u003e\n거의 대부분의 컴퓨터 언어는 시작 인덱스를 0으로 지정한다. 그 이유는 메모리에 있는데, 메모리를 기준으로 배열의 첫 번째 데이터는 주소의 이동이 없다.\u003cbr\u003e\n만약 주소가 0x0101이라면, 첫 번째 데이터는 0x0101이 되기 때문에 주소의 이동이 없으므로 0번째 데이터라고 정의하는 것이다. 이는 관점의 차이로, 초대 프로그램의 언어가 이와 같은 방식을 차용했다. 이후 이를 기반으로 생겨난 수 많은 언어들이 이 영향을 받았다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이처럼 배열의 주소에서 해당 인덱스만큼 주소에 더해 데이터를 읽는 것이므로, 동작은 아래와 같다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111156-887c9080-e120-11eb-94db-46545b8a5e9c.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e주소 0x0404를 시작으로 4번째 데이터인 0x0407인 주소에 접근한다. 배열의 주소와 배열의 인덱스를 알고 있으므로 별도의 연산 없이 바로 접근 가능하다. 이로써 0x0407의 값 9에 접근할 수 있다.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-java\"\u003e\u003ccode class=\"language-java\"\u003e\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"token doc-comment comment\"\u003e/**\n * 누구나 자료 구조와 알고리즘 배열 읽기 클래스\n *\n * \u003cspan class=\"token keyword\"\u003e@author\u003c/span\u003e RWB\n * \u003cspan class=\"token keyword\"\u003e@see\u003c/span\u003e \u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003ea\u003c/span\u003e \u003cspan class=\"token attr-name\"\u003ehref\u003c/span\u003e\u003cspan class=\"token attr-value\"\u003e\u003cspan class=\"token punctuation attr-equals\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003ehttps://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e자료구조가 중요한 까닭\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;/\u003c/span\u003ea\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n * \u003cspan class=\"token keyword\"\u003e@since\u003c/span\u003e 2021.07.09 Fri 22:53:39\n */\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eArrayRead\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"token comment\"\u003e// 배열\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e ARRAY \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token number\"\u003e6\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e43\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e14\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e9\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e94\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 메인 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eargs\u003c/span\u003e: [String[]] 매개변수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@throws\u003c/span\u003e \u003cspan class=\"token reference\"\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003c/span\u003e 데이터 입출력 예외\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e args\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ethrows\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e writer \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eSystem\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eout\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 읽을 인덱스\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e4\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e result \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e builder \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"4번 째 아이템: \"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresult\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ewrite\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ebuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003enewLine\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eflush\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eclose\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 배열 읽기 결과 반환 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eindex\u003c/span\u003e: [int] 인덱스\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@return\u003c/span\u003e [int] 인덱스에 해당하는 값\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"token function\"\u003eread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-tc\"\u003e\u003ccode class=\"language-tc\"\u003e4번 째 아이템: 9\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eJAVA 소스는 위와 같다. 배열 \u003ccode\u003earray\u003c/code\u003e을 선언하고, \u003ccode\u003earray[3]\u003c/code\u003e을 호출하면 배열의 4번째 값인 94가 변수 \u003ccode\u003efour\u003c/code\u003e에 할당된다. 목표에 바로 접근하므로 작업에 필요한 단계는 단 하나다.\u003c/p\u003e\n\u003ch2 id=\"1-3-검색\"\u003e\u003ca class=\"head-link\" href=\"#1-3-검색\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e1-3. 검색\u003c/h2\u003e\n\u003cp\u003e이처럼 주소의 값이나 인덱스를 정확히 알고 있다면, 별도의 연산 없이 바로 해당하는 값을 갖고올 수 있다. 하지만 실제로 배열을 다루다보면 꼭 이렇게 간단한 케이스만 있지는 않다.\u003c/p\u003e\n\u003cp\u003e우리가 구조를 알지 못하는 배열이 있다고 가정할 때, 해당 배열에서 우리가 원하는 값을 찾아야할 경우가 적지않게 발생한다. 이 경우 원하는 값의 인덱스를 가지고 있지도 않으며, 심지어 배열 내부에 원하는 값이 존재하는지조차 알 수 없다. 이 경우 \u003cspan class=\"primary\"\u003e검색\u003c/span\u003e연산을 통해 배열의 값을 찾아야 한다.\u003c/p\u003e\n\u003cp\u003e위에서 선언했던 배열을 다시 가져와보자.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111152-86b2cd00-e120-11eb-9abe-477f4ec60f29.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e이번엔 우리가 이 배열에 대한 정확한 정보를 가지고있지 않다고 가정해보자. 현재 우리는 이 배열의 어떤 인덱스에 어떤 값이 있는지 전혀 모르는 상태다.\u003c/p\u003e\n\u003cp\u003e이 상황에서 14라는 값을 검색해보자.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111164-8a465400-e120-11eb-9432-8c127bfed9b2.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e검색은 읽기 작업의 반복이라고 봐도 무방하다. 위 그림은 이러한 검색의 특성을 여실히 보여준다. 목표값인 14를 찾기 위해 \u003ccode\u003earray[0]\u003c/code\u003e 부터 순차적으로 읽음으로써 14를 찾는다.\u003c/p\u003e\n\u003cp\u003e만약 어떠한 방법으로든 읽기과정을 줄이면서도 정상적인 검색이 가능하다면 소요시간이 효과적으로 감소할 것이다.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-java\"\u003e\u003ccode class=\"language-java\"\u003e\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"token doc-comment comment\"\u003e/**\n * 누구나 자료 구조와 알고리즘 배열 검색 클래스\n *\n * \u003cspan class=\"token keyword\"\u003e@author\u003c/span\u003e RWB\n * \u003cspan class=\"token keyword\"\u003e@see\u003c/span\u003e \u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003ea\u003c/span\u003e \u003cspan class=\"token attr-name\"\u003ehref\u003c/span\u003e\u003cspan class=\"token attr-value\"\u003e\u003cspan class=\"token punctuation attr-equals\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003ehttps://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e자료구조가 중요한 까닭\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;/\u003c/span\u003ea\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n * \u003cspan class=\"token keyword\"\u003e@since\u003c/span\u003e 2021.07.09 Fri 23:47:03\n */\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eArrayFind\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e ARRAY \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token number\"\u003e6\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e43\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e14\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e9\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e94\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 메인 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eargs\u003c/span\u003e: [String[]] 매개변수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@throws\u003c/span\u003e \u003cspan class=\"token reference\"\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003c/span\u003e 데이터 입출력 예외\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e args\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ethrows\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e writer \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eSystem\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eout\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 목표 숫자\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e target \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e14\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e result \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003efind\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003etarget\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e builder \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003etarget\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"이 포함된 인덱스: \"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresult\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ewrite\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ebuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003enewLine\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eflush\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eclose\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 요소 검색 및 인덱스 반환 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003etarget\u003c/span\u003e: [int] 목표 숫자\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@return\u003c/span\u003e [int] 인덱스\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"token function\"\u003efind\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e target\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token comment\"\u003e// 인덱스\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e result \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"token comment\"\u003e// 목표 숫자와 배열의 값이 일치할 경우\u003c/span\u003e\n\t\t\t\u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003etarget \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\tresult \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e i\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\t\u003cspan class=\"token keyword\"\u003ebreak\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e result\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-tc\"\u003e\u003ccode class=\"language-tc\"\u003e14이 포함된 인덱스: 2\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e하지만 위는 가장 기초적인 검색 알고리즘을 적용한 것이다. 3번째 요소를 찾기 위해선 3개 과정이 필요하고, 5484번째 요소를 찾기 위해선 5484개 과정이 필요하다.\u003c/p\u003e\n\u003cp\u003e그러나, 요소가 맨 끝에 있거나, 불행히도 배열 내에 존재하지 않을 경우 배열 전체를 검색해야할 수도 있다. 즉 배열에 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 요소가 있다면, 검색의 최대 작업 갯수는 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개가 된다.\u003c/p\u003e\n\u003ch2 id=\"1-4-삽입\"\u003e\u003ca class=\"head-link\" href=\"#1-4-삽입\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e1-4. 삽입\u003c/h2\u003e\n\u003cp\u003e배열에 새로운 요소를 넣는 작업을 \u003cspan class=\"primary\"\u003e삽입\u003c/span\u003e 연산이라 한다. 배열에서 55를 삽입하는 과정을 통해 삽입 연산에 대해 알아보자.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111179-8d414480-e120-11eb-9c36-965d4506fd8c.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e런타임 시 배열을 할당했다면 우리는 배열의 주소를 알고 있을 것이다. 배열의 맨 끝에 요소를 추가한다면 그냥 이어붙이면 된다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111188-8fa39e80-e120-11eb-8576-aee6d30ae3a7.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e하지만 배열의 중간에 삽입한다면 이야기가 조금 달라진다. 삽입하려는 위치 이후의 요소를 한 칸씩 뒤로 미루고, 해당 위치에 값을 삽입하게 된다.\u003c/p\u003e\n\u003cp\u003e최악의 경우, 배열의 가장 첫 인덱스인 0의 위치에 요소를 삽입한다면 모든 배열의 요소를 한 칸씩 뒤로 미룬뒤 55를 삽입해야한다. 즉, 배열에 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 요소가 있을 경우 삽입에 필요한 작업량은 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 요소를 하나씩 이동하는 작업 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN + 1\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e의 작업량이 발생할 수 있다.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-java\"\u003e\u003ccode class=\"language-java\"\u003e\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eutil\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eArrays\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"token doc-comment comment\"\u003e/**\n * 누구나 자료 구조와 알고리즘 배열 삽입 클래스\n *\n * \u003cspan class=\"token keyword\"\u003e@author\u003c/span\u003e RWB\n * \u003cspan class=\"token keyword\"\u003e@see\u003c/span\u003e \u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003ea\u003c/span\u003e \u003cspan class=\"token attr-name\"\u003ehref\u003c/span\u003e\u003cspan class=\"token attr-value\"\u003e\u003cspan class=\"token punctuation attr-equals\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003ehttps://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e자료구조가 중요한 까닭\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;/\u003c/span\u003ea\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n * \u003cspan class=\"token keyword\"\u003e@since\u003c/span\u003e 2021.07.09 Sat 00:27:47\n */\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eArrayInsert\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"token comment\"\u003e// 배열\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e ARRAY \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token number\"\u003e6\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e43\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e14\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e9\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e94\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 메인 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eargs\u003c/span\u003e: [String[]] 매개변수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@throws\u003c/span\u003e \u003cspan class=\"token reference\"\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003c/span\u003e 데이터 입출력 예외\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e args\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ethrows\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e writer \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eSystem\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eout\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 삽입할 인덱스\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 삽입할 요소\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e item \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e55\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token function\"\u003einsert\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e builder \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"번 째 요소에 \"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eitem\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\" 삽입: \"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eArrays\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eARRAY\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ewrite\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ebuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003enewLine\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eflush\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eclose\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 배열 삽입 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eindex\u003c/span\u003e: [int] 삽입 위치\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eitem\u003c/span\u003e: [int] 삽입할 요소\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token annotation punctuation\"\u003e@SuppressWarnings\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"ManualArrayCopy\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003einsert\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token comment\"\u003e// 배열의 값이 -1(빈 요소)가 아닐 경우\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e!=\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e--\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\tARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\n\t\tARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-tc\"\u003e\u003ccode class=\"language-tc\"\u003e2번 째 요소에 55 삽입: [6, 43, 55, 14, 9, 94, -1, -1, -1, -1]\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e삽입 소스는 위와 같다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e@SuppressWarnings는 뭔가요?\u003c/strong\u003e\u003cbr\u003e\nEclipse, IntelliJ와 같은 IDE는 코드를 분석하는 과정에서 오류 또는 경고를 개발자에게 알려줌으로써 잠재적 위험을 제거할 수 있도록 유도한다. 간혹 의도된 동작임에도, IDE의 최적화 설정과 맞지 않아 경고를 띄우기도 한다. 이 경우 @SuppressWarnings 애노테이션을 쓰면 해당 경고를 무시할 수 있다. @@SuppressWarnings를 지워도 소스 동작엔 아무런 문제가 없다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e위에서도 언급했지만, JAVA의 배열은 고정길이를 가진다. 삽입 연산을 하기 위해선 필연적으로 현재 배열의 크기보다 하나 이상 커야하므로, 이전과 달이 총 길이가 10인 배열을 선언했다. 배열의 요소가 -1일 경우, 해당 요소는 아직 할당되지 않은 빈 요소로 간주한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e가변 길이를 가지는 List\u003c/strong\u003e\u003cbr\u003e\nJAVA에서도 얼마든지 가변길이 배열이 필요한 경우가 생긴다. 이 경우 \u003ccode\u003eArrayList\u003c/code\u003e와 같은 \u003ccode\u003eList\u003c/code\u003e 데이터를 활용하면 된다. \u003ccode\u003eList\u003c/code\u003e는 가변길이를 가짐으로써 비정형화된 배열 데이터를 다루는데 유리하다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e배열의 가장 끝 요소부터 삽입하려는 인덱스 이전까지 순차적으로 내려오며 현재 요소의 값을 이전 요소의 값으로 할당하여 요소를 이동시킨다. 이후 삽입하려는 인덱스에 요소를 할당함으로써 삽입이 완료된다.\u003c/p\u003e\n\u003ch2 id=\"1-5-삭제\"\u003e\u003ca class=\"head-link\" href=\"#1-5-삭제\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e1-5. 삭제\u003c/h2\u003e\n\u003cp\u003e삽입을 했으니, 반대로 \u003cspan class=\"primary\"\u003e삭제\u003c/span\u003e도 필요할 수 있다. 삭제 연산은 원하는 인덱스의 요소를 삭제하는 것이다. 간단히 말하자면, 삽입과 정 반대의 프로세스를 가진다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111198-93372580-e120-11eb-9949-aa21aef11dfa.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e마찬가지로, 배열의 맨 끝에 요소를 삭제한다면 그냥 끝의 요소를 삭제하면 그만이다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111204-9500e900-e120-11eb-8c44-c45faeb459fd.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e하지만 배열의 중간을 삭제한다면 동일한 작업이 필요하다. 삭제하려는 위치의 요소를 삭제하고, 요소를 한 칸씩 당겨야 한다.\u003c/p\u003e\n\u003cp\u003e최악의 경우, 배열의 가장 첫 인덱스인 0의 위치의 요소를 삭제한다면 해당 요소를 삭제한 뒤 모든 배열의 요소를 한 칸씩 앞으로 당길 것이다. 즉, 배열에 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 요소가 있을 경우 삭제에 필요한 작업량은 해당 인덱스의 요소를 삭제하는 작업 1개, \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN - 1\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 요소를 하나씩 이동하는 작업 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN - 1\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개로 최대 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e의 작업량이 발생할 수 있다.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-java\"\u003e\u003ccode class=\"language-java\"\u003e\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eutil\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eArrays\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"token doc-comment comment\"\u003e/**\n * 누구나 자료 구조와 알고리즘 배열 삭제 클래스\n *\n * \u003cspan class=\"token keyword\"\u003e@author\u003c/span\u003e RWB\n * \u003cspan class=\"token keyword\"\u003e@see\u003c/span\u003e \u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003ea\u003c/span\u003e \u003cspan class=\"token attr-name\"\u003ehref\u003c/span\u003e\u003cspan class=\"token attr-value\"\u003e\u003cspan class=\"token punctuation attr-equals\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003ehttps://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e자료구조가 중요한 까닭\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;/\u003c/span\u003ea\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n * \u003cspan class=\"token keyword\"\u003e@since\u003c/span\u003e 2021.07.09 Sat 00:59:02\n */\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eArrayDelete\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"token comment\"\u003e// 배열\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e ARRAY \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token number\"\u003e6\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e43\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e14\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e9\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e94\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 메인 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eargs\u003c/span\u003e: [String[]] 매개변수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@throws\u003c/span\u003e \u003cspan class=\"token reference\"\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003c/span\u003e 데이터 입출력 예외\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e args\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ethrows\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e writer \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eSystem\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eout\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 삭제할 인덱스\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token function\"\u003eremove\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e builder \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"번째 요소 삭제 \"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eArrays\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eARRAY\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ewrite\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ebuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003enewLine\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eflush\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eclose\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 배열 삭제 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eindex\u003c/span\u003e: [int] 삭제 위치\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token annotation punctuation\"\u003e@SuppressWarnings\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"ManualArrayCopy\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003eremove\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token comment\"\u003e// 배열의 값이 -1(빈 요소)가 아닐 경우\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e!=\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\tARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\t\n\t\t\tARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003eARRAY\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-tc\"\u003e\u003ccode class=\"language-tc\"\u003e2번째 요소 삭제 [6, 43, 9, 94, -1, -1, -1, -1, -1, -1]\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e삭제 소스는 위와 같다.\u003c/p\u003e\n\u003cp\u003e삭제는 삽입과 달리 배열의 크기가 증가할 필요가 없다. 마찬가지로 배열의 요소가 -1일 경우, 해당 요소는 삭제된 빈 요소로 간주한다.\u003c/p\u003e\n\u003cp\u003e삽입과는 반대로, 삭제하려는 인덱스부터 배열의 끝까지 순차적으로 올라가며 현재 요소의 값을 이후 요소의 값으로 할당하여 요소를 이동시킨다. 이후 배열의 끝 요소를 제거함으로써 삭제가 완료된다.\u003c/p\u003e\n\u003ch2 id=\"1-6-집합-단-하나의-규칙이-효율성을-바꾼다\"\u003e\u003ca class=\"head-link\" href=\"#1-6-집합-단-하나의-규칙이-효율성을-바꾼다\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e1-6. 집합: 단 하나의 규칙이 효율성을 바꾼다\u003c/h2\u003e\n\u003cp\u003e배열의 경우 요소의 타입만 맞다면 별다른 신경을 쓰지 않는다. 이말인즉슨, 중복되는 요소에 대한 처리도 이루어지지 않는다. 하지만 종종 중복되는 값을 허용하지 않는 배열의 필요성이 생기기도 한다. 책에서는 이를 \u003cspan class=\"primary\"\u003e집합\u003c/span\u003e이라는 개념으로 설명한다.\u003c/p\u003e\n\u003cp\u003e배열에 요소를 삽입할 때, 중복여부를 확인하기 위해선 검색 작업이 선행되어야 한다. 검색을 통해 집합에 해당 요소가 없는 것이 확인될 경우에만 삽입이 이루어지는 방식이다.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111212-97634300-e120-11eb-8d2e-c024761e23ff.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/50317129/125111220-992d0680-e120-11eb-97a2-3e1e8eda7518.png\" width=\"600px\"\u003e\n\u003c/p\u003e\n\u003cp\u003e위의 두 그림은 집합 개념이 적용된 배열에서 존재하지 않는 값 55와, 존재하는 값 14를 삽입했을 때 나타나는 결과를 도식화한 것이다.\u003c/p\u003e\n\u003cp\u003e55의 경우 기존에 존재하지 않았으므로 삽입이 가능하지만, 14의 경우 이미 2번 째 인덱스에 동일한 값이 있으므로 삽입이 불가능하다.\u003c/p\u003e\n\u003cp\u003e검증이 완료된 이후의 삽입 과정은 기존의 삽입 과정과 동일하다. 단, 작업량은 달라진다. 기존의 삽입 작업량에서 검색의 작업량이 추가되기 때문이다.\u003c/p\u003e\n\u003cp\u003e가장 최악의 케이스는 중복되지 않는 임의의 값을 배열의 0번 째 인덱스에 삽입하는 것이다. \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 요소를 가진 배열에서 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개 요소를 검색하는 작업량 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개, \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 요소를 하나씩 이동하는 작업 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eN\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eN\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개, 해당 인덱스에 요소를 삽입하는 작업 1개로 최대 \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003e2N + 1\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e2\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e개의 작업량이 발생한다.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-java\"\u003e\u003ccode class=\"language-java\"\u003e\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token namespace\"\u003ejava\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eio\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"token doc-comment comment\"\u003e/**\n * 누구나 자료 구조와 알고리즘 집합 배열 클래스\n *\n * \u003cspan class=\"token keyword\"\u003e@author\u003c/span\u003e RWB\n * \u003cspan class=\"token keyword\"\u003e@see\u003c/span\u003e \u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003ea\u003c/span\u003e \u003cspan class=\"token attr-name\"\u003ehref\u003c/span\u003e\u003cspan class=\"token attr-value\"\u003e\u003cspan class=\"token punctuation attr-equals\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003ehttps://rwb0104.github.io/posts/2021/07/09/about-algorithm-chapter01/\u003cspan class=\"token punctuation\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e자료구조가 중요한 까닭\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token tag\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;/\u003c/span\u003ea\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n * \u003cspan class=\"token keyword\"\u003e@since\u003c/span\u003e 2021.07.10 Sat 01:30:56\n */\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eUniqueArray\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"token comment\"\u003e// 배열\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e ARRAY \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token number\"\u003e6\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e43\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e14\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e9\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e94\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 메인 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eargs\u003c/span\u003e: [String[]] 매개변수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@throws\u003c/span\u003e \u003cspan class=\"token reference\"\u003e\u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\u003c/span\u003e 데이터 입출력 예외\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e args\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ethrows\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eIOException\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e writer \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eBufferedWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eOutputStreamWriter\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eSystem\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eout\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 삽입할 인덱스\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 삽입할 요소\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e item \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e55\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token keyword\"\u003eboolean\u003c/span\u003e result \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003ehasInserted\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e builder \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStringBuilder\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"번 째 인덱스에 \"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eitem\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\" 삽입 결과: \"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\tbuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eappend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresult\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ewrite\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ebuilder\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003enewLine\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eflush\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\twriter\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eclose\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 집합 배열 삽입 결과 반환 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eindex\u003c/span\u003e: [int] 삽입 위치\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eitem\u003c/span\u003e: [int] 삽입할 요소\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@return\u003c/span\u003e [boolean] 삽입 결과\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eboolean\u003c/span\u003e \u003cspan class=\"token function\"\u003ehasInserted\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e result \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003efind\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eitem\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 중복되지 않을 경우\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresult \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"token function\"\u003einsert\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\n\t\t\t\u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token boolean\"\u003etrue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token comment\"\u003e// 중복될 경우\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eelse\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token boolean\"\u003efalse\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 요소 검색 및 인덱스 반환 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003etarget\u003c/span\u003e: [int] 목표 숫자\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@return\u003c/span\u003e [int] 인덱스\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"token function\"\u003efind\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e target\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token comment\"\u003e// 인덱스\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e result \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"token comment\"\u003e// 목표 숫자와 배열의 값이 일치할 경우\u003c/span\u003e\n\t\t\t\u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003etarget \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\tresult \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e i\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\t\u003cspan class=\"token keyword\"\u003ebreak\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\n\t\t\u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e result\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\n\t\u003cspan class=\"token doc-comment comment\"\u003e/**\n\t * 배열 삽입 함수\n\t *\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eindex\u003c/span\u003e: [int] 삽입 위치\n\t * \u003cspan class=\"token keyword\"\u003e@param\u003c/span\u003e \u003cspan class=\"token parameter\"\u003eitem\u003c/span\u003e: [int] 삽입할 요소\n\t */\u003c/span\u003e\n\t\u003cspan class=\"token annotation punctuation\"\u003e@SuppressWarnings\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"ManualArrayCopy\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003einsert\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"token comment\"\u003e// 배열의 값이 -1(빈 요소)가 아닐 경우\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e!=\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e index\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e--\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n\t\t\t\tARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e ARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\t\n\t\tARRAY\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003eindex\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e item\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-tc\"\u003e\u003ccode class=\"language-tc\"\u003e2번 째 인덱스에 55 삽입 결과: true\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e집합 배열의 삽입 소스는 위와 같다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efind\u003c/code\u003e와 \u003ccode\u003einsert\u003c/code\u003e 함수는 검색과 삽입 파트에서 사용한 로직과 동일한 로직이다. 집합 배열은 반드시 고유한 요소만을 삽입해야 하므로, \u003ccode\u003ehasInserted\u003c/code\u003e 함수를 구성하여 중복 여부를 검증한 뒤 삽입을 진행한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efind\u003c/code\u003e 함수는 검색되는 요소가 없을 경우 -1을 반환한다. 즉, -1을 반환하는 숫자는 고유한 숫자다. \u003ccode\u003efind\u003c/code\u003e가 -1을 반환할 경우 \u003ccode\u003einsert\u003c/code\u003e 함수로 삽입을 진행한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eSet 객체는 중복을 허용하지 않아요\u003c/strong\u003e\u003cbr\u003e\nJAVA의 배열은 기본적으로 요소의 중복같은건 신경쓰지 않는다. 때문에, 요소의 중복을 감지하기 위해선 별도의 검증 로직을 구성해야한다.\u003cbr\u003e\n하지만 \u003ccode\u003eHashSet\u003c/code\u003e과 같은 \u003ccode\u003eSet\u003c/code\u003e 객체를 활용하면 항상 고유한 값만 삽입할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"마무리\"\u003e\u003ca class=\"head-link\" href=\"#마무리\"\u003e\u003cspan\u003e🔗\u003c/span\u003e\u003c/a\u003e마무리\u003c/h1\u003e\n\u003cp\u003e이 장에서는 최대한 개념 위주로 설명하며, 설명에 어떠한 알고리즘 지식이 들어가지 않은 것으로 보인다. 이러한 저자의 의도를 최대한 반영하여, 내 로직 역시 가능한 기본 데이터 타입을 사용했으며, 복잡한 로직을 최대한 지양했다. 철저히 연산이 동작하는 기본 원리에 입각하도록 소스를 구성했다.\u003c/p\u003e\n\u003cp\u003e다음 장에서는 알고리즘에 대한 본격적인 내용이 기술될 것이다.\u003c/p\u003e"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2021","07","10","about-algorithm-chapter01"]},"buildId":"MwcIMGgVNg3IV_ISdVcdA","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-5ba9c403cc30e4733b64.js"></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" async=""></script><script src="/_next/static/chunks/6bbc0c86603d2feda1b6d9e3f0b0f690f2f4c9a4.62794267ce6b83fa1d13.js" async=""></script><script src="/_next/static/chunks/main-a56a9833bc2424f9492b.js" async=""></script><script src="/_next/static/chunks/0a301732.10ced01e52dc82e99752.js" async=""></script><script src="/_next/static/chunks/a5190d9ce7329a37db61865e931a1a66806e37b1.e0bb27786170d93a4a8b.js" async=""></script><script src="/_next/static/chunks/39eb40a19e7e82f610f97d892c72a9a025d001d6.463482cc4895dad81b92.js" async=""></script><script src="/_next/static/chunks/d0cb84a5c8b749bd71f104256fde72bc846b2656.c889dd6a5a1e01ef484b.js" async=""></script><script src="/_next/static/chunks/pages/_app-2e0609bfb4d36bf9d207.js" async=""></script><script src="/_next/static/chunks/d6344e9a4d7f8e29af8741de220cdb9ff49f13dc.7896df7c38f14edd6e3e.js" async=""></script><script src="/_next/static/chunks/5631b5f5713ebfda782daea8f3e487334c496d05.137501440fe8249a994b.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-96c89aa2af9f19796390.js" async=""></script><script src="/_next/static/MwcIMGgVNg3IV_ISdVcdA/_buildManifest.js" async=""></script><script src="/_next/static/MwcIMGgVNg3IV_ISdVcdA/_ssgManifest.js" async=""></script></body></html>